/// <reference path="isc.objects.d.ts" />
/// <reference path="isc.types.d.ts" />

// Type definitions for Isomorphic SmartClient 11.1
// Project: https://gihub.com/kylemwhite/isc
// Definitions by: Kyle White <http://kmwTech.com>
// Definitions: https://gihub.com/DefinitelyTyped/DefinitelyTyped
// Generated: 5/3/2017 9:13:31 AM by kwhite
// Generated from SmartClient version SNAPSHOT_v11.1d_2017-05-03

declare namespace Isc {

    
	/**
	 * Properties used for passing into .create() or anything else that takes a BaseWidget Props argument.
	 * This is derived from the methods in the BaseWidget class and it's parents and their properties marked with the I flag.
	 */
	export interface BaseWidgetProps extends ClassProps {
	} // BaseWidgetProps


	/**
	 * Base class for Canvas and DrawItem. 
	 */
	export interface BaseWidget extends Class {
	} // BaseWidget

	export interface BaseWidgetStatic<T, P> extends ClassStatic<T, P> {
	} // BaseWidgetStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a BlurbItem Props argument.
	 * This is derived from the methods in the BlurbItem class and it's parents and their properties marked with the I flag.
	 */
	export interface BlurbItemProps extends FormItemProps {
		/** Should the user be able to select the text in this item?
		 * Flags: IRW */
		canSelectText?: boolean; // Flags=IRW
		/** If true, text that exceeds the specified size of the form item will be clipped.
		 * Flags: IRW, Group: appearance */
		clipValue?: boolean /* Boolean */; // Flags=IRW
		/** By default, texts span all remaining columns
		 * Flags: IRW, Group: appearance */
		colSpan?: number; // Flags=IRW
		/** Default class used to construct the EditProxy for this component when the component is Canvas.setEditMode','first placed into edit mode.
		 * Flags: IR */
		editProxyConstructor?: string /* SCClassName */; // Flags=IR
		/** Blurb items show no title by default.
		 * Flags: IRW, Group: appearance */
		showTitle?: boolean /* Boolean */; // Flags=IRW
		/** Base css style for this item.
		 * Flags: IRW, Group: appearance */
		textBoxStyle?: string /* CSSStyleName */; // Flags=IRW
		/** If true, item contents can wrap. If false, all the contents should appear on a single line.
		 * Flags: IRW, Group: appearance */
		wrap?: boolean; // Flags=IRW
	} // BlurbItemProps


	/**
	 * FormItem intended for inserting blurbs of instructional HTML into DynamicForms. Set the defaultValue of this item to the HTML you want to embed in the form. 
	 */
	export interface BlurbItem extends FormItem {
		/** Should the user be able to select the text in this item?
		 * Flags: IRW */
		canSelectText: boolean;

		/** If true, text that exceeds the specified size of the form item will be clipped.
		 * Flags: IRW, Group: appearance */
		clipValue: boolean /* Boolean */;

		/** By default, texts span all remaining columns
		 * Flags: IRW, Group: appearance */
		colSpan: number;

		/** Default class used to construct the EditProxy for this component when the component is Canvas.setEditMode','first placed into edit mode.
		 * Flags: IR */
		editProxyConstructor: string /* SCClassName */;

		/** Blurb items show no title by default.
		 * Flags: IRW, Group: appearance */
		showTitle: boolean /* Boolean */;

		/** Base css style for this item.
		 * Flags: IRW, Group: appearance */
		textBoxStyle: string /* CSSStyleName */;

		/** If true, item contents can wrap. If false, all the contents should appear on a single line.
		 * Flags: IRW, Group: appearance */
		wrap: boolean;

	} // BlurbItem

	export interface BlurbItemStatic<T, P> extends FormItemStatic<T, P> {
	} // BlurbItemStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a Button Props argument.
	 * This is derived from the methods in the Button class and it's parents and their properties marked with the I flag.
	 */
	export interface ButtonProps extends StatefulCanvasProps {
		/** Behavior on state changes -- BUTTON, RADIO or CHECKBOX
		 * Flags: IRW, Group: state */
		actionType?: SelectionType; // Flags=IRW
		/** Horizontal alignment of this component's title.
		 * Flags: IRW, Group: appearance */
		align?: Alignment; // Flags=IRW
		/** If true, ignore the specified size of this widget and always size just large enough to accommodate the title. If setWidth() is explicitly called on an autoFit:true button, autoFit will be reset to false. Note that for StretchImgButton instances, autoFit will occur horizontally only, as unpredictable vertical sizing is likely to distort the media. If you do want vertical auto-fit, this can be achieved by simply setting a small height, and having overflow:"visible"
		 * Flags: IRW, Group: sizing */
		autoFit?: boolean; // Flags=IRW
		/** Base CSS style className applied to the component. As the component changes StatefulCanvas.state and/or is selected, suffixes will be added to the base style. In some cases more than one suffix will be appended to reflect a combined state ("Selected" + "Disabled", for example). See StatefulCanvas.getStateSuffix for a description of the default set of suffixes which may be applied to the baseStyle
		 * Flags: IRW */
		baseStyle?: string /* CSSStyleName */; // Flags=IRW
		/** If enabled, the button will collapse to show just its icon when showing the title would cause overflow of a containing Layout. See Canvas.canAdaptWidth.
		 * Flags: IR */
		canAdaptWidth?: boolean /* Boolean */; // Flags=IR
		/** Specifies the cursor to display when the mouse pointer is over the icon image and this StatefulCanvas is Canvas.disabled','disabled. If not set and the mouse pointer is over the icon image, Button.iconCursor','iconCursor will be used.
		 * Flags: IR, Group: cues */
		disabledIconCursor?: Cursor; // Flags=IR
		/** If set to true, if the StatefulCanvas.title','title of this button contains the specified Canvas.accessKey','accessKey, when the title is displayed to the user it will be modified to include HTML to underline the accessKey. Note that this property may cause titles that include HTML (rather than simple strings) to be inappropriately modified, so should be disabled if your title string includes HTML characters.
		 * Flags: IRW */
		hiliteAccessKey?: boolean; // Flags=IRW
		/** Optional icon to be shown with the button title text. Specify as the partial URL to an image, relative to the imgDir of this component. Note that the string "blank" is a valid setting for this attribute and will always result in the system blank image, with no state suffixes applied. Typically, this might be used when an iconStyle is also specified and the iconStyle renders the icon via a stateful background-image or other CSS approach.
		 * Flags: IRW, Group: buttonIcon */
		icon?: string /* SCImgURL */; // Flags=IRW
		/** If this button is showing an icon should it be right or left aligned?
		 * Flags: IR, Group: buttonIcon */
		iconAlign?: string; // Flags=IR
		/** Specifies the cursor to display when the mouse pointer is over the icon image.
		 * Flags: IR, Group: cues */
		iconCursor?: Cursor; // Flags=IR
		/** Height in pixels of the icon image. If unset, defaults to StatefulCanvas.iconSize','iconSize.
		 * Flags: IR, Group: buttonIcon */
		iconHeight?: number /* integer */; // Flags=IR
		/** If this button is showing an icon should it appear to the left or right of the title? valid options are "left" and "right".
		 * Flags: IR, Group: buttonIcon */
		iconOrientation?: string; // Flags=IR
		/** Size in pixels of the icon image. The StatefulCanvas.iconWidth','iconWidth and StatefulCanvas.iconHeight','iconHeight properties can be used to configure width and height separately. Note: When configuring the properties of a StatefulCanvas (or derivative) AutoChild','AutoChild, it is best to set the iconWidth and iconHeight to the same value rather than setting an iconSize. This is because certain skins or customizations thereto might set the iconWidth and iconHeight, making the customization of the AutoChild's iconSize ineffective.
		 * Flags: IR, Group: buttonIcon */
		iconSize?: number /* int */; // Flags=IR
		/** Pixels between icon and title text.
		 * Flags: IR, Group: buttonIcon */
		iconSpacing?: number /* int */; // Flags=IR
		/** Base CSS style applied to the icon image. If set, as the StatefulCanvas changes StatefulCanvas.state','state and/or is StatefulCanvas.selected','selected, suffixes will be appended to iconStyle to form the className set on the image element. The following table lists out the standard set of suffixes which may be appended: <table border=1> <tr><th>CSS Class Applied</th><th>Description</th></tr> <tr><td>iconStyle</td><td>Default CSS style</td></tr> <tr><td>iconStyle+Selected</td> <td>Applied when StatefulCanvas.selected and StatefulCanvas.showSelectedIcon are true.</td></tr> <tr><td>iconStyle+Focused</td> <td>Applied when the component has keyboard focus, if StatefulCanvas.showFocusedIcon is true, and StatefulCanvas.showFocusedAsOver is not true.</td></tr> <tr><td>iconStyle+Over</td> <td>Applied when StatefulCanvas.showRollOverIcon is set to true and either the user rolls over the component or StatefulCanvas.showFocusedAsOver is true and the component has keyboard focus.</td></tr> <tr><td>iconStyle+Down</td> <td>Applied when the user presses the mouse button on the component if StatefulCanvas.showDownIcon is set to true</td></tr> <tr><td>iconStyle+Disabled</td> <td>Applied when the component is Canvas.disabled','disabled if StatefulCanvas.showDisabledIcon is true.</td></tr> <tr><td colspan=2>Combined styles</td></tr> <tr><td>iconStyle+SelectedFocused</td> <td>Combined Selected and focused styling</td></tr> <tr><td>iconStyle+SelectedOver</td> <td>Combined Selected and rollOver styling</td></tr> <tr><td>iconStyle+FocusedOver</td> <td>Combined Focused and rollOver styling</td></tr> <tr><td>iconStyle+SelectedFocusedOver</td> <td>Combined Selected, Focused and rollOver styling</td></tr> <tr><td>iconStyle+SelectedDown</td> <td>Combined Selected and mouse-down styling</td></tr> <tr><td>iconStyle+FocusedDown</td> <td>Combined Focused and mouse-down styling</td></tr> <tr><td>iconStyle+SelectedFocusedDown</td> <td>Combined Selected, Focused and mouse-down styling</td></tr> <tr><td>iconStyle+SelectedDisabled</td> <td>Combined Selected and Disabled styling</td></tr> </table> In addition, if StatefulCanvas.showRTLIcon is true, then in RTL mode, a final "RTL" suffix will be appended.
		 * Flags: IRW, Group: buttonIcon */
		iconStyle?: string /* CSSStyleName */; // Flags=IRW
		/** Width in pixels of the icon image. If unset, defaults to StatefulCanvas.iconSize','iconSize.
		 * Flags: IR, Group: buttonIcon */
		iconWidth?: number /* integer */; // Flags=IR
		/** Clip the contents of the button if necessary.
		 * Flags: IRWA */
		overflow?: Overflow; // Flags=IRWA
		/** String identifier for this canvas's mutually exclusive selection group.
		 * Flags: IRWA, Group: state */
		radioGroup?: string; // Flags=IRWA
		/** Whether this component is selected. For some components, selection affects appearance.
		 * Flags: IRW, Group: state */
		selected?: boolean /* Boolean */; // Flags=IRW
		/** If true and the title is clipped, then a hover containing the full title of this button is enabled.
		 * Flags: IRW, Group: hovers */
		showClippedTitleOnHover?: boolean /* Boolean */; // Flags=IRW
		/** Should we visibly change state when disabled?
		 * Flags: IRW, Group: state */
		showDisabled?: boolean /* Boolean */; // Flags=IRW
		/** If using an icon for this button, whether to switch the icon image if the button becomes disabled.
		 * Flags: IR, Group: buttonIcon */
		showDisabledIcon?: boolean /* Boolean */; // Flags=IR
		/** Should we visibly change state when the mouse goes down in this object?
		 * Flags: IRW, Group: state */
		showDown?: boolean /* Boolean */; // Flags=IRW
		/** If using an icon for this button, whether to switch the icon image when the mouse goes down on the button.
		 * Flags: IR, Group: buttonIcon */
		showDownIcon?: boolean /* Boolean */; // Flags=IR
		/** Should we visibly change state when the canvas receives focus? If StatefulCanvas.showFocusedAsOver is true, then "over" will be used to indicate focus. Otherwise a separate "focused" state will be used.
		 * Flags: IRW, Group: state */
		showFocused?: boolean /* Boolean */; // Flags=IRW
		/** If using an icon for this button, whether to switch the icon image when the button receives focus. If StatefulCanvas.showFocusedAsOver is true, the "Over" icon will be displayed when the canvas has focus, otherwise a separate "Focused" icon will be displayed
		 * Flags: IR, Group: buttonIcon */
		showFocusedIcon?: boolean /* Boolean */; // Flags=IR
		/** Should we visibly change state when the mouse goes over this object?
		 * Flags: IRW, Group: state */
		showRollOver?: boolean /* Boolean */; // Flags=IRW
		/** If using an icon for this button, whether to switch the icon image on mouse rollover.
		 * Flags: IR, Group: buttonIcon */
		showRollOverIcon?: boolean /* Boolean */; // Flags=IR
		/** If using an icon for this button, whether to switch the icon image when the button becomes selected.
		 * Flags: IR, Group: buttonIcon */
		showSelectedIcon?: boolean /* Boolean */; // Flags=IR
		/** Current "state" of this widget. The state setting is automatically updated as the user interacts with the component (see StatefulCanvas.showRollOver, StatefulCanvas.showDown, StatefulCanvas.showDisabled). StatefulCanvases will have a different appearance based on their current state. By default this is handled by changing the css className applied to the StatefulCanvas - see StatefulCanvas.baseStyle and StatefulCanvas.getStateSuffix for a description of how this is done. For Img or StretchImg based subclasses of StatefulCanvas, the appearance may also be updated by changing the src of the rendered image. See Img.src and StretchImgButton.src for a description of how the URL is modified to reflect the state of the widget in this case.
		 * Flags: IRWA, Group: state */
		state?: State; // Flags=IRWA
		/** The title HTML to display in this button.
		 * Flags: IRW, Group: basics */
		title?: string /* HTMLString */; // Flags=IRW
		/** Vertical alignment of this component's title.
		 * Flags: IRW, Group: appearance */
		valign?: VerticalAlignment; // Flags=IRW
		/** A boolean indicating whether the button's title should word-wrap, if necessary.
		 * Flags: IRW, Group: basics */
		wrap?: boolean /* Boolean */; // Flags=IRW

		/* Method Overrides */

	} // ButtonProps


	/**
	 * The Button widget class implements interactive, style-based button widgets. 
	 */
	export interface Button extends StatefulCanvas {
		/** Behavior on state changes -- BUTTON, RADIO or CHECKBOX
		 * Flags: IRW, Group: state */
		actionType: SelectionType;

		/** Horizontal alignment of this component's title.
		 * Flags: IRW, Group: appearance */
		align: Alignment;

		/** If true, ignore the specified size of this widget and always size just large enough to accommodate the title. If setWidth() is explicitly called on an autoFit:true button, autoFit will be reset to false. Note that for StretchImgButton instances, autoFit will occur horizontally only, as unpredictable vertical sizing is likely to distort the media. If you do want vertical auto-fit, this can be achieved by simply setting a small height, and having overflow:"visible"
		 * Flags: IRW, Group: sizing */
		autoFit: boolean;

		/** Base CSS style className applied to the component. As the component changes StatefulCanvas.state and/or is selected, suffixes will be added to the base style. In some cases more than one suffix will be appended to reflect a combined state ("Selected" + "Disabled", for example). See StatefulCanvas.getStateSuffix for a description of the default set of suffixes which may be applied to the baseStyle
		 * Flags: IRW */
		baseStyle: string /* CSSStyleName */;

		/** If enabled, the button will collapse to show just its icon when showing the title would cause overflow of a containing Layout. See Canvas.canAdaptWidth.
		 * Flags: IR */
		canAdaptWidth: boolean /* Boolean */;

		/** Specifies the cursor to display when the mouse pointer is over the icon image and this StatefulCanvas is Canvas.disabled','disabled. If not set and the mouse pointer is over the icon image, Button.iconCursor','iconCursor will be used.
		 * Flags: IR, Group: cues */
		disabledIconCursor: Cursor;

		/** If set to true, if the StatefulCanvas.title','title of this button contains the specified Canvas.accessKey','accessKey, when the title is displayed to the user it will be modified to include HTML to underline the accessKey. Note that this property may cause titles that include HTML (rather than simple strings) to be inappropriately modified, so should be disabled if your title string includes HTML characters.
		 * Flags: IRW */
		hiliteAccessKey: boolean;

		/** Optional icon to be shown with the button title text. Specify as the partial URL to an image, relative to the imgDir of this component. Note that the string "blank" is a valid setting for this attribute and will always result in the system blank image, with no state suffixes applied. Typically, this might be used when an iconStyle is also specified and the iconStyle renders the icon via a stateful background-image or other CSS approach.
		 * Flags: IRW, Group: buttonIcon */
		icon: string /* SCImgURL */;

		/** If this button is showing an icon should it be right or left aligned?
		 * Flags: IR, Group: buttonIcon */
		iconAlign: string;

		/** Specifies the cursor to display when the mouse pointer is over the icon image.
		 * Flags: IR, Group: cues */
		iconCursor: Cursor;

		/** Height in pixels of the icon image. If unset, defaults to StatefulCanvas.iconSize','iconSize.
		 * Flags: IR, Group: buttonIcon */
		iconHeight: number /* integer */;

		/** If this button is showing an icon should it appear to the left or right of the title? valid options are "left" and "right".
		 * Flags: IR, Group: buttonIcon */
		iconOrientation: string;

		/** Size in pixels of the icon image. The StatefulCanvas.iconWidth','iconWidth and StatefulCanvas.iconHeight','iconHeight properties can be used to configure width and height separately. Note: When configuring the properties of a StatefulCanvas (or derivative) AutoChild','AutoChild, it is best to set the iconWidth and iconHeight to the same value rather than setting an iconSize. This is because certain skins or customizations thereto might set the iconWidth and iconHeight, making the customization of the AutoChild's iconSize ineffective.
		 * Flags: IR, Group: buttonIcon */
		iconSize: number /* int */;

		/** Pixels between icon and title text.
		 * Flags: IR, Group: buttonIcon */
		iconSpacing: number /* int */;

		/** Base CSS style applied to the icon image. If set, as the StatefulCanvas changes StatefulCanvas.state','state and/or is StatefulCanvas.selected','selected, suffixes will be appended to iconStyle to form the className set on the image element. The following table lists out the standard set of suffixes which may be appended: <table border=1> <tr><th>CSS Class Applied</th><th>Description</th></tr> <tr><td>iconStyle</td><td>Default CSS style</td></tr> <tr><td>iconStyle+Selected</td> <td>Applied when StatefulCanvas.selected and StatefulCanvas.showSelectedIcon are true.</td></tr> <tr><td>iconStyle+Focused</td> <td>Applied when the component has keyboard focus, if StatefulCanvas.showFocusedIcon is true, and StatefulCanvas.showFocusedAsOver is not true.</td></tr> <tr><td>iconStyle+Over</td> <td>Applied when StatefulCanvas.showRollOverIcon is set to true and either the user rolls over the component or StatefulCanvas.showFocusedAsOver is true and the component has keyboard focus.</td></tr> <tr><td>iconStyle+Down</td> <td>Applied when the user presses the mouse button on the component if StatefulCanvas.showDownIcon is set to true</td></tr> <tr><td>iconStyle+Disabled</td> <td>Applied when the component is Canvas.disabled','disabled if StatefulCanvas.showDisabledIcon is true.</td></tr> <tr><td colspan=2>Combined styles</td></tr> <tr><td>iconStyle+SelectedFocused</td> <td>Combined Selected and focused styling</td></tr> <tr><td>iconStyle+SelectedOver</td> <td>Combined Selected and rollOver styling</td></tr> <tr><td>iconStyle+FocusedOver</td> <td>Combined Focused and rollOver styling</td></tr> <tr><td>iconStyle+SelectedFocusedOver</td> <td>Combined Selected, Focused and rollOver styling</td></tr> <tr><td>iconStyle+SelectedDown</td> <td>Combined Selected and mouse-down styling</td></tr> <tr><td>iconStyle+FocusedDown</td> <td>Combined Focused and mouse-down styling</td></tr> <tr><td>iconStyle+SelectedFocusedDown</td> <td>Combined Selected, Focused and mouse-down styling</td></tr> <tr><td>iconStyle+SelectedDisabled</td> <td>Combined Selected and Disabled styling</td></tr> </table> In addition, if StatefulCanvas.showRTLIcon is true, then in RTL mode, a final "RTL" suffix will be appended.
		 * Flags: IRW, Group: buttonIcon */
		iconStyle: string /* CSSStyleName */;

		/** Width in pixels of the icon image. If unset, defaults to StatefulCanvas.iconSize','iconSize.
		 * Flags: IR, Group: buttonIcon */
		iconWidth: number /* integer */;

		/** Clip the contents of the button if necessary.
		 * Flags: IRWA */
		overflow: Overflow;

		/** String identifier for this canvas's mutually exclusive selection group.
		 * Flags: IRWA, Group: state */
		radioGroup: string;

		/** Whether this component is selected. For some components, selection affects appearance.
		 * Flags: IRW, Group: state */
		selected: boolean /* Boolean */;

		/** If true and the title is clipped, then a hover containing the full title of this button is enabled.
		 * Flags: IRW, Group: hovers */
		showClippedTitleOnHover: boolean /* Boolean */;

		/** Should we visibly change state when disabled?
		 * Flags: IRW, Group: state */
		showDisabled: boolean /* Boolean */;

		/** If using an icon for this button, whether to switch the icon image if the button becomes disabled.
		 * Flags: IR, Group: buttonIcon */
		showDisabledIcon: boolean /* Boolean */;

		/** Should we visibly change state when the mouse goes down in this object?
		 * Flags: IRW, Group: state */
		showDown: boolean /* Boolean */;

		/** If using an icon for this button, whether to switch the icon image when the mouse goes down on the button.
		 * Flags: IR, Group: buttonIcon */
		showDownIcon: boolean /* Boolean */;

		/** Should we visibly change state when the canvas receives focus? If StatefulCanvas.showFocusedAsOver is true, then "over" will be used to indicate focus. Otherwise a separate "focused" state will be used.
		 * Flags: IRW, Group: state */
		showFocused: boolean /* Boolean */;

		/** If using an icon for this button, whether to switch the icon image when the button receives focus. If StatefulCanvas.showFocusedAsOver is true, the "Over" icon will be displayed when the canvas has focus, otherwise a separate "Focused" icon will be displayed
		 * Flags: IR, Group: buttonIcon */
		showFocusedIcon: boolean /* Boolean */;

		/** Should we visibly change state when the mouse goes over this object?
		 * Flags: IRW, Group: state */
		showRollOver: boolean /* Boolean */;

		/** If using an icon for this button, whether to switch the icon image on mouse rollover.
		 * Flags: IR, Group: buttonIcon */
		showRollOverIcon: boolean /* Boolean */;

		/** If using an icon for this button, whether to switch the icon image when the button becomes selected.
		 * Flags: IR, Group: buttonIcon */
		showSelectedIcon: boolean /* Boolean */;

		/** Current "state" of this widget. The state setting is automatically updated as the user interacts with the component (see StatefulCanvas.showRollOver, StatefulCanvas.showDown, StatefulCanvas.showDisabled). StatefulCanvases will have a different appearance based on their current state. By default this is handled by changing the css className applied to the StatefulCanvas - see StatefulCanvas.baseStyle and StatefulCanvas.getStateSuffix for a description of how this is done. For Img or StretchImg based subclasses of StatefulCanvas, the appearance may also be updated by changing the src of the rendered image. See Img.src and StretchImgButton.src for a description of how the URL is modified to reflect the state of the widget in this case.
		 * Flags: IRWA, Group: state */
		state: State;

		/** The title HTML to display in this button.
		 * Flags: IRW, Group: basics */
		title: string /* HTMLString */;

		/** Vertical alignment of this component's title.
		 * Flags: IRW, Group: appearance */
		valign: VerticalAlignment;

		/** A boolean indicating whether the button's title should word-wrap, if necessary.
		 * Flags: IRW, Group: basics */
		wrap: boolean /* Boolean */;


		/* Instance Method Overrides */

	} // Button

	export interface ButtonStatic<T, P> extends StatefulCanvasStatic<T, P> {
	} // ButtonStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a ButtonItem Props argument.
	 * This is derived from the methods in the ButtonItem class and it's parents and their properties marked with the I flag.
	 */
	export interface ButtonItemProps extends CanvasItemProps {
		/** Should the button auto fit to its title. Maps to Button.autoFit attribute. Note that if an explicit width or height is specified for this item, it will be respected, disabling autoFit behavior
		 * Flags: IR */
		autoFit?: boolean /* Boolean */; // Flags=IR
		/** Optional baseStyle will be applied to the button.
		 * Flags: IRW, Group: appearance */
		baseStyle?: string /* CSSStyleName */; // Flags=IRW
		/** Constructor class for the button.
		 * Flags: IRA */
		buttonConstructor?: Class; // Flags=IRA
		/** Custom Properties to apply to our button item.
		 * Flags: IRA */
		buttonProperties?: any /* Object */; // Flags=IRA
		/** These items are in a row by themselves by default
		 * Flags: IRW, Group: formLayout */
		endRow?: boolean /* Boolean */; // Flags=IRW
		/** By default buttonItems are sized to match their content (see ButtonItem.autoFit). Specifying an explicit size for the button will disable this behavior.
		 * Flags: IRW, Group: appearance */
		height?: number; // Flags=IRW
		/** Optional icon image to display on the button for this item. See Button.icon.
		 * Flags: IR, Group: appearance */
		icon?: string /* SCImgURL */; // Flags=IR
		/** If this item is FormItem.getCanEdit','read-only, how should this item be displayed to the user? If set, overrides the form-level DynamicForm.readOnlyDisplay default.
		 * Flags: IRW */
		readOnlyDisplay?: ReadOnlyDisplayAppearance; // Flags=IRW
		/** This property governs whether StatefulCanvas.showFocusedAsOver','showFocusedAsOver is true on the automatically created Button for this item.
		 * Flags: IRW */
		showFocusedAsOver?: boolean /* Boolean */; // Flags=IRW
		/** Buttons do not show a title by default.
		 * Flags: IRW, Group: appearance */
		showTitle?: boolean /* Boolean */; // Flags=IRW
		/** These items are in a row by themselves by default
		 * Flags: IRW, Group: formLayout */
		startRow?: boolean /* Boolean */; // Flags=IRW

		/* Method Overrides */

		/** 
		 * Called when a ButtonItem is clicked on.
		 * @param {DynamicForm} form - the managing DynamicForm instance
		 * @param {FormItem} item - the form item itself (also available as "this")
		 */
		click?(form:DynamicForm, item:FormItem): boolean; 

	} // ButtonItemProps


	/**
	 * FormItem for adding a Button to a form. 
	 */
	export interface ButtonItem extends CanvasItem {
		/** Should the button auto fit to its title. Maps to Button.autoFit attribute. Note that if an explicit width or height is specified for this item, it will be respected, disabling autoFit behavior
		 * Flags: IR */
		autoFit: boolean /* Boolean */;

		/** Optional baseStyle will be applied to the button.
		 * Flags: IRW, Group: appearance */
		baseStyle: string /* CSSStyleName */;

		/** This item is an autoChild generated Canvas displayed by the ButtonItem and is an instance of Button by defaut, cuztomizeable via the ButtonItem.buttonConstructor attribute.
		 * Flags: R */
		button:  Canvas /* AutoChild Canvas */;

		/** Constructor class for the button.
		 * Flags: IRA */
		buttonConstructor: Class;

		/** Custom Properties to apply to our button item.
		 * Flags: IRA */
		buttonProperties: any /* Object */;

		/** These items are in a row by themselves by default
		 * Flags: IRW, Group: formLayout */
		endRow: boolean /* Boolean */;

		/** By default buttonItems are sized to match their content (see ButtonItem.autoFit). Specifying an explicit size for the button will disable this behavior.
		 * Flags: IRW, Group: appearance */
		height: number;

		/** Optional icon image to display on the button for this item. See Button.icon.
		 * Flags: IR, Group: appearance */
		icon: string /* SCImgURL */;

		/** If this item is FormItem.getCanEdit','read-only, how should this item be displayed to the user? If set, overrides the form-level DynamicForm.readOnlyDisplay default.
		 * Flags: IRW */
		readOnlyDisplay: ReadOnlyDisplayAppearance;

		/** This property governs whether StatefulCanvas.showFocusedAsOver','showFocusedAsOver is true on the automatically created Button for this item.
		 * Flags: IRW */
		showFocusedAsOver: boolean /* Boolean */;

		/** Buttons do not show a title by default.
		 * Flags: IRW, Group: appearance */
		showTitle: boolean /* Boolean */;

		/** These items are in a row by themselves by default
		 * Flags: IRW, Group: formLayout */
		startRow: boolean /* Boolean */;


		/* Instance Method Overrides */

		/** 
		 * Called when a ButtonItem is clicked on.
		 * @param {DynamicForm} form - the managing DynamicForm instance
		 * @param {FormItem} item - the form item itself (also available as "this")
		 */
		click?(form:DynamicForm, item:FormItem): boolean; 

	} // ButtonItem

	export interface ButtonItemStatic<T, P> extends CanvasItemStatic<T, P> {
	} // ButtonItemStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a Canvas Props argument.
	 * This is derived from the methods in the Canvas class and it's parents and their properties marked with the I flag.
	 */
	export interface CanvasProps extends BaseWidgetProps {
		/** If specified this governs the HTML accessKey for the widget. This should be set to a character - when a user hits the html accessKey modifier for the browser, plus this character, focus will be given to the widget in question. The accessKey modifier can vary by browser and platform. The following list of default behavior is for reference only, developers should also consult browser documentation for additional information. Internet Explorer (all platforms): Alt + accessKey Mozilla Firefox (Windows, Unix): Alt+Shift + accessKey Mozilla Firefox (Mac): Ctrl+Opt + accessKey Chrome and Safari (Windows, Unix): Alt + accessKey Chrome and Safari (Mac): Ctrl+Opt + accessKey 
		 * Flags: IRWA, Group: focus */
		accessKey?: string; // Flags=IRWA
		/** See Canvas.adaptiveWidthPriority.
		 * Flags: IR */
		adaptiveHeightPriority?: number /* integer */; // Flags=IR
		/** If multiple widgets in the same Layout have Canvas.canAdaptWidth','adaptive width, adaptiveWidthPriority can be set to indicate which of the components should be given priority access to space. The widget with the highest priority setting will be offered surplus space first, and asked to give up space last. Lack of a priority setting is treated as zero. Any adaptive widgets with the same priority setting will be asked to give up or release space according to their order in Layout.members.
		 * Flags: IR */
		adaptiveWidthPriority?: number /* integer */; // Flags=IR
		/** On Browser.isTouch','touch devices that support native touch scrolling, if Canvas.showCustomScrollbars','showCustomScrollbars is true and touch scrolling has not been disabled by the Canvas.useTouchScrolling and/or Canvas.disableTouchScrollingForDrag settings, should custom scrollbars <em>and</em> native touch scrolling be enabled for this component? If false or unset, then only native touch scrolling will be enabled. If true, then both scrolling mechanisms will be enabled. <strong>NOTE:</strong> Because native touch scrolling (also called momentum scrolling) is computationally intensive, some mobile browsers implement an optimization where the state of the DOM for the element being scrolled will be frozen or partially frozen during the scroll animation. This results in a delay between when the scroll position reaches a certain point in the animation and when the positions of the custom scrollbar thumbs are updated to reflect that scroll position.
		 * Flags: IRA, Group: scrolling */
		alwaysShowScrollbars?: boolean /* Boolean */; // Flags=IRA
		/** Default acceleration effect to apply to all animations on this Canvas. Can be overridden by setting animationAcceleration for specific animations or by passing an acceleration function directly into the appropriate method.
		 * Flags: IRWA, Group: animation */
		animateAcceleration?: AnimationAcceleration; // Flags=IRWA
		/** Default time for performing an animated fade. If unset, this.animateTime will be used by default instead
		 * Flags: IRWA, Group: animation */
		animateFadeTime?: number; // Flags=IRWA
		/** Default acceleration function for performing an animated hide. If unset, this.animateAcceleration will be used by default instead
		 * Flags: IRWA, Group: animation */
		animateHideAcceleration?: AnimationAcceleration; // Flags=IRWA
		/** Default animation effect to use if Canvas.animateHide is called without an explicit effect parameter
		 * Flags: IRWA, Group: animation */
		animateHideEffect?: string | AnimateShowEffect /* animateShowEffectId | animateShowEffect */; // Flags=IRWA
		/** Default time for performing an animated hide. If unset, this.animateTime will be used by default instead
		 * Flags: IRWA, Group: animation */
		animateHideTime?: number; // Flags=IRWA
		/** Default acceleration effect for performing an animated move. If unset, this.animateAcceleration will be used by default instead
		 * Flags: IRWA, Group: animation */
		animateMoveAcceleration?: AnimationAcceleration; // Flags=IRWA
		/** Default time for performing an animated move. If unset, this.animateTime will be used by default instead
		 * Flags: IRWA, Group: animation */
		animateMoveTime?: number; // Flags=IRWA
		/** Default acceleration function for performing an animated move and resize. If unset, this.animateAcceleration will be used by default instead
		 * Flags: IRWA, Group: animation */
		animateRectAcceleration?: AnimationAcceleration; // Flags=IRWA
		/** Default time for performing an animated setRect. If unset, this.animateTime will be used by default instead
		 * Flags: IRWA, Group: animation */
		animateRectTime?: number; // Flags=IRWA
		/** Default acceleration function for performing an animated resize. If unset, this.animateAcceleration will be used by default instead
		 * Flags: IRWA, Group: animation */
		animateResizeAcceleration?: AnimationAcceleration; // Flags=IRWA
		/** Default time for performing an animated resize. If unset, this.animateTime will be used by default instead
		 * Flags: IRWA, Group: animation */
		animateResizeTime?: number; // Flags=IRWA
		/** Default acceleration function for performing an animated scroll. If unset, this.animateAcceleration will be used by default instead
		 * Flags: IRWA, Group: animation */
		animateScrollAcceleration?: AnimationAcceleration; // Flags=IRWA
		/** Default time for performing an animated scroll. If unset, this.animateTime will be used by default instead
		 * Flags: IRWA, Group: animation */
		animateScrollTime?: number; // Flags=IRWA
		/** Default acceleration function for performing an animated show. If unset, this.animateAcceleration will be used by default instead
		 * Flags: IRWA, Group: animation */
		animateShowAcceleration?: AnimationAcceleration; // Flags=IRWA
		/** Default animation effect to use if Canvas.animateShow is called without an explicit effect parameter
		 * Flags: IRWA, Group: animation */
		animateShowEffect?: string | AnimateShowEffect /* animateShowEffectId | animateShowEffect */; // Flags=IRWA
		/** Default time for performing an animated show. If unset, this.animateTime will be used by default instead
		 * Flags: IRWA, Group: animation */
		animateShowTime?: number; // Flags=IRWA
		/** Default total duration of animations. Can be overridden by setting animation times for specific animations, or by passing a duration parameter into the appropriate animate...() method.
		 * Flags: IRWA, Group: animation */
		animateTime?: number; // Flags=IRWA
		/** Default directory for app-specific images, relative to the Page-wide Page.getAppImgDir','appImgDir.
		 * Flags: IRWA, Group: images */
		appImgDir?: string /* URL */; // Flags=IRWA
		/** ARIA role of this component. Usually does not need to be manually set - see accessibility.
		 * Flags: IR, Group: accessibility */
		ariaRole?: string /* String */; // Flags=IR
		/** ARIA state mappings for this component. Usually this does not need to be manually set - see accessibility. This attribute should be set to a mapping of aria state-names to values - for example to have the "aria-haspopup" property be present with a value "true", you'd specify: { haspopup : true } 
		 * Flags: IRA, Group: accessibility */
		ariaState?: any /* Object */; // Flags=IRA
		/** If true, this canvas will draw itself immediately after it is created. Note that you should turn this OFF for any canvases that are provided as children of other canvases, or they will draw initially, then be clear()ed and drawn again when added as children, causing a large performance penalty. For example, the following code is incorrect and will cause extra draw()s: isc.Layout.create({ members : [ isc.ListGrid.create() ] }); It should instead be: isc.Layout.create({ members : [ isc.ListGrid.create({ autoDraw: false }) ] }); In order to avoid unwanted autoDrawing systematically, it is recommend that you call isc.setAutoDraw','isc.setAutoDraw(false) immediately after SmartClient is loaded and before any components are created, then set autoDraw:true or call draw() explicitly to draw components. Otherwise, if the global setting for autoDraw remains true, you must set autoDraw:false, as shown above, on every component in your application that should not immediately draw: all Canvas children, Layout members, Window items, Tab panes, etc, however deeply nested. Forgetting to set autoDraw:false will result in one more clear()s - these are reported on the Results tab of the debugging','Developer Console, and can be tracked to individual components by using the "clears" log category in the Developer Console.
		 * Flags: IR, Group: drawing */
		autoDraw?: boolean /* Boolean */; // Flags=IR
		/** This initialization property allows developers to create a canvas using the Class.addAutoChild method, and have it added as a child to some other component. This property may be set to the childName of another already-created auto-child, or "none" to cause the component to be created without being added as a child to any other widget. If unset, the canvas will be added as a child to the component on which addAutoChild(...) was called. See autoChildren for an overview of the autoChild subsystem.
		 * Flags: IRA, Group: autoChildren */
		autoParent?: string /* String */; // Flags=IRA
		/** If set to true, the widget's parent (if any) will automatically be shown whenever the widget is shown.
		 * Flags: IRWA, Group: appearance */
		autoShowParent?: boolean /* Boolean */; // Flags=IRWA
		/** The background color for this widget. It corresponds to the CSS background-color attribute. You can set this property to an RGB value (e.g. #22AAFF) or a named color (e.g. red) from a list of browser supported color names.
		 * Flags: IRW, Group: appearance */
		backgroundColor?: string /* CSSColor */; // Flags=IRW
		/** URL for a background image for this widget (corresponding to the CSS "background-image" attribute).
		 * Flags: IRW, Group: appearance */
		backgroundImage?: string /* SCImgURL */; // Flags=IRW
		/** Specifies how the background image should be positioned on the widget. It corresponds to the CSS background-position attribute. If unset, no background-position attribute is specified if a background image is specified.
		 * Flags: IR, Group: appearance */
		backgroundPosition?: string; // Flags=IR
		/** Specifies how the background image should be tiled if this widget is larger than the image. It corresponds to the CSS background-repeat attribute. The default of null means no background-repeat CSS will be written out. See BackgroundRepeat type for details on other settings. NOTE: this setting directly sets the CSS property background-repeat but does not attempt to work around various known bugs with this setting, or lack of support in IE6. If you need to apply CSS-based workarounds for browser limitations with this setting, it's best to do so via setting Canvas.styleName.
		 * Flags: IR, Group: appearance */
		backgroundRepeat?: BackgroundRepeat; // Flags=IR
		/** Set the CSS border of this component, as a CSS string including border-width, border-style, and/or color (eg "2px solid blue"). This property applies the same border to all four sides of this component. Different per-side borders can be set in a CSS style and applied via Canvas.styleName. If Canvas.isGroup is set to true then border is derived from the Canvas.groupBorderCSS attribute, not from the explicit border property.
		 * Flags: IRW, Group: appearance */
		border?: string; // Flags=IRW
		/** Indicates that this object can receive dropped widgets (i.e. other widgets can be dropped on top of it).
		 * Flags: IRWA, Group: dragdrop */
		canAcceptDrop?: boolean /* Boolean */; // Flags=IRWA
		/** See Canvas.canAdaptWidth.
		 * Flags: IRW */
		canAdaptHeight?: boolean /* Boolean */; // Flags=IRW
		/** Indicates that this component is able to render itself at multiple possible sizes, in order to fit into less space when very little space is available, or to display more information or provide more immediate access to functionality when more space is available. Unlike simply indicating a flexible size via width:"*", setting canAdaptWidth indicates that a component has 2 (or more) different ways of rendering itself with different discrete sizes, but does not have the ability to use every additional available pixel. For example, a menu embedded in a toolbar might show as only a fixed-size icon which reveals menu options when clicked, or if enough space is available, could show all of the menu options directly in the toolbar. In this example, the menu should either be allocated just enough space for an icon, or enough space for all options to appear inline; any other amount of space being allocated is just a waste. When a component with canAdaptWidth is part of a Layout, Canvas.adaptWidthBy will be called every time component sizes are being calculated, passing a positive or negative pixel value: a positive pixel value indicates a surplus - all other component's minimum sizes can be accommodated, including any Canvas.minWidth declared on the canAdaptWidth component itself a negative pixel value indicates that the containing layout is going to be forced to Overflow (introduce scrollbars, clip content, etc) unless some component or set of components gives up at least this many pixels If a non-zero value is returned from adaptWidthBy, this means that the component is willing to shrink or expand by that many pixels. Returning 0 means that the component is unable to reduce size further, or for a surplus, cannot make good use of the surplus space. A call to Canvas.adaptWidthBy may surrender as many pixels as desired (as long as the widget won't drop below its minimum allowed width), no matter whether a positive (surplus) or negative (overflow) pixel value is supplied, but A call to Canvas.adaptWidthBy may not increase its size by more than the number of offered pixels - so if an overflow is present, it may not increase its size at all. Note that when the initial width is specified as a stretch size (e.g. "*"), then after Canvas.adaptWidthBy is called, the Framework will stretch (but not shrink) the member like any other stretch-size Layout member, but the unadaptedWidth argument will always reflect the unstretched width requested by the previous call to Canvas.adaptWidthBy. This behavior may be disabled by specifying the initial width as a number, or leaving it unspecified. Caution: you must either determine the current size of the canvas by maintaining your own internal state, or use the unadaptedWidth parameter passed to Canvas.adaptWidthBy. You must not call Canvas.getWidth or Canvas.getVisibleWidth on the canvas itself inside Canvas.adaptWidthBy as the size is in the processing of being determined, but you may draw children or call Canvas.getVisibleWidth on them, as we guarantee that the adaptive-width canvas is drawn before the first call to Canvas.adaptWidthBy. An example of drawing children in Canvas.adaptWidthBy to compute overall width may be seen in the inlinedMenuMobileSample', 'Inlined Menu Mobile Sample. Note that reasonable settings for Canvas.minWidth should be applied to all other flexible-sized members of a layout where a canAdaptWidth component appears, because when too little space is available, a canAdaptWidth component will absorb all available space until minimums for other components are hit (or the canAdaptWidth component reaches its maximum size). If more than one canAdaptWidth component is present, Canvas.adaptiveWidthPriority to give priority to a particular component when allocating space. All of the above behaviors are exactly the same for height, using Canvas.canAdaptHeight and Canvas.adaptHeightBy.
		 * Flags: IRW */
		canAdaptWidth?: boolean /* Boolean */; // Flags=IRW
		/** Indicates whether this widget can initiate custom drag-and-drop operations (other than reposition or resize). Normally Canvas.canDragReposition or Canvas.canDragResize would be used instead of this property. Note: this property may be manipulated by higher-level dragging semantics. If Canvas.useNativeDrag is true and this widget has been drawn, then this widget must be Canvas.redraw','redrawn in order for a change of the value of this attribute to take effect.
		 * Flags: IRWA, Group: dragdrop */
		canDrag?: boolean /* Boolean */; // Flags=IRWA
		/** Indicates whether this widget can be moved by a user of your application by simply dragging with the mouse.
		 * Flags: IRWA, Group: dragdrop */
		canDragReposition?: boolean /* Boolean */; // Flags=IRWA
		/** Indicates whether this widget can be resized by dragging on the edges and/or corners of the widget with the mouse.
		 * Flags: IRWA, Group: dragdrop */
		canDragResize?: boolean /* Boolean */; // Flags=IRWA
		/** If this Canvas is canAcceptDrop:true, when the user drags a droppable widget over an edge of the widget, should we scroll to show the rest of the widget's content? Returned from canvas.shouldDragScroll() if there are scrollbars.
		 * Flags: IRWA, Group: dragging */
		canDragScroll?: boolean; // Flags=IRWA
		/** Indicates that this object can be dropped on top of other widgets. Only valid if canDrag or canDragReposition is true.
		 * Flags: IRWA, Group: dragdrop */
		canDrop?: boolean /* Boolean */; // Flags=IRWA
		/** When explicitly set to false, disallows drop before this member in the Layout.
		 * Flags: IRWA, Group: layoutMember */
		canDropBefore?: boolean; // Flags=IRWA
		/** Can this widget be allowed to become the target of keyboard events? If canFocus is unset (the default), only scrollable widgets with visible scrollbars are focusable, to allow for keyboard scrolling. A widget normally receives focus by being clicked on or tabbed to.
		 * Flags: IRWA, Group: focus */
		canFocus?: boolean; // Flags=IRWA
		/** Will this Canvas fire hover events when the user hovers over it, or one of its children?
		 * Flags: IRW, Group: hovers */
		canHover?: boolean; // Flags=IRW
		/** Whether native drag selection of contained text is allowed within this Canvas. Note that setting this property to false will not avoid text selection which is initiated outside this Canvas from continuing into this Canvas, even if text selection began in another Canvas.
		 * Flags: IRWA, Group: events */
		canSelectText?: boolean /* Boolean */; // Flags=IRWA
		/** Array of all Canvii that are immediate children of this Canvas. Use Canvas.addChild and Canvas.removeChild to add and remove children after a Canvas has been created/drawn.
		 * Flags: IR, Group: containment */
		children?: Array<Canvas> /* Array of Canvas */; // Flags=IR
		/** Flag to disable snapping to alignment when children of this Canvas are resized
		 * Flags: IRW */
		childrenResizeSnapAlign?: boolean /* Boolean */; // Flags=IRW
		/** If enabled while Canvas.childrenSnapToGrid is enabled, children dragged within this Canvas will also snap to positions where their edges or center lines would be aligned with the edges or centers of other components, and lines will be shown to point out the possible alignment (with appearance controlled by Canvas.snapAlignCenterLineStyle and Canvas.snapAlignEdgeLineStyle respectively. By default, edge- or center-snapping is enabled for all components, but the set of eligible components can be explicitly set via Canvas.snapAlignCandidates. See also Canvas.childrenSnapCenterAlign and Canvas.childrenSnapEdgeAlign for enabling or disabling center alignment or edge alignment individually.
		 * Flags: IRW */
		childrenSnapAlign?: boolean /* Boolean */; // Flags=IRW
		/** See Canvas.childrenSnapAlign. This setting enables or disables snapping on center alignment only.
		 * Flags: IRW */
		childrenSnapCenterAlign?: boolean /* Boolean */; // Flags=IRW
		/** See Canvas.childrenSnapAlign. This setting enables or disables snapping on edge alignment only.
		 * Flags: IRW */
		childrenSnapEdgeAlign?: boolean /* Boolean */; // Flags=IRW
		/** If true, causes this canvas's children to snap to its grid when resizing. This behavior can be overridden on a per-child basis by setting the Canvas.snapToGrid','snapToGrid or Canvas.snapResizeToGrid','snapResizeToGrid value on the child.
		 * Flags: IRW, Group: dragdrop */
		childrenSnapResizeToGrid?: boolean; // Flags=IRW
		/** If true, causes this canvas's children to snap to its grid when dragging. This behavior can be overridden on a per-child basis by setting the Canvas.snapToGrid','snapToGrid value on the child.
		 * Flags: IRW, Group: dragdrop */
		childrenSnapToGrid?: boolean; // Flags=IRW
		/** Defaults for the Canvas.componentMask autoChild. Default properties include Canvas.backgroundColor being set to "black" and Canvas.opacity being set to 20.
		 * Flags: IR */
		componentMaskDefaults?: CanvasProps /* Canvas Properties */; // Flags=IR
		/** The contents of a canvas or label widget. Any HTML string is acceptable.
		 * Flags: IRWA, Group: contents */
		contents?: string /* HTMLString */; // Flags=IRWA
		/** Context menu to show for this object, an instance of the Menu widget. Note: if Canvas.destroy is called on a canvas, any specified context menu is not automatically destroyed as well. This is in contrast to MenuButtons which automatically destroy their specified MenuButton.menu by default. The behavior is intentional as context menus are commonly reused across components.
		 * Flags: IRWA, Group: cues */
		contextMenu?: Menu; // Flags=IRWA
		/** Specifies the cursor image to display when the mouse pointer is over this widget. It corresponds to the CSS cursor attribute. See Cursor type for different cursors. See also Canvas.disabledCursor and Canvas.noDropCursor.
		 * Flags: IRWA, Group: cues */
		cursor?: Cursor; // Flags=IRWA
		/** Array of side names ("T", "B", "L", "R") specifying which sides of the decorated component should show edges. For example: customEdges : ["T", "B"] .. would show edges only on the top and bottom of a component. The default of null means edges will be shown on all sides.
		 * Flags: IR, Group: imageEdges */
		customEdges?: Array<string> /* Array of String */; // Flags=IR
		/** A dataPath may be specified on any canvas. This provides a straightforward way to display or edit complex nested data. For components which support displaying or editing data values, (such as DynamicForm or ListGrid components), the dataPath may be set to specify how the components data is accessed. In this case the dataPath essentially specifies a nested object to edit - typically a path to a field value within a dataSource record. Note that a ValuesManager will be required to handle connecting the dataBoundcomponent to the appropriate sub object. This may be explicitly specified on the component, or a parent of the component, or automatically generated if a DataSource is specified on either the component or a parent thereof. To provide a simple example - if a complex object existed with the following format: { companyName:"Some Company", address:{ street:"123 Main Street", city:"New York", state:"NY" } } a developer could specify a DynamicForm instance with 'dataPath' set to "address" to edit the nested address object: isc.ValuesManager.create({ ID:'vm', values: { companyName:"Some Company", address:{ street:"123 Main Street", city:"New York", state:"NY" } } }); isc.DynamicForm.create({ valuesManager:"vm", dataPath:"address", items:[{name:"street"}, {name:"city"}, {name:"state"}] }); If a component is specified with a dataPath attribute but does not have an explicitly specified valuesManager, it will check its parent element chain for a specified valuesManager and automatically bind to that. This simplifies binding multiple components used to view or edit a nested data structure as the valuesManager needs only be defined once at a reasonably high level component. Here's an example of this approach: isc.ValuesManager.create({ ID:'vm', values: { companyName:"Some Company", address:{ street:"123 Main Street", city:"New York", state:"NY" } } }); isc.Layout.create({ valuesManager:vm, members:[ isc.DynamicForm.create({ dataPath:"/", items:[{name:"companyName"}] }), isc.DynamicForm.create({ dataPath:"address", items:[{name:"street"}, {name:"city"}, {name:"state"}] }) ] }); Note that in this case the valuesManager is specified on a Layout, which has no 'values' management behavior of its own, but contains items with a specified dataPath which do. In this example you'd see 2 forms allowing editing of the nested data structure. dataPaths from multiple nested components may also be combined. For example: isc.ValuesManager.create({ ID:'vm', values: { companyName:"Some Company", address:{ street:"123 Main Street", city:"New York", state:"NY" } parentCompany:{ companyName:"Some Corporation", address:{ street:"1 High Street", city:"New York", state:"NY" } } } }); isc.Layout.create({ valuesManager:vm, members:[ isc.DynamicForm.create({ dataPath:"/", items:[{name:"companyName"}] }), isc.DynamicForm.create({ dataPath:"address", items:[{name:"street"}, {name:"city"}, {name:"state"}] }), isc.Layout.create({ dataPath:"parentCompany", members:[ isc.DynamicForm.create({ dataPath:"/", items:[{name:"companyName", type:"staticText"}] }), isc.DetailViewer.create({ dataPath:"address", fields:[{name:"street", name:"city", name:"state"}] }) ] }) ] }); In this example the detailViewer will display data from the parentCompany.address object within the base record. Note that if a component has a specified dataSource and shows child components with a specified dataPath, there is no need to explicitly declare a valuesManager at all. If a component with a dataPath has a dataSource, or an ancestor with a dataSource specified, it will, a valuesManager will automatically be generated on the higher level component (and be available as component.valuesManager).
		 * Flags: IRWA */
		dataPath?: string /* DataPath */; // Flags=IRWA
		/** For custom components, establishes a default height for the component. For a component that should potentially be sized automatically by a Layout, set this property rather than Canvas.height directly, because Layouts regard a height setting as an explicit size that shouldn't be changed.
		 * Flags: IRWA, Group: sizing */
		defaultHeight?: number /* int */; // Flags=IRWA
		/** For custom components, establishes a default width for the component. For a component that should potentially be sized automatically by a Layout, set this property rather than Canvas.width directly, because Layouts regard a width setting as an explicit size that shouldn't be changed.
		 * Flags: IRWA, Group: sizing */
		defaultWidth?: number /* int */; // Flags=IRWA
		/** If set to true, the widget will be disabled. A widget is only considered enabled if it is individually enabled and all parents above it in the containment hierarchy are enabled. This allows you to enable or disable all components of a complex nested widget by enabling or disabling the top-level parent only.
		 * Flags: IRW, Group: enable */
		disabled?: boolean; // Flags=IRW
		/** Specifies the cursor image to display when the mouse pointer is over this widget if this widget is disabled. It corresponds to the CSS cursor attribute. See Cursor type for different cursors.
		 * Flags: IRWA, Group: cues */
		disabledCursor?: Cursor; // Flags=IRWA
		/** Disables Canvas.useTouchScrolling whenever a built-in drag operation has been enabled which is known to be non-functional if touch scrolling is enabled. Default behavior is to leave touch scrolling enabled even if it makes other enabled drag operations non-functional, since any accessibility','accessible application must provide an alternative way to perform drag and drop operations anyway. disableTouchScrollingForDrag exists so that applications can change the default setting on a per-component basis (via Class.changeDefaults), in order to make a system-wide or per-component-type decision about whether to favor touch scrolling vs retaining the ability to drag and drop via finger drags, instead of having to set useTouchScrolling on each individual instance. See the mobileDevelopment','Mobile Development overview for more background information.
		 * Flags: IR, Group: scrolling */
		disableTouchScrollingForDrag?: boolean /* Boolean */; // Flags=IR
		/** Amount of time (in milliseconds) between which two clicks are considered a single click
		 * Flags: IRWA, Group: events */
		doubleClickDelay?: number /* int */; // Flags=IRWA
		/** Visual appearance to show when the object is being dragged. May be overridden for dragResize or dragReposition events via Canvas.dragResizeAppearance and Canvas.dragRepositionAppearance.
		 * Flags: IRWA, Group: dragdrop */
		dragAppearance?: DragAppearance; // Flags=IRWA
		/** This indicates how the system will test for droppable targets: either by intersection with the mouse or intersection with the rectangle of the dragMoveTarget.
		 * Flags: IRWA, Group: dragdrop */
		dragIntersectStyle?: DragIntersectStyle; // Flags=IRWA
		/** This property controls what kind of mask is used in case Canvas.useDragMask is enabled.
		 * Flags: IRW, Group: dragdrop */
		dragMaskType?: DragMaskType; // Flags=IRW
		/** Sets maximum height that this Canvas can be resized to by a user. Actual limit will be minimum of dragMaxHeight and Canvas.maxHeight.
		 * Flags: IRWA, Group: sizing */
		dragMaxHeight?: number; // Flags=IRWA
		/** Maximum width that this Canvas can be resized to by a user. Actual limit will be minimum of dragMaxWidth and Canvas.maxWidth.
		 * Flags: IRWA, Group: sizing */
		dragMaxWidth?: number; // Flags=IRWA
		/** Minimum height that this Canvas can be resized to by a user. See Canvas.dragMinWidth for details of behavior.
		 * Flags: IRWA, Group: sizing */
		dragMinHeight?: number; // Flags=IRWA
		/** Minimum width that this Canvas can be resized to by a user. Actual limit will be maximum of dragMinWidth and Canvas.minWidth. Note that a Canvas with overflow:"visible" has an implicit minimize size based on it's contents. Note that dragMinWidth affects only user-initiated drag resizes. To set the minimum width of a Canvas embedded in a Layout, you can set +{minWidth}, or Layout.minMemberLength to constrain the minimum size along the length axis of all members of the Layout.
		 * Flags: IRWA, Group: sizing */
		dragMinWidth?: number; // Flags=IRWA
		/** If this widget has dragAppearance "target", this value specifies the opacity to render the target while it is being dragged. A null value implies we do not modify the opacity.
		 * Flags: IRWA, Group: dragdrop */
		dragOpacity?: number /* int */; // Flags=IRWA
		/** If Canvas.canDragReposition is true, this attributes specifies the visual appearance to show during drag reposition. If unset Canvas.dragAppearance will be used.
		 * Flags: IRWA, Group: dragdrop */
		dragRepositionAppearance?: DragAppearance; // Flags=IRWA
		/** Cursor to switch to if the mouse is over a widget that is drag repositionable.
		 * Flags: IRWA, Group: dragdrop */
		dragRepositionCursor?: Cursor; // Flags=IRWA
		/** If Canvas.canDragResize is true, this attributes specifies the visual appearance to show during drag resize. If unset Canvas.dragAppearance will be used.
		 * Flags: IRWA, Group: dragdrop */
		dragResizeAppearance?: DragAppearance; // Flags=IRWA
		/** If this widget supports drag-scrolling, This property specifies how many ms the user must hover over the drag-scroll threshold before scrolling begins.
		 * Flags: IRWA, Group: dragging */
		dragScrollDelay?: number; // Flags=IRWA
		/** Number of pixels the cursor needs to move before the EventHandler starts a drag operation.
		 * Flags: IRWA, Group: dragdrop */
		dragStartDistance?: number; // Flags=IRWA
		/** A different widget that should be actually dragged when dragging initiates on this widget. One example of this is to have a child widget that drags its parent, as with a drag box. Because the parent automatically repositions its children, setting the drag target of the child to the parent and then dragging the child will result in both widgets being moved. Valid dragTarget values are: - null (default) [this widget is its own drag target] - another widget, or widget ID - "parent" drag target is this widget's Canvas.getParentCanvas','parentCanvas - "top" drag target is this widget's Canvas.topElement','topElement
		 * Flags: IRWA, Group: dragdrop */
		dragTarget?: Canvas | string /* Canvas | String */; // Flags=IRWA
		/** Sets a dragType for this widget used, to be compared to Canvas.dropTypes','dropTypes on possible drop target widgets. See Canvas.dropTypes for a full explanation.
		 * Flags: IRWA, Group: dragdrop */
		dragType?: string /* String */; // Flags=IRWA
		/** When a drag and drop interaction occurs, if a Canvas.dragType','dragType is configured on the source widget, it is compared to the dropTypes configured on the target widget, and a drop is only allowed if the dragType is listed in the target widget's dropTypes array. The default setting means any dragType is eligible for dropping on this widget, including no dragType setting. See also Canvas.willAcceptDrop for dynamic determination of drop eligibility.
		 * Flags: IRWA, Group: dragdrop */
		dropTypes?: Array<string> /* Array of String | String */; // Flags=IRWA
		/** Dynamic contents allows the contents string to be treated as a simple, but powerful template. When this attribute is set to true, expressions of the form &#36;{arbitrary JS here} are replaced by the result of the evaluation of the JS code inside the curly brackets. This evaluation happens at draw time. If you want to trigger a re-evaluation of the expressions in the contents string you can call markForRedraw() on the canvas. You can use this feature to build some simple custom components. For example, let's say you want to show the value of a Slider in a Canvas somewhere on the screen. You can do this by observing the valueChanged() method on the slider and calling setContents() on your canvas with the new string or you can set the contents of the canvas to something like: "The slider value is &#36;{sliderInstance.getValue()}." Next you set dynamicContents: true on the canvas, observe valueChanged() on the slider and call canvas.markForRedraw() in that observation. This approach is cleaner than setContents() when the Canvas is aggregating several values or dynamic expressions. Like so: Slider.create({ ID: "mySlider" }); Canvas.create({ ID: "myCanvas", dynamicContents: true, contents: "The slider value is &#36;{mySlider.getValue()}." }); myCanvas.observe(mySlider, "valueChanged", "observer.markForRedraw()"); You can embed an arbitrary number of dynamic expressions in the contents string. The search and replace is optimized for speed. If an error occurs during the evaluation of one of the expressions, a warning is logged to the ISC Developer Console and the error string is embedded in place of the expected value in the Canvas. The value of a function is its return value. The value of any variable is the same as that returned by its toString() representation. Inside the evaluation contentext, this points to the canvas instance that has the dynamicContents string as its contents - in other words the canvas instance on which the template is declared.
		 * Flags: IRWA, Group: contents */
		dynamicContents?: boolean /* Boolean */; // Flags=IRWA
		/** An optional map of name:value parameters that will be available within the scope of the dynamicContents evaluation. For example - if you have e.g: Canvas.create({ dynamicContents: true, dynamicContentsVars: { name: "Bob" }, contents: "hello &#36;{name}" }); The above will create a canvas with contents hello Bob. You can add, remove, and change values in the dynamicContentsVars object literal, just call markForRedraw() on the canvas to have the dynamicContents template re-evaluated. Note that this is always available inside a dynamic contents string and points to the canvas instance containing the dynamic contents. Used only if Canvas.dynamicContents : true has been set.
		 * Flags: IRWA */
		dynamicContentsVars?: ValueMap; // Flags=IRWA
		/** Background color for the EdgedCanvas created to decorate this component. This can be used to provide an underlying "tint" color for translucent edge media
		 * Flags: IR, Group: imageEdges */
		edgeBackgroundColor?: string /* CSSColor */; // Flags=IR
		/** Background color for the center section only. Can be used as a surrogate background color for the decorated Canvas, if the Canvas is set to partially overlap the edges and hence can't show a background color itself without occluding media.
		 * Flags: IR, Group: imageEdges */
		edgeCenterBackgroundColor?: string /* CSSColor */; // Flags=IR
		/** Cursor to use when over each edge of a Canvas that is drag resizable. To disable drag resize cursors, set the edgeCursorMap property to null.
		 * Flags: IRWA, Group: dragdrop */
		edgeCursorMap?: any /* object */; // Flags=IRWA
		/** Base name of images for edges. Extensions for each corner or edge piece will be added to this image URL, before the extension. For example, with the default base name of "edge.gif", the top-left corner image will be "edge_TL.gif". The full list of extensions is: "_TL", "_TR", "_BL", "_BR", "_T", "_L", "_B", "_R", "_center".
		 * Flags: IR, Group: imageEdges */
		edgeImage?: string /* SCImgURL */; // Flags=IR
		/** How far into the edge of an object do we consider the "edge" for drag resize purposes?
		 * Flags: IRWA, Group: dragdrop */
		edgeMarginSize?: number; // Flags=IRWA
		/** Amount the contained Canvas should be offset. Defaults to edgeSize; set to less than edgeSize to allow the contained Canvas to overlap the edge and corner media.
		 * Flags: IR, Group: imageEdges */
		edgeOffset?: number; // Flags=IR
		/** Opacity of the edges. Defaults to matching this.opacity. if Canvas.setOpacity is called on a Canvas where edgeOpacity is set, edgeOpacity will be considered a percentage of the parent's opacity (so 50% opaque parent plus edgeOpacity 50 means 25% opaque edges)
		 * Flags: IR, Group: imageEdges */
		edgeOpacity?: number /* int */; // Flags=IR
		/** Whether to show media in the center section, that is, behind the decorated Canvas.
		 * Flags: IR, Group: imageEdges */
		edgeShowCenter?: boolean /* Boolean */; // Flags=IR
		/** Size in pixels for corners and edges
		 * Flags: IR, Group: imageEdges */
		edgeSize?: number; // Flags=IR
		/** An EditProxy controls the behaviors of a component when it is placed into devTools','editing mode. The editProxy AutoChild is created when a component is first placed into edit mode via Canvas.setEditMode. editProxy properties can be supplied on a PaletteNode or EditNode as PaletteNode.editProxyProperties','editProxyProperties, but must be provided before the component is first placed into edit mode. Most editable components use a custom EditProxy. See the documentation for each class' Canvas.editProxyConstructor','editProxyConstructor to determine the class.
		 * Flags: IR */
		editProxy?:  EditProxy /* AutoChild EditProxy */; // Flags=IR
		/** Default class used to construct the EditProxy for this component when the component is Canvas.setEditMode','first placed into edit mode.
		 * Flags: IR */
		editProxyConstructor?: string /* SCClassName */; // Flags=IR
		/** Criteria to be evaluated to determine whether this Canvas should be enabled. Re-evaluated whenever data in the Canvas.ruleScope changes. A basic criteria uses textMatchStyle:"exact". When specified in componentXML','Component XML this property allows xmlCriteriaShorthand','shorthand formats for defining criteria.
		 * Flags: IR, Group: ruleCriteria */
		enableWhen?: AdvancedCriteria; // Flags=IR
		/** When this Canvas is included as a member in a Layout, extra blank space that should be left after this member in a Layout.
		 * Flags: IR, Group: layoutMember */
		extraSpace?: number /* positiveInteger */; // Flags=IR
		/** Sets the style for the grouping frame around the canvas. Only necessary when Canvas.isGroup is set to true.
		 * Flags: IR, Group: appearance */
		groupBorderCSS?: string /* String */; // Flags=IR
		/** If set, the background color of the grouping label. Only applicable when Canvas.isGroup is set to true. This corresponds to the CSS background-color property on the grouping label. You can set this property to an RGB value (e.g. #22AAFF) or a named color (e.g. red) from a list of browser supported color names. 
		 * Flags: IRW, Group: appearance */
		groupLabelBackgroundColor?: string /* CSSColor */; // Flags=IRW
		/** Sets the style for the grouping label. Only necessary when Canvas.isGroup is set to true. Note that Canvas.groupLabelBackgroundColor overrides any background-color of this style.
		 * Flags: IR, Group: appearance */
		groupLabelStyleName?: string /* CSSStyleName */; // Flags=IR
		/** The title/label for the grouping. Only applicable when Canvas.isGroup','isGroup is set to true.
		 * Flags: IRW, Group: appearance */
		groupTitle?: string /* HTMLString */; // Flags=IRW
		/** Size for this component's vertical dimension. Can be a number of pixels, or a percentage like "50%". See documentation for Canvas.width for details on how percentage values are resolved actual size. Note that if Canvas.overflow','overflow is set to "visible", this size is a minimum, and the component may overflow to show all content and/or children. If trying to establish a default height for a custom component, set Canvas.defaultHeight','defaultHeight instead.
		 * Flags: IRW, Group: sizing */
		height?: number | string /* Number or String */; // Flags=IRW
		/** When this widget is hidden (see Canvas.visibility and Canvas.hide), should display:none be applied to the Canvas.getOuterElement','outer element? This setting is not supported for general use, but in certain cases, it has been shown that display:none is a work-around for browser bugs involving burn-through of iframes or plugins, where the content of the iframe or plugin may still be visible despite the containing widget being hidden.
		 * Flags: IRA, Group: appearance */
		hideUsingDisplayNone?: boolean; // Flags=IRA
		/** If this.showHover is true, this property can be used to customize the alignment of content in the hover canvas.
		 * Flags: IRW, Group: hovers */
		hoverAlign?: Alignment; // Flags=IRW
		/** If this.showHover is true and Canvas.getHoverComponent is implemented, should the hoverCanvas returned from it be automatically destroyed when it is hidden? The default of null indicates that the component will be automatically destroyed. Set to false to prevent this.
		 * Flags: IRW, Group: hovers */
		hoverAutoDestroy?: boolean; // Flags=IRW
		/** Maximum auto-fit width for a hover if Canvas.hoverAutoFitWidth is enabled. May be specified as a pixel value, or a percentage of page width.
		 * Flags: IRW, Group: hovers */
		hoverAutoFitMaxWidth?: number | string /* Number or String */; // Flags=IRW
		/** if Canvas.showHover is true, this property will cause the specified Canvas.hoverWidth to be treated as a minimum width for the hover. If the hover content string exceeds this, the hover will expand to accomodate it up to Canvas.hoverAutoFitMaxWidth (without the text wrapping). Using this settings differs from simply disabling wrapping via Canvas.hoverWrap','hoverWrap:false as the content will wrap if the Canvas.hoverAutoFitMaxWidth is exceeded.
		 * Flags: IRWA, Group: hovers */
		hoverAutoFitWidth?: boolean /* Boolean */; // Flags=IRWA
		/** If this.canHover is true, how long should the mouse be kept over this widget before the hover event is fired
		 * Flags: IRW, Group: hovers */
		hoverDelay?: number; // Flags=IRW
		/** If this.showHover is true, this property can be used to customize the height of the hover canvas shown.
		 * Flags: IRW, Group: hovers */
		hoverHeight?: number /* int */; // Flags=IRW
		/** If this.showHover is true, should this widget's hover canvas be moved with the mouse while visible?
		 * Flags: IRW, Group: hovers */
		hoverMoveWithMouse?: boolean; // Flags=IRW
		/** If this.showHover is true, should the hover canvas be shown with opacity other than 100?
		 * Flags: IRW, Group: hovers */
		hoverOpacity?: number; // Flags=IRW
		/** If this.showHover is true, this property can be used to specify the css style to apply to the hover canvas.
		 * Flags: IRW, Group: hovers */
		hoverStyle?: string /* CSSStyleName */; // Flags=IRW
		/** If this.showHover is true, this property can be used to customize the vertical alignment of content in the hover canvas.
		 * Flags: IRW, Group: hovers */
		hoverVAlign?: VerticalAlignment; // Flags=IRW
		/** If Canvas.showHover','this.showHover is true, this property can be used to customize the width of the hover canvas shown. See also Canvas.hoverAutoFitWidth and Canvas.hoverAutoFitMaxWidth.
		 * Flags: IRW, Group: hovers */
		hoverWidth?: number /* int */; // Flags=IRW
		/** If this.showHover is true, this property can be used to customize the whether content in the hover canvas is displayed in a single line, or wraps. Note that if developers wish to have hovers expand horizontally to fit their text without wrapping *up to some maximum*, and then wrap rather than exceeding that maximum, the Canvas.hoverAutoFitWidth and Canvas.hoverAutoFitMaxWidth attributes may be used instead of simply setting hoverWrap to false.
		 * Flags: IRW, Group: hovers */
		hoverWrap?: boolean; // Flags=IRW
		/** If specified as a pointer to an HTML element present in the DOM, this canvas will be rendered inside that element on Canvas.draw','draw(). NOTES: This feature is intended for temporary integration with legacy page architectures only; the native browser's reaction to DOM insertion is unspecified and unsupported. For consistent cross-browser layout and positioning semantics, use Canvas parents (especially Layouts) and use absolute positioning at top level. Persistence of htmlElement: If Canvas.htmlPosition is set to "replace" the htmlElement will be removed from the DOM when the canvas is drawn - therefore the htmlElement attribute will be cleared at this time. Otherwise if a Canvas is clear()d and then draw()n again it will be rendered inside the same htmlElement. If a Canvas is added as a child to Canvas parent, its htmlElement will be dropped. Canvas.position should typically be set to "relative" if the widget is to be rendered inline within a standard page.
		 * Flags: IRWA, Group: htmlElement */
		htmlElement?: string /* DOMElement */; // Flags=IRWA
		/** If Canvas.htmlElement is specified, this attribute specifies the position where the canvas should be inserted relative to the htmlElement in the DOM.
		 * Flags: IRWA, Group: htmlElement */
		htmlPosition?: DrawPosition; // Flags=IRWA
		/** Global identifier for referring to a widget in JavaScript. The ID property is optional if you do not need to refer to the widget from JavaScript, or can refer to it indirectly (for example, by storing the reference returned by Class.create','create()). An internal, unique ID will automatically be created upon instantiation for any canvas where one is not provided. The ID property should be unique in the global scope. If window[ID] is already assigned to something else a warning will be logged using the developer console, and the existing reference will be replaced, calling Canvas.destroy','destroy() on the previous object if it is a SmartClient Class instance. Automatically generated IDs will be unique as long as the canvases they refer to remain active - once a canvas with an automatically generated ID has been destroyed, its ID may be reused for the next canvas created with no explicitly specified ID.
		 * Flags: IR, Group: basics */
		ID?: string; // Flags=IR
		/** Should a grouping frame be shown around this canvas.
		 * Flags: IR */
		isGroup?: boolean; // Flags=IR
		/** Marks this Canvas as the Canvas.ruleScope that will be discovered by any contained DataBoundComponents which do not specify an explicit ruleScope.
		 * Flags: IR */
		isRuleScope?: boolean /* Boolean */; // Flags=IR
		/** Flag to disable snapping to alignment against this Canvas when other Canvases dragged into the same parent when Canvas.childrenSnapAlign is enabled on this Canvas' parent.
		 * Flags: IRW */
		isSnapAlignCandidate?: boolean /* Boolean */; // Flags=IRW
		/** Constrains drag-resizing and drag-repositioning of this canvas to either the rect of its parent (if set to true) or an arbitrary rect based its parent (if set to a [Left,Top,Width,Height] rect array). In the latter mode you may use negative offsets for left/top and a width/height greater than the visible or scroll width of the parent to allow positioning beyond the confines of the parent. If this canvas has no parent, constrains dragging to within the browser window. Affects target and outline dragAppearance, not tracker. Note: keepInParentRect affects only user drag interactions, not programmatic moves. <u>Example use cases:</u> keepInParentRect: true - confine to parent keepInParentRect: [0, 0, 500, 500] - confine to top left 500x500 region within parent keepInParentRect: [0, 0, 10000, 10000] - in combination with oveflow: "auto", confine to parent, but allow moving off the right and bottom of the parent to force scrolling (and hence enlarge the scrollWidth of the parent).
		 * Flags: IRWA, Group: dragdrop */
		keepInParentRect?: Array<number> /* Boolean | Array of Integer */; // Flags=IRWA
		/** When this Canvas is included as a member in a Layout, layoutAlign controls alignment on the breadth axis of the layout. Default is "left" for a VLayout, "top" for an HLayout.
		 * Flags: IRW, Group: layoutMember */
		layoutAlign?: Alignment | VerticalAlignment; // Flags=IRW
		/** If set, overrides the global Canvas.defaultPageSpace.
		 * Flags: IRWA, Group: positioning */
		leavePageSpace?: number /* Integer */; // Flags=IRWA
		/** Number of pixels the left side of the widget is offset to the right from its default drawing context (either its parent's topleft corner, or the document flow, depending on the value of the Canvas.position property). Can also be set as a percentage, specified as a String ending in '%', eg, "50%". In this case the top coordinate is considered as a percentage of the specified width of the Canvas.getParentCanvas','parent.
		 * Flags: IRW, Group: positioning */
		left?: number | string /* Number or String */; // Flags=IRW
		/** Strategy to use when locating children in this canvas from an autoTest locator string.
		 * Flags: IRWA, Group: autoTest */
		locateChildrenBy?: LocatorStrategy; // Flags=IRWA
		/** LocatorTypeStrategy to use when finding children within this canvas.
		 * Flags: IRWA, Group: autoTest */
		locateChildrenType?: LocatorTypeStrategy; // Flags=IRWA
		/** Strategy to use when locating peers of this canvas from an autoTest locator string.
		 * Flags: IRWA, Group: autoTest */
		locatePeersBy?: LocatorStrategy; // Flags=IRWA
		/** LocatorTypeStrategy to use when finding peers of this canvas.
		 * Flags: IRWA, Group: autoTest */
		locatePeersType?: LocatorTypeStrategy; // Flags=IRWA
		/** Set the CSS Margin, in pixels, for this component. Margin provides blank space outside of the border. This property sets the same thickness of margin on every side. Differing per-side margins can be set in a CSS style and applied via Canvas.styleName. Note that the specified size of the widget will be the size including the margin thickness on each side.
		 * Flags: IRW, Group: appearance */
		margin?: number; // Flags=IRW
		/** If Canvas.htmlElement is specified, should this canvas initially be drawn at the same dimensions as the htmlElement? Note: setting this property will not force the canvas to resize if the element subsequently resizes (for example due to page reflow).
		 * Flags: IRWA */
		matchElement?: boolean; // Flags=IRWA
		/** Maximum height available to this Canvas. See Canvas.maxWidth for details of behavior.
		 * Flags: IRWA, Group: sizing */
		maxHeight?: number; // Flags=IRWA
		/** Maximum width available to this Canvas. The maxWidth and Canvas.maxHeight settings apply to: For a canvas being managed as a member of a Layout, the maximum size the layout should apply to the canvas. For a canvas with a width or height specified as a percent value, a maximum numeric pixel value to limit how large the canvas is sized. determining size for a Canvas in a CanvasItem (maxHeight only) end user Canvas.canDragResize','drag resizing Maximum sizes do not apply in various other circumstances where sizes are being determined, such as ListGrid.showRecordComponents','ListGrid recordComponents.
		 * Flags: IRWA, Group: sizing */
		maxWidth?: number; // Flags=IRWA
		/** Default class used to construct menus created by this component, including context menus.
		 * Flags: IR, Group: cues */
		menuConstructor?: string /* SCClassName */; // Flags=IR
		/** Minimum height available to this Canvas. See Canvas.minWidth for details of behavior.
		 * Flags: IRWA, Group: sizing */
		minHeight?: number; // Flags=IRWA
		/** If the widget has drag resize configured on one or more of it's edges, and the edgeMarginSize is large enough that the remaining space is less than minNonEdgeSize, the edgeMarginSize will be reduced such that the non-edge part of the widget is at least 1/3 of the total space (with two draggable edges) or half of it (with one draggable edge).
		 * Flags: IRWA, Group: dragdrop */
		minNonEdgeSize?: number /* int */; // Flags=IRWA
		/** Minimum width available to this Canvas. The minWidth and Canvas.minHeight settings apply to: For a canvas being managed as a member of a Layout, the minimum size the layout should apply to the canvas. For a canvas with a width or height specified as a percent value, a minimum numeric pixel value to limit how large the canvas is sized. determining size for a Canvas in a CanvasItem (minHeight only) end user Canvas.canDragResize','drag resizing minimum size when using Overflow "visible" outside of a Layout - minimum size will be the greater of this setting or the minimum size needed to make all content visible Minimum sizes do not apply in various other circumstances where sizes are being determined, such as ListGrid.showRecordComponents','ListGrid recordComponents. See also Layout.minMemberLength as a way of establishing minimum sizes along the length axis for all members of a Layout with a single setting.
		 * Flags: IRWA, Group: sizing */
		minWidth?: number; // Flags=IRWA
		/** The minimum speed in pixels per second that must be reached for momentum scrolling to kick in. This setting only applies to touch-enabled devices.
		 * Flags: IRWA */
		momentumScrollMinSpeed?: number /* double */; // Flags=IRWA
		/** Amount of time (in milliseconds) between repeated 'mouseStillDown' events for this canvas. See Canvas.mouseStillDown for details.
		 * Flags: IRWA, Group: events */
		mouseStillDownDelay?: number /* int */; // Flags=IRWA
		/** Amount of time (in milliseconds) before mouseStillDown events start to be fired repeatedly for this canvas. See Canvas.mouseStillDown for details.
		 * Flags: IRWA, Group: events */
		mouseStillDownInitialDelay?: number /* int */; // Flags=IRWA
		/** If true, this canvas will receive all mouse-clicks as single Canvas.click','click events rather than as Canvas.doubleClick','doubleClick events.
		 * Flags: IRWA, Group: events */
		noDoubleClicks?: boolean /* Boolean */; // Flags=IRWA
		/** Specifies the cursor image to display when the user drags a droppable canvas over this if it is not a valid drop target for the event and EventHandler.showNoDropIndicator is true.
		 * Flags: IRWA, Group: cues */
		noDropCursor?: Cursor; // Flags=IRWA
		/** Renders the widget to be partly transparent. A widget's opacity property may be set to any number between 0 (transparent) to 100 (opaque). Null means don't specify opacity directly, 100 is fully opaque. Note that heavy use of opacity may have a performance impact on some older browsers. In older versions of Internet Explorer (Pre IE9 / HTML5), opacity is achieved through proprietary filters. If Canvas.neverUseFilters','filters have been disabled within this application developers must set Canvas.useOpacityFilter to true for specific components on which opacity support is required. Also note that opacity is incompatible with Canvas.useBackMask','backMasks.
		 * Flags: IRWA, Group: cues */
		opacity?: number; // Flags=IRWA
		/** Controls what happens when the drawn size of the content of a Canvas is either greater or smaller than the specified size of the Canvas. Similar to the CSS property overflow, but consistent across browsers. See Overflow type for details.
		 * Flags: IRW, Group: sizing */
		overflow?: Overflow; // Flags=IRW
		/** Set the CSS padding of this component, in pixels. Padding provides space between the border and the component's contents. This property sets the same thickness of padding on every side. Differing per-side padding can be set in a CSS style and applied via Canvas.styleName. Note that CSS padding does not affect the placement of Canvas.children. To provide a blank area around children, either use Canvas.margin','CSS margins or use a Layout as the parent instead, and use properties such as Layout.layoutMargin to create blank space.
		 * Flags: IRW, Group: appearance */
		padding?: number; // Flags=IRW
		/** This Canvas's immediate parent, if any. Can be initialized, but any subsequent manipulation should be via Canvas.addChild','addChild() and Canvas.removeChild','removeChild() calls on the parent. The parent Canvas should be fetched using Canvas.getParentCanvas','getParentCanvas().
		 * Flags: IR, Group: containment */
		parentCanvas?: Canvas; // Flags=IR
		/** Array of all Canvii that are peers of this Canvas. Use Canvas.addPeer and Canvas.removePeer to add and remove peers after a Canvas has been created/drawn.
		 * Flags: IRA, Group: containment */
		peers?: Array<Canvas> /* Array of Canvas */; // Flags=IRA
		/** Governs the model to be used when sizing canvases with percentage width or height, or positioning widgets with a specified Canvas.snapTo','snapTo. Only affects widgets with a a specified Canvas.percentSource','percentSource, or widgets that have Canvas.snapTo set and are peers of some Canvas.getMasterCanvas','other canvas. Determines whether the coordinates used for sizing (for percentage sized widgets) and positioning (if snapTo is set) should be relative to the visible size or the viewport size of the percentSource or Canvas.getMasterCanvas','master canvas widget.
		 * Flags: IRA, Group: sizing */
		percentBox?: PercentBoxModel; // Flags=IRA
		/** If this canvas has its size specified as a percentage, this property allows the user to explicitly designate another canvas upon which sizing will be based. If unset percentage sizing is based on - the Canvas.getMasterCanvas','master canvas if there is one and Canvas.snapTo','snapTo is set, - otherwise on the amount of space available in this widget's parent canvas, if this is a child of some other widget - otherwise the page size.
		 * Flags: IRWA, Group: sizing */
		percentSource?: Canvas; // Flags=IRWA
		/** Absolute or relative, corresponding to the "absolute" (with respect to parent) or "relative" (with respect to document flow) values for the CSS position attribute. Setting position:"relative" enables SmartClient components to be embedded directly into the native HTML flow of a page, causing the component to be rendered within an existing DOM structure. This attribute should only be set to "relative" on a top level component (a component with no Canvas.getParentCanvas). There are 2 ways to embed relatively positioned canvases in the DOM - by default the component will be written out inline when it gets Canvas.draw','drawn()n. For example to embed a canvas in an HTML table you could use this code: &lt;table&gt; &lt;tr&gt; &lt;td&gt; &lt;script&gt; isc.Canvas.create({autoDraw:true, backgroundColor:"red", position:"relative"}); &lt;/script&gt; &lt;td&gt; &lt;/tr&gt; &lt;/table&gt; Alternatively you can make use of the Canvas.htmlElement attribute. Relative positioning is intended as a short-term integration scenario while incrementally upgrading existing applications. Note that relative positioning is not used to manage layout within SmartClient components - instead the Layout class would typically be used. For best consistency and flexibility across browsers, all SmartClient layout managers use absolute positioning. For canvases with a specified Canvas.htmlElement, this attribute defaults to "relative". In all other cases the default value will be "absolute".
		 * Flags: IRWA, Group: positioning */
		position?: Positioning; // Flags=IRWA
		/** Should this canvas print its children absolutely positioned when generating Canvas.getPrintHTML','printable HTML. By default explicitly specified absolute positioning and sizing is ignored when generating print HTML. This is done intentionally: there is no way for the framework to predict how explicit sizes will translate to a the printed page and if HTML for printing includes the same absolute positioning and sizing as is displayed within an application it is very common to encounter undesirable effects, such as seeing tables get broken over several pages horizontally when there is enough room to print them on a single page of paper. In some cases, however, a developer may wish to have explicit sizing and positioning respected within the print-view. Setting this attribute to true will cause this to occur.
		 * Flags: IRWA, Group: printing */
		printChildrenAbsolutelyPositioned?: boolean /* Boolean */; // Flags=IRWA
		/** Prompt displayed in hover canvas if Canvas.showHover','showHover is true.
		 * Flags: IRW, Group: hovers */
		prompt?: string /* HTMLString */; // Flags=IRW
		/** If Canvas.proportionalResizing is set to "modifier" or "modifierOff" then proportional resizing of the widget is activated or deactivated, respectively, whenever at least one key in this set of modifier keys is pressed. The keys allowed in this set are: "Alt", "Ctrl", and "Shift". If this set of keys is empty then proportional resizing is always used if proportionalResizing is "modifier" and is never used if proportionalResizing is "modifierOff" .
		 * Flags: IR, Group: dragdrop */
		proportionalResizeModifiers?: Array<KeyName> /* Array of KeyName */; // Flags=IR
		/** If Canvas.canDragResize is true, this property specifies the conditions for when proportional resizing is used. The default is "none" , which means that proportional resizing is disabled.
		 * Flags: IR, Group: dragdrop */
		proportionalResizing?: ProportionalResizeMode; // Flags=IR
		/** Should this element be redrawn in response to a resize? Should be set to true for components whose Canvas.getInnerHTML','inner HTML will not automatically reflow to fit the component's new size.
		 * Flags: IRWA, Group: drawing */
		redrawOnResize?: boolean /* Boolean */; // Flags=IRWA
		/** When this Canvas is included as a member in a Layout, and Canvas.showResizeBar is set to true so that a resizeBar is created, resizeBarTarget:"next" can be set to indicate that the resizeBar should resize the next member of the layout rather than this one. For resizeBars that support hiding their target member when clicked on, resizeBarTarget:"next" also means that the next member will be the one hidden. This is typically used to create a 3-way split pane, where left and right-hand sections can be resized or hidden to allow a center section to expand. NOTE: as with any Layout, to ensure all available space is used, one or more members must maintain a flexible size (eg 75%, or *). In a two pane Layout with a normal resize bar, to fill all space after a user resizes, the member on the right should have flexible size. With resizeBarTarget:"next", the member on the left should have flexible size.
		 * Flags: IR, Group: layoutMember */
		resizeBarTarget?: string /* String */; // Flags=IR
		/** When drag resizing is enabled via Canvas.canDragResize, restricts resizes to only certain edges or corners. The default of null indicates the widget can be resized from any corner or edge (if canDragResize is true). To restrict resizing to only certain corners, set resizeFrom to an Array of EdgeNames.
		 * Flags: IRWA, Group: dragdrop */
		resizeFrom?: Array<EdgeName> /* Array of EdgeName */; // Flags=IRWA
		/** Canvas.ID of the component that gathers the context for evaluation of criteria-based rules specified by properties such as FormItem.visibleWhen. If not specified, this component will search through it's Canvas.parentCanvas chain until it either reaches the top or reaches a parent marked Canvas.isRuleScope. Determination of the ruleScope happens when the component is first drawn. The component designated as the ruleScope manages a nested data structure called the "rule context" which contains information from all DataBoundComponents that are registered with the ruleScope. By specifying Criterion.fieldName as a DataPath, AdvancedCriteria defined in properties such as FormItem.visibleWhen can access any part of the rule context. By default, the rule context contains data as follows: any DataBoundComponent that has a DataSource contributes the values of the selected record or record being edited under the ID of the DataSource. For any collision an editable display (such as a form or editable grid) wins over a static display (such as a non-editable grid with a selection.) any ListGrid or other component that manages a selection and has been assigned an explicit Canvas.ID will contribute the values of the selected record under &lt;componentId&gt;.selectedRecord, and also contributes 3 flags for checking for selection: anySelected, multiSelected, numSelected. any DynamicForm or other component that edits values and has been assigned an explicit Canvas.ID contributes its current values under &lt;componentId&gt;.values, and contributes a flag hasChanges. any DynamicForm or ListGrid that has been assigned an explicit Canvas.ID contributes a value &lt;componentId&gt;.focusField. When present the value indicates the component has focus along with the name of the field that has focus. Its absense indicates the component does not have focus at all. any ListGrid that has been assigned an explicit Canvas.ID contributes a flag isGrouped under &lt;componentId&gt;. For example, given a screen where: a ListGrid with ID "itemGrid" and DynamicForm with ID "itemForm" are both bound to the supplyItem sample DataSource the ListGrid has a single selection, and the record selected in the ListGrid is being edited in the form, and has been changed The default rule context available from Canvas.getRuleContext, expressed as JSON, would be: { supplyItem : { itemID : "654321", itemName : "Sewing Machine", price : 5.50, // note: user change ..other properties.. }, itemForm.values : { itemID : "654321", itemName : "Sewing Machine", price : 5.50, // note: user change ..other properties.. }, itemForm.focusField : "itemName", itemForm.hasChanges : true, itemGrid.selectedRecord : { itemID : "654321", itemName : "Sewing Machine", price : 3.50, // note: old price ..other properties.. }, itemGrid.anySelected : true, itemGrid.multiSelected : false, itemGrid.numSelected : 1, itemGrid.isGrouped : false } 
		 * Flags: IR */
		ruleScope?: string /* String */; // Flags=IR
		/** The class that will be used to create custom scrollbars for this component. Set this attribute to a Scrollbar subclass with e.g. a different skinImgDir, to customize scrollbar appearance for this component only. When skinning','spriting is enabled and supported by the skin, the default scrollbarConstructor is changed to a different scrollbar class which handles scrollbar spriting. Spriting of the scrollbars of an individual component can therefore be disabled by creating the component with scrollbarConstructor set to the "Scrollbar" class. "Scrollbar" is a basic scrollbar class that does not employ spriting.
		 * Flags: IA, Group: scrolling */
		scrollbarConstructor?: string /* String */; // Flags=IA
		/** How thick should we make the scrollbars for this canvas. This only applies if Canvas.showCustomScrollbars is true. <strong>NOTE:</strong> When skinning','spriting is enabled, changing the scrollbarSize may cause tiling of certain images and backgrounds that make up the custom scrollbar. This can be fixed for a component by creating it with Canvas.scrollbarConstructor set to "Scrollbar"&mdash;a basic scrollbar class that does not employ spriting.
		 * Flags: IRWA, Group: scrolling */
		scrollbarSize?: number; // Flags=IRWA
		/** Color for the css-based drop shadow shown if Canvas.useCSSShadow is true and Canvas.showShadow is true. Has no effect if we are not using css-based shadows - in that case, use Canvas.shadowImage instead.
		 * Flags: IRWA, Group: shadow */
		shadowColor?: string /* CSSColor */; // Flags=IRWA
		/** Depth of the shadow, or the virtual height above the page of the widget throwing the shadow. This is a single parameter that can be used to control both shadowSoftness and shadowOffset.
		 * Flags: IR, Group: shadow */
		shadowDepth?: number; // Flags=IR
		/** Horizontal offset for the Canvas.showShadow','shadow. Takes precedence over Canvas.shadowOffset if set. Has no effect if Canvas.useCSSShadow','css-shadows are not being used for this canvas.
		 * Flags: IRWA, Group: shadow */
		shadowHOffset?: number /* Number */; // Flags=IRWA
		/** If Canvas.useCSSShadow is false, (or for browsers that do not support css3), this property supplies the base name of the series of images for the sides, corners, and center of the shadow. The actual image names fetched for the dropShadow combine the segment name and the shadowDepth setting. For example, given "ds.png" as the base name, a depth of 4, and the top-left segment of the shadow, we'd use "ds4_TL.png". The names for segments are the same as those given for controlling resizable edges; see Canvas.resizeFrom. The center segment has the name "center". The center segment is the only segment that doesn't include the depth in the URL, so the final image name for the center given a baseName of "ds.png" would be just "ds_center.png".
		 * Flags: IRA, Group: shadow */
		shadowImage?: string /* SCImgURL */; // Flags=IRA
		/** Offset of the shadow. Defaults to half of shadowDepth if unset. Because of the blurred edges, a shadow is larger than the originating component by 2xsoftness. An shadowOffset of 0 means that the shadow will extend around the originating component equally in all directions. If Canvas.useCSSShadow','css shadows are being used, separate vertical and horizontal offsets may be specified via Canvas.shadowHOffset and Canvas.shadowVOffset.
		 * Flags: IRWA, Group: shadow */
		shadowOffset?: number; // Flags=IRWA
		/** Softness, or degree of blurring, of the shadow. A shadow with softness:x is 2x pixels larger in each direction than the element throwing the shadow, and the media for each edge should be x pixels wide/tall. Defaults to shadowDepth if unset.
		 * Flags: IRWA, Group: shadow */
		shadowSoftness?: number; // Flags=IRWA
		/** Explicit spread for the css-based drop shadow shown if Canvas.useCSSShadow is true and Canvas.showShadow is true. This property governs how much larger than the widget the shadow will appear. A negative value (coupled with an explicit offset) will result in a smaller shadow. Has no effect if we are not using css-based shadows - in that case, use Canvas.shadowImage instead.
		 * Flags: IRWA, Group: shadow */
		shadowSpread?: number /* Integer */; // Flags=IRWA
		/** Vertical offset for the Canvas.showShadow','shadow. Takes precedence over Canvas.shadowOffset if set. Has no effect if Canvas.useCSSShadow','css-shadows are not being used for this canvas.
		 * Flags: IRWA, Group: shadow */
		shadowVOffset?: number /* Number */; // Flags=IRWA
		/** Whether this canvas should be included in a printable view. Default is to: omit all peers (edges generated by showEdges:true, etc) omit anything considered a "control", such as a button or menu (see PrintProperties.omitControls) include everything else not marked shouldPrint:false 
		 * Flags: IRW, Group: printing */
		shouldPrint?: boolean; // Flags=IRW
		/** Whether to use the browser's native scrollbars or SmartClient-based scrollbars. SmartClient-based scrollbars are skinnable, giving you complete control over look and feel. SmartClient-based scrollbars also enable some interactions not possible with native scrollbars, such as ListGrid.fixedRecordHeights','variable height records in grids in combination with ListGrid.dataPageSize','data paging. Native browser scrollbars are slightly faster simply because there are less SmartClient components that need to be created, drawn and updated. Each visible SmartClient-based scrollbar on the screen has roughly the impact of two StretchImgButtons. SmartClient is always aware of the size of the scrollbar, regardless of whether native or custom scrollbars are used, and regardless of what operating system and/or operating system "theme" or "skin" is in use. This means SmartClient will correctly report the Canvas.getViewportHeight','viewport size, that is, the interior area of the widget excluding space taken by scrollbars, which is key for exactly filling a component with content without creating unnecessary scrolling. The showCustomScrollbars setting is typically overridden in load_skin.js in order to change the default for all SmartClient components at once. This may be achieved via the static Canvas.setShowCustomScrollbars method or via a simple addProperties block, like so: isc.Canvas.addProperties({ showCustomScrollbars:false }); On Browser.isTouch','touch devices, custom scrollbars are disabled in favor of enabling native touch scrolling if available. However, custom scrollbars <em>and</em> native touch scrolling can be enabled for the component by setting Canvas.alwaysShowScrollbars to true.
		 * Flags: IRA, Group: scrolling */
		showCustomScrollbars?: boolean; // Flags=IRA
		/** When this widget is dragged, if its dragAppearance is "target", should we show a shadow behind the canvas during the drag.
		 * Flags: IRWA, Group: dragdrop */
		showDragShadow?: boolean /* Boolean */; // Flags=IRWA
		/** Whether an EdgedCanvas should be used to show image-based edges around this component.
		 * Flags: IR, Group: imageEdges */
		showEdges?: boolean /* Boolean */; // Flags=IR
		/** If this.canHover is true, should we show the global hover canvas by default when the user hovers over this canvas?
		 * Flags: IRW, Group: hovers */
		showHover?: boolean /* Boolean */; // Flags=IRW
		/** When set to true, shows a widget hovering at the mouse point instead of the builtin hover label. Override Canvas.getHoverComponent','getHoverComponent to provide the Canvas to show as the hoverComponent.
		 * Flags: IRWA, Group: hoverComponents */
		showHoverComponents?: boolean /* Boolean */; // Flags=IRWA
		/** When this Canvas is included as a member in a Layout, whether a resizeBar should be shown after this member in the layout, to allow it to be resized. Whether a resizeBar is actually shown also depends on the Layout.defaultResizeBars','defaultResizeBars attribute of the layout, and whether this Canvas is the last layout member. By default the resize bar acts on the Canvas that it is declared on. If you want the resize bar to instead act on the next member of the Layout (e.g. to collapse down or to the right), set Canvas.resizeBarTarget as well.
		 * Flags: IRW, Group: layoutMember */
		showResizeBar?: boolean /* Boolean */; // Flags=IRW
		/** Whether to show a drop shadow for this Canvas. Shadows may be rendered using Canvas.useCSSShadow','css or via images. The appearance of shadows can be customized via Canvas.shadowColor (for css-based shadows) or Canvas.shadowImage (for image based shadows), Canvas.shadowDepth, Canvas.shadowOffset and Canvas.shadowSoftness. When Canvas.useCSSShadow is false, developers should be aware that the drop shadow is rendered as a Canvas.peers','peer and is drawn outside the specified width and height of the widget meaning a widget with shadows takes up a little more space than it otherwise would. A full screen canvas with showShadow set to true as this would be likely to cause browser scrollbars to appear - developers can handle this by either setting this property to false on full-screen widgets, or by setting overflow to "hidden" on the &lt;body&gt; element if browser-level scrolling is never intended to occur.
		 * Flags: IRW, Group: shadow */
		showShadow?: boolean /* Boolean */; // Flags=IRW
		/** Whether to show a snap grid for this Canvas. Note that the grid is only shown when either Canvas.childrenSnapToGrid','childrenSnapToGrid or Canvas.childrenSnapResizeToGrid','childrenSnapResizeToGrid is true. Grid is based on Canvas.snapHGap','snapHGap and Canvas.snapVGap','snapVGap properties.
		 * Flags: IRW */
		showSnapGrid?: boolean /* Boolean */; // Flags=IRW
		/** This is an advanced setting. If set to true, when a widget is Canvas.hide','hidden, the widget's handle will be resized such that it takes up no space, in addition to having its css visibility property set to "hidden". In addition to preventing the size of this widget from impacting the Canvas.getScrollWidth','scroll size of any parent widget while hidden, this setting works around a native bug observed in Internet Explorer 10, whereby an &lt;IFRAME&gt; element with visibility set to hidden can cause rendering problems, if the HTML loaded by the &lt;IFRAME&gt; contains a &lt;frameset&gt;. In this case the browser may refuse to draw other elements at the same coordinates with a lower z-index than the hidden frame. Setting this property to true works around this problem for cases where an &lt;IFRAME&gt; containing a &lt;frameset will be rendered out, for example in an HTMLFlow with contentsType set to "page".
		 * Flags: IRWA, Group: visibility */
		shrinkElementOnHide?: boolean; // Flags=IRWA
		/** Is it possible that a call to Canvas.redraw on this widget will change its size? Used by framework layout code when determining whether a component which has been Canvas.markForRedraw','marked as dirty needs an immediate redraw to determine its drawn size. If unset, default behavior assumes any component with overflow set to "visible" may change size on redraw, and any component with overflow set to "hidden", "scroll", or "auto" will not. This property overrides that behavior, and may be used to indicate that some component with non visible overflow can change size on redraw. An example use case would be a custom component with an override to explicitly resize the component as part of the redraw() flow.
		 * Flags: IRWA */
		sizeMayChangeOnRedraw?: boolean /* Boolean */; // Flags=IRWA
		/** Default directory for skin images (those defined by the class), relative to the Page-wide Page.getSkinDir','skinDir.
		 * Flags: IRWA, Group: images */
		skinImgDir?: string /* URL */; // Flags=IRWA
		/** When Canvas.childrenSnapAlign is enabled, list of candidates to check for alignment. If a list of snapAlignCandidates is never provided, the default is to use all children that are not explicitly excluded via Canvas.isSnapAlignCandidate, including automatically adding newly added children as candidates, and ignoring children that have been removed. Use Canvas.addSnapAlignCandidate and Canvas.removeSnapAlignCandidate to add and remove special candidates while retaining all children as default candidates. Possible candidates which are not drawn or are hidden are automatically ignored.
		 * Flags: IRW */
		snapAlignCandidates?: Array<Canvas> /* Array of Canvas */; // Flags=IRW
		/** CSS border declaration used for the line shown to indicate snapping to a center line when Canvas.childrenSnapAlign is set.
		 * Flags: IR */
		snapAlignCenterLineStyle?: string /* String */; // Flags=IR
		/** CSS border declaration used for the line shown to indicate snapping to a edge line when Canvas.childrenSnapAlign is set.
		 * Flags: IR */
		snapAlignEdgeLineStyle?: string /* String */; // Flags=IR
		/** Describes which axes to apply snap-to-grid to. Valid values are "horizontal", "vertical" or "both".
		 * Flags: IRW, Group: dragdrop */
		snapAxis?: string; // Flags=IRW
		/** If Canvas.snapTo','snapTo is defined to this widget, this property can be used to define which edge of this widget should be snapped to an edge of the master or parent element. If unspecified the, default snapTo behavior is set up to align the "snapTo" edge of this widget with the snapTo edge of the master or parent.
		 * Flags: IRW, Group: sizing */
		snapEdge?: string /* String */; // Flags=IRW
		/** The horizontal snap direction. Set this value to "before" to snap to the nearest gridpoint to the left; set it to "after" to snap to the nearest gridpoint to the right; and set it to "nearest" to snap to the nearest gridpoint in either direction.
		 * Flags: IRW, Group: dragdrop */
		snapHDirection?: string; // Flags=IRW
		/** The horizontal grid size to use, in pixels, when snap-to-grid is enabled.
		 * Flags: IRW, Group: dragdrop */
		snapHGap?: number; // Flags=IRW
		/** If Canvas.snapTo','snapTo is defined for this widget, this property can be used to specify an offset in px or percentage for the left coordinate of this widget. For example if snapTo is specified as "L" and snapOffsetLeft is set to 6, this widget will be rendered 6px inside the left edge of its parent or master element. Alternatively if snapTo was set to "R", a snapOffsetLeft value of -6 would cause the component to be rendered 6px inside the right edge of its parent or Canvas.getMasterCanvas','master canvas.
		 * Flags: IRW, Group: sizing */
		snapOffsetLeft?: number /* integer */; // Flags=IRW
		/** If Canvas.snapTo','snapTo is defined for this widget, this property can be used to specify an offset in px or percentage for the top coordinate of this widget. For example if snapTo is specified as "T" and snapOffsetTop is set to 6, this widget will be rendered 6px below the top edge of its parent or master element. . Alternatively if snapTo was set to "B", a snapOffsetTop value of -6 would cause the component to be rendered 6px inside the bottom edge of its parent or Canvas.getMasterCanvas','master canvas.
		 * Flags: IRW, Group: sizing */
		snapOffsetTop?: number /* integer */; // Flags=IRW
		/** When this canvas is dropped onto an object supporting snap-to-grid, should it snap to the grid (true, the default) or just drop wherever the mouse is (false).
		 * Flags: IRWA, Group: dragdrop */
		snapOnDrop?: boolean /* Boolean */; // Flags=IRWA
		/** Flag to disable snapping to alignment when this Canvas is resized. To control snapping to align for the children resized within this Canvas, see Canvas.childrenResizeSnapAlign','childrenResizeSnapAlign instead.
		 * Flags: IRW */
		snapResizeToAlign?: boolean /* Boolean */; // Flags=IRW
		/** Causes this canvas to snap to its parent's grid when resizing. Note that this value defaults to the Canvas's Canvas.snapToGrid','snapToGrid value if undefined.
		 * Flags: IRW, Group: dragdrop */
		snapResizeToGrid?: boolean; // Flags=IRW
		/** Position this widget such that it is aligned with ("snapped to") an edge of its Canvas.getMasterCanvas','master (if specified), or its Canvas.getParentCanvas','parent canvas. Note that this property also impacts the sizing of this widget. If this widgets size is specified as a percent value, and has no explicit Canvas.percentSource, sizing will be calculated based on the size of the Canvas.getMasterCanvas','master canvas when snapTo is set. Possible values: BR, BL, TR, TL, R, L, B, T, C where B=Bottom, T=Top, L=Left, R=right and C=center Standard snapTo behavior will attach the outer edge of the widget to the parent or master element - for example setting snapTo to "B" would align the bottom edge of this component with the bottom edge of the master or parent element (and center this component horizontally over its master or parent element). Canvas.snapEdge can be specified to change this behavior allowing the developer to, for example, align the top edge of this component with the bottom edge of its Canvas.getMasterCanvas','master canvas. Canvas.snapOffsetLeft and Canvas.snapOffsetTop may also be specified to offset the element from exact snapTo alignment.
		 * Flags: IRW, Group: sizing */
		snapTo?: string /* String */; // Flags=IRW
		/** Flag to disable snapping to alignment when this Canvas is dragged when Canvas.childrenSnapAlign is enabled on this Canvas' parent. To control snapping to align for the children dragged within this Canvas, see Canvas.childrenSnapAlign instead.
		 * Flags: IRW */
		snapToAlign?: boolean /* Boolean */; // Flags=IRW
		/** Flag to disable snapping to center alignment when this Canvas is dragged when Canvas.childrenSnapAlign is enabled on this Canvas' parent.
		 * Flags: IRW */
		snapToCenterAlign?: boolean /* Boolean */; // Flags=IRW
		/** Flag to disable snapping to edge alignment when this Canvas is dragged when Canvas.childrenSnapAlign is enabled on this Canvas' parent.
		 * Flags: IRW */
		snapToEdgeAlign?: boolean /* Boolean */; // Flags=IRW
		/** Causes this canvas to snap to its parent's grid when dragging.
		 * Flags: IRW, Group: dragdrop */
		snapToGrid?: boolean; // Flags=IRW
		/** The vertical snap direction. Set this value to "before" to snap to the nearest gridpoint above; set it to "after" to snap to the nearest gridpoint below; and set it to "nearest" to snap to the nearest gridpoint in either direction.
		 * Flags: IRW, Group: dragdrop */
		snapVDirection?: string; // Flags=IRW
		/** The vertical grid size to use, in pixels, when snap-to-grid is enabled.
		 * Flags: IRW, Group: dragdrop */
		snapVGap?: number; // Flags=IRW
		/** The CSS class applied to this widget as a whole.
		 * Flags: IRW, Group: appearance */
		styleName?: string /* CSSStyleName */; // Flags=IRW
		/** If specified this governs the tabIndex of the widget in the page's tab order. Setting this value to -1 will ensure the canvas does not show up in the page's tab order, though if Canvas.canFocus','canFocus is true, the user may still give it keyboard focus by clicking on the widget directly. By default SmartClient auto-assigns tab-indices, ensuring focusable widgets are reachable by tabbing in an intuitive order based on widget hierarchy and draw order. Specifying an explicit tab index means a widget will not participate in this automatic tab position allocation and is typically not recommended except for very simple cases. For more information on automatic tab index assignment, including recommended approaches for customizing tab order assignation, see the tabOrderOverview. Developers may call Canvas.clearExplicitTabIndex to clear any explicitly assigned tab index, and have the widget participate in automatic tab position allocation. canvas.tabIndex cannot be set to greater than Canvas.TAB_INDEX_FLOOR - as we reserve the values above this range for auto-assigned tab-indices.
		 * Flags: IRWA, Group: focus */
		tabIndex?: number; // Flags=IRWA
		/** Number of pixels the top of the widget is offset down from its default drawing context (either its parent's top-left corner, or the document flow, depending on the value of the Canvas.position property). Can also be set as a percentage, specified as a String ending in '%', eg, "50%". In this case the top coordinate is considered as a percentage of the specified height of the Canvas.getParentCanvas','parent.
		 * Flags: IRW, Group: positioning */
		top?: number | string /* Number or String */; // Flags=IRW
		/** Should canvases with no Canvas.getParentCanvas','parent canvas be moved to the end of the TabIndexManager tree on draw()? If set to false, the tab-position will not be modified on draw. This property is useful for cases where the tab position of a widget will be managed by some explicit tabIndex management code.
		 * Flags: IRWA */
		updateTabPositionOnDraw?: boolean; // Flags=IRWA
		/** Should canvases with a Canvas.getParentCanvas','parent canvas be added to the TabIndexManager under the parent as described in Canvas.updateChildTabPositions and Canvas.updateChildTabPosition? If set to false, the tab-position will not be modified on parent change. This property is useful for cases where the tab position of a widget will be managed by something other than the parent canvas, for example for CanvasItem.canvas','canvasItem canvases.
		 * Flags: IRWA */
		updateTabPositionOnReparent?: boolean; // Flags=IRWA
		/** In earlier versions of Internet Explorer (pre IE9), a native limitation exists whereby if HTML elements are overlapping on the page, certain elements can appear to "burn through" elements in the same position with a higher z-index. Specific cases in which this have been observed include Applets, &lt;IFRAME&gt; elements, and for older versions of IE, native &lt;SELECT&gt; items. The backMask is a workaround for this issue. If useBackMask is set to true, the component will render an empty &lt;IFRAME&gt; element behind the canvas, which prevents this effect in all known cases. Has no effect in other browsers.
		 * Flags: IRWA */
		useBackMask?: boolean /* Boolean */; // Flags=IRWA
		/** If Canvas.showShadow is true, should we use the css box-shadow property (where supported) to achieve the shadow? Set this property to false to switch to a media-based approach, achieved by rendering the Canvas.shadowImage in an automatically generated peer. This approach is also used regardless of this property value in older browsers where the css box-shadow property isn't supported. See also Canvas.shadowColor, Canvas.shadowDepth, Canvas.shadowOffset, Canvas.shadowSoftness and Canvas.shadowSpread
		 * Flags: IRA, Group: shadow */
		useCSSShadow?: boolean; // Flags=IRA
		/** This flag controls whether we register the component as a maskable item with the EventHandler. If enabled, a backmask will be automatically created for the dragMoveTarget on the fly to avoid burnthrough e.g. by plugins or frames. Note that this property will be defaulted to false unless the canvas contains an IFrame, in which case it will be defaulted to true. The Canvas.dragMaskType property controls what kind of mask is used in case useDragMask is enabled.
		 * Flags: IRW, Group: dragdrop */
		useDragMask?: boolean; // Flags=IRW
		/** If set, native HTML5 drag and drop will be used for all drags initiated on this widget (on browsers where this is supported). When using native HTML5 drags, the same series of events fires as for a normal drag (Canvas.dragStart, Canvas.dropMove, etc.), and the Canvas.dragType','dragType / Canvas.dropTypes','dropTypes system works. Canvas.dragAppearance','dragAppearance is not supported; however, basic customization of the browser's tracker image is supported in certain browsers via the EventHandler.setDragTrackerImage API. The primary difference with a native drag is that it can be cross-frame; that is, the user can drag out of the current browser window and drop into a different window or tab. To provide information that will be available to a foreign frame, use EventHandler.setNativeDragData. This API must be called when the Canvas.dragStart event fires, and will not work if called at any other time. However, due to browser bugs and/or browser-imposed limitations, the information provided to setNativeDragData cannot be accessed in the foreign frame until the actual drop occurs (mouse button released). This means drop eligibility cannot be determined dynamically based on the dragged data; instead, eligibility can only be determined based on the Canvas.dragType / Canvas.dropTypes system. For this reason, a Canvas.dragType must be set on the source of a drag. NOTE: Although Internet Explorer 10+ supports a subset of the <a href='http://www.w3.org/TR/html5/editing.html#dnd' target='_blank'>HTML5 drag and drop standard</a>, native drag and drop is disabled in IE because cross-window drags&mdash;the primary purpose of this API&mdash;are not possible.
		 * Flags: IR, Group: dragdrop */
		useNativeDrag?: boolean /* Boolean */; // Flags=IR
		/** Configures where the Opacity filter is used for IE6-8. With the default of null, opacity filters are used unless Canvas.neverUseFilters has been set. When set explicitly to true, opacity filters are used even if neverUseFilters is true. See IEFilters for background.
		 * Flags: IR, Group: IEFilters */
		useOpacityFilter?: boolean; // Flags=IR
		/** On Browser.isTouch','touch devices, if this Canvas can be scrolled, should touch-dragging the content area result in scrolling? Set to false if touch-dragging should not cause scrolling. Note that setting to false enables the use of Canvas.showCustomScrollbars','custom scrollbars on touch devices. useTouchScrolling can default to false if Canvas.disableTouchScrollingForDrag','disableTouchScrollingForDrag is true and various built-in drag operations are enabled that normally interfere with touch scrolling (e.g. ListGrid.canDragSelect and ListGrid.canReorderRecords). When touch scrolling is disabled, it can be difficult to interact with parts of the custom scrollbars at their default size of 16 pixels. In touch browsers, any touch 8px before the thumb of a Scrollbar','custom scrollbar will be mapped to the thumb, but the other parts of the scrollbar do not have a similar tolerance applied. The width of the custom scrollbars can be increased by setting the Canvas.scrollbarSize to a larger value, but note that when skinning','spriting is enabled, changing the scrollbarSize may cause tiling of certain images and backgrounds that make up the custom scrollbar. This can be fixed for a component by creating it with Canvas.scrollbarConstructor set to "Scrollbar"&mdash;a basic scrollbar class that does not employ spriting.
		 * Flags: IRA, Group: scrolling */
		useTouchScrolling?: boolean /* Boolean */; // Flags=IRA
		/** Controls widget visibility when the widget is initialized. See Visibility type for details.
		 * Flags: IRW, Group: appearance */
		visibility?: Visibility; // Flags=IRW
		/** Criteria to be evaluated to determine whether this Canvas should be visible. Re-evaluated whenever data in the Canvas.ruleScope changes. A basic criteria uses textMatchStyle:"exact". When specified in componentXML','Component XML this property allows xmlCriteriaShorthand','shorthand formats for defining criteria.
		 * Flags: IR, Group: ruleCriteria */
		visibleWhen?: AdvancedCriteria; // Flags=IR
		/** Size for this component's horizontal dimension. Can be a number of pixels, or a percentage like "50%". Percentage sizes are resolved to pixel values as follows: If a canvas has a specified Canvas.percentSource','percentSource, sizing will be a percentage of the size of that widget (see also Canvas.percentBox). Otherwise, if a canvas has a Canvas.getMasterCanvas','master canvas, and Canvas.snapTo','snapTo is set for the widget, sizing will be a percentage of the size of that widget (see also Canvas.percentBox). Otherwise if this is a child of some other canvas, percentages will be based on the inner size of the Canvas.getParentCanvas','parent canvas's viewport. Otherwise, for top level widgets, sizing is calculated as a percentage of page size. Note that if a Canvas.maxWidth or Canvas.minWidth are specified (or Canvas.maxHeight / Canvas.minHeight for heights), these properties act as explicit pixel limits on the canvas' size. For example, a canvas with Canvas.maxWidth set to 500, and width specified as "100%" will not render larger than 500 pixels in width even if there is more space available in the parent canvas or percentSource. Layout','Layouts may specially interpret percentage sizes on their children, and also allow "*" as a size. Note that if Canvas.overflow','overflow is set to "visible", this size is a minimum, and the component may overflow to show all content and/or children. If trying to establish a default width for a custom component, set Canvas.defaultWidth','defaultWidth instead.
		 * Flags: IRW, Group: sizing */
		width?: number | string /* Number or String */; // Flags=IRW

		/* Method Overrides */

		/** 
		 * Executed when the left mouse is clicked (pressed and then released) on this widget. No default implementation.
		 */
		click?(): boolean /* Boolean */; 

		/** 
		 * When a widget instance is created, it is assigned a unique global identifier that can be used to access the instance by name. The getID method returns this ID for a particular instance. Global IDs are essential when you need to embed a widget reference in a string, usually a string that will be evaluated in the future and/or in another object, where you may not have access to a variable or parameter holding the widget's reference.
		 */
		getID?(): string; 

		/** 
		 * Sets the widget's CSS visibility attribute to "hidden".
		 */
		hide?(): void; 

		/** 
		 * Marks the widget as "dirty" so that it will be added to a queue for redraw. Redraw of dirty components is handled by a looping timer and will after a very short delay (typically less than 100ms). In most cases it is recommended that developers use markForRedraw() instead of calling Canvas.redraw directly. Since this method queues the redraw, multiple calls to markForRedraw() within a single thread of execution will only lead to a single DOM manipulation which greatly improves application performance.
		 * @param {string} reason - reason for performing the redraw
		 */
		markForRedraw?(reason?:string): void; 

		/** 
		 * Fires when the interior size of the parent changes, including parent resize and scrollbar introduction or removal. This method allows a child to implement a layout policy that can be used within any parent, such as a Resizer component that always snaps to the parent's bottom-right corner. The default implementation of this method applies a child's percent sizes, if any, or implements layout based on the Canvas.snapTo property
		 */
		parentResized?(): void; 

		/** 
		 * Set the CSS border of this component, as a CSS string including border-width, border-style, and/or color (eg "2px solid blue"). This property applies the same border to all four sides of this component. Different per-side borders can be set in a CSS style and applied via Canvas.styleName.
		 * @param {string} newBorder - new border to set to (eg: "2px solid black")
		 */
		setBorder?(newBorder:string): void; 

		/** 
		 * Changes the contents of a widget to newContents, an HTML string. When Canvas.dynamicContents','dynamicContents is set, setContents() can also be called with no arguments to cause contents to be re-evaluated.
		 * @param {string} newContents - an HTML string to be set as the contents of this widget
		 */
		setContents?(newContents?:string): void; 

		/** 
		 * Sets this widget's visibility to "inherit", so that it becomes visible if all of its parents are visible or it has no parents. If the widget has not yet been drawn (and doesn't have a parent or master), this method calls the draw method as well.
		 */
		show?(): void; 

	} // CanvasProps


	/**
	 * Base class for all SmartClient visual components (except FormItem','FormItems). Canvas provides: basic visual lifecycle support - creation and destruction of HTML via Canvas.draw','draw() and Canvas.clear','clear(), visibility via Canvas.show','show() and Canvas.hide','hide(), z-layering via Canvas.bringToFront','bringToFront() and Canvas.sendToBack','sendToBack(). consistent cross-browser Canvas.moveTo','positioning, Canvas.resizeTo','sizing and Canvas.getScrollHeight','size detection, with automatic compensation for CSSStyleName','browser CSS behavior differences. clipping, scrolling and overflow management of content via Canvas.overflow consistent cross-browser Canvas.keyPress','key and Canvas.mouseDown','mouse events, including mobileDevelopment','mapping touch events to mouse events built-in drag and drop capabilities including Canvas.canDragReposition','moving, Canvas.canDragResize','resizing, Canvas.canDragScroll','drag scrolling and Canvas.snapToGrid','snap-to-grid behavior. the ability to either contain Canvas.contents','HTML content or Canvas.children','contain other Canvases, including Canvas.snapTo','an edge-based positioning and Canvas.percentSource','percent sizing system for children. For more advanced layout capabilities, see Layout. various other details like Canvas.cursor','cursors, Canvas.showClickMask','modal masking, Canvas.animateMove','animation, Canvas.ariaRole','accessibility properties, and Canvas.locateChildrenBy','settings for automatedTesting','automated testing.  
	 */
	export interface Canvas extends BaseWidget {
		/** If specified this governs the HTML accessKey for the widget. This should be set to a character - when a user hits the html accessKey modifier for the browser, plus this character, focus will be given to the widget in question. The accessKey modifier can vary by browser and platform. The following list of default behavior is for reference only, developers should also consult browser documentation for additional information. Internet Explorer (all platforms): Alt + accessKey Mozilla Firefox (Windows, Unix): Alt+Shift + accessKey Mozilla Firefox (Mac): Ctrl+Opt + accessKey Chrome and Safari (Windows, Unix): Alt + accessKey Chrome and Safari (Mac): Ctrl+Opt + accessKey 
		 * Flags: IRWA, Group: focus */
		accessKey: string;

		/** See Canvas.adaptiveWidthPriority.
		 * Flags: IR */
		adaptiveHeightPriority: number /* integer */;

		/** If multiple widgets in the same Layout have Canvas.canAdaptWidth','adaptive width, adaptiveWidthPriority can be set to indicate which of the components should be given priority access to space. The widget with the highest priority setting will be offered surplus space first, and asked to give up space last. Lack of a priority setting is treated as zero. Any adaptive widgets with the same priority setting will be asked to give up or release space according to their order in Layout.members.
		 * Flags: IR */
		adaptiveWidthPriority: number /* integer */;

		/** On Browser.isTouch','touch devices that support native touch scrolling, if Canvas.showCustomScrollbars','showCustomScrollbars is true and touch scrolling has not been disabled by the Canvas.useTouchScrolling and/or Canvas.disableTouchScrollingForDrag settings, should custom scrollbars <em>and</em> native touch scrolling be enabled for this component? If false or unset, then only native touch scrolling will be enabled. If true, then both scrolling mechanisms will be enabled. <strong>NOTE:</strong> Because native touch scrolling (also called momentum scrolling) is computationally intensive, some mobile browsers implement an optimization where the state of the DOM for the element being scrolled will be frozen or partially frozen during the scroll animation. This results in a delay between when the scroll position reaches a certain point in the animation and when the positions of the custom scrollbar thumbs are updated to reflect that scroll position.
		 * Flags: IRA, Group: scrolling */
		alwaysShowScrollbars: boolean /* Boolean */;

		/** Default acceleration effect to apply to all animations on this Canvas. Can be overridden by setting animationAcceleration for specific animations or by passing an acceleration function directly into the appropriate method.
		 * Flags: IRWA, Group: animation */
		animateAcceleration: AnimationAcceleration;

		/** Default time for performing an animated fade. If unset, this.animateTime will be used by default instead
		 * Flags: IRWA, Group: animation */
		animateFadeTime: number;

		/** Default acceleration function for performing an animated hide. If unset, this.animateAcceleration will be used by default instead
		 * Flags: IRWA, Group: animation */
		animateHideAcceleration: AnimationAcceleration;

		/** Default animation effect to use if Canvas.animateHide is called without an explicit effect parameter
		 * Flags: IRWA, Group: animation */
		animateHideEffect: string | AnimateShowEffect /* animateShowEffectId | animateShowEffect */;

		/** Default time for performing an animated hide. If unset, this.animateTime will be used by default instead
		 * Flags: IRWA, Group: animation */
		animateHideTime: number;

		/** Default acceleration effect for performing an animated move. If unset, this.animateAcceleration will be used by default instead
		 * Flags: IRWA, Group: animation */
		animateMoveAcceleration: AnimationAcceleration;

		/** Default time for performing an animated move. If unset, this.animateTime will be used by default instead
		 * Flags: IRWA, Group: animation */
		animateMoveTime: number;

		/** Default acceleration function for performing an animated move and resize. If unset, this.animateAcceleration will be used by default instead
		 * Flags: IRWA, Group: animation */
		animateRectAcceleration: AnimationAcceleration;

		/** Default time for performing an animated setRect. If unset, this.animateTime will be used by default instead
		 * Flags: IRWA, Group: animation */
		animateRectTime: number;

		/** Default acceleration function for performing an animated resize. If unset, this.animateAcceleration will be used by default instead
		 * Flags: IRWA, Group: animation */
		animateResizeAcceleration: AnimationAcceleration;

		/** Default time for performing an animated resize. If unset, this.animateTime will be used by default instead
		 * Flags: IRWA, Group: animation */
		animateResizeTime: number;

		/** Default acceleration function for performing an animated scroll. If unset, this.animateAcceleration will be used by default instead
		 * Flags: IRWA, Group: animation */
		animateScrollAcceleration: AnimationAcceleration;

		/** Default time for performing an animated scroll. If unset, this.animateTime will be used by default instead
		 * Flags: IRWA, Group: animation */
		animateScrollTime: number;

		/** Default acceleration function for performing an animated show. If unset, this.animateAcceleration will be used by default instead
		 * Flags: IRWA, Group: animation */
		animateShowAcceleration: AnimationAcceleration;

		/** Default animation effect to use if Canvas.animateShow is called without an explicit effect parameter
		 * Flags: IRWA, Group: animation */
		animateShowEffect: string | AnimateShowEffect /* animateShowEffectId | animateShowEffect */;

		/** Default time for performing an animated show. If unset, this.animateTime will be used by default instead
		 * Flags: IRWA, Group: animation */
		animateShowTime: number;

		/** Default total duration of animations. Can be overridden by setting animation times for specific animations, or by passing a duration parameter into the appropriate animate...() method.
		 * Flags: IRWA, Group: animation */
		animateTime: number;

		/** Default directory for app-specific images, relative to the Page-wide Page.getAppImgDir','appImgDir.
		 * Flags: IRWA, Group: images */
		appImgDir: string /* URL */;

		/** ARIA role of this component. Usually does not need to be manually set - see accessibility.
		 * Flags: IR, Group: accessibility */
		ariaRole: string /* String */;

		/** ARIA state mappings for this component. Usually this does not need to be manually set - see accessibility. This attribute should be set to a mapping of aria state-names to values - for example to have the "aria-haspopup" property be present with a value "true", you'd specify: { haspopup : true } 
		 * Flags: IRA, Group: accessibility */
		ariaState: any /* Object */;

		/** If true, this canvas will draw itself immediately after it is created. Note that you should turn this OFF for any canvases that are provided as children of other canvases, or they will draw initially, then be clear()ed and drawn again when added as children, causing a large performance penalty. For example, the following code is incorrect and will cause extra draw()s: isc.Layout.create({ members : [ isc.ListGrid.create() ] }); It should instead be: isc.Layout.create({ members : [ isc.ListGrid.create({ autoDraw: false }) ] }); In order to avoid unwanted autoDrawing systematically, it is recommend that you call isc.setAutoDraw','isc.setAutoDraw(false) immediately after SmartClient is loaded and before any components are created, then set autoDraw:true or call draw() explicitly to draw components. Otherwise, if the global setting for autoDraw remains true, you must set autoDraw:false, as shown above, on every component in your application that should not immediately draw: all Canvas children, Layout members, Window items, Tab panes, etc, however deeply nested. Forgetting to set autoDraw:false will result in one more clear()s - these are reported on the Results tab of the debugging','Developer Console, and can be tracked to individual components by using the "clears" log category in the Developer Console.
		 * Flags: IR, Group: drawing */
		autoDraw: boolean /* Boolean */;

		/** This initialization property allows developers to create a canvas using the Class.addAutoChild method, and have it added as a child to some other component. This property may be set to the childName of another already-created auto-child, or "none" to cause the component to be created without being added as a child to any other widget. If unset, the canvas will be added as a child to the component on which addAutoChild(...) was called. See autoChildren for an overview of the autoChild subsystem.
		 * Flags: IRA, Group: autoChildren */
		autoParent: string /* String */;

		/** If set to true, the widget's parent (if any) will automatically be shown whenever the widget is shown.
		 * Flags: IRWA, Group: appearance */
		autoShowParent: boolean /* Boolean */;

		/** The background color for this widget. It corresponds to the CSS background-color attribute. You can set this property to an RGB value (e.g. #22AAFF) or a named color (e.g. red) from a list of browser supported color names.
		 * Flags: IRW, Group: appearance */
		backgroundColor: string /* CSSColor */;

		/** URL for a background image for this widget (corresponding to the CSS "background-image" attribute).
		 * Flags: IRW, Group: appearance */
		backgroundImage: string /* SCImgURL */;

		/** Specifies how the background image should be positioned on the widget. It corresponds to the CSS background-position attribute. If unset, no background-position attribute is specified if a background image is specified.
		 * Flags: IR, Group: appearance */
		backgroundPosition: string;

		/** Specifies how the background image should be tiled if this widget is larger than the image. It corresponds to the CSS background-repeat attribute. The default of null means no background-repeat CSS will be written out. See BackgroundRepeat type for details on other settings. NOTE: this setting directly sets the CSS property background-repeat but does not attempt to work around various known bugs with this setting, or lack of support in IE6. If you need to apply CSS-based workarounds for browser limitations with this setting, it's best to do so via setting Canvas.styleName.
		 * Flags: IR, Group: appearance */
		backgroundRepeat: BackgroundRepeat;

		/** Set the CSS border of this component, as a CSS string including border-width, border-style, and/or color (eg "2px solid blue"). This property applies the same border to all four sides of this component. Different per-side borders can be set in a CSS style and applied via Canvas.styleName. If Canvas.isGroup is set to true then border is derived from the Canvas.groupBorderCSS attribute, not from the explicit border property.
		 * Flags: IRW, Group: appearance */
		border: string;

		/** Indicates that this object can receive dropped widgets (i.e. other widgets can be dropped on top of it).
		 * Flags: IRWA, Group: dragdrop */
		canAcceptDrop: boolean /* Boolean */;

		/** See Canvas.canAdaptWidth.
		 * Flags: IRW */
		canAdaptHeight: boolean /* Boolean */;

		/** Indicates that this component is able to render itself at multiple possible sizes, in order to fit into less space when very little space is available, or to display more information or provide more immediate access to functionality when more space is available. Unlike simply indicating a flexible size via width:"*", setting canAdaptWidth indicates that a component has 2 (or more) different ways of rendering itself with different discrete sizes, but does not have the ability to use every additional available pixel. For example, a menu embedded in a toolbar might show as only a fixed-size icon which reveals menu options when clicked, or if enough space is available, could show all of the menu options directly in the toolbar. In this example, the menu should either be allocated just enough space for an icon, or enough space for all options to appear inline; any other amount of space being allocated is just a waste. When a component with canAdaptWidth is part of a Layout, Canvas.adaptWidthBy will be called every time component sizes are being calculated, passing a positive or negative pixel value: a positive pixel value indicates a surplus - all other component's minimum sizes can be accommodated, including any Canvas.minWidth declared on the canAdaptWidth component itself a negative pixel value indicates that the containing layout is going to be forced to Overflow (introduce scrollbars, clip content, etc) unless some component or set of components gives up at least this many pixels If a non-zero value is returned from adaptWidthBy, this means that the component is willing to shrink or expand by that many pixels. Returning 0 means that the component is unable to reduce size further, or for a surplus, cannot make good use of the surplus space. A call to Canvas.adaptWidthBy may surrender as many pixels as desired (as long as the widget won't drop below its minimum allowed width), no matter whether a positive (surplus) or negative (overflow) pixel value is supplied, but A call to Canvas.adaptWidthBy may not increase its size by more than the number of offered pixels - so if an overflow is present, it may not increase its size at all. Note that when the initial width is specified as a stretch size (e.g. "*"), then after Canvas.adaptWidthBy is called, the Framework will stretch (but not shrink) the member like any other stretch-size Layout member, but the unadaptedWidth argument will always reflect the unstretched width requested by the previous call to Canvas.adaptWidthBy. This behavior may be disabled by specifying the initial width as a number, or leaving it unspecified. Caution: you must either determine the current size of the canvas by maintaining your own internal state, or use the unadaptedWidth parameter passed to Canvas.adaptWidthBy. You must not call Canvas.getWidth or Canvas.getVisibleWidth on the canvas itself inside Canvas.adaptWidthBy as the size is in the processing of being determined, but you may draw children or call Canvas.getVisibleWidth on them, as we guarantee that the adaptive-width canvas is drawn before the first call to Canvas.adaptWidthBy. An example of drawing children in Canvas.adaptWidthBy to compute overall width may be seen in the inlinedMenuMobileSample', 'Inlined Menu Mobile Sample. Note that reasonable settings for Canvas.minWidth should be applied to all other flexible-sized members of a layout where a canAdaptWidth component appears, because when too little space is available, a canAdaptWidth component will absorb all available space until minimums for other components are hit (or the canAdaptWidth component reaches its maximum size). If more than one canAdaptWidth component is present, Canvas.adaptiveWidthPriority to give priority to a particular component when allocating space. All of the above behaviors are exactly the same for height, using Canvas.canAdaptHeight and Canvas.adaptHeightBy.
		 * Flags: IRW */
		canAdaptWidth: boolean /* Boolean */;

		/** Indicates whether this widget can initiate custom drag-and-drop operations (other than reposition or resize). Normally Canvas.canDragReposition or Canvas.canDragResize would be used instead of this property. Note: this property may be manipulated by higher-level dragging semantics. If Canvas.useNativeDrag is true and this widget has been drawn, then this widget must be Canvas.redraw','redrawn in order for a change of the value of this attribute to take effect.
		 * Flags: IRWA, Group: dragdrop */
		canDrag: boolean /* Boolean */;

		/** Indicates whether this widget can be moved by a user of your application by simply dragging with the mouse.
		 * Flags: IRWA, Group: dragdrop */
		canDragReposition: boolean /* Boolean */;

		/** Indicates whether this widget can be resized by dragging on the edges and/or corners of the widget with the mouse.
		 * Flags: IRWA, Group: dragdrop */
		canDragResize: boolean /* Boolean */;

		/** If this Canvas is canAcceptDrop:true, when the user drags a droppable widget over an edge of the widget, should we scroll to show the rest of the widget's content? Returned from canvas.shouldDragScroll() if there are scrollbars.
		 * Flags: IRWA, Group: dragging */
		canDragScroll: boolean;

		/** Indicates that this object can be dropped on top of other widgets. Only valid if canDrag or canDragReposition is true.
		 * Flags: IRWA, Group: dragdrop */
		canDrop: boolean /* Boolean */;

		/** When explicitly set to false, disallows drop before this member in the Layout.
		 * Flags: IRWA, Group: layoutMember */
		canDropBefore: boolean;

		/** Can this widget be allowed to become the target of keyboard events? If canFocus is unset (the default), only scrollable widgets with visible scrollbars are focusable, to allow for keyboard scrolling. A widget normally receives focus by being clicked on or tabbed to.
		 * Flags: IRWA, Group: focus */
		canFocus: boolean;

		/** Will this Canvas fire hover events when the user hovers over it, or one of its children?
		 * Flags: IRW, Group: hovers */
		canHover: boolean;

		/** Whether native drag selection of contained text is allowed within this Canvas. Note that setting this property to false will not avoid text selection which is initiated outside this Canvas from continuing into this Canvas, even if text selection began in another Canvas.
		 * Flags: IRWA, Group: events */
		canSelectText: boolean /* Boolean */;

		/** If this canvas is being displayed in a CanvasItem, this property will be set to point at the item. Otherwise this property will be null.
		 * Flags: R */
		canvasItem: CanvasItem;

		/** Array of all Canvii that are immediate children of this Canvas. Use Canvas.addChild and Canvas.removeChild to add and remove children after a Canvas has been created/drawn.
		 * Flags: IR, Group: containment */
		children: Array<Canvas> /* Array of Canvas */;

		/** Flag to disable snapping to alignment when children of this Canvas are resized
		 * Flags: IRW */
		childrenResizeSnapAlign: boolean /* Boolean */;

		/** If enabled while Canvas.childrenSnapToGrid is enabled, children dragged within this Canvas will also snap to positions where their edges or center lines would be aligned with the edges or centers of other components, and lines will be shown to point out the possible alignment (with appearance controlled by Canvas.snapAlignCenterLineStyle and Canvas.snapAlignEdgeLineStyle respectively. By default, edge- or center-snapping is enabled for all components, but the set of eligible components can be explicitly set via Canvas.snapAlignCandidates. See also Canvas.childrenSnapCenterAlign and Canvas.childrenSnapEdgeAlign for enabling or disabling center alignment or edge alignment individually.
		 * Flags: IRW */
		childrenSnapAlign: boolean /* Boolean */;

		/** See Canvas.childrenSnapAlign. This setting enables or disables snapping on center alignment only.
		 * Flags: IRW */
		childrenSnapCenterAlign: boolean /* Boolean */;

		/** See Canvas.childrenSnapAlign. This setting enables or disables snapping on edge alignment only.
		 * Flags: IRW */
		childrenSnapEdgeAlign: boolean /* Boolean */;

		/** If true, causes this canvas's children to snap to its grid when resizing. This behavior can be overridden on a per-child basis by setting the Canvas.snapToGrid','snapToGrid or Canvas.snapResizeToGrid','snapResizeToGrid value on the child.
		 * Flags: IRW, Group: dragdrop */
		childrenSnapResizeToGrid: boolean;

		/** If true, causes this canvas's children to snap to its grid when dragging. This behavior can be overridden on a per-child basis by setting the Canvas.snapToGrid','snapToGrid value on the child.
		 * Flags: IRW, Group: dragdrop */
		childrenSnapToGrid: boolean;

		/** Automatically generated mask canvas displayed when Canvas.showComponentMask is called.
		 * Flags: R */
		componentMask:  Canvas /* AutoChild Canvas */;

		/** Defaults for the Canvas.componentMask autoChild. Default properties include Canvas.backgroundColor being set to "black" and Canvas.opacity being set to 20.
		 * Flags: IR */
		componentMaskDefaults: CanvasProps /* Canvas Properties */;

		/** The contents of a canvas or label widget. Any HTML string is acceptable.
		 * Flags: IRWA, Group: contents */
		contents: string /* HTMLString */;

		/** Context menu to show for this object, an instance of the Menu widget. Note: if Canvas.destroy is called on a canvas, any specified context menu is not automatically destroyed as well. This is in contrast to MenuButtons which automatically destroy their specified MenuButton.menu by default. The behavior is intentional as context menus are commonly reused across components.
		 * Flags: IRWA, Group: cues */
		contextMenu: Menu;

		/** Specifies the cursor image to display when the mouse pointer is over this widget. It corresponds to the CSS cursor attribute. See Cursor type for different cursors. See also Canvas.disabledCursor and Canvas.noDropCursor.
		 * Flags: IRWA, Group: cues */
		cursor: Cursor;

		/** Array of side names ("T", "B", "L", "R") specifying which sides of the decorated component should show edges. For example: customEdges : ["T", "B"] .. would show edges only on the top and bottom of a component. The default of null means edges will be shown on all sides.
		 * Flags: IR, Group: imageEdges */
		customEdges: Array<string> /* Array of String */;

		/** A dataPath may be specified on any canvas. This provides a straightforward way to display or edit complex nested data. For components which support displaying or editing data values, (such as DynamicForm or ListGrid components), the dataPath may be set to specify how the components data is accessed. In this case the dataPath essentially specifies a nested object to edit - typically a path to a field value within a dataSource record. Note that a ValuesManager will be required to handle connecting the dataBoundcomponent to the appropriate sub object. This may be explicitly specified on the component, or a parent of the component, or automatically generated if a DataSource is specified on either the component or a parent thereof. To provide a simple example - if a complex object existed with the following format: { companyName:"Some Company", address:{ street:"123 Main Street", city:"New York", state:"NY" } } a developer could specify a DynamicForm instance with 'dataPath' set to "address" to edit the nested address object: isc.ValuesManager.create({ ID:'vm', values: { companyName:"Some Company", address:{ street:"123 Main Street", city:"New York", state:"NY" } } }); isc.DynamicForm.create({ valuesManager:"vm", dataPath:"address", items:[{name:"street"}, {name:"city"}, {name:"state"}] }); If a component is specified with a dataPath attribute but does not have an explicitly specified valuesManager, it will check its parent element chain for a specified valuesManager and automatically bind to that. This simplifies binding multiple components used to view or edit a nested data structure as the valuesManager needs only be defined once at a reasonably high level component. Here's an example of this approach: isc.ValuesManager.create({ ID:'vm', values: { companyName:"Some Company", address:{ street:"123 Main Street", city:"New York", state:"NY" } } }); isc.Layout.create({ valuesManager:vm, members:[ isc.DynamicForm.create({ dataPath:"/", items:[{name:"companyName"}] }), isc.DynamicForm.create({ dataPath:"address", items:[{name:"street"}, {name:"city"}, {name:"state"}] }) ] }); Note that in this case the valuesManager is specified on a Layout, which has no 'values' management behavior of its own, but contains items with a specified dataPath which do. In this example you'd see 2 forms allowing editing of the nested data structure. dataPaths from multiple nested components may also be combined. For example: isc.ValuesManager.create({ ID:'vm', values: { companyName:"Some Company", address:{ street:"123 Main Street", city:"New York", state:"NY" } parentCompany:{ companyName:"Some Corporation", address:{ street:"1 High Street", city:"New York", state:"NY" } } } }); isc.Layout.create({ valuesManager:vm, members:[ isc.DynamicForm.create({ dataPath:"/", items:[{name:"companyName"}] }), isc.DynamicForm.create({ dataPath:"address", items:[{name:"street"}, {name:"city"}, {name:"state"}] }), isc.Layout.create({ dataPath:"parentCompany", members:[ isc.DynamicForm.create({ dataPath:"/", items:[{name:"companyName", type:"staticText"}] }), isc.DetailViewer.create({ dataPath:"address", fields:[{name:"street", name:"city", name:"state"}] }) ] }) ] }); In this example the detailViewer will display data from the parentCompany.address object within the base record. Note that if a component has a specified dataSource and shows child components with a specified dataPath, there is no need to explicitly declare a valuesManager at all. If a component with a dataPath has a dataSource, or an ancestor with a dataSource specified, it will, a valuesManager will automatically be generated on the higher level component (and be available as component.valuesManager).
		 * Flags: IRWA */
		dataPath: string /* DataPath */;

		/** For custom components, establishes a default height for the component. For a component that should potentially be sized automatically by a Layout, set this property rather than Canvas.height directly, because Layouts regard a height setting as an explicit size that shouldn't be changed.
		 * Flags: IRWA, Group: sizing */
		defaultHeight: number /* int */;

		/** For custom components, establishes a default width for the component. For a component that should potentially be sized automatically by a Layout, set this property rather than Canvas.width directly, because Layouts regard a width setting as an explicit size that shouldn't be changed.
		 * Flags: IRWA, Group: sizing */
		defaultWidth: number /* int */;

		/** If this property is set to true, the Canvas.destroy','destroy() method has been called on this canvas. This implies the canvas is no longer valid. Its ID has been removed from global scope, and calling standard canvas APIs on it is likely to result in errors.
		 * Flags: RA */
		destroyed: boolean;

		/** This property is set to true when the Canvas.destroy method is called on a widget. If this property is true, but Canvas.destroyed is not, this indicates the canvas is in the process of being destroyed.
		 * Flags: RA */
		destroying: boolean;

		/** If set to true, the widget will be disabled. A widget is only considered enabled if it is individually enabled and all parents above it in the containment hierarchy are enabled. This allows you to enable or disable all components of a complex nested widget by enabling or disabling the top-level parent only.
		 * Flags: IRW, Group: enable */
		disabled: boolean;

		/** Specifies the cursor image to display when the mouse pointer is over this widget if this widget is disabled. It corresponds to the CSS cursor attribute. See Cursor type for different cursors.
		 * Flags: IRWA, Group: cues */
		disabledCursor: Cursor;

		/** Disables Canvas.useTouchScrolling whenever a built-in drag operation has been enabled which is known to be non-functional if touch scrolling is enabled. Default behavior is to leave touch scrolling enabled even if it makes other enabled drag operations non-functional, since any accessibility','accessible application must provide an alternative way to perform drag and drop operations anyway. disableTouchScrollingForDrag exists so that applications can change the default setting on a per-component basis (via Class.changeDefaults), in order to make a system-wide or per-component-type decision about whether to favor touch scrolling vs retaining the ability to drag and drop via finger drags, instead of having to set useTouchScrolling on each individual instance. See the mobileDevelopment','Mobile Development overview for more background information.
		 * Flags: IR, Group: scrolling */
		disableTouchScrollingForDrag: boolean /* Boolean */;

		/** Amount of time (in milliseconds) between which two clicks are considered a single click
		 * Flags: IRWA, Group: events */
		doubleClickDelay: number /* int */;

		/** Visual appearance to show when the object is being dragged. May be overridden for dragResize or dragReposition events via Canvas.dragResizeAppearance and Canvas.dragRepositionAppearance.
		 * Flags: IRWA, Group: dragdrop */
		dragAppearance: DragAppearance;

		/** This indicates how the system will test for droppable targets: either by intersection with the mouse or intersection with the rectangle of the dragMoveTarget.
		 * Flags: IRWA, Group: dragdrop */
		dragIntersectStyle: DragIntersectStyle;

		/** This property controls what kind of mask is used in case Canvas.useDragMask is enabled.
		 * Flags: IRW, Group: dragdrop */
		dragMaskType: DragMaskType;

		/** Sets maximum height that this Canvas can be resized to by a user. Actual limit will be minimum of dragMaxHeight and Canvas.maxHeight.
		 * Flags: IRWA, Group: sizing */
		dragMaxHeight: number;

		/** Maximum width that this Canvas can be resized to by a user. Actual limit will be minimum of dragMaxWidth and Canvas.maxWidth.
		 * Flags: IRWA, Group: sizing */
		dragMaxWidth: number;

		/** Minimum height that this Canvas can be resized to by a user. See Canvas.dragMinWidth for details of behavior.
		 * Flags: IRWA, Group: sizing */
		dragMinHeight: number;

		/** Minimum width that this Canvas can be resized to by a user. Actual limit will be maximum of dragMinWidth and Canvas.minWidth. Note that a Canvas with overflow:"visible" has an implicit minimize size based on it's contents. Note that dragMinWidth affects only user-initiated drag resizes. To set the minimum width of a Canvas embedded in a Layout, you can set +{minWidth}, or Layout.minMemberLength to constrain the minimum size along the length axis of all members of the Layout.
		 * Flags: IRWA, Group: sizing */
		dragMinWidth: number;

		/** If this widget has dragAppearance "target", this value specifies the opacity to render the target while it is being dragged. A null value implies we do not modify the opacity.
		 * Flags: IRWA, Group: dragdrop */
		dragOpacity: number /* int */;

		/** If Canvas.canDragReposition is true, this attributes specifies the visual appearance to show during drag reposition. If unset Canvas.dragAppearance will be used.
		 * Flags: IRWA, Group: dragdrop */
		dragRepositionAppearance: DragAppearance;

		/** Cursor to switch to if the mouse is over a widget that is drag repositionable.
		 * Flags: IRWA, Group: dragdrop */
		dragRepositionCursor: Cursor;

		/** If Canvas.canDragResize is true, this attributes specifies the visual appearance to show during drag resize. If unset Canvas.dragAppearance will be used.
		 * Flags: IRWA, Group: dragdrop */
		dragResizeAppearance: DragAppearance;

		/** If this widget supports drag-scrolling, This property specifies how many ms the user must hover over the drag-scroll threshold before scrolling begins.
		 * Flags: IRWA, Group: dragging */
		dragScrollDelay: number;

		/** Number of pixels the cursor needs to move before the EventHandler starts a drag operation.
		 * Flags: IRWA, Group: dragdrop */
		dragStartDistance: number;

		/** A different widget that should be actually dragged when dragging initiates on this widget. One example of this is to have a child widget that drags its parent, as with a drag box. Because the parent automatically repositions its children, setting the drag target of the child to the parent and then dragging the child will result in both widgets being moved. Valid dragTarget values are: - null (default) [this widget is its own drag target] - another widget, or widget ID - "parent" drag target is this widget's Canvas.getParentCanvas','parentCanvas - "top" drag target is this widget's Canvas.topElement','topElement
		 * Flags: IRWA, Group: dragdrop */
		dragTarget: Canvas | string /* Canvas | String */;

		/** Sets a dragType for this widget used, to be compared to Canvas.dropTypes','dropTypes on possible drop target widgets. See Canvas.dropTypes for a full explanation.
		 * Flags: IRWA, Group: dragdrop */
		dragType: string /* String */;

		/** When a drag and drop interaction occurs, if a Canvas.dragType','dragType is configured on the source widget, it is compared to the dropTypes configured on the target widget, and a drop is only allowed if the dragType is listed in the target widget's dropTypes array. The default setting means any dragType is eligible for dropping on this widget, including no dragType setting. See also Canvas.willAcceptDrop for dynamic determination of drop eligibility.
		 * Flags: IRWA, Group: dragdrop */
		dropTypes: Array<string> /* Array of String | String */;

		/** Dynamic contents allows the contents string to be treated as a simple, but powerful template. When this attribute is set to true, expressions of the form &#36;{arbitrary JS here} are replaced by the result of the evaluation of the JS code inside the curly brackets. This evaluation happens at draw time. If you want to trigger a re-evaluation of the expressions in the contents string you can call markForRedraw() on the canvas. You can use this feature to build some simple custom components. For example, let's say you want to show the value of a Slider in a Canvas somewhere on the screen. You can do this by observing the valueChanged() method on the slider and calling setContents() on your canvas with the new string or you can set the contents of the canvas to something like: "The slider value is &#36;{sliderInstance.getValue()}." Next you set dynamicContents: true on the canvas, observe valueChanged() on the slider and call canvas.markForRedraw() in that observation. This approach is cleaner than setContents() when the Canvas is aggregating several values or dynamic expressions. Like so: Slider.create({ ID: "mySlider" }); Canvas.create({ ID: "myCanvas", dynamicContents: true, contents: "The slider value is &#36;{mySlider.getValue()}." }); myCanvas.observe(mySlider, "valueChanged", "observer.markForRedraw()"); You can embed an arbitrary number of dynamic expressions in the contents string. The search and replace is optimized for speed. If an error occurs during the evaluation of one of the expressions, a warning is logged to the ISC Developer Console and the error string is embedded in place of the expected value in the Canvas. The value of a function is its return value. The value of any variable is the same as that returned by its toString() representation. Inside the evaluation contentext, this points to the canvas instance that has the dynamicContents string as its contents - in other words the canvas instance on which the template is declared.
		 * Flags: IRWA, Group: contents */
		dynamicContents: boolean /* Boolean */;

		/** An optional map of name:value parameters that will be available within the scope of the dynamicContents evaluation. For example - if you have e.g: Canvas.create({ dynamicContents: true, dynamicContentsVars: { name: "Bob" }, contents: "hello &#36;{name}" }); The above will create a canvas with contents hello Bob. You can add, remove, and change values in the dynamicContentsVars object literal, just call markForRedraw() on the canvas to have the dynamicContents template re-evaluated. Note that this is always available inside a dynamic contents string and points to the canvas instance containing the dynamic contents. Used only if Canvas.dynamicContents : true has been set.
		 * Flags: IRWA */
		dynamicContentsVars: ValueMap;

		/** Background color for the EdgedCanvas created to decorate this component. This can be used to provide an underlying "tint" color for translucent edge media
		 * Flags: IR, Group: imageEdges */
		edgeBackgroundColor: string /* CSSColor */;

		/** Background color for the center section only. Can be used as a surrogate background color for the decorated Canvas, if the Canvas is set to partially overlap the edges and hence can't show a background color itself without occluding media.
		 * Flags: IR, Group: imageEdges */
		edgeCenterBackgroundColor: string /* CSSColor */;

		/** Cursor to use when over each edge of a Canvas that is drag resizable. To disable drag resize cursors, set the edgeCursorMap property to null.
		 * Flags: IRWA, Group: dragdrop */
		edgeCursorMap: any /* object */;

		/** Base name of images for edges. Extensions for each corner or edge piece will be added to this image URL, before the extension. For example, with the default base name of "edge.gif", the top-left corner image will be "edge_TL.gif". The full list of extensions is: "_TL", "_TR", "_BL", "_BR", "_T", "_L", "_B", "_R", "_center".
		 * Flags: IR, Group: imageEdges */
		edgeImage: string /* SCImgURL */;

		/** How far into the edge of an object do we consider the "edge" for drag resize purposes?
		 * Flags: IRWA, Group: dragdrop */
		edgeMarginSize: number;

		/** Amount the contained Canvas should be offset. Defaults to edgeSize; set to less than edgeSize to allow the contained Canvas to overlap the edge and corner media.
		 * Flags: IR, Group: imageEdges */
		edgeOffset: number;

		/** Opacity of the edges. Defaults to matching this.opacity. if Canvas.setOpacity is called on a Canvas where edgeOpacity is set, edgeOpacity will be considered a percentage of the parent's opacity (so 50% opaque parent plus edgeOpacity 50 means 25% opaque edges)
		 * Flags: IR, Group: imageEdges */
		edgeOpacity: number /* int */;

		/** Whether to show media in the center section, that is, behind the decorated Canvas.
		 * Flags: IR, Group: imageEdges */
		edgeShowCenter: boolean /* Boolean */;

		/** Size in pixels for corners and edges
		 * Flags: IR, Group: imageEdges */
		edgeSize: number;

		/** The component's EditNode for a component that has been created by a Palette from a PaletteNode.
		 * Flags: R */
		editNode: EditNode;

		/** An EditProxy controls the behaviors of a component when it is placed into devTools','editing mode. The editProxy AutoChild is created when a component is first placed into edit mode via Canvas.setEditMode. editProxy properties can be supplied on a PaletteNode or EditNode as PaletteNode.editProxyProperties','editProxyProperties, but must be provided before the component is first placed into edit mode. Most editable components use a custom EditProxy. See the documentation for each class' Canvas.editProxyConstructor','editProxyConstructor to determine the class.
		 * Flags: IR */
		editProxy:  EditProxy /* AutoChild EditProxy */;

		/** Default class used to construct the EditProxy for this component when the component is Canvas.setEditMode','first placed into edit mode.
		 * Flags: IR */
		editProxyConstructor: string /* SCClassName */;

		/** Criteria to be evaluated to determine whether this Canvas should be enabled. Re-evaluated whenever data in the Canvas.ruleScope changes. A basic criteria uses textMatchStyle:"exact". When specified in componentXML','Component XML this property allows xmlCriteriaShorthand','shorthand formats for defining criteria.
		 * Flags: IR, Group: ruleCriteria */
		enableWhen: AdvancedCriteria;

		/** When this Canvas is included as a member in a Layout, extra blank space that should be left after this member in a Layout.
		 * Flags: IR, Group: layoutMember */
		extraSpace: number /* positiveInteger */;

		/** Sets the style for the grouping frame around the canvas. Only necessary when Canvas.isGroup is set to true.
		 * Flags: IR, Group: appearance */
		groupBorderCSS: string /* String */;

		/** If set, the background color of the grouping label. Only applicable when Canvas.isGroup is set to true. This corresponds to the CSS background-color property on the grouping label. You can set this property to an RGB value (e.g. #22AAFF) or a named color (e.g. red) from a list of browser supported color names. 
		 * Flags: IRW, Group: appearance */
		groupLabelBackgroundColor: string /* CSSColor */;

		/** Sets the style for the grouping label. Only necessary when Canvas.isGroup is set to true. Note that Canvas.groupLabelBackgroundColor overrides any background-color of this style.
		 * Flags: IR, Group: appearance */
		groupLabelStyleName: string /* CSSStyleName */;

		/** The title/label for the grouping. Only applicable when Canvas.isGroup','isGroup is set to true.
		 * Flags: IRW, Group: appearance */
		groupTitle: string /* HTMLString */;

		/** Size for this component's vertical dimension. Can be a number of pixels, or a percentage like "50%". See documentation for Canvas.width for details on how percentage values are resolved actual size. Note that if Canvas.overflow','overflow is set to "visible", this size is a minimum, and the component may overflow to show all content and/or children. If trying to establish a default height for a custom component, set Canvas.defaultHeight','defaultHeight instead.
		 * Flags: IRW, Group: sizing */
		height: number | string /* Number or String */;

		/** When this widget is hidden (see Canvas.visibility and Canvas.hide), should display:none be applied to the Canvas.getOuterElement','outer element? This setting is not supported for general use, but in certain cases, it has been shown that display:none is a work-around for browser bugs involving burn-through of iframes or plugins, where the content of the iframe or plugin may still be visible despite the containing widget being hidden.
		 * Flags: IRA, Group: appearance */
		hideUsingDisplayNone: boolean;

		/** If this.showHover is true, this property can be used to customize the alignment of content in the hover canvas.
		 * Flags: IRW, Group: hovers */
		hoverAlign: Alignment;

		/** If this.showHover is true and Canvas.getHoverComponent is implemented, should the hoverCanvas returned from it be automatically destroyed when it is hidden? The default of null indicates that the component will be automatically destroyed. Set to false to prevent this.
		 * Flags: IRW, Group: hovers */
		hoverAutoDestroy: boolean;

		/** Maximum auto-fit width for a hover if Canvas.hoverAutoFitWidth is enabled. May be specified as a pixel value, or a percentage of page width.
		 * Flags: IRW, Group: hovers */
		hoverAutoFitMaxWidth: number | string /* Number or String */;

		/** if Canvas.showHover is true, this property will cause the specified Canvas.hoverWidth to be treated as a minimum width for the hover. If the hover content string exceeds this, the hover will expand to accomodate it up to Canvas.hoverAutoFitMaxWidth (without the text wrapping). Using this settings differs from simply disabling wrapping via Canvas.hoverWrap','hoverWrap:false as the content will wrap if the Canvas.hoverAutoFitMaxWidth is exceeded.
		 * Flags: IRWA, Group: hovers */
		hoverAutoFitWidth: boolean /* Boolean */;

		/** If this.canHover is true, how long should the mouse be kept over this widget before the hover event is fired
		 * Flags: IRW, Group: hovers */
		hoverDelay: number;

		/** If this.showHover is true, this property can be used to customize the height of the hover canvas shown.
		 * Flags: IRW, Group: hovers */
		hoverHeight: number /* int */;

		/** If this.showHover is true, should this widget's hover canvas be moved with the mouse while visible?
		 * Flags: IRW, Group: hovers */
		hoverMoveWithMouse: boolean;

		/** If this.showHover is true, should the hover canvas be shown with opacity other than 100?
		 * Flags: IRW, Group: hovers */
		hoverOpacity: number;

		/** If this.showHover is true, this property can be used to specify the css style to apply to the hover canvas.
		 * Flags: IRW, Group: hovers */
		hoverStyle: string /* CSSStyleName */;

		/** If this.showHover is true, this property can be used to customize the vertical alignment of content in the hover canvas.
		 * Flags: IRW, Group: hovers */
		hoverVAlign: VerticalAlignment;

		/** If Canvas.showHover','this.showHover is true, this property can be used to customize the width of the hover canvas shown. See also Canvas.hoverAutoFitWidth and Canvas.hoverAutoFitMaxWidth.
		 * Flags: IRW, Group: hovers */
		hoverWidth: number /* int */;

		/** If this.showHover is true, this property can be used to customize the whether content in the hover canvas is displayed in a single line, or wraps. Note that if developers wish to have hovers expand horizontally to fit their text without wrapping *up to some maximum*, and then wrap rather than exceeding that maximum, the Canvas.hoverAutoFitWidth and Canvas.hoverAutoFitMaxWidth attributes may be used instead of simply setting hoverWrap to false.
		 * Flags: IRW, Group: hovers */
		hoverWrap: boolean;

		/** If specified as a pointer to an HTML element present in the DOM, this canvas will be rendered inside that element on Canvas.draw','draw(). NOTES: This feature is intended for temporary integration with legacy page architectures only; the native browser's reaction to DOM insertion is unspecified and unsupported. For consistent cross-browser layout and positioning semantics, use Canvas parents (especially Layouts) and use absolute positioning at top level. Persistence of htmlElement: If Canvas.htmlPosition is set to "replace" the htmlElement will be removed from the DOM when the canvas is drawn - therefore the htmlElement attribute will be cleared at this time. Otherwise if a Canvas is clear()d and then draw()n again it will be rendered inside the same htmlElement. If a Canvas is added as a child to Canvas parent, its htmlElement will be dropped. Canvas.position should typically be set to "relative" if the widget is to be rendered inline within a standard page.
		 * Flags: IRWA, Group: htmlElement */
		htmlElement: string /* DOMElement */;

		/** If Canvas.htmlElement is specified, this attribute specifies the position where the canvas should be inserted relative to the htmlElement in the DOM.
		 * Flags: IRWA, Group: htmlElement */
		htmlPosition: DrawPosition;

		/** Global identifier for referring to a widget in JavaScript. The ID property is optional if you do not need to refer to the widget from JavaScript, or can refer to it indirectly (for example, by storing the reference returned by Class.create','create()). An internal, unique ID will automatically be created upon instantiation for any canvas where one is not provided. The ID property should be unique in the global scope. If window[ID] is already assigned to something else a warning will be logged using the developer console, and the existing reference will be replaced, calling Canvas.destroy','destroy() on the previous object if it is a SmartClient Class instance. Automatically generated IDs will be unique as long as the canvases they refer to remain active - once a canvas with an automatically generated ID has been destroyed, its ID may be reused for the next canvas created with no explicitly specified ID.
		 * Flags: IR, Group: basics */
		ID: string;

		/** Should a grouping frame be shown around this canvas.
		 * Flags: IR */
		isGroup: boolean;

		/** This boolean flag will be set to true by framework logic while generating print HTML for this widget as a result to a call to Canvas.showPrintPreview (or just Canvas.getPrintHTML). Note that this flag is set recursively as parent widgets generate print HTML for their children. This is a read-only property and should not be modified by application code.
		 * Flags: R */
		isPrinting: boolean /* Boolean */;

		/** Marks this Canvas as the Canvas.ruleScope that will be discovered by any contained DataBoundComponents which do not specify an explicit ruleScope.
		 * Flags: IR */
		isRuleScope: boolean /* Boolean */;

		/** Flag to disable snapping to alignment against this Canvas when other Canvases dragged into the same parent when Canvas.childrenSnapAlign is enabled on this Canvas' parent.
		 * Flags: IRW */
		isSnapAlignCandidate: boolean /* Boolean */;

		/** Constrains drag-resizing and drag-repositioning of this canvas to either the rect of its parent (if set to true) or an arbitrary rect based its parent (if set to a [Left,Top,Width,Height] rect array). In the latter mode you may use negative offsets for left/top and a width/height greater than the visible or scroll width of the parent to allow positioning beyond the confines of the parent. If this canvas has no parent, constrains dragging to within the browser window. Affects target and outline dragAppearance, not tracker. Note: keepInParentRect affects only user drag interactions, not programmatic moves. <u>Example use cases:</u> keepInParentRect: true - confine to parent keepInParentRect: [0, 0, 500, 500] - confine to top left 500x500 region within parent keepInParentRect: [0, 0, 10000, 10000] - in combination with oveflow: "auto", confine to parent, but allow moving off the right and bottom of the parent to force scrolling (and hence enlarge the scrollWidth of the parent).
		 * Flags: IRWA, Group: dragdrop */
		keepInParentRect: Array<number> /* Boolean | Array of Integer */;

		/** When this Canvas is included as a member in a Layout, layoutAlign controls alignment on the breadth axis of the layout. Default is "left" for a VLayout, "top" for an HLayout.
		 * Flags: IRW, Group: layoutMember */
		layoutAlign: Alignment | VerticalAlignment;

		/** If set, overrides the global Canvas.defaultPageSpace.
		 * Flags: IRWA, Group: positioning */
		leavePageSpace: number /* Integer */;

		/** Number of pixels the left side of the widget is offset to the right from its default drawing context (either its parent's topleft corner, or the document flow, depending on the value of the Canvas.position property). Can also be set as a percentage, specified as a String ending in '%', eg, "50%". In this case the top coordinate is considered as a percentage of the specified width of the Canvas.getParentCanvas','parent.
		 * Flags: IRW, Group: positioning */
		left: number | string /* Number or String */;

		/** Strategy to use when locating children in this canvas from an autoTest locator string.
		 * Flags: IRWA, Group: autoTest */
		locateChildrenBy: LocatorStrategy;

		/** LocatorTypeStrategy to use when finding children within this canvas.
		 * Flags: IRWA, Group: autoTest */
		locateChildrenType: LocatorTypeStrategy;

		/** Strategy to use when locating peers of this canvas from an autoTest locator string.
		 * Flags: IRWA, Group: autoTest */
		locatePeersBy: LocatorStrategy;

		/** LocatorTypeStrategy to use when finding peers of this canvas.
		 * Flags: IRWA, Group: autoTest */
		locatePeersType: LocatorTypeStrategy;

		/** Set the CSS Margin, in pixels, for this component. Margin provides blank space outside of the border. This property sets the same thickness of margin on every side. Differing per-side margins can be set in a CSS style and applied via Canvas.styleName. Note that the specified size of the widget will be the size including the margin thickness on each side.
		 * Flags: IRW, Group: appearance */
		margin: number;

		/** If Canvas.htmlElement is specified, should this canvas initially be drawn at the same dimensions as the htmlElement? Note: setting this property will not force the canvas to resize if the element subsequently resizes (for example due to page reflow).
		 * Flags: IRWA */
		matchElement: boolean;

		/** Maximum height available to this Canvas. See Canvas.maxWidth for details of behavior.
		 * Flags: IRWA, Group: sizing */
		maxHeight: number;

		/** Maximum width available to this Canvas. The maxWidth and Canvas.maxHeight settings apply to: For a canvas being managed as a member of a Layout, the maximum size the layout should apply to the canvas. For a canvas with a width or height specified as a percent value, a maximum numeric pixel value to limit how large the canvas is sized. determining size for a Canvas in a CanvasItem (maxHeight only) end user Canvas.canDragResize','drag resizing Maximum sizes do not apply in various other circumstances where sizes are being determined, such as ListGrid.showRecordComponents','ListGrid recordComponents.
		 * Flags: IRWA, Group: sizing */
		maxWidth: number;

		/** Default class used to construct menus created by this component, including context menus.
		 * Flags: IR, Group: cues */
		menuConstructor: string /* SCClassName */;

		/** Minimum height available to this Canvas. See Canvas.minWidth for details of behavior.
		 * Flags: IRWA, Group: sizing */
		minHeight: number;

		/** If the widget has drag resize configured on one or more of it's edges, and the edgeMarginSize is large enough that the remaining space is less than minNonEdgeSize, the edgeMarginSize will be reduced such that the non-edge part of the widget is at least 1/3 of the total space (with two draggable edges) or half of it (with one draggable edge).
		 * Flags: IRWA, Group: dragdrop */
		minNonEdgeSize: number /* int */;

		/** Minimum width available to this Canvas. The minWidth and Canvas.minHeight settings apply to: For a canvas being managed as a member of a Layout, the minimum size the layout should apply to the canvas. For a canvas with a width or height specified as a percent value, a minimum numeric pixel value to limit how large the canvas is sized. determining size for a Canvas in a CanvasItem (minHeight only) end user Canvas.canDragResize','drag resizing minimum size when using Overflow "visible" outside of a Layout - minimum size will be the greater of this setting or the minimum size needed to make all content visible Minimum sizes do not apply in various other circumstances where sizes are being determined, such as ListGrid.showRecordComponents','ListGrid recordComponents. See also Layout.minMemberLength as a way of establishing minimum sizes along the length axis for all members of a Layout with a single setting.
		 * Flags: IRWA, Group: sizing */
		minWidth: number;

		/** The minimum speed in pixels per second that must be reached for momentum scrolling to kick in. This setting only applies to touch-enabled devices.
		 * Flags: IRWA */
		momentumScrollMinSpeed: number /* double */;

		/** Amount of time (in milliseconds) between repeated 'mouseStillDown' events for this canvas. See Canvas.mouseStillDown for details.
		 * Flags: IRWA, Group: events */
		mouseStillDownDelay: number /* int */;

		/** Amount of time (in milliseconds) before mouseStillDown events start to be fired repeatedly for this canvas. See Canvas.mouseStillDown for details.
		 * Flags: IRWA, Group: events */
		mouseStillDownInitialDelay: number /* int */;

		/** If true, this canvas will receive all mouse-clicks as single Canvas.click','click events rather than as Canvas.doubleClick','doubleClick events.
		 * Flags: IRWA, Group: events */
		noDoubleClicks: boolean /* Boolean */;

		/** Specifies the cursor image to display when the user drags a droppable canvas over this if it is not a valid drop target for the event and EventHandler.showNoDropIndicator is true.
		 * Flags: IRWA, Group: cues */
		noDropCursor: Cursor;

		/** Renders the widget to be partly transparent. A widget's opacity property may be set to any number between 0 (transparent) to 100 (opaque). Null means don't specify opacity directly, 100 is fully opaque. Note that heavy use of opacity may have a performance impact on some older browsers. In older versions of Internet Explorer (Pre IE9 / HTML5), opacity is achieved through proprietary filters. If Canvas.neverUseFilters','filters have been disabled within this application developers must set Canvas.useOpacityFilter to true for specific components on which opacity support is required. Also note that opacity is incompatible with Canvas.useBackMask','backMasks.
		 * Flags: IRWA, Group: cues */
		opacity: number;

		/** Controls what happens when the drawn size of the content of a Canvas is either greater or smaller than the specified size of the Canvas. Similar to the CSS property overflow, but consistent across browsers. See Overflow type for details.
		 * Flags: IRW, Group: sizing */
		overflow: Overflow;

		/** Set the CSS padding of this component, in pixels. Padding provides space between the border and the component's contents. This property sets the same thickness of padding on every side. Differing per-side padding can be set in a CSS style and applied via Canvas.styleName. Note that CSS padding does not affect the placement of Canvas.children. To provide a blank area around children, either use Canvas.margin','CSS margins or use a Layout as the parent instead, and use properties such as Layout.layoutMargin to create blank space.
		 * Flags: IRW, Group: appearance */
		padding: number;

		/** This Canvas's immediate parent, if any. Can be initialized, but any subsequent manipulation should be via Canvas.addChild','addChild() and Canvas.removeChild','removeChild() calls on the parent. The parent Canvas should be fetched using Canvas.getParentCanvas','getParentCanvas().
		 * Flags: IR, Group: containment */
		parentCanvas: Canvas;

		/** Array of all Canvii that are peers of this Canvas. Use Canvas.addPeer and Canvas.removePeer to add and remove peers after a Canvas has been created/drawn.
		 * Flags: IRA, Group: containment */
		peers: Array<Canvas> /* Array of Canvas */;

		/** Governs the model to be used when sizing canvases with percentage width or height, or positioning widgets with a specified Canvas.snapTo','snapTo. Only affects widgets with a a specified Canvas.percentSource','percentSource, or widgets that have Canvas.snapTo set and are peers of some Canvas.getMasterCanvas','other canvas. Determines whether the coordinates used for sizing (for percentage sized widgets) and positioning (if snapTo is set) should be relative to the visible size or the viewport size of the percentSource or Canvas.getMasterCanvas','master canvas widget.
		 * Flags: IRA, Group: sizing */
		percentBox: PercentBoxModel;

		/** If this canvas has its size specified as a percentage, this property allows the user to explicitly designate another canvas upon which sizing will be based. If unset percentage sizing is based on - the Canvas.getMasterCanvas','master canvas if there is one and Canvas.snapTo','snapTo is set, - otherwise on the amount of space available in this widget's parent canvas, if this is a child of some other widget - otherwise the page size.
		 * Flags: IRWA, Group: sizing */
		percentSource: Canvas;

		/** Absolute or relative, corresponding to the "absolute" (with respect to parent) or "relative" (with respect to document flow) values for the CSS position attribute. Setting position:"relative" enables SmartClient components to be embedded directly into the native HTML flow of a page, causing the component to be rendered within an existing DOM structure. This attribute should only be set to "relative" on a top level component (a component with no Canvas.getParentCanvas). There are 2 ways to embed relatively positioned canvases in the DOM - by default the component will be written out inline when it gets Canvas.draw','drawn()n. For example to embed a canvas in an HTML table you could use this code: &lt;table&gt; &lt;tr&gt; &lt;td&gt; &lt;script&gt; isc.Canvas.create({autoDraw:true, backgroundColor:"red", position:"relative"}); &lt;/script&gt; &lt;td&gt; &lt;/tr&gt; &lt;/table&gt; Alternatively you can make use of the Canvas.htmlElement attribute. Relative positioning is intended as a short-term integration scenario while incrementally upgrading existing applications. Note that relative positioning is not used to manage layout within SmartClient components - instead the Layout class would typically be used. For best consistency and flexibility across browsers, all SmartClient layout managers use absolute positioning. For canvases with a specified Canvas.htmlElement, this attribute defaults to "relative". In all other cases the default value will be "absolute".
		 * Flags: IRWA, Group: positioning */
		position: Positioning;

		/** Should this canvas print its children absolutely positioned when generating Canvas.getPrintHTML','printable HTML. By default explicitly specified absolute positioning and sizing is ignored when generating print HTML. This is done intentionally: there is no way for the framework to predict how explicit sizes will translate to a the printed page and if HTML for printing includes the same absolute positioning and sizing as is displayed within an application it is very common to encounter undesirable effects, such as seeing tables get broken over several pages horizontally when there is enough room to print them on a single page of paper. In some cases, however, a developer may wish to have explicit sizing and positioning respected within the print-view. Setting this attribute to true will cause this to occur.
		 * Flags: IRWA, Group: printing */
		printChildrenAbsolutelyPositioned: boolean /* Boolean */;

		/** Prompt displayed in hover canvas if Canvas.showHover','showHover is true.
		 * Flags: IRW, Group: hovers */
		prompt: string /* HTMLString */;

		/** If Canvas.proportionalResizing is set to "modifier" or "modifierOff" then proportional resizing of the widget is activated or deactivated, respectively, whenever at least one key in this set of modifier keys is pressed. The keys allowed in this set are: "Alt", "Ctrl", and "Shift". If this set of keys is empty then proportional resizing is always used if proportionalResizing is "modifier" and is never used if proportionalResizing is "modifierOff" .
		 * Flags: IR, Group: dragdrop */
		proportionalResizeModifiers: Array<KeyName> /* Array of KeyName */;

		/** If Canvas.canDragResize is true, this property specifies the conditions for when proportional resizing is used. The default is "none" , which means that proportional resizing is disabled.
		 * Flags: IR, Group: dragdrop */
		proportionalResizing: ProportionalResizeMode;

		/** Should this element be redrawn in response to a resize? Should be set to true for components whose Canvas.getInnerHTML','inner HTML will not automatically reflow to fit the component's new size.
		 * Flags: IRWA, Group: drawing */
		redrawOnResize: boolean /* Boolean */;

		/** When this Canvas is included as a member in a Layout, and Canvas.showResizeBar is set to true so that a resizeBar is created, resizeBarTarget:"next" can be set to indicate that the resizeBar should resize the next member of the layout rather than this one. For resizeBars that support hiding their target member when clicked on, resizeBarTarget:"next" also means that the next member will be the one hidden. This is typically used to create a 3-way split pane, where left and right-hand sections can be resized or hidden to allow a center section to expand. NOTE: as with any Layout, to ensure all available space is used, one or more members must maintain a flexible size (eg 75%, or *). In a two pane Layout with a normal resize bar, to fill all space after a user resizes, the member on the right should have flexible size. With resizeBarTarget:"next", the member on the left should have flexible size.
		 * Flags: IR, Group: layoutMember */
		resizeBarTarget: string /* String */;

		/** When drag resizing is enabled via Canvas.canDragResize, restricts resizes to only certain edges or corners. The default of null indicates the widget can be resized from any corner or edge (if canDragResize is true). To restrict resizing to only certain corners, set resizeFrom to an Array of EdgeNames.
		 * Flags: IRWA, Group: dragdrop */
		resizeFrom: Array<EdgeName> /* Array of EdgeName */;

		/** Canvas.ID of the component that gathers the context for evaluation of criteria-based rules specified by properties such as FormItem.visibleWhen. If not specified, this component will search through it's Canvas.parentCanvas chain until it either reaches the top or reaches a parent marked Canvas.isRuleScope. Determination of the ruleScope happens when the component is first drawn. The component designated as the ruleScope manages a nested data structure called the "rule context" which contains information from all DataBoundComponents that are registered with the ruleScope. By specifying Criterion.fieldName as a DataPath, AdvancedCriteria defined in properties such as FormItem.visibleWhen can access any part of the rule context. By default, the rule context contains data as follows: any DataBoundComponent that has a DataSource contributes the values of the selected record or record being edited under the ID of the DataSource. For any collision an editable display (such as a form or editable grid) wins over a static display (such as a non-editable grid with a selection.) any ListGrid or other component that manages a selection and has been assigned an explicit Canvas.ID will contribute the values of the selected record under &lt;componentId&gt;.selectedRecord, and also contributes 3 flags for checking for selection: anySelected, multiSelected, numSelected. any DynamicForm or other component that edits values and has been assigned an explicit Canvas.ID contributes its current values under &lt;componentId&gt;.values, and contributes a flag hasChanges. any DynamicForm or ListGrid that has been assigned an explicit Canvas.ID contributes a value &lt;componentId&gt;.focusField. When present the value indicates the component has focus along with the name of the field that has focus. Its absense indicates the component does not have focus at all. any ListGrid that has been assigned an explicit Canvas.ID contributes a flag isGrouped under &lt;componentId&gt;. For example, given a screen where: a ListGrid with ID "itemGrid" and DynamicForm with ID "itemForm" are both bound to the supplyItem sample DataSource the ListGrid has a single selection, and the record selected in the ListGrid is being edited in the form, and has been changed The default rule context available from Canvas.getRuleContext, expressed as JSON, would be: { supplyItem : { itemID : "654321", itemName : "Sewing Machine", price : 5.50, // note: user change ..other properties.. }, itemForm.values : { itemID : "654321", itemName : "Sewing Machine", price : 5.50, // note: user change ..other properties.. }, itemForm.focusField : "itemName", itemForm.hasChanges : true, itemGrid.selectedRecord : { itemID : "654321", itemName : "Sewing Machine", price : 3.50, // note: old price ..other properties.. }, itemGrid.anySelected : true, itemGrid.multiSelected : false, itemGrid.numSelected : 1, itemGrid.isGrouped : false } 
		 * Flags: IR */
		ruleScope: string /* String */;

		/** The class that will be used to create custom scrollbars for this component. Set this attribute to a Scrollbar subclass with e.g. a different skinImgDir, to customize scrollbar appearance for this component only. When skinning','spriting is enabled and supported by the skin, the default scrollbarConstructor is changed to a different scrollbar class which handles scrollbar spriting. Spriting of the scrollbars of an individual component can therefore be disabled by creating the component with scrollbarConstructor set to the "Scrollbar" class. "Scrollbar" is a basic scrollbar class that does not employ spriting.
		 * Flags: IA, Group: scrolling */
		scrollbarConstructor: string /* String */;

		/** How thick should we make the scrollbars for this canvas. This only applies if Canvas.showCustomScrollbars is true. <strong>NOTE:</strong> When skinning','spriting is enabled, changing the scrollbarSize may cause tiling of certain images and backgrounds that make up the custom scrollbar. This can be fixed for a component by creating it with Canvas.scrollbarConstructor set to "Scrollbar"&mdash;a basic scrollbar class that does not employ spriting.
		 * Flags: IRWA, Group: scrolling */
		scrollbarSize: number;

		/** Color for the css-based drop shadow shown if Canvas.useCSSShadow is true and Canvas.showShadow is true. Has no effect if we are not using css-based shadows - in that case, use Canvas.shadowImage instead.
		 * Flags: IRWA, Group: shadow */
		shadowColor: string /* CSSColor */;

		/** Depth of the shadow, or the virtual height above the page of the widget throwing the shadow. This is a single parameter that can be used to control both shadowSoftness and shadowOffset.
		 * Flags: IR, Group: shadow */
		shadowDepth: number;

		/** Horizontal offset for the Canvas.showShadow','shadow. Takes precedence over Canvas.shadowOffset if set. Has no effect if Canvas.useCSSShadow','css-shadows are not being used for this canvas.
		 * Flags: IRWA, Group: shadow */
		shadowHOffset: number /* Number */;

		/** If Canvas.useCSSShadow is false, (or for browsers that do not support css3), this property supplies the base name of the series of images for the sides, corners, and center of the shadow. The actual image names fetched for the dropShadow combine the segment name and the shadowDepth setting. For example, given "ds.png" as the base name, a depth of 4, and the top-left segment of the shadow, we'd use "ds4_TL.png". The names for segments are the same as those given for controlling resizable edges; see Canvas.resizeFrom. The center segment has the name "center". The center segment is the only segment that doesn't include the depth in the URL, so the final image name for the center given a baseName of "ds.png" would be just "ds_center.png".
		 * Flags: IRA, Group: shadow */
		shadowImage: string /* SCImgURL */;

		/** Offset of the shadow. Defaults to half of shadowDepth if unset. Because of the blurred edges, a shadow is larger than the originating component by 2xsoftness. An shadowOffset of 0 means that the shadow will extend around the originating component equally in all directions. If Canvas.useCSSShadow','css shadows are being used, separate vertical and horizontal offsets may be specified via Canvas.shadowHOffset and Canvas.shadowVOffset.
		 * Flags: IRWA, Group: shadow */
		shadowOffset: number;

		/** Softness, or degree of blurring, of the shadow. A shadow with softness:x is 2x pixels larger in each direction than the element throwing the shadow, and the media for each edge should be x pixels wide/tall. Defaults to shadowDepth if unset.
		 * Flags: IRWA, Group: shadow */
		shadowSoftness: number;

		/** Explicit spread for the css-based drop shadow shown if Canvas.useCSSShadow is true and Canvas.showShadow is true. This property governs how much larger than the widget the shadow will appear. A negative value (coupled with an explicit offset) will result in a smaller shadow. Has no effect if we are not using css-based shadows - in that case, use Canvas.shadowImage instead.
		 * Flags: IRWA, Group: shadow */
		shadowSpread: number /* Integer */;

		/** Vertical offset for the Canvas.showShadow','shadow. Takes precedence over Canvas.shadowOffset if set. Has no effect if Canvas.useCSSShadow','css-shadows are not being used for this canvas.
		 * Flags: IRWA, Group: shadow */
		shadowVOffset: number /* Number */;

		/** Whether this canvas should be included in a printable view. Default is to: omit all peers (edges generated by showEdges:true, etc) omit anything considered a "control", such as a button or menu (see PrintProperties.omitControls) include everything else not marked shouldPrint:false 
		 * Flags: IRW, Group: printing */
		shouldPrint: boolean;

		/** Whether to use the browser's native scrollbars or SmartClient-based scrollbars. SmartClient-based scrollbars are skinnable, giving you complete control over look and feel. SmartClient-based scrollbars also enable some interactions not possible with native scrollbars, such as ListGrid.fixedRecordHeights','variable height records in grids in combination with ListGrid.dataPageSize','data paging. Native browser scrollbars are slightly faster simply because there are less SmartClient components that need to be created, drawn and updated. Each visible SmartClient-based scrollbar on the screen has roughly the impact of two StretchImgButtons. SmartClient is always aware of the size of the scrollbar, regardless of whether native or custom scrollbars are used, and regardless of what operating system and/or operating system "theme" or "skin" is in use. This means SmartClient will correctly report the Canvas.getViewportHeight','viewport size, that is, the interior area of the widget excluding space taken by scrollbars, which is key for exactly filling a component with content without creating unnecessary scrolling. The showCustomScrollbars setting is typically overridden in load_skin.js in order to change the default for all SmartClient components at once. This may be achieved via the static Canvas.setShowCustomScrollbars method or via a simple addProperties block, like so: isc.Canvas.addProperties({ showCustomScrollbars:false }); On Browser.isTouch','touch devices, custom scrollbars are disabled in favor of enabling native touch scrolling if available. However, custom scrollbars <em>and</em> native touch scrolling can be enabled for the component by setting Canvas.alwaysShowScrollbars to true.
		 * Flags: IRA, Group: scrolling */
		showCustomScrollbars: boolean;

		/** When this widget is dragged, if its dragAppearance is "target", should we show a shadow behind the canvas during the drag.
		 * Flags: IRWA, Group: dragdrop */
		showDragShadow: boolean /* Boolean */;

		/** Whether an EdgedCanvas should be used to show image-based edges around this component.
		 * Flags: IR, Group: imageEdges */
		showEdges: boolean /* Boolean */;

		/** If this.canHover is true, should we show the global hover canvas by default when the user hovers over this canvas?
		 * Flags: IRW, Group: hovers */
		showHover: boolean /* Boolean */;

		/** When set to true, shows a widget hovering at the mouse point instead of the builtin hover label. Override Canvas.getHoverComponent','getHoverComponent to provide the Canvas to show as the hoverComponent.
		 * Flags: IRWA, Group: hoverComponents */
		showHoverComponents: boolean /* Boolean */;

		/** When this Canvas is included as a member in a Layout, whether a resizeBar should be shown after this member in the layout, to allow it to be resized. Whether a resizeBar is actually shown also depends on the Layout.defaultResizeBars','defaultResizeBars attribute of the layout, and whether this Canvas is the last layout member. By default the resize bar acts on the Canvas that it is declared on. If you want the resize bar to instead act on the next member of the Layout (e.g. to collapse down or to the right), set Canvas.resizeBarTarget as well.
		 * Flags: IRW, Group: layoutMember */
		showResizeBar: boolean /* Boolean */;

		/** Whether to show a drop shadow for this Canvas. Shadows may be rendered using Canvas.useCSSShadow','css or via images. The appearance of shadows can be customized via Canvas.shadowColor (for css-based shadows) or Canvas.shadowImage (for image based shadows), Canvas.shadowDepth, Canvas.shadowOffset and Canvas.shadowSoftness. When Canvas.useCSSShadow is false, developers should be aware that the drop shadow is rendered as a Canvas.peers','peer and is drawn outside the specified width and height of the widget meaning a widget with shadows takes up a little more space than it otherwise would. A full screen canvas with showShadow set to true as this would be likely to cause browser scrollbars to appear - developers can handle this by either setting this property to false on full-screen widgets, or by setting overflow to "hidden" on the &lt;body&gt; element if browser-level scrolling is never intended to occur.
		 * Flags: IRW, Group: shadow */
		showShadow: boolean /* Boolean */;

		/** Whether to show a snap grid for this Canvas. Note that the grid is only shown when either Canvas.childrenSnapToGrid','childrenSnapToGrid or Canvas.childrenSnapResizeToGrid','childrenSnapResizeToGrid is true. Grid is based on Canvas.snapHGap','snapHGap and Canvas.snapVGap','snapVGap properties.
		 * Flags: IRW */
		showSnapGrid: boolean /* Boolean */;

		/** This is an advanced setting. If set to true, when a widget is Canvas.hide','hidden, the widget's handle will be resized such that it takes up no space, in addition to having its css visibility property set to "hidden". In addition to preventing the size of this widget from impacting the Canvas.getScrollWidth','scroll size of any parent widget while hidden, this setting works around a native bug observed in Internet Explorer 10, whereby an &lt;IFRAME&gt; element with visibility set to hidden can cause rendering problems, if the HTML loaded by the &lt;IFRAME&gt; contains a &lt;frameset&gt;. In this case the browser may refuse to draw other elements at the same coordinates with a lower z-index than the hidden frame. Setting this property to true works around this problem for cases where an &lt;IFRAME&gt; containing a &lt;frameset will be rendered out, for example in an HTMLFlow with contentsType set to "page".
		 * Flags: IRWA, Group: visibility */
		shrinkElementOnHide: boolean;

		/** Is it possible that a call to Canvas.redraw on this widget will change its size? Used by framework layout code when determining whether a component which has been Canvas.markForRedraw','marked as dirty needs an immediate redraw to determine its drawn size. If unset, default behavior assumes any component with overflow set to "visible" may change size on redraw, and any component with overflow set to "hidden", "scroll", or "auto" will not. This property overrides that behavior, and may be used to indicate that some component with non visible overflow can change size on redraw. An example use case would be a custom component with an override to explicitly resize the component as part of the redraw() flow.
		 * Flags: IRWA */
		sizeMayChangeOnRedraw: boolean /* Boolean */;

		/** Default directory for skin images (those defined by the class), relative to the Page-wide Page.getSkinDir','skinDir.
		 * Flags: IRWA, Group: images */
		skinImgDir: string /* URL */;

		/** When Canvas.childrenSnapAlign is enabled, list of candidates to check for alignment. If a list of snapAlignCandidates is never provided, the default is to use all children that are not explicitly excluded via Canvas.isSnapAlignCandidate, including automatically adding newly added children as candidates, and ignoring children that have been removed. Use Canvas.addSnapAlignCandidate and Canvas.removeSnapAlignCandidate to add and remove special candidates while retaining all children as default candidates. Possible candidates which are not drawn or are hidden are automatically ignored.
		 * Flags: IRW */
		snapAlignCandidates: Array<Canvas> /* Array of Canvas */;

		/** CSS border declaration used for the line shown to indicate snapping to a center line when Canvas.childrenSnapAlign is set.
		 * Flags: IR */
		snapAlignCenterLineStyle: string /* String */;

		/** CSS border declaration used for the line shown to indicate snapping to a edge line when Canvas.childrenSnapAlign is set.
		 * Flags: IR */
		snapAlignEdgeLineStyle: string /* String */;

		/** Describes which axes to apply snap-to-grid to. Valid values are "horizontal", "vertical" or "both".
		 * Flags: IRW, Group: dragdrop */
		snapAxis: string;

		/** If Canvas.snapTo','snapTo is defined to this widget, this property can be used to define which edge of this widget should be snapped to an edge of the master or parent element. If unspecified the, default snapTo behavior is set up to align the "snapTo" edge of this widget with the snapTo edge of the master or parent.
		 * Flags: IRW, Group: sizing */
		snapEdge: string /* String */;

		/** The horizontal snap direction. Set this value to "before" to snap to the nearest gridpoint to the left; set it to "after" to snap to the nearest gridpoint to the right; and set it to "nearest" to snap to the nearest gridpoint in either direction.
		 * Flags: IRW, Group: dragdrop */
		snapHDirection: string;

		/** The horizontal grid size to use, in pixels, when snap-to-grid is enabled.
		 * Flags: IRW, Group: dragdrop */
		snapHGap: number;

		/** If Canvas.snapTo','snapTo is defined for this widget, this property can be used to specify an offset in px or percentage for the left coordinate of this widget. For example if snapTo is specified as "L" and snapOffsetLeft is set to 6, this widget will be rendered 6px inside the left edge of its parent or master element. Alternatively if snapTo was set to "R", a snapOffsetLeft value of -6 would cause the component to be rendered 6px inside the right edge of its parent or Canvas.getMasterCanvas','master canvas.
		 * Flags: IRW, Group: sizing */
		snapOffsetLeft: number /* integer */;

		/** If Canvas.snapTo','snapTo is defined for this widget, this property can be used to specify an offset in px or percentage for the top coordinate of this widget. For example if snapTo is specified as "T" and snapOffsetTop is set to 6, this widget will be rendered 6px below the top edge of its parent or master element. . Alternatively if snapTo was set to "B", a snapOffsetTop value of -6 would cause the component to be rendered 6px inside the bottom edge of its parent or Canvas.getMasterCanvas','master canvas.
		 * Flags: IRW, Group: sizing */
		snapOffsetTop: number /* integer */;

		/** When this canvas is dropped onto an object supporting snap-to-grid, should it snap to the grid (true, the default) or just drop wherever the mouse is (false).
		 * Flags: IRWA, Group: dragdrop */
		snapOnDrop: boolean /* Boolean */;

		/** Flag to disable snapping to alignment when this Canvas is resized. To control snapping to align for the children resized within this Canvas, see Canvas.childrenResizeSnapAlign','childrenResizeSnapAlign instead.
		 * Flags: IRW */
		snapResizeToAlign: boolean /* Boolean */;

		/** Causes this canvas to snap to its parent's grid when resizing. Note that this value defaults to the Canvas's Canvas.snapToGrid','snapToGrid value if undefined.
		 * Flags: IRW, Group: dragdrop */
		snapResizeToGrid: boolean;

		/** Position this widget such that it is aligned with ("snapped to") an edge of its Canvas.getMasterCanvas','master (if specified), or its Canvas.getParentCanvas','parent canvas. Note that this property also impacts the sizing of this widget. If this widgets size is specified as a percent value, and has no explicit Canvas.percentSource, sizing will be calculated based on the size of the Canvas.getMasterCanvas','master canvas when snapTo is set. Possible values: BR, BL, TR, TL, R, L, B, T, C where B=Bottom, T=Top, L=Left, R=right and C=center Standard snapTo behavior will attach the outer edge of the widget to the parent or master element - for example setting snapTo to "B" would align the bottom edge of this component with the bottom edge of the master or parent element (and center this component horizontally over its master or parent element). Canvas.snapEdge can be specified to change this behavior allowing the developer to, for example, align the top edge of this component with the bottom edge of its Canvas.getMasterCanvas','master canvas. Canvas.snapOffsetLeft and Canvas.snapOffsetTop may also be specified to offset the element from exact snapTo alignment.
		 * Flags: IRW, Group: sizing */
		snapTo: string /* String */;

		/** Flag to disable snapping to alignment when this Canvas is dragged when Canvas.childrenSnapAlign is enabled on this Canvas' parent. To control snapping to align for the children dragged within this Canvas, see Canvas.childrenSnapAlign instead.
		 * Flags: IRW */
		snapToAlign: boolean /* Boolean */;

		/** Flag to disable snapping to center alignment when this Canvas is dragged when Canvas.childrenSnapAlign is enabled on this Canvas' parent.
		 * Flags: IRW */
		snapToCenterAlign: boolean /* Boolean */;

		/** Flag to disable snapping to edge alignment when this Canvas is dragged when Canvas.childrenSnapAlign is enabled on this Canvas' parent.
		 * Flags: IRW */
		snapToEdgeAlign: boolean /* Boolean */;

		/** Causes this canvas to snap to its parent's grid when dragging.
		 * Flags: IRW, Group: dragdrop */
		snapToGrid: boolean;

		/** The vertical snap direction. Set this value to "before" to snap to the nearest gridpoint above; set it to "after" to snap to the nearest gridpoint below; and set it to "nearest" to snap to the nearest gridpoint in either direction.
		 * Flags: IRW, Group: dragdrop */
		snapVDirection: string;

		/** The vertical grid size to use, in pixels, when snap-to-grid is enabled.
		 * Flags: IRW, Group: dragdrop */
		snapVGap: number;

		/** The CSS class applied to this widget as a whole.
		 * Flags: IRW, Group: appearance */
		styleName: string /* CSSStyleName */;

		/** If specified this governs the tabIndex of the widget in the page's tab order. Setting this value to -1 will ensure the canvas does not show up in the page's tab order, though if Canvas.canFocus','canFocus is true, the user may still give it keyboard focus by clicking on the widget directly. By default SmartClient auto-assigns tab-indices, ensuring focusable widgets are reachable by tabbing in an intuitive order based on widget hierarchy and draw order. Specifying an explicit tab index means a widget will not participate in this automatic tab position allocation and is typically not recommended except for very simple cases. For more information on automatic tab index assignment, including recommended approaches for customizing tab order assignation, see the tabOrderOverview. Developers may call Canvas.clearExplicitTabIndex to clear any explicitly assigned tab index, and have the widget participate in automatic tab position allocation. canvas.tabIndex cannot be set to greater than Canvas.TAB_INDEX_FLOOR - as we reserve the values above this range for auto-assigned tab-indices.
		 * Flags: IRWA, Group: focus */
		tabIndex: number;

		/** Number of pixels the top of the widget is offset down from its default drawing context (either its parent's top-left corner, or the document flow, depending on the value of the Canvas.position property). Can also be set as a percentage, specified as a String ending in '%', eg, "50%". In this case the top coordinate is considered as a percentage of the specified height of the Canvas.getParentCanvas','parent.
		 * Flags: IRW, Group: positioning */
		top: number | string /* Number or String */;

		/** The top-most Canvas (i.e., not a child of any other Canvas), if any, in this widget's containment hierarchy.
		 * Flags: RA, Group: containment */
		topElement: Canvas;

		/** Should canvases with no Canvas.getParentCanvas','parent canvas be moved to the end of the TabIndexManager tree on draw()? If set to false, the tab-position will not be modified on draw. This property is useful for cases where the tab position of a widget will be managed by some explicit tabIndex management code.
		 * Flags: IRWA */
		updateTabPositionOnDraw: boolean;

		/** Should canvases with a Canvas.getParentCanvas','parent canvas be added to the TabIndexManager under the parent as described in Canvas.updateChildTabPositions and Canvas.updateChildTabPosition? If set to false, the tab-position will not be modified on parent change. This property is useful for cases where the tab position of a widget will be managed by something other than the parent canvas, for example for CanvasItem.canvas','canvasItem canvases.
		 * Flags: IRWA */
		updateTabPositionOnReparent: boolean;

		/** In earlier versions of Internet Explorer (pre IE9), a native limitation exists whereby if HTML elements are overlapping on the page, certain elements can appear to "burn through" elements in the same position with a higher z-index. Specific cases in which this have been observed include Applets, &lt;IFRAME&gt; elements, and for older versions of IE, native &lt;SELECT&gt; items. The backMask is a workaround for this issue. If useBackMask is set to true, the component will render an empty &lt;IFRAME&gt; element behind the canvas, which prevents this effect in all known cases. Has no effect in other browsers.
		 * Flags: IRWA */
		useBackMask: boolean /* Boolean */;

		/** If Canvas.showShadow is true, should we use the css box-shadow property (where supported) to achieve the shadow? Set this property to false to switch to a media-based approach, achieved by rendering the Canvas.shadowImage in an automatically generated peer. This approach is also used regardless of this property value in older browsers where the css box-shadow property isn't supported. See also Canvas.shadowColor, Canvas.shadowDepth, Canvas.shadowOffset, Canvas.shadowSoftness and Canvas.shadowSpread
		 * Flags: IRA, Group: shadow */
		useCSSShadow: boolean;

		/** This flag controls whether we register the component as a maskable item with the EventHandler. If enabled, a backmask will be automatically created for the dragMoveTarget on the fly to avoid burnthrough e.g. by plugins or frames. Note that this property will be defaulted to false unless the canvas contains an IFrame, in which case it will be defaulted to true. The Canvas.dragMaskType property controls what kind of mask is used in case useDragMask is enabled.
		 * Flags: IRW, Group: dragdrop */
		useDragMask: boolean;

		/** If set, native HTML5 drag and drop will be used for all drags initiated on this widget (on browsers where this is supported). When using native HTML5 drags, the same series of events fires as for a normal drag (Canvas.dragStart, Canvas.dropMove, etc.), and the Canvas.dragType','dragType / Canvas.dropTypes','dropTypes system works. Canvas.dragAppearance','dragAppearance is not supported; however, basic customization of the browser's tracker image is supported in certain browsers via the EventHandler.setDragTrackerImage API. The primary difference with a native drag is that it can be cross-frame; that is, the user can drag out of the current browser window and drop into a different window or tab. To provide information that will be available to a foreign frame, use EventHandler.setNativeDragData. This API must be called when the Canvas.dragStart event fires, and will not work if called at any other time. However, due to browser bugs and/or browser-imposed limitations, the information provided to setNativeDragData cannot be accessed in the foreign frame until the actual drop occurs (mouse button released). This means drop eligibility cannot be determined dynamically based on the dragged data; instead, eligibility can only be determined based on the Canvas.dragType / Canvas.dropTypes system. For this reason, a Canvas.dragType must be set on the source of a drag. NOTE: Although Internet Explorer 10+ supports a subset of the <a href='http://www.w3.org/TR/html5/editing.html#dnd' target='_blank'>HTML5 drag and drop standard</a>, native drag and drop is disabled in IE because cross-window drags&mdash;the primary purpose of this API&mdash;are not possible.
		 * Flags: IR, Group: dragdrop */
		useNativeDrag: boolean /* Boolean */;

		/** Configures where the Opacity filter is used for IE6-8. With the default of null, opacity filters are used unless Canvas.neverUseFilters has been set. When set explicitly to true, opacity filters are used even if neverUseFilters is true. See IEFilters for background.
		 * Flags: IR, Group: IEFilters */
		useOpacityFilter: boolean;

		/** On Browser.isTouch','touch devices, if this Canvas can be scrolled, should touch-dragging the content area result in scrolling? Set to false if touch-dragging should not cause scrolling. Note that setting to false enables the use of Canvas.showCustomScrollbars','custom scrollbars on touch devices. useTouchScrolling can default to false if Canvas.disableTouchScrollingForDrag','disableTouchScrollingForDrag is true and various built-in drag operations are enabled that normally interfere with touch scrolling (e.g. ListGrid.canDragSelect and ListGrid.canReorderRecords). When touch scrolling is disabled, it can be difficult to interact with parts of the custom scrollbars at their default size of 16 pixels. In touch browsers, any touch 8px before the thumb of a Scrollbar','custom scrollbar will be mapped to the thumb, but the other parts of the scrollbar do not have a similar tolerance applied. The width of the custom scrollbars can be increased by setting the Canvas.scrollbarSize to a larger value, but note that when skinning','spriting is enabled, changing the scrollbarSize may cause tiling of certain images and backgrounds that make up the custom scrollbar. This can be fixed for a component by creating it with Canvas.scrollbarConstructor set to "Scrollbar"&mdash;a basic scrollbar class that does not employ spriting.
		 * Flags: IRA, Group: scrolling */
		useTouchScrolling: boolean /* Boolean */;

		/** Controls widget visibility when the widget is initialized. See Visibility type for details.
		 * Flags: IRW, Group: appearance */
		visibility: Visibility;

		/** Criteria to be evaluated to determine whether this Canvas should be visible. Re-evaluated whenever data in the Canvas.ruleScope changes. A basic criteria uses textMatchStyle:"exact". When specified in componentXML','Component XML this property allows xmlCriteriaShorthand','shorthand formats for defining criteria.
		 * Flags: IR, Group: ruleCriteria */
		visibleWhen: AdvancedCriteria;

		/** Size for this component's horizontal dimension. Can be a number of pixels, or a percentage like "50%". Percentage sizes are resolved to pixel values as follows: If a canvas has a specified Canvas.percentSource','percentSource, sizing will be a percentage of the size of that widget (see also Canvas.percentBox). Otherwise, if a canvas has a Canvas.getMasterCanvas','master canvas, and Canvas.snapTo','snapTo is set for the widget, sizing will be a percentage of the size of that widget (see also Canvas.percentBox). Otherwise if this is a child of some other canvas, percentages will be based on the inner size of the Canvas.getParentCanvas','parent canvas's viewport. Otherwise, for top level widgets, sizing is calculated as a percentage of page size. Note that if a Canvas.maxWidth or Canvas.minWidth are specified (or Canvas.maxHeight / Canvas.minHeight for heights), these properties act as explicit pixel limits on the canvas' size. For example, a canvas with Canvas.maxWidth set to 500, and width specified as "100%" will not render larger than 500 pixels in width even if there is more space available in the parent canvas or percentSource. Layout','Layouts may specially interpret percentage sizes on their children, and also allow "*" as a size. Note that if Canvas.overflow','overflow is set to "visible", this size is a minimum, and the component may overflow to show all content and/or children. If trying to establish a default width for a custom component, set Canvas.defaultWidth','defaultWidth instead.
		 * Flags: IRW, Group: sizing */
		width: number | string /* Number or String */;


		/* Instance Method Overrides */

		/** 
		 * Executed when the left mouse is clicked (pressed and then released) on this widget. No default implementation.
		 */
		click?(): boolean /* Boolean */; 

		/** 
		 * When a widget instance is created, it is assigned a unique global identifier that can be used to access the instance by name. The getID method returns this ID for a particular instance. Global IDs are essential when you need to embed a widget reference in a string, usually a string that will be evaluated in the future and/or in another object, where you may not have access to a variable or parameter holding the widget's reference.
		 */
		getID?(): string; 

		/** 
		 * Sets the widget's CSS visibility attribute to "hidden".
		 */
		hide?(): void; 

		/** 
		 * Marks the widget as "dirty" so that it will be added to a queue for redraw. Redraw of dirty components is handled by a looping timer and will after a very short delay (typically less than 100ms). In most cases it is recommended that developers use markForRedraw() instead of calling Canvas.redraw directly. Since this method queues the redraw, multiple calls to markForRedraw() within a single thread of execution will only lead to a single DOM manipulation which greatly improves application performance.
		 * @param {string} reason - reason for performing the redraw
		 */
		markForRedraw?(reason?:string): void; 

		/** 
		 * Fires when the interior size of the parent changes, including parent resize and scrollbar introduction or removal. This method allows a child to implement a layout policy that can be used within any parent, such as a Resizer component that always snaps to the parent's bottom-right corner. The default implementation of this method applies a child's percent sizes, if any, or implements layout based on the Canvas.snapTo property
		 */
		parentResized?(): void; 

		/** 
		 * Set the CSS border of this component, as a CSS string including border-width, border-style, and/or color (eg "2px solid blue"). This property applies the same border to all four sides of this component. Different per-side borders can be set in a CSS style and applied via Canvas.styleName.
		 * @param {string} newBorder - new border to set to (eg: "2px solid black")
		 */
		setBorder?(newBorder:string): void; 

		/** 
		 * Changes the contents of a widget to newContents, an HTML string. When Canvas.dynamicContents','dynamicContents is set, setContents() can also be called with no arguments to cause contents to be re-evaluated.
		 * @param {string} newContents - an HTML string to be set as the contents of this widget
		 */
		setContents?(newContents?:string): void; 

		/** 
		 * Sets this widget's visibility to "inherit", so that it becomes visible if all of its parents are visible or it has no parents. If the widget has not yet been drawn (and doesn't have a parent or master), this method calls the draw method as well.
		 */
		show?(): void; 

	} // Canvas

	export interface CanvasStatic<T, P> extends BaseWidgetStatic<T, P> {
		/** If enabled, uses a moderately expensive workaround to allow the use of IE filters in CSS to produce gradient effects for buttons, grid rows, and other elements, without the use of image backgrounds. See IEFilters for background.
		 * Flags: IR, Group: IEFilters */
		allowExternalFilters: boolean;

		/** A fixed number of pixels at the top of the page in which components will not be placed. This is overridable per-instance via the Canvas.leavePageSpace attribute. Essentially, the effect is that all top-level components are shifted down this number of pixels, and the page height is treated as this number of pixels <em>less</em> than the real page height. This attribute can be useful on certain mobile devices, when components should not be placed in a top portion of the screen. For example, on iOS devices in certain configurations, this can be set to 20 to avoid placing any component into the status bar area. Or, if using iOS 7.1's 'minimal-ui' viewport parameter, this can be set to 20 to avoid placing any component into the top 20px area of the screen, which if tapped on iPhone in landscape, causes Mobile Safari's address bar and tab bar to be shown. This setting can be changed at runtime by calling Canvas.setDefaultPageSpace. <strong>Note:</strong> As documented by the mobileDevelopment','Mobile Application Development page, when the SmartClient application is running in Mobile Safari on iPhone running iOS 7.1 or later, and neither the isc_useDefaultViewport nor the isc_useMinimalUI global is set to false when the framework is loaded, then the framework will automatically set the defaultPageSpace to 0 in portrait orientation, and to 20 in landscape orientation.
		 * Flags: IRA, Group: positioning */
		defaultPageSpace: number /* int */;

		/** Specifies the width and height of Canvas.loadingImageSrc.
		 * Flags: RWA, Group: animation */
		loadingImageSize: number /* integer */;

		/** Image URL to be displayed while data is being loaded (if enabled for the widget waiting for data). Must be square; Canvas.loadingImageSize specifies the width and height.
		 * Flags: RWA, Group: animation */
		loadingImageSrc: string /* SCImgURL */;

		/** Disables automatic use of filters in IE by default. Filters will only be used if Canvas.useOpacityFilter is explicitly set to true on a component. Does not remove filters on already drawn components, or which are applied via CSS. See IEFilters for background.
		 * Flags: IR, Group: IEFilters */
		neverUseFilters: boolean;

		/** If set, the AlphaImageLoader IE filter will never be used. Does not remove AlphaImageLoader usage in already-drawn components. See IEFilters for background.
		 * Flags: IR, Group: IEFilters */
		neverUsePNGWorkaround: boolean;

		/** Specifies the lower limit for automatically assigned tab indices for focusable canvii.
		 * Flags: R, Group: focus */
		TAB_INDEX_FLOOR: number /* integer */;


	/* Methods */

		/** 
		 * Retrieve a Canvas by it's global Canvas.ID','ID.
		 * @param {string} ID - global ID of the Canvas
		 */
		getById(ID:string /* String */): Canvas; 

	} // CanvasStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a CanvasItem Props argument.
	 * This is derived from the methods in the CanvasItem class and it's parents and their properties marked with the I flag.
	 */
	export interface CanvasItemProps  {
		/** If FormItem.prompt is specified for this item, should the prompt be applied to the CanvasItem.canvas for this item?
		 * Flags: IRW */
		applyPromptToCanvas?: boolean /* Boolean */; // Flags=IRW
		/** Should this item's CanvasItem.canvas','canvas be automatically destroyed when the item is destroyed? Form items are destroyed automatically when a call to DynamicForm.setItems removes them from their parent form, or if their parent form is destroyed. This property governs whether, when this occurs, the item's canvas should also be Canvas.destroy','destroyed. This property has no effect for canvases automatically created via the "autoChild" pattern, using CanvasItem.canvasProperties, CanvasItem.canvasDefaults etc. CanvasItems which create their canvas in this way will always destroy the canvas when the item is destroyed or on an explicit CanvasItem.setCanvas call, regardless of this property's value. Setting this property to true is typically appropriate for cases where a custom CanvasItem automatically creates its canvas as part of its initialization flow, and the canvas will not be re-used outside the item. Note that once a canvas has been destroyed it can not be re-used elsewhere within an application.
		 * Flags: IRWA */
		autoDestroy?: boolean /* Boolean */; // Flags=IRWA
		/** The canvas that will be displayed inside this item. You can pass an instance you've already created, or its global ID as a String. You can also implement CanvasItem.createCanvas to dynamically create the canvas when the FormItem is initialized. If canvas and createCanvas() are unspecified, the canvas for this item will be auto-created using the overrideable defaults: CanvasItem.canvasProperties and CanvasItem.canvasConstructor Note that subclasses of CanvasItem may use a different AutoChild name than just "canvas". For example, SliderItem uses "slider", and in that case, you need to use the specific APIs provided by the subclass. Note that Canvas.canvasItem will be set on the canvas to point back to this item.
		 * Flags: IRW */
		canvas?:  Canvas /* AutoChild Canvas */; // Flags=IRW
		/** If CanvasItem.canvas','this.canvas is not specified as a canvas instance at init time, a canvas will be created instead. This property denotes the class of that widget (Should be set to the name of a subclass of Canvas).
		 * Flags: IRW */
		canvasConstructor?: string /* String */; // Flags=IRW
		/** Default properties for the canvas if this.canvas is not already a canvas instance.
		 * Flags: IRW */
		canvasDefaults?: any /* Object */; // Flags=IRW
		/** Properties to apply to this canvas on creation if this.canvas is not already a canvas instance.
		 * Flags: IRW */
		canvasProperties?: any /* Object */; // Flags=IRW
		/** Flag to disable the criteria editing overrides described in CanvasItem.getCriterion whereby if this item contains a DynamicForm as its canvas, it will be used to edit nested AdvancedCriteria automatically. This flag is required for cases where a canvasItem contains a DynamicForm, but the form is not set up to show inner field values of nested objects, and therefore should not attempt to apply nested advanced criteria directly to the form.
		 * Flags: IRA */
		editCriteriaInInnerForm?: boolean /* Boolean */; // Flags=IRA
		/** Height of the Canvas. Can be either a number indicating a fixed height in pixels, a percentage indicating a percentage of the overall form's height, or "*" indicating take whatever remaining space is available. See the formLayout overview for details. Height may also be explicitly specified on the CanvasItem.canvas. In this any canvasItem.height will be ignored in favor of the value applied to the canvas directly. In either case, percentage values will be resolved using standard formItem sizing rules as described in formLayout
		 * Flags: IRW */
		height?: number | string /* int | String */; // Flags=IRW
		/** Maximum valid height for this CanvasItem in pixels. Used in calculating the row heights of the containing DynamicForm if the item has a flexible CanvasItem.height.
		 * Flags: IRW */
		maxHeight?: number /* Integer */; // Flags=IRW
		/** Minimum valid height for this CanvasItem in pixels. Used in calculating the row heights of the containing DynamicForm if the item has a flexible CanvasItem.height.
		 * Flags: IRW */
		minHeight?: number /* Integer */; // Flags=IRW
		/** Whether this CanvasItem is intended to hold multiple values. 
		 * Flags: IR */
		multiple?: boolean /* Boolean */; // Flags=IR
		/** CanvasItems support specifying overflow for the Canvas directly on the item.
		 * Flags: IR */
		overflow?: Overflow; // Flags=IR
		/** This text is shown as a tooltip prompt when the cursor hovers over this item. When item is FormItem.setCanEdit','read-only a different hover can be shown with FormItem.readOnlyHover.
		 * Flags: IRW, Group: basics */
		prompt?: string /* HTMLString */; // Flags=IRW
		/** Should this item's value be saved in the form's values and hence returned from DynamicForm.getValues? Note that by default, shouldSaveValue is false for CanvasItems, meaning that no value from the CanvasItem will be present in DynamicForm.getValues and no value for the CanvasItem will be saved when DynamicForm.saveData is called. See the CanvasItem class overview for a discussion of values handling in CanvasItems.
		 * Flags: IR */
		shouldSaveValue?: boolean /* Boolean */; // Flags=IR

		/* Method Overrides */

	} // CanvasItemProps


	/**
	 * FormItem which renders a Canvas inline in a DynamicForm instance. CanvasItem is CanvasItem.shouldSaveValue','shouldSaveValue:false by default, meaning that no value from the CanvasItem will be present in DynamicForm.getValues and no value will be saved when DynamicForm.saveData is called. This is appropriate if the Canvas does not participate in editing a value of the form and is embedded in the form for layout or UI purposes only (e.g. ButtonItem, SectionItem). Note that some built-in CanvasItem types override the shouldSaveValue default to true (e.g. MultiComboBoxItem, RichTextItem). If you set FormItem.shouldSaveValue','shouldSaveValue:true, a CanvasItem.showValue','showValue event will be raised to provide a value that your item should display. Handle this event by calling methods on the Canvas you've created to cause the value to be displayed. The CanvasItem.showValue','showValue event will be triggered in various situations where the form receives data, including a call to DynamicForm.setValues, DynamicForm.editRecord, or if DynamicForm.fetchData is called and a Record is returned. Bear in mind that the showValue event can be called when the form and your item have not yet been drawn; in this case, store the value for later display. To provide a value to the form, call CanvasItem.storeValue whenever the user changes the value in your Canvas. Generally, if storeValue() is called then CanvasItem.shouldSaveValue','shouldSaveValue should be overridden to true. Note that the form will not call getValue() in order to discover your item's value, so there is no purpose in overriding this method; instead, call storeValue() to proactively inform the form about changes to the value. This approach is necessary in order to enable change events. If you cannot easily detect changes to values in your Canvas, a workaround is to call storeValue right before the form saves. 
	 */
	export interface CanvasItem  {
		/** If FormItem.prompt is specified for this item, should the prompt be applied to the CanvasItem.canvas for this item?
		 * Flags: IRW */
		applyPromptToCanvas: boolean /* Boolean */;

		/** Should this item's CanvasItem.canvas','canvas be automatically destroyed when the item is destroyed? Form items are destroyed automatically when a call to DynamicForm.setItems removes them from their parent form, or if their parent form is destroyed. This property governs whether, when this occurs, the item's canvas should also be Canvas.destroy','destroyed. This property has no effect for canvases automatically created via the "autoChild" pattern, using CanvasItem.canvasProperties, CanvasItem.canvasDefaults etc. CanvasItems which create their canvas in this way will always destroy the canvas when the item is destroyed or on an explicit CanvasItem.setCanvas call, regardless of this property's value. Setting this property to true is typically appropriate for cases where a custom CanvasItem automatically creates its canvas as part of its initialization flow, and the canvas will not be re-used outside the item. Note that once a canvas has been destroyed it can not be re-used elsewhere within an application.
		 * Flags: IRWA */
		autoDestroy: boolean /* Boolean */;

		/** The canvas that will be displayed inside this item. You can pass an instance you've already created, or its global ID as a String. You can also implement CanvasItem.createCanvas to dynamically create the canvas when the FormItem is initialized. If canvas and createCanvas() are unspecified, the canvas for this item will be auto-created using the overrideable defaults: CanvasItem.canvasProperties and CanvasItem.canvasConstructor Note that subclasses of CanvasItem may use a different AutoChild name than just "canvas". For example, SliderItem uses "slider", and in that case, you need to use the specific APIs provided by the subclass. Note that Canvas.canvasItem will be set on the canvas to point back to this item.
		 * Flags: IRW */
		canvas:  Canvas /* AutoChild Canvas */;

		/** If CanvasItem.canvas','this.canvas is not specified as a canvas instance at init time, a canvas will be created instead. This property denotes the class of that widget (Should be set to the name of a subclass of Canvas).
		 * Flags: IRW */
		canvasConstructor: string /* String */;

		/** Default properties for the canvas if this.canvas is not already a canvas instance.
		 * Flags: IRW */
		canvasDefaults: any /* Object */;

		/** Properties to apply to this canvas on creation if this.canvas is not already a canvas instance.
		 * Flags: IRW */
		canvasProperties: any /* Object */;

		/** Flag to disable the criteria editing overrides described in CanvasItem.getCriterion whereby if this item contains a DynamicForm as its canvas, it will be used to edit nested AdvancedCriteria automatically. This flag is required for cases where a canvasItem contains a DynamicForm, but the form is not set up to show inner field values of nested objects, and therefore should not attempt to apply nested advanced criteria directly to the form.
		 * Flags: IRA */
		editCriteriaInInnerForm: boolean /* Boolean */;

		/** Height of the Canvas. Can be either a number indicating a fixed height in pixels, a percentage indicating a percentage of the overall form's height, or "*" indicating take whatever remaining space is available. See the formLayout overview for details. Height may also be explicitly specified on the CanvasItem.canvas. In this any canvasItem.height will be ignored in favor of the value applied to the canvas directly. In either case, percentage values will be resolved using standard formItem sizing rules as described in formLayout
		 * Flags: IRW */
		height: number | string /* int | String */;

		/** Maximum valid height for this CanvasItem in pixels. Used in calculating the row heights of the containing DynamicForm if the item has a flexible CanvasItem.height.
		 * Flags: IRW */
		maxHeight: number /* Integer */;

		/** Minimum valid height for this CanvasItem in pixels. Used in calculating the row heights of the containing DynamicForm if the item has a flexible CanvasItem.height.
		 * Flags: IRW */
		minHeight: number /* Integer */;

		/** Whether this CanvasItem is intended to hold multiple values. 
		 * Flags: IR */
		multiple: boolean /* Boolean */;

		/** CanvasItems support specifying overflow for the Canvas directly on the item.
		 * Flags: IR */
		overflow: Overflow;

		/** This text is shown as a tooltip prompt when the cursor hovers over this item. When item is FormItem.setCanEdit','read-only a different hover can be shown with FormItem.readOnlyHover.
		 * Flags: IRW, Group: basics */
		prompt: string /* HTMLString */;

		/** Should this item's value be saved in the form's values and hence returned from DynamicForm.getValues? Note that by default, shouldSaveValue is false for CanvasItems, meaning that no value from the CanvasItem will be present in DynamicForm.getValues and no value for the CanvasItem will be saved when DynamicForm.saveData is called. See the CanvasItem class overview for a discussion of values handling in CanvasItems.
		 * Flags: IR */
		shouldSaveValue: boolean /* Boolean */;


		/* Instance Method Overrides */

	} // CanvasItem

	export interface CanvasItemStatic<T, P> extends ClassStatic<T, P> {
	} // CanvasItemStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a CellSelection Props argument.
	 * This is derived from the methods in the CellSelection class and it's parents and their properties marked with the I flag.
	 */
	export interface CellSelectionProps  {

		/* Method Overrides */

		/** 
		 * Returns an array of the currently selected cells. Each cell is returned as a 2 element array in the form [rowNum, colNum].
		 */
		getSelectedCells?(): Array<any> /* array */; 

	} // CellSelectionProps


	/**
	 * Maintains a representation of selection over a 2-dimensional grid of objects. Automatically created to manage cell-selection on CubeGrid widgets. 
	 */
	export interface CellSelection  {

		/* Instance Method Overrides */

		/** 
		 * Returns an array of the currently selected cells. Each cell is returned as a 2 element array in the form [rowNum, colNum].
		 */
		getSelectedCells?(): Array<any> /* array */; 

	} // CellSelection

	export interface CellSelectionStatic<T, P> extends ClassStatic<T, P> {
	} // CellSelectionStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a Class Props argument.
	 * This is derived from the methods in the Class class and it's parents and their properties marked with the I flag.
	 */
	export interface ClassProps  {

		/* Method Overrides */

		/** 
		 * Add properties to this instance.
		 * @param {} list - array of objects with properties to add
		 */
		addPropertyList?(list: any[] /* object[] */): any /* object */; 

		/** 
		 * Return the global identifier for this object.
		 */
		getID?(): string; 

	} // ClassProps


	/**
	 * The Class object is root of the Isomorphic SmartClient inheritance tree -- it includes functionality for creating instances, adding methods and properties, getting prototypes, etc. To add functionality to ALL classes, add them to Class. To create a Class, call ClassFactory.defineClass("MyClass", "MySuperClass") defineClass will return the created class, and make it available as isc.MyClass, and as the global variable MyClass if not in isc','portal mode. You can then: add class-level (static) properties and methods to the class: MyClass.addClassProperties() these methods and properties are accessed through the Class variable itself, eg: MyClass.someStaticMethod() or MyClass.someStaticProperty add default instance properties and methods to the class: MyClass.addProperties() these methods and properties are accessed through a class instance, eg: var myInstance = MyClass.create(); myInstance.someInstanceMethod() create new instances of this class: var myInstance = MyClass.create() NOTE: as a convention, all class names begin with a capital letter and all instances begin with a lower case letter. 
	 */
	export interface Class  {

		/* Instance Method Overrides */

		/** 
		 * Add properties to this instance.
		 * @param {} list - array of objects with properties to add
		 */
		addPropertyList?(list: any[] /* object[] */): any /* object */; 

		/** 
		 * Return the global identifier for this object.
		 */
		getID?(): string; 

	} // Class

	export interface ClassStatic<T, P>  {

	/* Methods */

		/** 
		 * Add static (Class-level) properties and methods to this object These properties can then be accessed as MyClass.property, or for functions, called as MyClass.methodName()
		 * @param {P} Props - objects with properties to add (think named parameters). all the properties of each argument will be applied as class-level properties.
		 */
		addClassProperties(Props?:P): T; 

		/** 
		 * Add default properties to all instances of this class
		 * @param {P} Props - array of objects with properties to add
		 */
		addPropertyList(Props:P): T; 

		/** 
		 * Changes a set of defaults defined as a JavaScript Object. For these kind of properties, simply calling Class.addProperties would replace the original Object with yours, wiping out settings required for the basic functionality of the component. This method instead applies your overrides over the existing properties, without destroying non-overridden properties. For example let's say you have a component that's defined as follows isc.defineClass("MyComponent"); isc.MyComponent.addProperties({ simpleProperty: "some value", propertyBlock : { foo: "bar", zoo: "moo" } } If you wanted to override simpleProperty, you can just call Class.addProperties like this: isc.MyComponent.addProperties({ simpleProperty: "my override" }); If you want to override the value of propertyBlock.moo above, but you don't want to clobber the value of propertyBlock.zoo. If you use the above pattern like so: isc.MyComponent.addProperties({ propertyBlock: { foo: "new value", zoo: "moo" } }); You need to re-specify the value of propertyBlock.zoo which you didn't want to override. Failing to re-specify it would destroy the value. Instead of re-specifying the value, you can use this method to modify the value of foo - like this: isc.MyComponent.changeDefaults("propertyBlock", { foo: "new value" }); See also the AutoChild system for information about standard sets of defaults that are available for customization.
		 * @param {string} defaultsName - name of the property to change
		 * @param {any} newDefaults - overrides for defaults
		 */
		changeDefaults(defaultsName:string /* String */, newDefaults:any /* Object */): void; 

		/** 
		 * Create an instance of this class. All arguments passed to this method are passed on to the Class.init instance method. Unless Class.addPropertiesOnCreate is set to false, all arguments passed to this method must be Objects and all properties on those objects will be copied to the newly created instance before Class.init is called. If there are overlapping properties in the passed arguments, the last wins. Any return value from Class.init is thrown away. Note: Generally, you would not override this method. If you want to specify a constructor for your class, provide an override for Class.init for generic classes or Canvas.initWidget for any subclasses of UI components (i.e. descendants of Canvas).
		 * @param {P} Props - Any arguments passed will be passed along to the init() routine of the instance. Unless Class.addPropertiesOnCreate is set to false, any arguments passed to this method must be of type Object.
		 */
		create(Props?:P): T; 

	} // ClassStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a DataSource Props argument.
	 * This is derived from the methods in the DataSource class and it's parents and their properties marked with the I flag.
	 */
	export interface DataSourceProps extends ClassProps {
		/** Whether to make this DataSource available as a global variable for convenience.
		 * Flags: IRA, Group: identity */
		addGlobalId?: boolean; // Flags=IRA
		/** By default, all DataSources are assumed to be capable of handling AdvancedCriteria on fetch or filter type operations. This property may be set to false to indicate that this dataSource does not support advancedCriteria. See DataSource.supportsAdvancedCriteria for further information on this. NOTE: If you specify this property in a DataSource descriptor (.ds.xml file), it is enforced on the server. This means that if you run a request containing AdvancedCriteria against a DataSource that advertises itself as allowAdvancedCriteria:false, it will be rejected.
		 * Flags: IRWA */
		allowAdvancedCriteria?: boolean; // Flags=IRWA
		/** If a DSRequest arrives from the client that requests serverSummaries','server-calculated summaries, should it be allowed? Note this setting only affects dsRequests that come from the browser (or another client). This setting has no effect on server summaries declared in .ds.xml files or summaries configured in DSRequests created programmatically on the server side, which are always allowed. Default value of null means this DataSource will use the system-wide default, which is set via datasources.allowClientRequestedSummaries in server_properties','server.properties, and defaults to allowing client-requested summaries. If client-requested summarization is allowed, but the server-side &lt;operationBinding&gt; provides specific summarization settings, the client-requested summarization is ignored.
		 * Flags: IR, Group: serverSummaries */
		allowClientRequestedSummaries?: boolean; // Flags=IR
		/** Enables saving of a log of changes to this DataSource in a second DataSource with the same fields, called the "audit DataSource". NOTE: this feature applies to Enterprise Edition only; for more information on edition-specific features, see <a href='http://smartclient.com/product' target='_blank'>http://smartclient.com/product</a>. When auditing is enabled, every time a DSRequest modifies this DataSource, a Record is added to the audit DataSource that shows the record as it existed after the change was made (or for a "remove", the values of the record at the time of deletion). In addition, the audit DataSource has the following additional metadata fields: DataSource.auditTypeFieldName','"audit_operationType": type of the change ("update", "add" or "remove") DataSource.auditUserFieldName','"audit_modifier": username of the user that made the change. The username is determined in the same way that the OperationBinding.requiresRole','Declarative Security subsystem determines the current user. DataSource.auditTimeStampFieldName','"audit_changeTime": a field of type "datetime" recording the timestamp of the change DataSource.auditRevisionFieldName','"audit_revision": a field of type "sequence" recording a simple increasing integer value If any of the field names above collide with field names of the DataSource being audited, an integer suffix will also be added, starting with 2 (for example, "audit_modifier2", then "audit_modifier3", etc). To omit a data field from the automatically generated audit DataSource, just set DataSourceField.audit to false. Note: audit DataSource feature works only with single row operations, i.e. operations with OperationBinding.allowMultiUpdate','allowMultiUpdate enabled are not supported. Note, audit can be disabled for a given DSRequest via server-side API DSRequest.setSkipAudit() or for specific opreation via OperationBinding.skipAudit','operationBinding.skipAudit setting. <h4>Auto-generated Audit DataSources</h4> The audit DataSource is normally automatically generated, and unless otherwise specified with DataSource.auditDataSourceID, the ID of the audit DataSource will be audit_[OriginalDSID]. By default, the automatically generated audit DataSource will be of the same type as the DataSource being audited, however, if the DataSource being audited is not already a SQLDataSource, we recommend using DataSource.auditDSConstructor','auditDSConstructor:"sql" to use a SQLDataSource as the audit DataSource. This is because a SQLDataSource used an audit DataSource will automatically generate a SQL table for storing audit data the first time changes are made. JPA would require manual creation of a Java Bean, and Hibernate requires <a href='http://www.google.com/search?q=hbm2ddl.auto' target='_blank'>hbm2ddl.auto=update</a> to be set, which is widely considered unsafe for production use. Automatically created audit DataSources can be loaded and queried just like other DataSources, using the DataSourceLoader, and using the server-side API DataSource.getAuditDataSource(). However, you must load the DataSource being audited before loading its automatically created audit DataSource. Note, that automatic SQL tables creation can be disabled. See DataSource.autoCreateAuditTable','autoCreateAuditTable for details. <h4>Manually created Audit DataSources</h4> The audit DataSource can also be manually created. In this case, you can can either follow the naming conventions described above for the ID of the audit DataSource and the names of metadata fields, or use the linked properties to assign custom names. If you omit any data fields from the tracked DataSource in your audit DataSource, those fields will be ignored for auditing purposes, exactly as though DataSourceField.audit had been set to false for an automatically-generated audit DataSource. Also, note that in case of manually defined audit DataSource, if this DataSource is defined so it inherits the audited DataSource, all the audited DataSource's fields will be inherited, this including the primary keys. Since for the audit DataSource the primary key should be the revision field, in order to prevent the audit DataSource having two primary keys, the inherited DataSource's primary key will have to be declared in audit DataSource, but with the primaryKey attribute omitted (as well not being of type "sequence") in the audit DataSource.
		 * Flags: IR, Group: serverDataIntegration */
		audit?: boolean; // Flags=IR
		/** For DataSources with DataSource.audit','auditing enabled, optionally specifies the ID of the audit DataSource. If this property is not specified, the ID of the audit DataSource will be audit_[OriginalDSID] 
		 * Flags: IR */
		auditDataSourceID?: string; // Flags=IR
		/** For DataSources with DataSource.audit','auditing enabled, optionally specifies the DataSource.serverConstructor for the automatically generated audit DataSource. The default is to use the same serverConstructor as the DataSource where audit="true" was declared. This property is primarily intended to allow the use of SQLDataSource (DataSource.serverType','serverType:"sql") as an audit DataSource for a DataSource that might be of another type. For example, you might have a DataSource that implements all CRUD operations via Java logic in dmiOverview','DMI declaration methods, and so doesn't provide generic storage; by using SQLDataSource as the type of your audit DataSource, you don't need to implement your own scheme for storing and querying audit data, and the necessary audit tables will be automatically generated in the database. Similarly, even if you do use a reusable DataSource type such as the built-in JPADataSource, using SQLDataSource for audit DataSources means there's no need to write a JPA bean just to achieve storage of an audit trail. To simplify this intended usage, the string "sql" is allowed for auditDSConstructor as a means of specifying that the built-in SQLDataSource class should be used. For any other type, use the fully qualified Java classname, as is normal for serverConstructor.
		 * Flags: IR */
		auditDSConstructor?: string /* String */; // Flags=IR
		/** For DataSources with DataSource.audit','auditing enabled, specifies the field name used to store the revision number for the change (in a field of type "sequence"). If empty string is specified as the field name, the audit DataSource will not store this field.
		 * Flags: IR */
		auditRevisionFieldName?: string; // Flags=IR
		/** For DataSources with DataSource.audit','auditing enabled, specifies the field name used to store the timestamp when the operation was performed (in a field of type "datetime"). If empty string is specified as the field name, the audit DataSource will not store this field.
		 * Flags: IR */
		auditTimeStampFieldName?: string; // Flags=IR
		/** For DataSources with DataSource.audit','auditing enabled, specifies the field name used to store the DSOperationType','operationType (in a field of type "text"). If empty string is specified as the field name, the audit DataSource will not store this field.
		 * Flags: IR */
		auditTypeFieldName?: string; // Flags=IR
		/** For DataSources with DataSource.audit','auditing enabled, specifies the field name used to store the user who performed the operation. If empty string is specified as the field name, the audit DataSource will not store this field.
		 * Flags: IR */
		auditUserFieldName?: string; // Flags=IR
		/** When a DataSource is not DataSource.cacheAllData:true and a fetch results in the entire dataset being retrieved, this attribute being set to true causes the DataSource to automatically switch to cacheAllData:true and prevent further server-trips for fetch requests. DataSource.cacheAllData','cacheAllData is automatically enabled in either of these conditions: The request has no criteria and no startRow/endRow request properties. The latter can be accomplished by disabling paging with a DataBoundComponent.dataFetchMode','dataFetchMode setting of "basic" or "local" or by an explicit fetchData request with those request properties excluded. The request has no criteria but has startRow/endRow specified and the response received has all data available (startRow:0 and endRow:totalRows). 
		 * Flags: IR, Group: clientData */
		autoCacheAllData?: boolean /* Boolean */; // Flags=IR
		/** Whether to convert relative date values to concrete date values before sending to the server. Default value is true, which means that the server does not need to understand how to filter using relative dates - it receives all date values as absolute dates.
		 * Flags: IR */
		autoConvertRelativeDates?: boolean /* Boolean */; // Flags=IR
		/** Setting autoCreateAuditTable to true indicates that audit DataSource will automatically create SQL table when DataSource.audit','auditing is enabled. Note, that autoCreateAuditTable attribute takes effect only if framework setting audit.autoCreateTables in server.properties is set to false, which by default is set to true.
		 * Flags: IR */
		autoCreateAuditTable?: boolean; // Flags=IR
		/** This property allows you to specify that your DataSource's schema (field definitions) should be automatically derived from some kind of metadata. This causes SmartClient to create a special super-DataSource, which is used purely as a source of default schema for this DataSource; this is arranged by causing the autoDerived DataSource to automatically DataSource.inheritsFrom','inherit from the special super-DataSource. This allows you to auto-derive schema from existing metadata, whilst still being able to override any or all of it as required. This property has a different implementation depending upon the DataSource.serverType','serverType of the DataSource: For a DataSource with serverType: "sql", automatically derive the dataSource's schema from the Spring bean or Java class specified in DataSource.schemaBean','schemaBean. If schemaBean is not specified, derive the schema from the columns in the SQL table specified in DataSource.tableName','tableName. More information on SQL DataSources is sqlDataSource','here For a DataSource with serverType: "hibernate", automatically derive the dataSource's schema from the Spring bean, Hibernate mapping or Java class named in the DataSource.schemaBean','schemaBean property. If no such thing exists, derive the schema from the Hibernate mapping or Java class specified in the DataSource.beanClassName','beanClassName property (this allows you to specify schema and mapping separately, in the unusual circumstance that you have a need to do so). Note that the "mappings" referred to here can mean either .hbm.xml files or annotated classes; both are supported. If neither of these is successful, derive the schema from the underlying SQL table specified in DataSource.tableName','tableName. More information on Hibernate DataSources is hibernateIntegration','here For a DataSource with serverType: "jpa1" or "jpa", automatically derive the dataSource's schema from the annotated JPA class named in the DataSource.schemaBean','schemaBean property. If the schemaBean property is not defined, derive the schema from the annotated JPA class named in the DataSource.beanClassName','beanClassName property (as with Hibernate, this allows you to specify schema and mapping separately if you need to do so). JPA DataSource generation relies on annotations (the orm.xml mapping file is not supported). More information on JPA DataSources is jpaIntegration','here For other DataSource types, attempt to find a Spring bean with the name specified in the DataSource.schemaBean','schemaBean property. If no such bean is found (or Spring is not present), attempt to instantiate an object whose fully-qualified class name is the value in the schemaBean property. If one of these approaches succeeds, we derive the schema from the discovered object (by treating it as a Java Bean and assuming that each one of its getters corresponds to a like-named field in the DataSource). More information on custom DataSource implementations is writeCustomDataSource','here. <h4>Field types</h4> The following table shows how SQL types are derived into FieldType','DataSource types when we use an SQL table as a source of metadata for a SQL or Hibernate DataSource: <table border="1" class="normal"> <tr><th>SQL type</th><th>DataSourceField.type','DataSource type</th></tr> <tr><td>CHAR, VARCHAR, LONGVARCHAR, TEXT, CLOB</td><td>text</td></tr> <tr><td>BIT, TINYINT, SMALLINT, INTEGER, BIGINT, DECIMAL<sup>*</sup>, NUMBER<sup>**</sup></td><td>integer</td></tr> <tr><td>REAL, FLOAT, DOUBLE, DECIMAL<sup>*</sup>, NUMBER<sup>**</sup></td><td>float</td></tr> <tr><td>DATE</td><td>date</td></tr> <tr><td>TIME</td><td>time</td></tr> <tr><td>TIMESTAMP</td><td>datetime</td></tr> <tr><td>BLOB, BINARY, VARBINARY, LONGVARBINARY</td><td>binary</td></tr> </table> <sup>*</sup>For DECIMAL types, we inspect the "DECIMAL_DIGITS" attribute of the JDBC metadata and designate the field type "integer" if that attribute is 0, or "float" if it is some other value. <sup>**</sup>NUMBER is an Oracle-only type that appears in the JDBC metadata as DECIMAL and is handled exactly the same way as DECIMAL The following table shows how Java types are derived into DataSource types when we use an unannotated Java class (Spring bean, Hibernate mapping or POJO) as a source of metadata for a SQL, Hibernate or custom DataSource: <table border="1" class="normal"> <tr><th>Java type</th><th>DataSourceField.type','DataSource type</th></tr> <tr><td>boolean, Boolean</td><td>boolean</td></tr> <tr><td>char, Character, String, Reader</td><td>text</td></tr> <tr><td>byte, short, int, long, Byte, Short, Integer, Long, BigInteger</td><td>integer</td></tr> <tr><td>float, double, Float, Double, BigDecimal</td><td>float</td></tr> <tr><td>Enum</td><td>enum (see discussion below)</td></tr> <tr><td>InputStream</td><td>binary</td></tr> <tr><td>java.sql.Date, java.util.Date, java.util.Calendar</td><td>date</td></tr> <tr><td>java.sql.Time</td><td>time</td></tr> <tr><td>java.sql.Timestamp</td><td>datetime</td></tr> </table> Finally, this table shows how Java types are derived into DataSource types when we use an annotated class as a source of metadata. Note annotated classes are necessary for JPA DataSources, but you can choose to use them for other types of DataSource as well. For Hibernate DataSources, this is very worthwhile because Hibernate will also make use of the annotations as config, meaning you don't need to specify .hbm.xml files. For SQL and custom DataSources, there is no benefit at the persistence level, but it may still be worthwhile because the use of an annotated class gives us better metadata and allows us to generate a better, closer-fitting autoDerive DataSource than we can from examination of SQL schema or plain Java Beans: <table border="1" class="normal"> <tr><th>Java type</th><th>DataSourceField.type','DataSource type</th></tr> <tr><td>boolean, Boolean</td><td>boolean</td></tr> <tr><td>char, Character, String, Reader</td><td>text</td></tr> <tr><td>byte, short, int, long, Byte, Short, Integer, Long, BigInteger</td><td>integer</td></tr> <tr><td>float, double, Float, Double, BigDecimal</td><td>float</td></tr> <tr><td>InputStream</td><td>binary</td></tr> <tr><td>java.util.Date (with Temporal set to DATE), java.sql.Date</td><td>date</td></tr> <tr><td>java.util.Date (with Temporal set to TIME), java.sql.Time</td><td>time</td></tr> <tr><td>java.util.Date (with Temporal set to TIMESTAMP), java.util.Calendar, java.sql.Timestamp</td><td>datetime</td></tr> <tr><td>Enum (with Enumerated set to STRING)</td><td>enum (see discussion below)</td></tr> <tr><td>Enum (with Enumerated set to ORDINAL)</td><td>intEnum (see discussion below)</td></tr> <tr><td>Field with Lob annotation</td><td>binary</td></tr> <tr><td>Field with GeneratedValue annotation</td><td>sequence, if the field is an integer type (see discussion below)</td></tr> </table> <h4>Primary keys, sequences and identity columns</h4> We attempt to derive information about primary keys from the metadata we have. If the metadata source is an SQL table: If the table does not have a native primary key constraint, no attempt is made to identify primary key fields. Otherwise: The column or columns that make up the table's native primary key constraint are identified using the JDBC DatabaseMetaData.getPrimaryKeys() API Each DataSource field that corresponds to one of these native primary key columns is marked primaryKey: true For each of these columns, the metadata returned by DatabaseMetaData.getColumns() is inspected. If the metadata includes IS_AUTOINCREMENT=YES, we mark the corresponding field as type="sequence". This information should be reliably provided by databases that implement "auto-increment" or "identity" column types, such as MySQL or Microsoft SQL Server If the previous step does not identify a column as a sequence, we inspect the ResultSetMetaData obtained by running a dummy query on the table. If the isAutoIncrement() API returns true for that column, we mark the corresponding field as type="sequence" If the previous steps have not identified the column as a sequence, we check the TYPE_NAME in the column metadata. If it is "serial", this means the column is a PostgreSQL "serial" or "serial8" type column. Postgres does not transparently implement auto-increment columns, but it does provide this serial type, which causes the column to be implicitly bound to an underlying sequence. So this type causes us to mark the field type="sequence", and we also set DataSourceField.implicitSequence','implicitSequence true If the previous steps have not identified the column as a sequence, we check the COLUMN_DEF in the column metadata. If this contains the token "$$ISEQ" and ends with "NEXTVAL", this means the column is an Oracle "GENERATED AS IDENTITY" column. This type of column was introduced in Oracle 12c and is conceptually exactly the same thing as the Postgres "serial" column described above. We treat it the same way: mark it type="sequence" and implicitSequence="true" If the previous steps have not identified the column as a sequence, then you may be using a pure sequence database, such as an Oracle version earlier than 12c, or you may be using a database where both sequences and identity columns are available (Oracle, Postgres, DB2), and a sequence is being used either by design or because the table was created before the database product supported identity columns. In this case, we cannot determine if the column should be a sequence or not. However, in many applications, the fact that the column is an integer and is a primary key would imply that it is also a sequence. Therefore, if the column is an integer and the server.properties flag auto.derive.integer.pk.always.sequence is true, we mark the field as type="sequence" If, after all this, SmartClient ends up incorrectly marking a primary key field as a sequence (or vice versa), you can always override it on a per-field basis by simply redeclaring the field with the correct type in your .ds.xml file: &lt;DataSource serverType="sql" tableName="myTable" autoDeriveSchema="true"&gt; &lt;fields&gt; &lt;!-- This field was incorrectly marked as a sequence --&gt; &lt;field name="notASeq" type="integer" /&gt; &lt;!-- This field was incorrectly marked as an integer when it should be a sequence --&gt; &lt;field name="isASeq" type="sequence" /&gt; &lt;/fields&gt; &lt;/DataSource&gt; If the metadata source is Hibernate mappings described in a .hbm.xml file: The first field we encounter that is described in the mapping with an &lt;id&gt; tag is marked as a primaryKey If that field is marked as being generated, we set its type to "sequence" If the metadata source is an annotated object (whether JPA, Hibernate or just an annotated POJO): Any field with an @Id annotation is is marked as a primaryKey (this differs from the Hibernate .hbm.xml file case because that is specific to Hibernate, which does support composite keys, but not by specifying multiple &lt;id&gt; tags. Annotations are supported, via annotated POJOs, for any kind of persistence strategy, so multiple @Id fields are perfectly valid) Any field with a @GeneratedValue annotation is either marked as type="sequence" (if it is an integer type) or as DataSourceField.autoGenerated','autoGenerated="true" (for other field types) Finally, if the metadata is a plain, unannotated Java object, no attempt is made to derive primary key fields. <h4>enums and valueMaps</h4> When we come across Java Enum properties in plain or annotated classes, as well as setting the field type as noted in the above tables, we also generate a valueMap for the field, based on the Enum members. For cases where we generate a field of SmartClient type "enum" (see the above tables), the keys of the valueMap are the result of calling name() on each member of the underlying Java Enum (in other words, its value exactly as declared in its enum declaration). For cases where we generate a field of SmartClient type "intEnum", the keys of the valueMap are strings representing the ordinal number of each member in the Java Enum - "0", "1", etc. Note that this behavior will be overriden by DataSource.enumTranslateStrategy','DataSource.enumTranslateStrategy if both are set. In both of these case, the display values generated for the valueMap are the result of calling toString() on each Enum member. If that gives the same value as calling name(), the value is passed through DataTools.deriveTitleFromName(), which applies the same processing rules as DataSource.getAutoTitle to derive a more user-friendly display value. <h4>Further notes</h4> schemaBean implies autoDeriveSchema, because it has no other purpose than to name the bean to use for auto-derived schema. Thus, if you specify schemaBean you do not need to specify autoDeriveSchema as well (though it does no harm to do so). However, tableName and beanClassName can be validly specified without implying autoDeriveSchema, so in those cases you must explicitly specify autoDeriveSchema. The underlying super-DataSource is cached in server memory, so that it does not have to be derived and created each time you need it. However, the cache manager will automatically refresh the cached copy if it detects that the deriving DataSource has changed. Thus, if you change the metadata your DataSource is deriving (if, for example, you add a column to a table), all you need to do is touch the .ds.xml file (ie, update its last changed timestamp - you don't actually have to change it) and the cached copy will be refreshed next time it is needed. When autoDeriveSchema is set, SQLDataSource will automatically discover foreignKeys and deliver table and column name information to the client in hashed form so that two DataSources that are linked by native SQL foreign keys will automatically discover each other if loaded into the same application, and set DataSourceField.foreignKey','foreignKey automatically. Because the table and column names are delivered as cryptohashes, there is no information leakage, but regardless, the feature can be disabled via setting datasource.autoLinkFKs to false in server_properties','server.properties. This hashed linkage information is delivered to the client in properties DataSource.tableCode and DataSourceField.fkTableCode/DataSourceField.fkColumnCode','fkColumnCode
		 * Flags: IR, Group: fields */
		autoDeriveSchema?: boolean; // Flags=IR
		/** If set, titles are automatically derived from DataSourceField.name','field.name for any field that does not have a DataSourceField.title','field.title and is not marked DataSourceField.hidden','hidden:true, by calling the method DataSource.getAutoTitle.
		 * Flags: IR */
		autoDeriveTitles?: boolean; // Flags=IR
		/** Causes Tree.discoverTree to be called on dsResponse.data in order to automatically discover tree structures in the response data. If autoDiscoverTree is set, discoverTree() is called after the default dsResponse.data has been derived (OperationBinding.recordXPath','recordXPath and DataSourceField.valueXPath','valueXPath have been applied) and after DataSource.transformResponse has been called. If a DataSourceField is declared with DataSourceField.childrenProperty','childrenProperty:true, discoverTree() will be invoked with DiscoverTreeSettings.newChildrenProperty','settings.newChildrenProperty set to the name of the field marked as the childrenField. Similarly, if the DataSource has a DataSource.titleField it will be used as the DiscoverTreeSettings.nameProperty','settings.nameProperty.
		 * Flags: IR */
		autoDiscoverTree?: boolean; // Flags=IR
		/** If true, causes all operations on this DataSource to automatically start or join a transaction associated with the current HttpServletRequest. This means that multiple operations sent to the server in a RPCManager.startQueue','request queue will be committed in a single transaction. Note that this includes fetch operations - setting this property to true has the same effect as a transaction policy of ALL for just this DataSource's operations - see the server-side RPCManager.setTransactionPolicy() for details of the different TransactionPolicy settings. If this property is explicitly false, this causes all operations on this DataSource to be committed individually - the same as a transaction policy of NONE, just for this DataSource's operations. In either case, you can override the setting for individual operations - see OperationBinding.autoJoinTransactions. If this property if null or not defined, we fall back to the default setting for this type of DataSource. These are defined in server_properties','server.properties as follows: Hibernate: hibernate.autoJoinTransactions JPA/JPA2: jpa.autoJoinTransactions SQL: There is one setting per configured database connection (DataSource.dbName','dbName). For example, the setting for the default MySQL connection is sql.Mysql.autoJoinTransactions If the setting is not defined at the DataSource-type level, we use the system global default, which is defined in server.properties as autoJoinTransactions. At the dbName and global system levels, you can set the autoJoinTransactions attribute to a valid Transaction Policy, rather than a simple true or false (although these values work too - true is the same as ALL, false is the same as NONE). For valid TransactionPolicy values and their meanings, see the server-side Javadoc for RPCManager.setTransactionPolicy() Note that the configuration settings discussed here can be overridden for a particular queue of requests by setting the server-side RPCManager's transaction policy. Look in the server-side Javadoc for RPCManager.getTransactionPolicy(). Transactions can also be initiated manually, separate from the RPCManager/HttpServletRequest lifecycle, useful for both multi-threaded web applications, and standalone applications that don't use a servlet container - see standaloneDataSourceUsage. NOTE: Setting this property to true does not cause a transactional persistence mechanism to automatically appear - you have to ensure that your DataSource supports transactions. The SmartClient built-in SQL, Hibernate and JPA DataSources support transactions, but note that they do so at the provider level. This means that you can combine updates to, say, an Oracle database and a MySQL database in the same queue, but they will be committed in <em>two</em> transactions - one per database. The SmartClient server will commit or rollback these two transactions as if they were one, so a failure in some Oracle update would cause all the updates to both databases to be rolled back. However, this is not a true atomic transaction; it is possible for one transaction to be committed whilst the other is not - in the case of hardware failure, for example. NOTE: Not all the supported SQL databases are supported for transactions. Databases supported in this release are: DB2 HSQLDB Firebird Informix Microsoft SQL Server MySQL (you must use InnoDB tables; the default MyISAM storage engine does not support transactions) Oracle PostgreSQL 
		 * Flags: IR */
		autoJoinTransactions?: boolean; // Flags=IR
		/** This property has different meanings depending on the DataSource.serverType','serverType: For SQL DataSources (DataSources with serverType "sql") If set, results from the database will be used to create one instance of the indicated Java bean per database row. Otherwise a Map is used to represent each row retrieved from SQL. With this feature active, a DSResponse from this DataSource will contain a Collection of instances of the indicated beanClassName, available via DSResponse.getData(). This creates a couple of possibilities: <dl> <dt>Add business logic for derived properties, such as computed formulas</dt> <dd>For example, declare a DataSourceField named "revenueProjection". By default this field will call getRevenueProjection() on your bean to retrieve the value to send to the client. Your implementation of getRevenueProjection() could apply some kind of formula to other values loaded from the database.</dd> <dt>Call business logic on retrieved beans via DMI</dt> <dd>By adding a dmiOverview','DMI method that calls DSRequest.execute() to retrieve a DSResponse, you have an opportunity to call business logic methods on the beans representing each row affected by the DSRequest. For example, notify a related BPEL process of changes to certain fields.</dd> </dl> By using beanClassName on a specific OperationBinding, you can: Use a bean to represent your data only when it matters; for example, avoid the overhead of using a bean for "fetch" operations, but do use a bean for "update" operations so that you can execute relevant business logic after the update completes. Skip the use of beans for complex reporting queries that produce results unrelated to your persistent object model. Set beanClassName to blank ("") on a specific operationBinding to override DataSource.beanClassName for that specific operation. For SQL joins that produce additional data fields, use a special, operation-specific bean that represents a join of multiple entities and contains business logic specific to that joined dataset Note that beanClassName affects what numeric field types will be used for inbound DSRequest data. For fields with numeric types, the DSRequest.data','record data in DSRequests will automatically be converted to the type of the target field, before the request is received in a DMI. For details, see dsRequestBeanTypes. Note that dmiOverview','DMI also has a built-in facility for populating a bean with the inbound DSRequest.data - just declare the bean as a method argument. For generic DataSources (DataSources with serverType "generic") visualBuilder','Visual Builder sets this property when it creates a generic DataSource using the Javabean Wizard. It has no built-in server-side effects. For Hibernate DataSources (DataSources with serverType "hibernate") The name of the Java bean or POJO class that is mapped in Hibernate. This will typically be the fully-qualified class name - eg com.foo.MyClass - but it may be the simple class name - just MyClass - or it may be some other value. It all depends on how your classes have been mapped in Hibernate. The declared Java bean will affect how its properties will be mapped to built-in numeric types, see hibernateIntegration','Hibernate Integration overview for details. Note: If you are intending to use Hibernate as a data-access layer only, you do not need to create Hibernate mappings or Java objects: SmartClient will generate everything it needs on the fly. For JPA DataSources (DataSources with serverType "jpa" or "jpa1") The fully qualified class name of the JPA annotated entity. NOTE for Hibernate and JPA users: When you use JPA, or use Hibernate as a full ORM system (ie, not just allowing SmartClient Server to drive Hibernate as a data access layer), the beans returned on the server-side are live. This means that if you make any changes to them, the ORM system will persist those changes. This is true even if the beans were created as part of a fetch operation. This causes a problem in the common case where you want to use a DMI or custom DataSource implementation to apply some post-processing to the beans fetched from the persistent store. If you change the values in the beans directly, those changes will be persisted. If you want to alter the data returned from a JPA or Hibernate persistent store as part of a fetch request just so you can alter what gets sent to the client, you can use the server-side DSResponse's getRecords() method. This will return your bean data in "record" format - ie, as a List of Maps. You can alter these records without affecting your persistent store, and then call setData() on the DSResponse), passing the altered list of records. See the server-side Javadocs for DSResponse for details of these two methods.
		 * Flags: IR */
		beanClassName?: string /* String */; // Flags=IR
		/** When DataSource.cacheAllData','cacheAllData mode is enabled and a DataSource.cacheAllOperationId has been set, this flag affects whether cached results are used for all "fetch" requests regardless of their DSRequest.operationId, or are used only for "fetch" requests that use the cacheAllOperationId, allowing other requests to go to server normally. Default of true means that the cacheAllOperationId will be used to fetch all rows, but the resulting cache will be used for all "fetch" operations regardless of the operationId specified on the request. Switching to "false" effectively creates caching just for one specific operationId - the cacheAllOperationId - while allowing all other requests to go to the server normally.
		 * Flags: IR, Group: clientData */
		cacheAcrossOperationIds?: boolean /* Boolean */; // Flags=IR
		/** Set this property to true to have a DataSource fetch all of its data client-side on the first fetch request. However, unlike a DataSource.clientOnly','clientOnly DataSource, this DataSource will still save changes normally, sending remote requests. You can manually set this attribute after initialization by calling DataSource.setCacheAllData; setting DataSource.autoCacheAllData:true causes a DataSource to automatically switch to cacheAllData:true when a fetch results in the entire dataset being brought client-side. To cause automatic cache updates, you can set DataSource.cacheMaxAge to a number of seconds and once data has been client-side for that length of time, the next fetch causes the cache to be dropped and a new cache retrieved. Note that multiple DataSource.operationBindings of type "fetch" which return distinct results will not work with cacheAllData: only one cache is created and is used for all fetch operations, regardless of whether DSRequest.operationId has been set. However, "fetch" operationBindings used as a OperationBinding.cacheSyncOperation will work normally, so long as they return all data fields that are returned by the default "fetch" operation, so that the cache can be updated. To specify which operationId to use for fetching all data, use DataSource.cacheAllOperationId','cacheAllOperationId. To use the cache only for requests that have the cacheAllOperationId, allowing any other operationId (or absence of an operationId) to contact the server as normal, set DataSource.cacheAcrossOperationIds','cacheAcrossOperationIds.
		 * Flags: IRW, Group: clientData */
		cacheAllData?: boolean /* Boolean */; // Flags=IRW
		/** DSRequest.operationId to use for fetching data in case DataSource.cacheAllData','cacheAllData is true. By default a standard fetch operation is used (with no operationId specified).
		 * Flags: IR, Group: clientData */
		cacheAllOperationId?: string /* String */; // Flags=IR
		/** For a DataSource.cacheAllData or client-only DataSource, a set of records to use as a dataset, specified as an Array of JavaScript Objects representing records.
		 * Flags: IRW, Group: clientData */
		cacheData?: Array<any> /* Array of Record */; // Flags=IRW
		/** The maximum time, in seconds, to maintain the client-side cache. If a fetch occurs after the cacheMaxAge has expired, the current cache will be dropped and another complete cache fetched.
		 * Flags: IRW, Group: clientData */
		cacheMaxAge?: number /* Number */; // Flags=IRW
		/** Applies only to dataFormat: "json" and DataSource.dataTransport:"scriptInclude". Specifies the name of the query parameter that tells your JSON service what function to call as part of the response.
		 * Flags: IR, Group: clientDataIntegration */
		callbackParam?: string /* String */; // Flags=IR
		/** When true, indicates that this DataSource supports multi-level sorting.
		 * Flags: IR */
		canMultiSort?: boolean; // Flags=IR
		/** fieldName for a field in the dataSource expected to contain an explicit array of child nodes. Enables loading a databound tree as a hierarchical data structure, rather than a flat list of nodes linked by foreignKey. Note this is an alternative to setting DataSourceField.childrenProperty directly on the childrenField object. By default the children field will be assumed to be DataSourceField.multiple','multiple, for XML databinding. This implies that child data should be delivered in the format: &lt;childrenFieldName&gt; &lt;item name="firstChild" ...&gt; &lt;item name="secondChild" ...&gt; &lt;/childrenFieldName&gt; However data may also be delivered as a direct list of childrenFieldName elements: &lt;childrenFieldName name="firstChild" ...&gt; &lt;childrenFieldName name="secondChild" ...&gt; If you want to return your data in this format, you will need to explicitly set multiple to false in the appropriate dataSource field definition.
		 * Flags: IR, Group: dataSourceRelations */
		childrenField?: string; // Flags=IR
		/** A clientOnly DataSource simulates the behavior of a remote data store by manipulating a static dataset in memory as DSRequest','DSRequests are executed on it. Any changes are lost when the user reloads the page or navigates away. A clientOnly DataSource will return responses asynchronously, just as a DataSource accessing remote data does. This allows a clientOnly DataSource to be used as a temporary placeholder while a real DataSource is being implemented - if a clientOnly DataSource is replaced by a DataSource that accesses a remote data store, UI code for components that used the clientOnly DataSource will not need be changed. A clientOnly DataSource can also be used as a shared cache of modifiable data across multiple UI components when immediate saving is not desirable. In this case, several components may interact with a clientOnly DataSource and get the benefit of ResultSet behaviors such as automatic cache sync and in-browser data filtering and sorting. When it's finally time to save, DataSource.cacheData can be inspected for changes and data can be saved to the original DataSource via DataSource.addData, DataSource.updateData and DataSource.removeData, possibly in a RPCManager.startQueue','transactional queue. Note that DataSource.getClientOnlyDataSource lets you easily obtain a clientOnly DataSource representing a subset of the data available from a normal DataSource. See also DataSource.cacheAllData - a cacheAllData behaves like a write-through cache, performing fetch and filter operations locally while still performing remote save operations immediately. ClientOnly DataSources can be populated programmatically via DataSource.cacheData - see clientOnlyDataSources','this discussion for other ways to populate a client-only DataSource with data.
		 * Flags: IR, Group: clientOnlyDataSources */
		clientOnly?: boolean /* Boolean */; // Flags=IR
		/** For DataSources of DataSource.serverType','serverType "hibernate", the name of a Spring bean to query to obtain Hibernate Configuration for this particular DataSource. Note that this is intended for DataSource-specific configuration overrides for unusual circumstances, such as a DataSource whose physical data store is a completely different database to that used by other DataSources. See the hibernateIntegration','Integration with Hibernate article for more information
		 * Flags: IRA, Group: serverDataIntegration */
		configBean?: string /* String */; // Flags=IRA
		/** Indicates that declarative security rules are waived for rows that were created by the current user. Practically, this means that when a security check fails, instead of a security exception being thrown, we alter the criteria to ensure that the request can only return or affect rows that were created by the current authenticated user. This allows you to create security regimes whereby users can see and edit data they created, but have access to other users' data forbidden or limited. In order for this to work, we require two things: The DataSource must specify a field of type "creator" - this field type is described on FieldType','this page The authentication regime in use must include the idea of a "current user". The authentication provided by the Servlet API is an example of such a regime. This setting can be overridden at operationBinding and field level, allowing extremely fine-grained control.
		 * Flags: IR, Group: fieldLevelAuth */
		creatorOverrides?: boolean; // Flags=IR
		/** Decides under what conditions the ResultSet cache should be dropped when the ResultSet.criteria changes.
		 * Flags: IRWA */
		criteriaPolicy?: CriteriaPolicy; // Flags=IRWA
		/** Name of the field that has the most pertinent numeric, date, or enum value, for use when a DataBoundComponent needs to show a short summary of a record. For example, for a DataSource of employees, good choices might be the "salary" field, "hire date" or "status" (active, vacation, on leave, etc). Unlike DataSource.titleField, dataField is not automatically determined in the absence of an explicit setting.
		 * Flags: IR, Group: dsSpecialFields */
		dataField?: string /* String */; // Flags=IR
		/** Indicates the format to be used for HTTP requests and responses when fulfilling DSRequests (eg, when DataSource.fetchData is called).
		 * Flags: IR, Group: clientDataIntegration */
		dataFormat?: DSDataFormat; // Flags=IR
		/** Controls the format in which inputs are sent to the dataURL when fulfilling DSRequests. May be overridden for individual request types using OperationBinding.dataProtocol','operation bindings.
		 * Flags: IR, Group: clientDataIntegration */
		dataProtocol?: DSProtocol; // Flags=IR
		/** Transport to use for all operations on this DataSource. Defaults to RPCManager.defaultTransport. This would typically only be set to enable "scriptInclude" transport for contacting DataSource.dataFormat','JSON web services hosted on servers other than the origin server. When using the "scriptInclude" transport, be sure to set DataSource.callbackParam or OperationBinding.callbackParam to match the name of the query parameter name expected by your JSON service provider.
		 * Flags: IR, Group: clientDataIntegration */
		dataTransport?: RPCTransport; // Flags=IR
		/** Default URL to contact to fulfill all DSRequests. Can also be set on a per-operationType basis via OperationBinding.dataURL. NOTE: Best practice is to use the same dataURL for all DataSources which fulfill DSRequests via the server-side RPCManager API. Otherwise, cross-DataSource RPCManager.startQueue','operation queuing will not be possible.
		 * Flags: IR, Group: clientDataIntegration */
		dataURL?: string /* URL */; // Flags=IR
		/** For DataSources using the sqlDataSource','SmartClient SQL engine for persistence, which database configuration to use. Database configurations can be created using the adminConsole','Admin Console. If unset, the default database configuration is used (which is also settable using the "Databases" tab).
		 * Flags: IR, Group: serverDataIntegration */
		dbName?: string /* String */; // Flags=IR
		/** Before we start editing values in DataBoundComponents bound to this dataSource, should we perform a deep clone of the underlying values (a "deep clone" is one created by traversing the original values object recursively, cloning the contents of nested objects and arrays). If this flag is explicitly set to false, we perform a shallow clone of the underlying values before edit (a "shallow clone" is a copy created by simply copying the top-level attributes of an object). If this flag is not explicitly set, it defaults to the value of the same-named static property, DataSource.deepCloneOnEdit. This flag can also be overridden per-component and per-field - see DataBoundComponent.deepCloneOnEdit and DataSourceField.deepCloneOnEdit. Note, this flag only has an effect if you are editing a values object that contains nested objects or arrays, using Canvas.dataPath','dataPaths. When editing "flat" data - the mainstream case - there is no difference between a deep clone and a shallow clone.
		 * Flags: IRWA */
		deepCloneOnEdit?: boolean /* Boolean */; // Flags=IRWA
		/** For DataSource.serverType','serverType:"sql" DataSources, sets the default DataSourceField.sqlStorageStrategy','sqlStorageStrategy to use for boolean fields where no sqlStorageStrategy has been declared on the field. Can also be set system-wide via the server_properties setting sql.defaultBooleanStorageStrategy, or for a particular database configuration by setting sql.dbName.defaultBooleanStorageStrategy (see adminConsole','Admin Console overview for more information on SQL configuration). Note that when this property is unset, the default DataSourceField.sqlStorageStrategy strategy is effectively "string".
		 * Flags: IR, Group: serverDataIntegration */
		defaultBooleanStorageStrategy?: string /* String */; // Flags=IR
		/** Controls when primary keys are required for "update" and "remove" server operations, when allowMultiUpdate has not been explicitly configured on either the OperationBinding.allowMultiUpdate','operationBinding.allowMultiUpdate or via the server-side API DSRequest.setAllowMultiUpdate(). Default value of null means this DataSource will use the system-wide default, which is set via datasources.defaultMultiUpdatePolicy in server_properties','server.properties, and defaults to allowing multi updates for requests associated with an RPCManager, see MultiUpdatePolicy for details.
		 * Flags: IR */
		defaultMultiUpdatePolicy?: MultiUpdatePolicy; // Flags=IR
		/** The default textMatchStyle to use for DSRequests that do not explicitly state a DSRequest.textMatchStyle','textMatchStyle. Note, however, that DSRequests issued by ListGrids and other DataBoundComponent','components will generally have a setting for textMatchStyle on the component itself (see ListGrid.autoFetchTextMatchStyle, for example).
		 * Flags: IR, Group: clientDataIntegration */
		defaultTextMatchStyle?: TextMatchStyle; // Flags=IR
		/** Name of the field that has a long description of the record, or has the primary text data value for a record that represents an email message, SMS, log or similar. For example, for a DataSource representing employees, a field containing the employee's "bio" might be a good choice, or for an email message, the message body. If descriptionField is unset, it defaults to any field named "description" or "desc" in the record, or the first long text field (greater than 255 characters) in the record, or null if no such field exists.
		 * Flags: IR, Group: dsSpecialFields */
		descriptionField?: string /* String */; // Flags=IR
		/** Settings to use when discoverTree() is automatcially called because DataSource.autoDiscoverTree is set to true for this DataSource
		 * Flags: IR */
		discoverTreeSettings?: any /* DiscoverTreeSettings */; // Flags=IR
		/** Indicates that for server responses, for any data being interpreted as DataSource records, only data that corresponds to declared fields should be retained; any extra fields should be discarded. For DataSource.dataFormat','JSON data, this means extra properties in selected objects are dropped. By default, for DMI DSResponses, DSResponse.data is filtered on the server to just the set of fields defined on the DataSource. This type of filtering can also be enabled for non-DMI DSResponses (see the overview in dmiOverview','DMI). Setting this property to false disables this filtering for this DataSource only. This setting overrides the configuration in server_properties','server.properties. This setting can be overridden by ServerObject.dropExtraFields.
		 * Flags: IR, Group: clientDataIntegration */
		dropExtraFields?: boolean; // Flags=IR
		/** If the criteria applied to a fetch type operation contain fields that are not present in the dataSource, should they be ignored when performing filtering on the client. This property is useful for cases where you custom server logic makes use of criteria values to determine what set of records to return to the client, but the data does not actually have record values for these fields and as such the client-side filtering logic should ignore them.
		 * Flags: IR */
		dropUnknownCriteria?: boolean /* Boolean */; // Flags=IR
		/** If we are DataSource.progressiveLoading','loading progressively, indicates the number of extra records SmartClient Server will advertise as being available, if it detects that there are more records to view (see DataSource.lookAhead','lookAhead). This property has no effect if we are not progressive-loading.
		 * Flags: IRW, Group: progressiveLoading */
		endGap?: number /* int */; // Flags=IRW
		/** The name of the property this DataSource uses for constant name when translating Java enumerated types to and from Javascript, if the EnumTranslateStrategy is set to "bean". Defaults to "_constant" if not set. This property is only applicable if you are using the SmartClient server
		 * Flags: IA */
		enumConstantProperty?: string /* String */; // Flags=IA
		/** The name of the property this DataSource uses for ordinal number when translating Java enumerated types to and from Javascript, if the EnumTranslateStrategy is set to "bean". Defaults to "_ordinal" if not set. This property is only applicable if you are using the SmartClient server
		 * Flags: IA */
		enumOrdinalProperty?: string /* String */; // Flags=IA
		/** Sets the strategy this DataSource uses to translate Java enumerated types (objects of type enum) to and from Javascript. This property is only applicable if you are using the SmartClient server
		 * Flags: IA */
		enumTranslateStrategy?: EnumTranslateStrategy; // Flags=IA
		/** The list of fields that compose records from this DataSource. Each DataSource field can have type, user-visible title, validators, and other metadata attached. After a DataSource has been Class.create','created, access the list of fields via DataSource.getFieldNames and access individual fields via DataSource.getField. 
		 * Flags: IR, Group: fields */
		fields?: Array<DataSourceField> /* Array of DataSourceField */; // Flags=IR
		/** The native field name used by this DataSource on the server to represent the fileContents for fileSource','FileSource Operations. If the fileContentsField is not configured, then a field named "fileContents" or "contents" will be used, if it exists. <!-- If not found, the first field with a "binary" type will be used. TODO: Binary field support not working yet. --> If not found, the longest text field which is not the DataSource.fileNameField','fileNameField, DataSource.fileTypeField','fileTypeField or DataSource.fileFormatField','fileFormatField will be used. Note that the only method which will actually return the fileContents is DataSource.getFile','getFile() -- the other fileSource','FileSource methods omit the fileContents for the sake of efficiency.
		 * Flags: IR, Group: fileSource */
		fileContentsField?: string /* String */; // Flags=IR
		/** The native field name used by this DataSource on the server to represent the fileFormat for fileSource','FileSource Operations. If the fileFormatField is not configured, then a field named "fileFormat" will be used, if it exists. Otherwise, the DataSource will not track fileFormats -- this may be acceptable if, for instance, the fileFormat is always the same. The fileFormat is specified according to the extension that would have been used in the filesystem -- for instance, the fileFormat for employees.ds.xml would be "xml".
		 * Flags: IR, Group: fileSource */
		fileFormatField?: string /* String */; // Flags=IR
		/** The native field name used by this DataSource on the server to represent fileLastModified for fileSource','FileSource Operations. If the fileLastModifiedField is not configured, then a field named "fileLastModified" will be used, if it exists. <!-- TODO: Binary fields? --> Otherwise, the server will look for a field with a "modifierTimestamp" type. If that is not found, the DataSource will not keep track of the last modified date.
		 * Flags: IR, Group: fileSource */
		fileLastModifiedField?: string /* String */; // Flags=IR
		/** The native field name used by this DataSource on the server to represent the fileName for fileSource','FileSource Operations operations. Any extensions to the fileName to indicate type or format (e.g. ".ds.xml") are stored in the DataSource.fileTypeField','fileTypeField and DataSource.fileFormatField','fileFormatField, if specified for this DataSource. If not specified for a DataSource, the fileNameField will be inferred on the server as follows: <!-- f the DataSource.fileContentsField is binary, then we use the filename field which corresponds to the binary field, if it exists. TODO: Not implemented yet. --> If there is a field named "fileName", "name", or "title", then that field is used. Otherwise, if there is a single primary key, and it has the type "text", then that field is used. Otherwise, an error is logged 
		 * Flags: IR, Group: fileSource */
		fileNameField?: string /* String */; // Flags=IR
		/** The native field name used by this DataSource on the server to represent the fileType for fileSource','FileSource Operations. If the fileTypeField is not configured, then a field named "fileType" will be used, if it exists. Otherwise, the DataSource will not track fileTypes -- this may be acceptable if, for instance, you use a separate DataSource for each fileType. The fileType is specified according to the extension that would have been used in the filesystem -- for instance, the fileType for employees.ds.xml would be "ds".
		 * Flags: IR, Group: fileSource */
		fileTypeField?: string /* String */; // Flags=IR
		/** The native field name used by this DataSource on the server to represent fileVersion for fileSource','FileSource Operations. Automatic file versioning is configured by the presence of this property: if you want automatic versioning for a FileSource DataSource, it is sufficient to simply define a fileVersionField. When automatic versioning is on: Calls to DataSource.saveFile will save a new version of the file, retaining previous versions up to the maximum configured by DataSource.maxFileVersions; when that maximum is reached, the oldest version is overwritten The DataSource.getFile API always returns the most recent version The DataSource.listFiles API only includes the most recent version of any file You can view and retrieve earlier versions of a file with the DataSource.listFileVersions and DataSource.getFileVersion APIs. Note that retrieving a previous version of a file and then calling saveFile() goes through the normal process of saving a new version The fileVersion field is expected to be of type "datetime", and automatic versioning will not work otherwise. Note, to minimize the possibility of version timestamp collisions, we recommend that fileVersion fields specify DataSourceField.storeMilliseconds','storeMilliseconds: true. If the fileVersionField is not configured, no automatic file versioning will be done.
		 * Flags: IR, Group: fileSource */
		fileVersionField?: string /* String */; // Flags=IR
		/** Namespaces definitions to add to the root element of outbound XML messages sent to a web service, as a mapping from namespace prefix to namespace URI. The default value is: globalNamespaces : { xsi: "http://www.w3.org/2001/XMLSchema-instance", xsd: "http://www.w3.org/2001/XMLSchema" }, This default value allows the use of the xsi:type and xsi:nil attributes without further declarations. Note that some web services will only accept specific revisions of the XML Schema URI. If xsi-namespaced attributes seem to be ignored by an older webservice, try the URI "http://www.w3.org/1999/XMLSchema-instance" instead.
		 * Flags: IRW */
		globalNamespaces?: any /* Object */; // Flags=IRW
		/** Value to use for the DataSource.ownerIdField','ownerIdField if no one has authenticated. This setting can be overridden at the operationBinding level.
		 * Flags: IR */
		guestUserId?: string; // Flags=IR
		/** Designates a field of FieldType','type:"image" as the field to use when rendering a record as an image, for example, in a TileGrid. For example, for a DataSource of employees, a "photo" field of type "image" should be designated as the iconField. If not explicitly set, iconField looks for fields named "picture", "thumbnail", "icon", "image" and "img", in that order, and will use any of these fields as the iconField if it exists and has type "image". To avoid any field being used as the iconField, set iconField to null.
		 * Flags: IR, Group: dsSpecialFields */
		iconField?: string; // Flags=IR
		/** Unique identifier for this DataSource. Required for all DataSources. DataSources will make themselves available as JavaScript globals under the same name as their ID only if DataSource.addGlobalId is set.
		 * Flags: IR, Group: identity */
		ID?: string; // Flags=IR
		/** For JPA and Hibernate DataSources this property indicates, that data source has composite primary key and specifies fully-qualified Java class: with @EmbeddedId you have to specify class name of declared id with @IdClass you have to specify class specified in annotation declaration
		 * Flags: IR, Group: fields */
		idClassName?: string; // Flags=IR
		/** For fields on this dataSource that specify DataSourceField.ignoreTextMatchStyle','ignoreTextMatchStyle true, the prevailing textMatchStyle is ignored and SmartClient matches exact values. This property dictates whether that match is case-sensitive like the "exactCase" textMatchStyle, or case-insensitive like the "exact" textMatchStyle (the default). Please see the TextMatchStyle','TextMatchStyle documentation for a discussion of the nuances of case-sensitive matching.
		 * Flags: IR */
		ignoreTextMatchStyleCaseSensitive?: boolean /* Boolean */; // Flags=IR
		/** Criteria that are implicitly applied to all fetches made through this DataSource. These criteria are never shown to or edited by the user and are cumulative with any other criteria provided on the DSRequest. For example, a DataSource might *always* implicitly limit its fetch results to records owned by the current user's department. Components and ResultSets requesting data from the DataSource can then apply further implicitCriteria of their own, separately from their regular, user-editable criteria. For instance, a grid bound to this dataSource might be further limited to implicitly show only the subset of records created by the current user. See DataBoundComponent.implicitCriteria and ResultSet.implicitCriteria for more on these localized options.
		 * Flags: IRW */
		implicitCriteria?: Criteria; // Flags=IRW
		/** Name of the field that has the second most pertinent piece of textual information in the record, for use when a DataBoundComponent needs to show a short summary of a record. For example, for a DataSource of employees, a "job title" field would probably be the second most pertinent text field aside from the employee's "full name". Unlike DataSource.titleField, infoField is not automatically determined in the absence of an explicit setting.
		 * Flags: IR, Group: dsSpecialFields */
		infoField?: string /* String */; // Flags=IR
		/** For dataSources of DataSource.serverType','serverType "sql" and "hibrenate", specifies the inheritance mode to use. This property has no effect for any other type of DataSource.
		 * Flags: IR, Group: fields */
		inheritanceMode?: DSInheritanceMode; // Flags=IR
		/** ID of another DataSource this DataSource inherits its DataSource.fields from. Local fields (fields defined in this DataSource) are added to inherited fields to form the full set of fields. Fields with the same name are merged in the same way that DataBoundComponent.fields','databound component fields are merged with DataSource fields. The default order of the combined fields is new local fields first (including any fields present in the parent DataSource which the local DataSource re-declares), then parent fields. You can set DataSource.useParentFieldOrder to instead use the parent's field order, with new local fields appearing last. You can set DataSource.showLocalFieldsOnly to have all non-local fields hidden. Note that only fields are inherited - other properties such as dataURL and dataFormat are not. You can use ordinary inheritance, that is, creating a subclass of DataSource, in order to share properties such as dataURL across a series of DataSources that also inherit fields from each other via inheritsFrom. This feature can be used for: creating a customized view (eg, only certain fields shown) which will be used by multiple DataBoundComponent','databound components. adding presentation-specific attributes to metadata that has been automatically derived from XMLTools.loadXMLSchema','XML Schema or other metadata formats modeling object subclassing and extension in server-side code and storage systems modeling relational database joins, and the equivalents in other systems creating hooks for others to customize your application in a maintainable way. For example, if you have a dataSource "employee", you can create a dataSource "customizedEmployee" which inherits from "employee" but does not initially define any fields, and bind all DataBoundComponent','databound components to "customizedEmployee". Customizations of fields (including appearance changes, field order, new fields, hiding of fields, and custom validation rules) can be added to "customizedEmployee", so that they are kept separately from the original field data and have the best possible chance of working with future versions of the "employee" dataSource. 
		 * Flags: IR, Group: fields */
		inheritsFrom?: string /* DataSource ID */; // Flags=IR
		/** Allows you to specify an arbitrary prefix string to apply to all json format responses sent from the server to this application. The inclusion of such a prefix ensures your code is not directly executable outside of your application, as a preventative measure against <a href='http://www.google.com/search?q=javascript+hijacking' target='_blank'>javascript hijacking</a>. Only applies to responses formatted as json objects. Does not apply to responses returned via scriptInclude type transport. Note: If the prefix / suffix served by your backend is not a constant, you can use OperationBinding.dataFormat','dataFormat:"custom" instead and explicitly parse the prefix out as part of DataSource.transformResponse','transformResponse().
		 * Flags: IRA */
		jsonPrefix?: string /* String */; // Flags=IRA
		/** Allows you to specify an arbitrary suffix string to apply to all json format responses sent from the server to this application. The inclusion of such a suffix ensures your code is not directly executable outside of your application, as a preventative measure against <a href='http://www.google.com/search?q=javascript+hijacking' target='_blank'>javascript hijacking</a>. Only applies to responses formatted as json objects. Does not apply to responses returned via scriptInclude type transport.
		 * Flags: IRA */
		jsonSuffix?: string /* String */; // Flags=IRA
		/** If we are DataSource.progressiveLoading','loading progressively, indicates the number of extra records SmartClient Server will read beyond the end record requested by the client, in order to establish if there are more records to view. This property has no effect if we are not progressive-loading. This property can be tweaked in conjunction with DataSource.endGap','endGap to change behavior at the end of a dataset. For example, with the default values of lookAhead: 1 and endGap: 20, we can end up with the viewport shrinking if we get a case where there really was only one more record (because the client was initially told there were 20 more). This is not a problem per se, but it may be surprising to the user. You could prevent this happening (at the cost of larger reads) by setting lookAhead to be endGap+1.
		 * Flags: IRW, Group: progressiveLoading */
		lookAhead?: number /* int */; // Flags=IRW
		/** If DataSource.fileVersionField','automatic file versioning is enabled for a FileSource DataSource, this property configures the maximum number of versions to retain.
		 * Flags: IR, Group: fileSource */
		maxFileVersions?: number /* Integer */; // Flags=IR
		/** When true, indicates that fields in this DataSource will never be positively updated to the null value; they may arrive at null values by being omitted, but we will not send actual null values in update requests. When false (the default), null is not treated in any special way. Setting this value causes null-assigned fields to be replaced with the field's DataSourceField.nullReplacementValue','nullReplacementValue, if one is declared. If no nullReplacementValue is declared for the field, the null assignment is replaced with the DataSource's DataSource.nullStringValue','nullStringValue, DataSource.nullIntegerValue','nullIntegerValue, DataSource.nullFloatValue','nullFloatValue or DataSource.nullDateValue','nullDateValue, depending on the field type. For "add" operations, setting DataSource.omitNullDefaultsOnAdd','omitNullDefaultsOnAdd causes null-valued fields to be removed from the request entirely, rather than replaced with default values as described above.
		 * Flags: IR */
		noNullUpdates?: boolean; // Flags=IR
		/** If DataSource.noNullUpdates is set, the value to use for any boolean field that has a null value assigned on an update operation, and does not specify an explicit DataSourceField.nullReplacementValue','nullReplacementValue.
		 * Flags: IR */
		nullBooleanValue?: boolean; // Flags=IR
		/** If DataSource.noNullUpdates is set, the value to use for any date or time field that has a null value assigned on an update operation, and does not specify an explicit DataSourceField.nullReplacementValue','nullReplacementValue. Unlike strings and numbers, there is no "natural" choice for a null replacement value for dates. The default value we have chosen is midnight on January 1st 1970, simply because this is "the epoch" - the value that is returned by calling "new Date(0)"
		 * Flags: IR */
		nullDateValue?: Date; // Flags=IR
		/** If DataSource.noNullUpdates is set, the value to use for any float field that has a null value assigned on an update operation, and does not specify an explicit DataSourceField.nullReplacementValue','nullReplacementValue.
		 * Flags: IR */
		nullFloatValue?: number /* float */; // Flags=IR
		/** If DataSource.noNullUpdates is set, the value to use for any integer field that has a null value assigned on an update operation, and does not specify an explicit DataSourceField.nullReplacementValue','nullReplacementValue.
		 * Flags: IR */
		nullIntegerValue?: number /* int */; // Flags=IR
		/** If DataSource.noNullUpdates is set, the value to use for any text field that has a null value assigned on an update operation, and does not specify an explicit DataSourceField.nullReplacementValue','nullReplacementValue.
		 * Flags: IR */
		nullStringValue?: string /* String */; // Flags=IR
		/** When true, and DataSource.noNullUpdates','noNullUpdates is also true, indicates that "add" requests on this DataSource will have null-valued fields removed from the request entirely before it is sent to the server, as opposed to the default behavior of replacing such null values with defaults.
		 * Flags: IR */
		omitNullDefaultsOnAdd?: boolean; // Flags=IR
		/** Optional array of OperationBindings, which provide instructions to the DataSource about how each DSOperation is to be performed. When using the SmartClient Server, OperationBindings are specified in your DataSource descriptor (.ds.xml file) and control server-side behavior such as what Java object to route DSRequest to (OperationBinding.serverObject) or customizations to SQL, JQL and HQL queries (OperationBinding.customSQL, OperationBinding.customJQL and OperationBinding.customHQL). See the javaDataIntegration', 'Java Integration samples. For DataSources bound to WSDL-described web services using DataSource.serviceNamespace, OperationBindings are used to bind each DataSource OperationBinding.operationType','operationType to an OperationBinding.wsOperation','operation of a WSDL-described WebService','web service, so that a DataSource can both fetch and save data to a web service. For example, this code accomplishes part of the binding to the <a href='http://www.google.com/search?q=sforce+partner+wsdl' target='_blank'>SalesForce partner web services</a> isc.DataSource.create({ serviceNamespace : "urn:partner.soap.sforce.com", operationBindings : [ { operationType:"fetch", wsOperation:"query", recordName: "sObject" }, { operationType:"update", wsOperation:"update", recordName: "SaveResult" }, { operationType:"add", wsOperation:"create", recordName: "SaveResult" }, { operationType:"remove", wsOperation:"delete", recordName: "DeleteResult" } ], ... }); NOTE: additional code is required to handle authentication and other details, see the complete code in smartclientSDK/examples/databinding/SalesForce. For DataSources that contact non-WSDL-described XML or JSON services, OperationBindings can be used to separately configure the URL, HTTP method, input and output processing for each operationType. This makes it possible to fetch JSON data from one URL for the "fetch" operationType and save to a web service for the "update" operationType, while appearing as a single integrated DataSource to a DataBoundComponent such as an ListGrid.canEdit','editable ListGrid. If no operationBinding is defined for a given DataSource operation, all of the properties which are valid on the operationBinding are checked for on the DataSource itself. This also means that for a read-only DataSource, that is, a DataSource only capable of fetch operations, operationBindings need not be specified, and instead all operationBinding properties can be set on the DataSource itself. An example of using OperationBinding properties directly on the DataSource in order to read an RSS feed can be found here: ${isc.DocUtils.linkForStandaloneExample('/examples/databinding/rss_databinding.html', '/examples/databinding/rss_databinding.html')}
		 * Flags: IR */
		operationBindings?: Array<OperationBinding> /* Array of OperationBinding */; // Flags=IR
		/** Requires that the currently authenticated user match the contents of this field, for client-initiated requests (i.e., where DSRequest.isClientRequest() returns true on the server). When a new row is added by a client-initiated DSRequest, the ownerIdField will be automatically populated with the currently authenticated user (clobbering any value supplied by the client). Client-initiated attempts to update the ownerIdField will also be prevented. If you wish to set the ownerIdField to a different value via an "add" or "update" operation, you can do so in server-side DMI code (possibly consulting DSRequest.getClientSuppliedValues() to get the value that was clobbered). For client-initiated "fetch", "update" or "remove" operations, the server will modify client-supplied criteria so that only rows whose ownerIdField matches the currently authenticated user can be read, updated or deleted. The ownerIdField setting can be overridden at the OperationBinding.ownerIdField level. If ownerIdField is specified, DataSource.requiresAuthentication','requiresAuthentication will default to true. If requiresAuthentication is explicitly set to false, then unauthenticated users will be able to see all records. To avoid this, you can use DataSource.guestUserId','guestUserId to specify a default user to apply when no one has authenticated.
		 * Flags: IR */
		ownerIdField?: string; // Flags=IR
		/** When using the patternOperators','pattern operators OperatorId','search operator, character that escapes the DataSource.patternSingleWildcard or DataSource.patternMultiWildcard if placed before it, so that it is treated as a literal character.
		 * Flags: IR */
		patternEscapeChar?: string /* String */; // Flags=IR
		/** When using the patternOperators','pattern operators OperatorId','search operator, character that matches a series of one or more characters. Pass multiple strings to provide multiple alternative wildcards.
		 * Flags: IR */
		patternMultiWildcard?: Array<string> /* String | Array of String */; // Flags=IR
		/** When using the patternOperators','pattern operators OperatorId','search operator, character that matches any single character. Pass multiple strings to provide multiple alternative wildcards.
		 * Flags: IR */
		patternSingleWildcard?: Array<string> /* String | Array of String */; // Flags=IR
		/** User-visible plural name for this DataSource. For example, for the supplyItem DataSource, "Supply Items". Defaults to dataSource.title + "s".
		 * Flags: IR, Group: titles */
		pluralTitle?: string; // Flags=IR
		/** If set, the DataSource will ensure that it never uses a cached HTTP response, even if the server marks the response as cacheable. Note that this does not disable caching at higher levels in the framework, for example, the caching performed by ResultSet.
		 * Flags: IR */
		preventHTTPCaching?: boolean /* Boolean */; // Flags=IR
		/** If true, causes SmartClient Server to use the "progressive loading" pattern for fetches on this dataSource, as described in the Paging and total dataset length section of the ResultSet','ResultSet documentation. Essentially, this means that we avoid issuing a row count query and instead advertise total rows as being slightly more than the number of rows we have already read (see DataSource.endGap','endGap). This allows users to load more of a dataset by scrolling past the end of the currently-loaded rows, but it prevents them from scrolling directly to the end of the dataset. Generally, progressive loading is appropriate when you have to deal with very large datasets. Note that by default, a dataSource will switch into progressive loading mode automatically when it detects that it is dealing with a dataset beyond a certain size - see DataSource.progressiveLoadingThreshold. This setting can be overridden for individual fetch operations with the OperationBinding.progressiveLoading property, and also at the level of the individual DSRequest.progressiveLoading','DSRequest. You can also specify progressiveLoading on DataBoundComponent.progressiveLoading','DataBoundComponents and certain types of FormItem - SelectItem.progressiveLoading','SelectItem and ComboBoxItem.progressiveLoading','ComboBoxItem. Currently, this property only applies to users of the built-in SQLDataSource, but you could use it in custom DataSource implementations to trigger the server behavior described in the ResultSet documentation linked to above.
		 * Flags: IRW, Group: progressiveLoading */
		progressiveLoading?: boolean; // Flags=IRW
		/** Indicates the dataset size that will cause SmartClient Server to automatically switch into DataSource.progressiveLoading','progressive loading mode for this DataSource. To prevent automatic switching to progressive loading, set this property to -1.
		 * Flags: IRW, Group: progressiveLoading */
		progressiveLoadingThreshold?: number /* int */; // Flags=IRW
		/** For DataSources with type DSServerType','projectFile, looks up the locations to use as DataSource.projectFileLocations','projectFileLocations from the project's configuration (i.e. project.properties, server_properties','server.properties etc.). For instance, to look up the value of project.datasources and use it for projectFileLocations, use "datasources" as the projectFileKey. If you specify both projectFileKey and projectFileLocations, then both with be used, with the projectFileLocations applied last.
		 * Flags: IR, Group: fileSource */
		projectFileKey?: string /* String */; // Flags=IR
		/** For DataSources with type DSServerType','projectFile, specifies locations for the project files. In XML, each location is expressed with a &lt;location&gt; tag, e.g.: &lt;projectFileLocations&gt; &lt;location&gt;[WEBROOT]/shared/ds&lt;/location&gt; &lt;location&gt;ds://datasources&lt;/location&gt; &lt;/projectFileLocations&gt; Directories should be specified as absolute paths on the server. If you want to construct a webroot-relative path, then prefix the path with [WEBROOT] (unlike in server_properties','server.properties, where you would use $webRoot as the prefix). To specify another DataSource to be used via fileSource','fileSource operations, use ds://dsName (where "dsName" is the name of the other DataSource). A projectFile DataSource uses the standard fileSource','fileSource field names: fileName, fileType, fileFormat, fileContents, fileSize and fileLastModified. When defining a projectFile DataSource, you can use DataSource.inheritsFrom','inheritsFrom with a value of "ProjectFile" to inherit definitions for these fields -- e.g.: &lt;DataSource ID="MyDataSources" type="projectFile" inheritsFrom="ProjectFile"&gt; &lt;projectFileLocations&gt; &lt;location&gt;[WEBROOT]/shared/ds&lt;/location&gt; &lt;location&gt;ds://datasources&lt;/location&gt; &lt;/projectFileLocations&gt; &lt;/DataSource&gt; For directory locations, the fileName is relative to the directory specified. Note that the fileName does not include any extension for type or format. For instance, for "employees.ds.xml", the fileName would be "employees", the fileType would be "ds" and the fileFormat would be "xml". A projectFile DataSource executes the various fileSource','fileSource operations in the following manner. The general rule is that fileName, fileType, and fileFormat are treated as primary keys. If files with the same combination of those attributes exist in more than one of the configured locations, the locations are considered in reverse order, with priority given to the location listed last. When modifying an existing file, the last location which contains the file will be used. When creating a new file, the file will be created in the last configured location. <dl> <dt>DataSource.listFiles','listFiles <dd>Returns a combined list of files from all configured locations. Note that listFiles does not recurse into subdirectories. If the same combination of fileName / fileType / fileFormat exists in more than one configured location, then the data for fileSize and fileLastModified will be taken from the last configured location which contains the file. <dt>DataSource.hasFile','hasFile <dd>Indicates whether the file exists in any of the configured locations. <dt>DataSource.getFile','getFile <dd>Returns file data by searching the locations in reverse order. <dt>DataSource.saveFile','saveFile <dd>If the file exists, it will be saved in the last location in which it exists. If it is a new file, it will be saved in the last configured location. <dt>DataSource.renameFile','renameFile <dd>The file will be renamed in the last location in which it exists. Note that if the file exists in more than one location, the rename will not affect other locations. Thus, a subsequent listFiles operation will return the file from the other location (as well as the renamed file). <dt>DataSource.removeFile','removeFile <dd>The file will be removed from the last location in which it exists. Note that if the file exists in more than one location, the removal will not affect other locations. Thus, a subsequent listFiles operation will return the file from the other location. </dl> For convenience, a projectFile DataSource also responds to the standard DataSource operations, in the following manner: <dl> <dt>add <dd>Executes a saveFile operation, either adding the file or updating an existing file. <dt>fetch <dd>Executes a listFiles operation. Note that the results will not include the fileContents. In order to obtain the fileContents, you must use a DataSource.getFile','getFile operation. <dt>update <dd>Executes a renameFile operation. Note that this will not update the fileContents -- for that, you need to use "add", or a DataSource.saveFile','saveFile operation. <dt>remove <dd>Executes a removeFile operation. </dl> If you specify both DataSource.projectFileKey','projectFileKey and projectFileLocations, then both with be used, with the projectFileLocations applied last.
		 * Flags: IR, Group: fileSource */
		projectFileLocations?: Array<string> /* Array of String */; // Flags=IR
		/** For dataSources of DataSource.serverType','serverType "sql", determines whether we qualify column names with table names in any SQL we generate. This property can be overridden on specific operationBindings.
		 * Flags: IR */
		qualifyColumnNames?: boolean /* Boolean */; // Flags=IR
		/** If set, tells the SQL engine to quote column names in all generated DML and DDL statements for this dataSource. This will ensure that queries generated against tables that do not follow the database product's natural column-naming conventions will still work. In general we recommend that you allow the database to use its natural naming scheme when creating tables (put more simply, just do not quote column names in the CREATE TABLE statement); if you do this, you will not need to worry about quoting column names when querying. However, if you are dealing with pre-existing tables, or do not have control over the database naming conventions used, this property may become necessary. This property may also be necessary if you are using field/column names that clash with reserved words in the underlying database (these vary by database, but a field called "date" or "timestamp" would have problems with most database products) Note: Only applicable to dataSources of DataSource.serverType','serverType "sql".
		 * Flags: IR */
		quoteColumnNames?: boolean; // Flags=IR
		/** For SQL DataSources, tells the framework whether to surround the associated DataSource.tableName','table name with quotation marks whenever it appears in generated queries. This is only required if you have to connect to a table with a name that is in breach of your database product's naming conventions. For example, some products (eg, Oracle) internally convert all unquoted references to upper case, so if you create a table called myTest, the database actually calls it MYTEST unless you quoted the name in the create command, like this: &nbsp;&nbsp;CREATE TABLE "myTest" If you <em>do</em> quote the name like this, or if you have to connect to a legacy table that has been named in this way, then you must set this property to tell the SQL engine that it must quote any references to this table name (this requirement depends on the database in use - as noted below, some are not affected by this problem). If you do not, you will see exceptions along the lines of "Table or view 'myTest' does not exist". Note, other database products (eg, Postgres) convert unquoted names to lower case, which leads to the same issues. Still others (eg, SQL Server) are not case sensitive and are not affected by this issue. Generally, we recommend that you avoid using this property unless you have a specific reason to do so. It is preferable to avoid the issue altogether by simply not quoting table names at creation time, if you are able to do so.
		 * Flags: IRA, Group: serverDataIntegration */
		quoteTableName?: boolean /* Boolean */; // Flags=IRA
		/** Provides a default value for OperationBinding.recordName.
		 * Flags: IR, Group: clientDataIntegration */
		recordName?: string /* String */; // Flags=IR
		/** See OperationBinding.recordXPath. recordXPath can be specified directly on the DataSource for a simple read-only DataSource only capable of "fetch" operations.
		 * Flags: IR, Group: clientDataIntegration */
		recordXPath?: string /* XPathExpression */; // Flags=IR
		/** Additional properties to pass through to the DSRequests made by this DataSource. This must be set before any DSRequests are issued and before any component is bound to the DataSource. These properties are applied before DataSource.transformRequest is called.
		 * Flags: IRW, Group: clientDataIntegration */
		requestProperties?: DSRequestProps /* DSRequest Properties */; // Flags=IRW
		/** The required message when a field that has been marked as DataSourceField.required','required is not filled in by the user. Note that DataSourceField.requiredMessage wins over this setting if both are set.
		 * Flags: IRW, Group: formTitles */
		requiredMessage?: string /* HTMLString */; // Flags=IRW
		/** Indicates that the specified VelocityExpression must evaluate to true for a user to access this DataSource. See also OperationBinding.requires.
		 * Flags: IR, Group: auth */
		requires?: string /* VelocityExpression */; // Flags=IR
		/** Whether a user must be authenticated in order to access this DataSource. This establishes a default for the DataSource as a whole; individual DataSource.operationBindings within the DataSource may still override this setting by explicitly setting OperationBinding.requiresAuthentication. Whether the user is authenticated is determined by calling httpServletRequest.getRemoteUser(), hence works with both simple J2EE security (realms and form-based authentication) and JAAS (Java Authentication & Authorization Service). If you wish to use an authentication scheme that does not make use of the servlet API's standards, SmartClient Server also implements the setAuthenticated method on RPCManager. You can use this API to tell SmartClient that all the requests in the queue currently being processed are associated with an authenticated user; in this case, SmartClient will not attempt to authenticate the user via httpServletRequest.getRemoteUser() You can set the default value for this property via setting "authentication.defaultRequired" in server_properties','server.properties. This allows you to, for example, cause all DataSources to require authentication for all operations by default. Note that setting this property does not automatically cause an authentication mechanism to appear - you still need to separately configure an authentication system. Likewise, setting requiresAuthentication="false" does not automatically allow users to bypass your authentication mechanism - you need to set up a URL that will accept DSRequests and process them similar to the default "IDACall" servlet, and which is not protected by the authentication system. See servletDetails','Deploying SmartClient for details on the IDACall servlet.
		 * Flags: IR, Group: auth */
		requiresAuthentication?: boolean; // Flags=IR
		/** Similar to OperationBinding.requiresRole, but controls access to the DataSource as a whole.
		 * Flags: IR, Group: auth */
		requiresRole?: string /* String */; // Flags=IR
		/** Very advanced: for servers that do not support paging, and must return large numbers of XML records in one HTTP response, SmartClient breaks up the processing of the response in order to avoid the "script running slowly" dialog appearing for an end user. If you have a relatively small number of records with a great deal of properties or subobjects on each record, and you have not set DataSource.dropExtraFields to eliminate unused data, and you see the "script running slowly" dialog, you may need to set this number lower.
		 * Flags: IRWA */
		resultBatchSize?: number /* int */; // Flags=IRWA
		/** Class for ResultSets used by this datasource. If null, defaults to using ResultSet. This can be set to a custom subclass of ResultSet that, for example, hangs onto to extra information necessary for integration with web services.
		 * Flags: IRA */
		resultSetClass?: string /* Class Object */; // Flags=IRA
		/** Class for ResultTrees used by this datasource. If null, defaults to using ResultTree. This can be set to a custom subclass of ResultTree that, for example, hangs on to extra information necessary for integration with web services.
		 * Flags: IRA */
		resultTreeClass?: string /* Class Object */; // Flags=IRA
		/** This property only applies to the built-in SQL DataSource provided in Pro and better editions of SmartClient Defines the name of the schema we use to qualify the DataSource.tableName','tableName in generated SQL. If you do not provide this property, table names will not be qualified in generated SQL, and thus the default schema will be used. Support for multiple schemas (or schemata) varies quite significantly across the supported databases, as does the meaning of the phrase "default schema". In addition, some databases allow you to override the default schema in the JDBC connection URL, which is a preferable approach if all your tables are in the same (non-default) schema. The following table provides information by product: <table border="1" class="normal" width="90%"> <tr><td> Product</td><td width="90%"> Notes</td></tr> <tr><td> DB2</td><td> Arbitrarily named schemas are supported. The default schema is named after the connecting user, though this can be overridden by specifying the "currentSchema" property on the JDBC connection URL</td></tr> <tr><td> DB2 for iSeries</td><td> Arbitrarily named schemas are supported. "Schema" is synonymous with "library". The default schema depends on the setting of the "naming" connection property. When this is set to "sql", behavior is similar to other DB2 editions: the default schema is named after the connecting user, unless overridden by specifying a library name in the JDBC connection URL. When "naming" is set to "system", the schema of an unqualified table is resolved using a traditional search of the library list; the library list can be provided in the "libraries" property</td></tr> <tr><td> Firebird</td><td> Firebird does not support the concept of schema at all - all "schema objects" like tables and indexes belong directly to the database. In addition, Firebird actively rejects qualified table names in queries as syntax errors; therefore, you should not set the schema property for a DataSource that will be backed by a Firebird database </td></tr> <tr><td> HSQLDB</td><td> Arbitrarily named schemas are supported. The default schema is auto-created when the database is created; by default it is called "PUBLIC", but can be renamed. It is not possible to set the default schema in the JDBC connection URL</td></tr> <tr><td> Informix</td><td> Informix databases can be flagged as "ANSI mode" at creation time. ANSI-mode databases behave similarly to DB2 for schema support: arbitrarily named schemas are supported, and the default schema is the one named after the connected user. Non-ANSI databases have no real schema support at all. It is not possible to set the default schema in the JDBC connection URL with either type of database</td></tr> <tr><td> Microsoft SQL Server</td><td> Prior to SQL Server 2005, schema support is similar to Oracle: "schema" is synonymous with "owner". As of SQL Server 2005, schema is supported as a separate concept, and a user's default schema can be configured (though it still defaults to a schema with the same name as the user). It is not possible to set the default schema in the JDBC connection URL</td></tr> <tr><td> MySQL</td><td> MySQL does not have a separate concept of "schema"; it treats the terms "schema" and "database" interchangeably. In fact MySQL databases actually behave more like schemas, in that a connection to database X can refer to a table in database Y simply by qualifying the name in the query. Also, because schema and database are the same concept in MySQL, overriding the "default schema" is done implicitly when you specify which database to connect to in your JDBC connection URL</td></tr> <tr><td> Oracle</td><td> Arbitrarily named schemas are not supported; in Oracle, "schema" is synonymous with "user", so each valid user in the database is associated implicitly with a schema of the same name, and there are no other schemas possible. It is possible to refer to tables in another user's schema (assuming you have the privileges to do so) by simply qualifying the table name. The default schema is always implied by the connecting user and cannot be overridden.</td></tr> <tr><td> Postgres</td><td> Arbitrarily named schemas are supported. Rather than the concept of a "default schema", Postgres supports the idea of a search path of schemas, whereby unqualified table references cause a search of the list of schemas in order, and the first schema in the path is the "current" one for creation purposes. Unfortunately, there is no way to specify this search path on the JDBC connection URL, so the default schema comes from the user definition, ultimately defaulting to the default "public" schema</td></tr> </table>
		 * Flags: IR */
		schema?: string /* String */; // Flags=IR
		/** For DataSources that specify DataSource.autoDeriveSchema, this property indicates the name of the Spring bean, Hibernate mapping or fully-qualified Java class to use as parent schema.
		 * Flags: IR, Group: fields */
		schemaBean?: string; // Flags=IR
		/** Default scriptlet to be executed on the server for each operation. If OperationBinding.script is specified, it will be executed for the operation binding in question instead of running this scriptlet. Scriptlets are used similarly to DMIs configured via DataSource.serverObject or OperationBinding.serverObject - they can add business logic by modifying the DSRequest before it's executed, modifying the default DSResponse, or taking other, unrelated actions. For example: &lt;DataSource&gt; &lt;script language="groovy"&gt; ... Groovy code ... &lt;/script&gt; ... other DataSource properties &lt;/DataSource&gt; Scriptlets can be written in any language supported by the "JSR 223" standard, including Java itself. See the dmiOverview','DMI Script Overview for rules on how to return data, add additional imports, and other settings. The following variables are available for DMI scriptlets: requestContext: RequestContext (from com.isomorphic.servlet) dataSource: the current DataSource (same as DSRequest.getDataSource()) dsRequest: the current DSRequest criteria: shortcut to DSRequest.getCriteria() (a Map) values: shortcut to DSRequest.getValues() (a Map) oldValues: shortcut to DSRequest.getOldValues() (a Map) sqlConnection: SQLDataSource only: the current SQLConnection object. If using DataSource.autoJoinTransactions','automatic transactions are enabled, this SQLConnection is in the context of the current transaction. rpcManager: the current RPCManager applicationContext: the Spring ApplicationContext (when applicable) beanFactory: the Spring BeanFactory (when applicable) Scriptlets also have access to a set of contextual variables related to the Servlets API, as follows: servletRequest: the current ServletRequest session: the current HttpSession servletResponse: the current ServletResponse (advanced use only) servletContext: the current ServletContext(advanced use only) As with DMI in general, be aware that if you write scriptlets that depend upon these variables, you preclude your DataSource from being used in the widest possible variety of circumstances. For example, adding a scriptlet that relies on the HttpSession prevents your DataSource from being used in a command-line process. Note that if a dataSource configuration has both a &lt;script&gt; block and a specified OperationBinding.serverObject','serverObject for some operation, the script block will be executed, and the serverObject ignored.
		 * Flags: IR */
		script?: string /* String */; // Flags=IR
		/** Analogous to DataSource.dropExtraFields, for data sent to the server. Setting this attribute to false ensures that for any records in the data object, only fields that correspond to declared dataSource fields will be present on the dsRequest data object passed to DataSource.transformRequest and ultimately sent to the server.
		 * Flags: IR, Group: clientDataIntegration */
		sendExtraFields?: boolean /* Boolean */; // Flags=IR
		/** Set this attribute if you need to send the dsRequest.parentNode to the server-side.
		 * Flags: IRWA */
		sendParentNode?: boolean /* Boolean */; // Flags=IRWA
		/** For fields of DataSourceField.type','type "sequence" in a dataSource of DataSource.serverType','serverType "sql", indicates the SequenceMode to use. This property has no effect for fields or dataSources of other types. You can set a default sequenceMode for all DataSources of a given database type by setting property "sql.{database_type}.default.sequence.mode" in server.properties. You set a global default sequenceMode that applies to all database types by setting property "sql.default.sequence.mode". For example: sql.mysql.default.sequence.mode: jdbcDriver 
		 * Flags: IR */
		sequenceMode?: SequenceMode; // Flags=IR
		/** This property allows you to write and use custom DataSource subclasses on the server, by specifying either the fully-qualified name of the DataSource subclass that should be instantiated server-side for this dataSource, or the token "spring:" followed by a valid Spring bean ID, if you wish to instantiate your custom dataSource object using Spring dependency injection. For example, "spring:MyDataSourceBean". See also serverInit for special concerns with framework initialization when using Spring. It is also particularly important that you read the discussion of caching and thread-safety linked to below, as there are special considerations in this area when using Spring. the token "cdi:" followed by a valid CDI bean name, if you wish to instantiate your custom dataSource object using CDI dependency injection. For example, "cdi:MyDataSourceBean". One reason you might wish to do this would be to override the validate() method to provide some arbitrary custom validation (such as complex database lookups, validation embedded in legacy applications, etc). It is also possible - though obviously a more substantial task - to override the execute() method in your custom DataSource. This is one way of creating a completely customized DataSource implementation. Note: If you use this property, you are responsible for making sure that it refers to a valid server-side class that extends com.isomorphic.datasource.BasicDataSource, or to a Spring bean of the same description. If your implementation relies on methods or state only present in certain specialized subclasses of DataSource (for example, you want the normal behavior and features of a HibernateDataSource, but with a specialized validate() method), then you should extend the subclass rather than the base class. NOTE: Please take note of the points made in serverDataSourceImplementation','this discussion of caching and thread-safety issues in server-side DataSources.
		 * Flags: IR */
		serverConstructor?: string /* String */; // Flags=IR
		/** For Direct Method Invocation (DMI) binding, declares the ServerObject to use as the default target for all DataSource.operationBindings. Specifying this attribute in an XML DataSource stored on the server enables DMI for this DataSource. Note that if a dataSource configuration has both a OperationBinding.script','&lt;script&gt; block and a specified serverObject for some operation, the script block will be executed, and the serverObject ignored.
		 * Flags: IR, Group: serverDataIntegration */
		serverObject?: ServerObject; // Flags=IR
		/** Setting a DataSource to be serverOnly="true" ensures that it will not be visible to the client. Any request through IDACall to this DataSource will return a failure response. Only requests which have been initiated on the server-side will be executed against this DataSource.
		 * Flags: IR */
		serverOnly?: string /* String */; // Flags=IR
		/** For a DataSource stored in .xml format on the SmartClient server, indicates what server-side connector to use to execute requests, that is, what happens if you call dsRequest.execute() in server code.
		 * Flags: IR, Group: serverDataIntegration */
		serverType?: DSServerType; // Flags=IR
		/** For an XML DataSource, URN of the WebService to use to invoke operations. This URN comes from the "targetNamespace" attribute of the &lt;wsdl:definitions&gt; element in a WSDL (Web Service Description Language) document, and serves as the unique identifier of the service. Having loaded a WebService using XMLTools.loadWSDL, setting serviceNamespace combined with specifying OperationBinding','operationBindings that set OperationBinding.wsOperation will cause a DataSource to invoke web service operations to fulfill DataSource requests (DSRequest','DSRequests). Setting serviceNamespace also defaults DataSource.dataURL','dataURL to the service's location, DataSource.dataFormat','dataFormat to "xml" and OperationBinding.dataProtocol','dataProtocol to "soap".
		 * Flags: IR, Group: wsdlBinding */
		serviceNamespace?: string /* URN */; // Flags=IR
		/** For a DataSource that inherits DataSource.fields from another DataSource (via DataSource.inheritsFrom), indicates that only the fields listed in this DataSource should be shown. All other inherited parent fields will be marked "hidden:true".
		 * Flags: IR, Group: fields */
		showLocalFieldsOnly?: boolean; // Flags=IR
		/** Whether RPCRequests sent by this DataSource should enable RPCRequest.showPrompt in order to block user interactions until the request completes. DataSource requests default to blocking UI interaction because, very often, if the user continues to interact with an application that is waiting for a server response, some kind of invalid or ambiguous situation can arise. Examples include pressing a "Save" button a second time before the first save completes, making further edits while edits are still being saved, or trying to initiate editing on a grid that hasn't loaded data. Defaulting to blocking the UI prevents these bad interactions, or alternatively, avoids the developer having to write repetitive code to block invalid interactions on every screen. If an operation should ever be non-blocking, methods that initiate DataSource requests (such as DataSource.fetchData) will generally have a requestProperties argument allowing showPrompt to be set to false for a specific request.
		 * Flags: IRW */
		showPrompt?: boolean /* Boolean */; // Flags=IRW
		/** Sets what level of JSON validation will apply for this DataSource. Note that the point of "partial" validation mode is that if the JSON ihat's delivered is correct, we'll still need to validate to get "date" and such in the correct time, but shouldn't need to for the rest.
		 * Flags: IRW */
		skipJSONValidation?: SkipJSONValidation; // Flags=IRW
		/** When true, indicates that any updates for this DataSource include only those fields that have actually changed (and primaryKey fields); when false (the default), all field values are included in updates, whether they have changed or not
		 * Flags: IR */
		sparseUpdates?: boolean; // Flags=IR
		/** The paging strategy to use for this DataSource. If this property is not set, the default paging strategy, specified with the server_properties','server.properties setting sql.defaultPaging, is used. This setting can be overridden with the OperationBinding.sqlPaging property. NOTE: Operations that involve a OperationBinding.customSQL','customSQL clause ignore this property, because customSQL operations usually need to be treated as special cases. For these operations, the paging strategy comes from the server_properties','server.properties setting sql.defaultCustomSQLPaging or sql.defaultCustomSQLProgressivePaging, depending on whether or not DataSource.progressiveLoading','progressiveLoading is in force. Note that these can always be overridden by a sqlPaging setting on the OperationBinding.
		 * Flags: IRW */
		sqlPaging?: SQLPagingStrategy; // Flags=IRW
		/** If explicitly set true or left null, causes the server to use a "hint" in the SQL we generate for paged queries. If explicitly set false, forces off the use of hints. This property can be overridden per operationBinding - see OperationBinding.sqlUsePagingHint. Note this property is only applicable to DataSource.serverType','SQL DataSources, only when a DataSource.sqlPaging','paging strategy of "sqlLimit" is in force, and it only has an effect for those specific database products where we employ a native hint in the generated SQL in an attempt to improve performance.
		 * Flags: IR, Group: sqlPaging */
		sqlUsePagingHint?: boolean; // Flags=IR
		/** If set to true, both client and server-side advanced filtering used by SmartClient will follow SQL99 behavior for dealing with NULL values, which is often counter-intuitive to users. Specifically, when a field has NULL value, all of the following expressions are false: field == "someValue" (normally false) field != "someValue" (normally true) not (field == "someValue") (normally true) not (field != "someValue") (normally false) This property can be overridden per-query by specifying strictSQLFiltering directly as a property on the AdvancedCriteria. NOTE: On the server side, this property is only applicable if you are using the SQL DataSource; the other built-in types (Hibernate and JPA/JPA2) do not offer this mode.
		 * Flags: IRA */
		strictSQLFiltering?: boolean /* Boolean */; // Flags=IRA
		/** For DataSources using the sqlDataSource','SmartClient SQL engine for persistence, what database table name to use. The default is to use the DataSource ID as the table name.
		 * Flags: IR, Group: serverDataIntegration */
		tableName?: string /* String */; // Flags=IR
		/** Tag name to use when serializing to XML. If unspecified, the dataSource.ID will be used.
		 * Flags: IRA, Group: clientDataIntegration */
		tagName?: string /* String */; // Flags=IRA
		/** User-visible name for this DataSource. For example, for the supplyItem DataSource, "Supply Item". If is unset, getAutoTitle() method will be used with dataSource.ID. value in order to derive a default value for the title. For example "employee" ID will be derived to "Employee", "team_member" ID will be derived to "Team Member".
		 * Flags: IRW, Group: titles */
		title?: string; // Flags=IRW
		/** Best field to use for a user-visible title for an individual record from this dataSource. For example, for a DataSource of employees, a "full name" field would probably most clearly label an employee record. If not explicitly set, titleField looks for fields named "title", "label", "name", and "id" in that order. If a field exists with one of those names, it becomes the titleField. If not, then the first field is designated as the titleField.
		 * Flags: IR, Group: titles */
		titleField?: string; // Flags=IR
		/** If set to "false", transformation of values for DataSourceField.multiple','multiple:true fields, normally controlled by DataSourceField.multipleStorage, is instead disabled for this entire DataSource.
		 * Flags: IR, Group: multipleField */
		transformMultipleFields?: boolean; // Flags=IR
		/** OperatorId','Search operators like "matchesPattern" use patterns like "foo*txt" to match text values. The patterns are similar to the patterns you use to match names of files in a command-line interface, or to the pattern allowed for the SQL "LIKE" operator. translatePatternOperators controls whether these pattern operators should be translated to a nested series of "startsWith"/"endsWidth"/"contains" operators before being sent to the server. This allows a server that only implements simple operators like "startsWith" to support pattern operators such as "matchesPattern" and "containsPattern", but with caveats: single-character wildcards are not supported multiple wildcards are not truly order-dependent, for example *1*2*3* will match 1,2,3 as interior characters in any order. may be less efficient than a direct server-side implementation that is able to translate the pattern directly to the underlying storage engine. Note that since "containsPattern" is essentially equivalent to "matchesPattern" but with "*" wildcards at the beginning and end of every pattern, the second limitation (pattern not really order dependent) may be fairly obvious to users when using this feature. For example, "m*t" will match "we meet" and "we teem". The following are examples of how patterns are translated to simpler operators. Note that the case sensitive version of the operator is referred to below, but of course "iMatchesPattern" and "iContainsPattern" will be translated to case-insensitive versions of these operators, such as "iStartsWith". *foo (endsWith) foo* (startsWith) *foo* (contains) *foo*bar (contains and endsWith) foo*bar* (startsWith and contains) foo*bar (startsWith and endsWith) *foo*bar* (multiple contains) Also supported: one startsWith, multiple contains, one endsWith.
		 * Flags: IR */
		translatePatternOperators?: boolean; // Flags=IR
		/** For this dataSource, should the millisecond portion of time and datetime values be trimmed off before before being sent from client to server or vice versa. By default, millisecond information is preserved (ie, it is not trimmed). You only need to consider trimming millisecond values if their presence causes a problem - for example, a custom server that is not expecting that extra information and so fails parsing. Note that there is no inherent support for millisecond precision in SmartClient widgets; if you need millisecond-precise visibility and editability of values in your client, you must write custom formatters and editors (or sponsor the addition of such things to the framework). Server-side, millisecond-precise values are delivered to and obtained from DataSources, so DataSource implementations that are capable of persisting and reading millisecond values should work transparently. Of the built-in DataSource types, the JPA and Hibernate DataSources will transparently handle millisecond-precise values as long as the underlying database supports millisecond precision, and the underlying column is of an appropriate type. The SQLDataSource provides accuracy to the nearest second by default; you can switch on millisecond precision per-field with the DataSourceField.storeMilliseconds','storeMilliseconds attribute.
		 * Flags: IR */
		trimMilliseconds?: boolean; // Flags=IR
		/** For DataSources using the sqlDataSource','SmartClient SQL engine for persistence, whether to use ANSI-style joins (ie, joins implemented with JOIN directives in the table clause, as opposed to additional join expressions in the where clause). The default value of null has the same meaning as setting this flag to false. Note, outer joins (see DataSourceField.joinType','joinType) only work with certain database products if you choose not to use ANSI joins. Other than that, the join strategies are equivalent. If you wish to switch on ANSI-style joins for every DataSource, without the need to manually set this property on all of them, set server_properties','server.properties flag sql.useAnsiJoins to true.
		 * Flags: IR, Group: serverDataIntegration */
		useAnsiJoins?: boolean; // Flags=IR
		/** Like DataBoundComponent.useFlatFields, but applies to all DataBound components that bind to this DataSource.
		 * Flags: IR, Group: fields */
		useFlatFields?: boolean /* Boolean */; // Flags=IR
		/** Like OperationBinding.useHttpProxy, but serves as a default for this DataSource that may be overridden by individual operationBindings.
		 * Flags: IR, Group: clientDataIntegration */
		useHttpProxy?: boolean; // Flags=IR
		/** Whether to attempt validation on the client at all for this DataSource. If unset (the default), client-side validation is enabled. Disabling client-side validation entirely is a good way to test server-side validation.
		 * Flags: IRWA, Group: validation */
		useLocalValidators?: boolean; // Flags=IRWA
		/** Whether we store server responses for this DataSource into Offline','browser-based offline storage, and then use those stored responses at a later time if we are offline (ie, the application cannot connect to the server). Note that by default we do NOT use offline storage for a dataSource.
		 * Flags: IRW, Group: offlineGroup */
		useOfflineStorage?: boolean; // Flags=IRW
		/** For a DataSource that inherits DataSource.fields from another DataSource (via DataSource.inheritsFrom), indicates that the parent's field order should be used instead of the order of the fields as declared in this DataSource. New fields, if any, are placed at the end.
		 * Flags: IR, Group: fields */
		useParentFieldOrder?: boolean; // Flags=IR
		/** This flag is part of the Automatic Transactions feature; it is only applicable in Power Edition and above. If true, causes all transactional operations on this DataSource to use the current Spring-managed transaction, if one exists. If there is no current Spring transaction to use at the time of execution, a server-side Exception is thrown. Note, a "transactional operation" is one that would have joined the SmartClient shared transaction in the absence of Spring integration - see DataSource.autoJoinTransactions','auotJoinTransactions. This feature is primarily intended for situations where you have dmiOverview','DMI methods that make use of both Spring DAO operations and SmartClient DSRequest operations, and you would like all of them to share the same transaction. An example of the primary intended use case: &#x0040;Transactional(isolation=Isolation.READ_COMMITTED, propagation=Propagation.REQUIRED) public class WorldService { public DSResponse doSomeStuff(DSRequest dsReq, HttpServletRequest servletReq) throws Exception { ApplicationContext ac = (ApplicationContext)servletReq.getSession().getServletContext().getAttribute("applicationContext"); WorldDao dao = (WorldDao)ac.getBean("worldDao"); dao.insert(req.getValues()); DSRequest other = new DSRequest("MyOtherDataSource", "add"); // Set up the 'other' dsRequest with critiera, values, etc // ... // This dsRequest execution will use the same transaction that the DAO operation // above used; if it fails, the DAO operation will be rolled back other.execute(); return new DSResponse(); } } Note: if you want to rollback an integrated Spring-managed transaction, you can use any of the normal Spring methods for transaction rollback: Programmatically mark the transaction for rollback with the setRollbackOnly() API Throw a RuntimeException, or Throw an ordinary checked Exception. but configure Spring to rollback on that Exception. This can be done in the @Transactional annotation: &#x0040;Transactional(isolation=Isolation.READ_COMMITTED, propagation=Propagation.REQUIRED, rollbackFor=MyRollbackException.class) Spring's exception-handling model is different from SmartClient's, so care must be taken to get the correct error processing. If a transactional DSRequest fails, SmartClient code will throw an ordinary checked Exception; but Spring will ignore that Exception. So you can either: Wrap every DSRequest.execute() in a try/catch block. Catch Exception and throw a RuntimeException instead Just use the "rollbackFor" annotation to make your transactional method rollback for all instances of Exception Note: Spring transaction integration is conceptually different from SmartClient's DataSource.autoJoinTransactions','built-in transaction feature, because SmartClient transactions apply to a queue of DSRequests, whereas Spring transactions are scoped to a single method invocation. If you want to make a whole SmartClient queue share a single Spring-managed transaction, you can wrap the processing of an entire queue in a call to a transactional Spring method. See the <em>Using Spring Transactions with SmartClient DMI</em> section at the bottom of the springIntegration','Spring integration page for more details. You can set useSpringTransaction as the default setting for all dataSources for a given database provider by adding the property {dbName}.useSpringTransaction to your server.properties file. For example, Mysql.useSpringTransaction: true or hibernate.useSpringTransaction: true. You can set it as the default for all providers with a server.properties setting like this: useSpringTransaction: true. When useSpringTransaction is the default, you can switch it off for a specific dataSource by explicitly setting the flag to false for that DataSource. Finally, this setting can be overridden at the operationBinding level - see OperationBinding.useSpringTransaction <h3>Configuration</h3> When using Spring transactions, SmartClient needs a way to lookup the JNDI connection being used by Spring, and this needs to be configured. First, register a bean like this in your applicationContext.xml file: &lt;bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean"&gt; &lt;!-- Set this to the JNDI name Spring is using --&gt; &lt;property name="jndiName" value="isomorphic/jdbc/defaultDatabase"/&gt; &lt;/bean&gt; and then add a line like this to your server.properties: # Set this property to match the "id" of the JndiObjectFactoryBean registered in Spring sql.spring.jdbcDataSourceBean: dataSource 
		 * Flags: IR */
		useSpringTransaction?: boolean; // Flags=IR
		/** Should HTTP responses to requests by this dataSource be formatted using the strict JSON subset of the javascript language? If set to true, responses returned by the server should match the format described <a href='http://www.json.org/js.html' target='_blank'>here</a>. Only applies to dataSources which send requests to a server and have DataSource.dataFormat set to "json" or "iscServer". Note: using strict JSON avoids a known issue in Internet Explorer 9 where datasource transactions can leak memory due to a browser behavior where the native eval() method fails to clean up references when the objects go out of scope. See RPCManager.allowIE9Leak for more on this.
		 * Flags: IR */
		useStrictJSON?: boolean; // Flags=IR
		/** This property is only applicable to DataSource.serverType','SQL DataSources, and only for OperationBinding','operations that express a OperationBinding.customSQL','customSQL clause. In these circumstances, we generally switch off paging because we are unable to generate a "row count" query that tells the framework the size of the complete, unpaged resultset. The useSubselectForRowCount flag causes the framework to derive a rowcount query by simply wrapping the entire customSQL clause in a subselect, like so: &nbsp;&nbsp;&nbsp;&nbsp;SELECT COUNT(*) FROM ({customSQL clause here}) However, this is not guaranteed to give good results. Because the customSQL clause can contain anything that you can write in SQL, running it inside a subselect in order to count the rows might not work, might have unintended side-effects (if, for example, it is a stored procedure call that performs updates as part of its function), or it might just be a bad idea - for example, if the customSQL query is slow-running, you'll make it twice as slow with this flag, simply because you'll be running it twice. We recommend using this flag with care. NOTE: This setting can be overridden per-operation - see OperationBinding.useSubselectForRowCount. You can also set a global default for this setting, so you don't have to specify it in every dataSource - define useSubselectForRowCount as true in your server_properties','server.properties file.
		 * Flags: IR, Group: sqlPaging */
		useSubselectForRowCount?: boolean; // Flags=IR
		/** When set, causes a DataSource.clientOnly','client-only or DataSource.cacheAllData DataSource to create a second DataSource to perform it's one-time fetch. By default, this attribute will be considered true when clientOnly is true, cacheAllData is false or unset and a dataURL or testFileName is specified on the DataSource.
		 * Flags: IRW, Group: clientData */
		useTestDataFetch?: boolean; // Flags=IRW
		/** If true, indicates that the SmartClient Server should automatically apply a ValidatorType of "hasRelatedRecord" to every field on this dataSource that has a DataSourceField.foreignKey','foreignKey defined.
		 * Flags: IR */
		validateRelatedRecords?: boolean; // Flags=IR
		/** Sets the XML namespace prefixes available for XPaths on a DataSource-wide basied. See OperationBinding.xmlNamespaces for details.
		 * Flags: IR, Group: clientDataIntegration */
		xmlNamespaces?: any /* Object */; // Flags=IR

		/* Method Overrides */

		/** 
		 * Perform a "fetch" DataSource operation against this DataSource, sending search criteria and retrieving matching records. NOTE: do not attempt to override this method to create a custom DataSource. For a server-side custom DataSource, use the DataSource.serverConstructor attribute, and the customDataSource', 'Custom DataSource samples. For a client-side custom DataSource, see DataSource.dataProtocol','dataProtocol:"custom". In contrast to ListGrid.fetchData, which creates a ResultSet to manage the returned data, calling dataSource.fetchData() provides the returned data in the callback as a simple JavaScript Array of JavaScript Objects. Calling dataSource.fetchData() does not automatically update any visual components or caches: code in the callback passed to fetchData() decides what to do with the returned data. For example, given a ListGrid "myGrid" and a DataSource "employees", the following code would populate "myGrid" with data fetched from the DataSource: isc.DataSource.get("employees").fetchData(null, "myGrid.setData(data)"); Unlike calling myGrid.fetchData(), which creates a ResultSet, the data provided to the grid is "disconnected" data, unmanaged by SmartClient's databinding facilities and safe to directly modify. This is useful when, for example, a ListGrid is being used as a more sophisticated version of HTML's multi-select component. Disconnected datasets may be used to populate various visual components. For example, while an individual FormItem can be configured to fetch FormItem.valueMap','valueMap options from a DataSource via the FormItem.optionDataSource','optionDataSource property, the following code shows storing a dataset to derive valueMaps from later: isc.DataSource.get("countries").fetchData(null, "window.countries = data"); ... later, a form is created dynamically ... function showForm() { isc.DynamicForm.create({ items : [ { name:"country", title:"Pick Country", valueMap: window.countries.getValueMap("countryId", "countryName") }, ... You can also create a ResultSet from the data retrieved from fetchData(), like so: isc.DataSource.get("countries").fetchData(null, function (dsResponse, data) { isc.ResultSet.create({ dataSource:"countries", allRows:data }) } ) This gives you a dataset that supports client-side filtering (via ResultSet.setCriteria','setCriteria()), can provide ResultSet.getValueMap','filtered valueMaps, will ResultSet.disableCacheSync','automatically reflect updates to the DataSource made via other components, and can be re-used with multiple visual components. See also DataSource.getClientOnlyDataSource and DataSource.cacheAllData for similar capabilities for dealing with smaller datasets entirely within the browser, or working with modifiable caches representing subsets of the data available from a DataSource. See also the server-side com.isomorphic.js.JSTranslater class in the ${isc.DocUtils.linkForDocNode('javaServerReference', 'Java Server Reference')} for other, similar approaches involving dumping data into the page during initial page load. Note: care should be taken when using this approach. Large datasets degrade the basic performance of some browsers, so use PickList.optionDataSource','optionDataSource and similar facilities to manage datasets that may become very large. Data-Driven Visual Component Creation DataSource.fetchData() can also be used to create SmartClient components in a data-driven way. Many properties on SmartClient visual components are configured via an Array of Objects - the same data format that dataSource.fetchData() returns. These include ListGrid.fields, TabSet.tabs, DynamicForm.items, Facet.values and even DataSource.fields. For example, if you had a DataSource "myFormFields" whose fields included the basic properties of FormItem','FormItems (name, title, type, etc), this example code would create a form based on stored field definitions, loaded from the "myFormFields" DataSource on the fly: isc.DataSource.get("myFormFields").fetchData(null, "isc.DynamicForm.create({ items:data })" ) This capability to dynamically create visual components from dynamically fetched data provides a foundation for creating interfaces that can be customized by end users. See also the server-side API com.isomorphic.datasource.DataSource.addDynamicDSGenerator() for dynamically creating DataSources supporting all server-side DataSource features, and DataSource.inheritsFrom for sharing field definitions across multiple DataSources.
		 * @param {Criteria} criteria - search criteria
		 * @param {DSCallback} callback - callback to invoke on completion
		 * @param {DSRequestProps} requestProperties - additional properties to set on the DSRequest that will be issued
		 */
		fetchData?(criteria?:Criteria, callback?:DSCallback, requestProperties?:DSRequestProps /* DSRequest Properties */): void; 

		/** 
		 * Return the field definition object.
		 * @param {string} fieldName - Name of the field to retrieve
		 */
		getField?(fieldName:string /* String */): DataSourceField; 

		/** 
		 * Converts a list of Records to simple text formats with a Record per line and values separated by a configurable separator, including both tab-separated-values and comma-separated-values (aka CSV). In addition to the settings parameter for this method, DataSourceField.exportForceText can be set. If two or more different text exports are needed for the same DataSource creating a conflict for any DataSourceField setting, DataSource.inheritsFrom can be used to create a child DataSource where these settings can be changed without recapitulating all field definitions.
		 * @param {Array<any>} records - records to convert
		 * @param {TextExportSettingsProps} settings - settings for the export
		 */
		recordsAsText?(records:Array<any> /* Array of Record */, settings?:TextExportSettingsProps /* TextExportSettings Properties */): string /* String */; 

		/** 
		 * Perform a "remove" DataSource operation against this DataSource, to delete an existing DataSource record.
		 * @param {any} data - primary key values of record to delete, (or complete record)
		 * @param {DSCallback} callback - callback to invoke on completion
		 * @param {DSRequestProps} requestProperties - additional properties to set on the DSRequest that will be issued
		 */
		removeData?(data:any | any /* Record | PrimaryKeys */, callback?:DSCallback, requestProperties?:DSRequestProps /* DSRequest Properties */): void; 

		/** 
		 * Perform an "update" DataSource operation against this DataSource, to update values in an existing DataSource record.
		 * @param {any} updatedRecord - updated record
		 * @param {DSCallback} callback - callback to invoke on completion
		 * @param {DSRequestProps} requestProperties - additional properties to set on the DSRequest that will be issued
		 */
		updateData?(updatedRecord:any /* Record Properties */, callback?:DSCallback, requestProperties?:DSRequestProps /* DSRequest Properties */): void; 

	} // DataSourceProps


	/**
	 * A DataSource is data-provider-independent description of a set of objects that will be loaded, edited and saved within the user interface of your application. Each DataSource consists of a list of DataSource.fields','fields that make up a DataSource record, along with DataSourceField.type','field types, DataSourceField.validators','validation rules, DataSourceField.foreignKey','relationships to other DataSources, and other metadata. The abstract object description provided by a DataSource is easily mapped to a variety of backend object models and storage schemes. The following table shows analogous terminology across systems. <table border=1 class="normal"> <tr> <td>Isomorphic SmartClient</td> <td>Relational Database</td> <td>Enterprise Java Beans (EJB)</td> <td>Entity/Relationship Modeling</td> <td>OO/UML</td> <td>XML Schema/WSDL</td> <td>LDAP</td> </tr><tr> <td>DataSource</td> <td>Table</td> <td>EJB class</td> <td>Entity</td> <td>Class</td> <td>Element Schema (ComplexType)</td> <td>Objectclass</td> </tr><tr> <td>Record</td> <td>Row</td> <td>EJB instance</td> <td>Entity instance</td> <td>Class instance/Object</td> <td>Element instance (ComplexType)</td> <td>Entry</td> </tr><tr> <td>Field</td> <td>Column</td> <td>Property</td> <td>Attribute</td> <td>Property/Attribute</td> <td>Attribute or Element (SimpleType)</td> <td>Attribute</td> </tr></table> DataSources can be dataSourceDeclaration','declared in either JavaScript or XML format, and can also be metadataImport','imported from existing metadata formats, including XML Schema. Data Binding is the process by which DataBoundComponent','Data Binding-capable UI components can automatically configure themselves for viewing, editing and saving data described by DataSources. DataBinding is covered in the ${isc.DocUtils.linkForDocNode('QuickStartGuide', 'QuickStart Guide')}, Chapter 6, Data Binding. clientServerIntegration','Data Integration is the process by which a DataSource can be connected to server systems such as SQL DataBases, Java Object models, WSDL web services and other data providers. Data Integration comes in two variants: client-side and server-side. serverDataIntegration','Server-side integration uses the SmartClient Java-based server to connect to data represented by Java Objects or JDBC-accessible databases. clientDataIntegration','Client-side integration connects SmartClient DataSources to XML, JSON or other formats accessible via HTTP. DataSources have a concept of dataSourceOperations','4 core operations ("fetch", "add", "update" and "remove") that can be performed on the set of objects represented by a DataSource. Once a DataSource has been integrated with your data store, databinding-capable UI components can leverage the 4 core DataSource operations to provide many complete user interactions without the need to configure how each individual component loads and saves data. These interactions include ListGrid','grid views, TreeGrid','tree views, DetailViewer','detail views, DynamicForm','form-based DynamicForm.editRecord','editing and DynamicForm.saveData','saving, grid-based ListGrid.canEdit','editing and ListGrid.saveByCell','saving, and custom interactions provided by patternReuse custom databinding-capable components. 
	 */
	export interface DataSource extends Class {
		/** Whether to make this DataSource available as a global variable for convenience.
		 * Flags: IRA, Group: identity */
		addGlobalId: boolean;

		/** By default, all DataSources are assumed to be capable of handling AdvancedCriteria on fetch or filter type operations. This property may be set to false to indicate that this dataSource does not support advancedCriteria. See DataSource.supportsAdvancedCriteria for further information on this. NOTE: If you specify this property in a DataSource descriptor (.ds.xml file), it is enforced on the server. This means that if you run a request containing AdvancedCriteria against a DataSource that advertises itself as allowAdvancedCriteria:false, it will be rejected.
		 * Flags: IRWA */
		allowAdvancedCriteria: boolean;

		/** If a DSRequest arrives from the client that requests serverSummaries','server-calculated summaries, should it be allowed? Note this setting only affects dsRequests that come from the browser (or another client). This setting has no effect on server summaries declared in .ds.xml files or summaries configured in DSRequests created programmatically on the server side, which are always allowed. Default value of null means this DataSource will use the system-wide default, which is set via datasources.allowClientRequestedSummaries in server_properties','server.properties, and defaults to allowing client-requested summaries. If client-requested summarization is allowed, but the server-side &lt;operationBinding&gt; provides specific summarization settings, the client-requested summarization is ignored.
		 * Flags: IR, Group: serverSummaries */
		allowClientRequestedSummaries: boolean;

		/** Enables saving of a log of changes to this DataSource in a second DataSource with the same fields, called the "audit DataSource". NOTE: this feature applies to Enterprise Edition only; for more information on edition-specific features, see <a href='http://smartclient.com/product' target='_blank'>http://smartclient.com/product</a>. When auditing is enabled, every time a DSRequest modifies this DataSource, a Record is added to the audit DataSource that shows the record as it existed after the change was made (or for a "remove", the values of the record at the time of deletion). In addition, the audit DataSource has the following additional metadata fields: DataSource.auditTypeFieldName','"audit_operationType": type of the change ("update", "add" or "remove") DataSource.auditUserFieldName','"audit_modifier": username of the user that made the change. The username is determined in the same way that the OperationBinding.requiresRole','Declarative Security subsystem determines the current user. DataSource.auditTimeStampFieldName','"audit_changeTime": a field of type "datetime" recording the timestamp of the change DataSource.auditRevisionFieldName','"audit_revision": a field of type "sequence" recording a simple increasing integer value If any of the field names above collide with field names of the DataSource being audited, an integer suffix will also be added, starting with 2 (for example, "audit_modifier2", then "audit_modifier3", etc). To omit a data field from the automatically generated audit DataSource, just set DataSourceField.audit to false. Note: audit DataSource feature works only with single row operations, i.e. operations with OperationBinding.allowMultiUpdate','allowMultiUpdate enabled are not supported. Note, audit can be disabled for a given DSRequest via server-side API DSRequest.setSkipAudit() or for specific opreation via OperationBinding.skipAudit','operationBinding.skipAudit setting. <h4>Auto-generated Audit DataSources</h4> The audit DataSource is normally automatically generated, and unless otherwise specified with DataSource.auditDataSourceID, the ID of the audit DataSource will be audit_[OriginalDSID]. By default, the automatically generated audit DataSource will be of the same type as the DataSource being audited, however, if the DataSource being audited is not already a SQLDataSource, we recommend using DataSource.auditDSConstructor','auditDSConstructor:"sql" to use a SQLDataSource as the audit DataSource. This is because a SQLDataSource used an audit DataSource will automatically generate a SQL table for storing audit data the first time changes are made. JPA would require manual creation of a Java Bean, and Hibernate requires <a href='http://www.google.com/search?q=hbm2ddl.auto' target='_blank'>hbm2ddl.auto=update</a> to be set, which is widely considered unsafe for production use. Automatically created audit DataSources can be loaded and queried just like other DataSources, using the DataSourceLoader, and using the server-side API DataSource.getAuditDataSource(). However, you must load the DataSource being audited before loading its automatically created audit DataSource. Note, that automatic SQL tables creation can be disabled. See DataSource.autoCreateAuditTable','autoCreateAuditTable for details. <h4>Manually created Audit DataSources</h4> The audit DataSource can also be manually created. In this case, you can can either follow the naming conventions described above for the ID of the audit DataSource and the names of metadata fields, or use the linked properties to assign custom names. If you omit any data fields from the tracked DataSource in your audit DataSource, those fields will be ignored for auditing purposes, exactly as though DataSourceField.audit had been set to false for an automatically-generated audit DataSource. Also, note that in case of manually defined audit DataSource, if this DataSource is defined so it inherits the audited DataSource, all the audited DataSource's fields will be inherited, this including the primary keys. Since for the audit DataSource the primary key should be the revision field, in order to prevent the audit DataSource having two primary keys, the inherited DataSource's primary key will have to be declared in audit DataSource, but with the primaryKey attribute omitted (as well not being of type "sequence") in the audit DataSource.
		 * Flags: IR, Group: serverDataIntegration */
		audit: boolean;

		/** For DataSources with DataSource.audit','auditing enabled, optionally specifies the ID of the audit DataSource. If this property is not specified, the ID of the audit DataSource will be audit_[OriginalDSID] 
		 * Flags: IR */
		auditDataSourceID: string;

		/** For DataSources with DataSource.audit','auditing enabled, optionally specifies the DataSource.serverConstructor for the automatically generated audit DataSource. The default is to use the same serverConstructor as the DataSource where audit="true" was declared. This property is primarily intended to allow the use of SQLDataSource (DataSource.serverType','serverType:"sql") as an audit DataSource for a DataSource that might be of another type. For example, you might have a DataSource that implements all CRUD operations via Java logic in dmiOverview','DMI declaration methods, and so doesn't provide generic storage; by using SQLDataSource as the type of your audit DataSource, you don't need to implement your own scheme for storing and querying audit data, and the necessary audit tables will be automatically generated in the database. Similarly, even if you do use a reusable DataSource type such as the built-in JPADataSource, using SQLDataSource for audit DataSources means there's no need to write a JPA bean just to achieve storage of an audit trail. To simplify this intended usage, the string "sql" is allowed for auditDSConstructor as a means of specifying that the built-in SQLDataSource class should be used. For any other type, use the fully qualified Java classname, as is normal for serverConstructor.
		 * Flags: IR */
		auditDSConstructor: string /* String */;

		/** For DataSources with DataSource.audit','auditing enabled, specifies the field name used to store the revision number for the change (in a field of type "sequence"). If empty string is specified as the field name, the audit DataSource will not store this field.
		 * Flags: IR */
		auditRevisionFieldName: string;

		/** For DataSources with DataSource.audit','auditing enabled, specifies the field name used to store the timestamp when the operation was performed (in a field of type "datetime"). If empty string is specified as the field name, the audit DataSource will not store this field.
		 * Flags: IR */
		auditTimeStampFieldName: string;

		/** For DataSources with DataSource.audit','auditing enabled, specifies the field name used to store the DSOperationType','operationType (in a field of type "text"). If empty string is specified as the field name, the audit DataSource will not store this field.
		 * Flags: IR */
		auditTypeFieldName: string;

		/** For DataSources with DataSource.audit','auditing enabled, specifies the field name used to store the user who performed the operation. If empty string is specified as the field name, the audit DataSource will not store this field.
		 * Flags: IR */
		auditUserFieldName: string;

		/** When a DataSource is not DataSource.cacheAllData:true and a fetch results in the entire dataset being retrieved, this attribute being set to true causes the DataSource to automatically switch to cacheAllData:true and prevent further server-trips for fetch requests. DataSource.cacheAllData','cacheAllData is automatically enabled in either of these conditions: The request has no criteria and no startRow/endRow request properties. The latter can be accomplished by disabling paging with a DataBoundComponent.dataFetchMode','dataFetchMode setting of "basic" or "local" or by an explicit fetchData request with those request properties excluded. The request has no criteria but has startRow/endRow specified and the response received has all data available (startRow:0 and endRow:totalRows). 
		 * Flags: IR, Group: clientData */
		autoCacheAllData: boolean /* Boolean */;

		/** Whether to convert relative date values to concrete date values before sending to the server. Default value is true, which means that the server does not need to understand how to filter using relative dates - it receives all date values as absolute dates.
		 * Flags: IR */
		autoConvertRelativeDates: boolean /* Boolean */;

		/** Setting autoCreateAuditTable to true indicates that audit DataSource will automatically create SQL table when DataSource.audit','auditing is enabled. Note, that autoCreateAuditTable attribute takes effect only if framework setting audit.autoCreateTables in server.properties is set to false, which by default is set to true.
		 * Flags: IR */
		autoCreateAuditTable: boolean;

		/** This property allows you to specify that your DataSource's schema (field definitions) should be automatically derived from some kind of metadata. This causes SmartClient to create a special super-DataSource, which is used purely as a source of default schema for this DataSource; this is arranged by causing the autoDerived DataSource to automatically DataSource.inheritsFrom','inherit from the special super-DataSource. This allows you to auto-derive schema from existing metadata, whilst still being able to override any or all of it as required. This property has a different implementation depending upon the DataSource.serverType','serverType of the DataSource: For a DataSource with serverType: "sql", automatically derive the dataSource's schema from the Spring bean or Java class specified in DataSource.schemaBean','schemaBean. If schemaBean is not specified, derive the schema from the columns in the SQL table specified in DataSource.tableName','tableName. More information on SQL DataSources is sqlDataSource','here For a DataSource with serverType: "hibernate", automatically derive the dataSource's schema from the Spring bean, Hibernate mapping or Java class named in the DataSource.schemaBean','schemaBean property. If no such thing exists, derive the schema from the Hibernate mapping or Java class specified in the DataSource.beanClassName','beanClassName property (this allows you to specify schema and mapping separately, in the unusual circumstance that you have a need to do so). Note that the "mappings" referred to here can mean either .hbm.xml files or annotated classes; both are supported. If neither of these is successful, derive the schema from the underlying SQL table specified in DataSource.tableName','tableName. More information on Hibernate DataSources is hibernateIntegration','here For a DataSource with serverType: "jpa1" or "jpa", automatically derive the dataSource's schema from the annotated JPA class named in the DataSource.schemaBean','schemaBean property. If the schemaBean property is not defined, derive the schema from the annotated JPA class named in the DataSource.beanClassName','beanClassName property (as with Hibernate, this allows you to specify schema and mapping separately if you need to do so). JPA DataSource generation relies on annotations (the orm.xml mapping file is not supported). More information on JPA DataSources is jpaIntegration','here For other DataSource types, attempt to find a Spring bean with the name specified in the DataSource.schemaBean','schemaBean property. If no such bean is found (or Spring is not present), attempt to instantiate an object whose fully-qualified class name is the value in the schemaBean property. If one of these approaches succeeds, we derive the schema from the discovered object (by treating it as a Java Bean and assuming that each one of its getters corresponds to a like-named field in the DataSource). More information on custom DataSource implementations is writeCustomDataSource','here. <h4>Field types</h4> The following table shows how SQL types are derived into FieldType','DataSource types when we use an SQL table as a source of metadata for a SQL or Hibernate DataSource: <table border="1" class="normal"> <tr><th>SQL type</th><th>DataSourceField.type','DataSource type</th></tr> <tr><td>CHAR, VARCHAR, LONGVARCHAR, TEXT, CLOB</td><td>text</td></tr> <tr><td>BIT, TINYINT, SMALLINT, INTEGER, BIGINT, DECIMAL<sup>*</sup>, NUMBER<sup>**</sup></td><td>integer</td></tr> <tr><td>REAL, FLOAT, DOUBLE, DECIMAL<sup>*</sup>, NUMBER<sup>**</sup></td><td>float</td></tr> <tr><td>DATE</td><td>date</td></tr> <tr><td>TIME</td><td>time</td></tr> <tr><td>TIMESTAMP</td><td>datetime</td></tr> <tr><td>BLOB, BINARY, VARBINARY, LONGVARBINARY</td><td>binary</td></tr> </table> <sup>*</sup>For DECIMAL types, we inspect the "DECIMAL_DIGITS" attribute of the JDBC metadata and designate the field type "integer" if that attribute is 0, or "float" if it is some other value. <sup>**</sup>NUMBER is an Oracle-only type that appears in the JDBC metadata as DECIMAL and is handled exactly the same way as DECIMAL The following table shows how Java types are derived into DataSource types when we use an unannotated Java class (Spring bean, Hibernate mapping or POJO) as a source of metadata for a SQL, Hibernate or custom DataSource: <table border="1" class="normal"> <tr><th>Java type</th><th>DataSourceField.type','DataSource type</th></tr> <tr><td>boolean, Boolean</td><td>boolean</td></tr> <tr><td>char, Character, String, Reader</td><td>text</td></tr> <tr><td>byte, short, int, long, Byte, Short, Integer, Long, BigInteger</td><td>integer</td></tr> <tr><td>float, double, Float, Double, BigDecimal</td><td>float</td></tr> <tr><td>Enum</td><td>enum (see discussion below)</td></tr> <tr><td>InputStream</td><td>binary</td></tr> <tr><td>java.sql.Date, java.util.Date, java.util.Calendar</td><td>date</td></tr> <tr><td>java.sql.Time</td><td>time</td></tr> <tr><td>java.sql.Timestamp</td><td>datetime</td></tr> </table> Finally, this table shows how Java types are derived into DataSource types when we use an annotated class as a source of metadata. Note annotated classes are necessary for JPA DataSources, but you can choose to use them for other types of DataSource as well. For Hibernate DataSources, this is very worthwhile because Hibernate will also make use of the annotations as config, meaning you don't need to specify .hbm.xml files. For SQL and custom DataSources, there is no benefit at the persistence level, but it may still be worthwhile because the use of an annotated class gives us better metadata and allows us to generate a better, closer-fitting autoDerive DataSource than we can from examination of SQL schema or plain Java Beans: <table border="1" class="normal"> <tr><th>Java type</th><th>DataSourceField.type','DataSource type</th></tr> <tr><td>boolean, Boolean</td><td>boolean</td></tr> <tr><td>char, Character, String, Reader</td><td>text</td></tr> <tr><td>byte, short, int, long, Byte, Short, Integer, Long, BigInteger</td><td>integer</td></tr> <tr><td>float, double, Float, Double, BigDecimal</td><td>float</td></tr> <tr><td>InputStream</td><td>binary</td></tr> <tr><td>java.util.Date (with Temporal set to DATE), java.sql.Date</td><td>date</td></tr> <tr><td>java.util.Date (with Temporal set to TIME), java.sql.Time</td><td>time</td></tr> <tr><td>java.util.Date (with Temporal set to TIMESTAMP), java.util.Calendar, java.sql.Timestamp</td><td>datetime</td></tr> <tr><td>Enum (with Enumerated set to STRING)</td><td>enum (see discussion below)</td></tr> <tr><td>Enum (with Enumerated set to ORDINAL)</td><td>intEnum (see discussion below)</td></tr> <tr><td>Field with Lob annotation</td><td>binary</td></tr> <tr><td>Field with GeneratedValue annotation</td><td>sequence, if the field is an integer type (see discussion below)</td></tr> </table> <h4>Primary keys, sequences and identity columns</h4> We attempt to derive information about primary keys from the metadata we have. If the metadata source is an SQL table: If the table does not have a native primary key constraint, no attempt is made to identify primary key fields. Otherwise: The column or columns that make up the table's native primary key constraint are identified using the JDBC DatabaseMetaData.getPrimaryKeys() API Each DataSource field that corresponds to one of these native primary key columns is marked primaryKey: true For each of these columns, the metadata returned by DatabaseMetaData.getColumns() is inspected. If the metadata includes IS_AUTOINCREMENT=YES, we mark the corresponding field as type="sequence". This information should be reliably provided by databases that implement "auto-increment" or "identity" column types, such as MySQL or Microsoft SQL Server If the previous step does not identify a column as a sequence, we inspect the ResultSetMetaData obtained by running a dummy query on the table. If the isAutoIncrement() API returns true for that column, we mark the corresponding field as type="sequence" If the previous steps have not identified the column as a sequence, we check the TYPE_NAME in the column metadata. If it is "serial", this means the column is a PostgreSQL "serial" or "serial8" type column. Postgres does not transparently implement auto-increment columns, but it does provide this serial type, which causes the column to be implicitly bound to an underlying sequence. So this type causes us to mark the field type="sequence", and we also set DataSourceField.implicitSequence','implicitSequence true If the previous steps have not identified the column as a sequence, we check the COLUMN_DEF in the column metadata. If this contains the token "$$ISEQ" and ends with "NEXTVAL", this means the column is an Oracle "GENERATED AS IDENTITY" column. This type of column was introduced in Oracle 12c and is conceptually exactly the same thing as the Postgres "serial" column described above. We treat it the same way: mark it type="sequence" and implicitSequence="true" If the previous steps have not identified the column as a sequence, then you may be using a pure sequence database, such as an Oracle version earlier than 12c, or you may be using a database where both sequences and identity columns are available (Oracle, Postgres, DB2), and a sequence is being used either by design or because the table was created before the database product supported identity columns. In this case, we cannot determine if the column should be a sequence or not. However, in many applications, the fact that the column is an integer and is a primary key would imply that it is also a sequence. Therefore, if the column is an integer and the server.properties flag auto.derive.integer.pk.always.sequence is true, we mark the field as type="sequence" If, after all this, SmartClient ends up incorrectly marking a primary key field as a sequence (or vice versa), you can always override it on a per-field basis by simply redeclaring the field with the correct type in your .ds.xml file: &lt;DataSource serverType="sql" tableName="myTable" autoDeriveSchema="true"&gt; &lt;fields&gt; &lt;!-- This field was incorrectly marked as a sequence --&gt; &lt;field name="notASeq" type="integer" /&gt; &lt;!-- This field was incorrectly marked as an integer when it should be a sequence --&gt; &lt;field name="isASeq" type="sequence" /&gt; &lt;/fields&gt; &lt;/DataSource&gt; If the metadata source is Hibernate mappings described in a .hbm.xml file: The first field we encounter that is described in the mapping with an &lt;id&gt; tag is marked as a primaryKey If that field is marked as being generated, we set its type to "sequence" If the metadata source is an annotated object (whether JPA, Hibernate or just an annotated POJO): Any field with an @Id annotation is is marked as a primaryKey (this differs from the Hibernate .hbm.xml file case because that is specific to Hibernate, which does support composite keys, but not by specifying multiple &lt;id&gt; tags. Annotations are supported, via annotated POJOs, for any kind of persistence strategy, so multiple @Id fields are perfectly valid) Any field with a @GeneratedValue annotation is either marked as type="sequence" (if it is an integer type) or as DataSourceField.autoGenerated','autoGenerated="true" (for other field types) Finally, if the metadata is a plain, unannotated Java object, no attempt is made to derive primary key fields. <h4>enums and valueMaps</h4> When we come across Java Enum properties in plain or annotated classes, as well as setting the field type as noted in the above tables, we also generate a valueMap for the field, based on the Enum members. For cases where we generate a field of SmartClient type "enum" (see the above tables), the keys of the valueMap are the result of calling name() on each member of the underlying Java Enum (in other words, its value exactly as declared in its enum declaration). For cases where we generate a field of SmartClient type "intEnum", the keys of the valueMap are strings representing the ordinal number of each member in the Java Enum - "0", "1", etc. Note that this behavior will be overriden by DataSource.enumTranslateStrategy','DataSource.enumTranslateStrategy if both are set. In both of these case, the display values generated for the valueMap are the result of calling toString() on each Enum member. If that gives the same value as calling name(), the value is passed through DataTools.deriveTitleFromName(), which applies the same processing rules as DataSource.getAutoTitle to derive a more user-friendly display value. <h4>Further notes</h4> schemaBean implies autoDeriveSchema, because it has no other purpose than to name the bean to use for auto-derived schema. Thus, if you specify schemaBean you do not need to specify autoDeriveSchema as well (though it does no harm to do so). However, tableName and beanClassName can be validly specified without implying autoDeriveSchema, so in those cases you must explicitly specify autoDeriveSchema. The underlying super-DataSource is cached in server memory, so that it does not have to be derived and created each time you need it. However, the cache manager will automatically refresh the cached copy if it detects that the deriving DataSource has changed. Thus, if you change the metadata your DataSource is deriving (if, for example, you add a column to a table), all you need to do is touch the .ds.xml file (ie, update its last changed timestamp - you don't actually have to change it) and the cached copy will be refreshed next time it is needed. When autoDeriveSchema is set, SQLDataSource will automatically discover foreignKeys and deliver table and column name information to the client in hashed form so that two DataSources that are linked by native SQL foreign keys will automatically discover each other if loaded into the same application, and set DataSourceField.foreignKey','foreignKey automatically. Because the table and column names are delivered as cryptohashes, there is no information leakage, but regardless, the feature can be disabled via setting datasource.autoLinkFKs to false in server_properties','server.properties. This hashed linkage information is delivered to the client in properties DataSource.tableCode and DataSourceField.fkTableCode/DataSourceField.fkColumnCode','fkColumnCode
		 * Flags: IR, Group: fields */
		autoDeriveSchema: boolean;

		/** If set, titles are automatically derived from DataSourceField.name','field.name for any field that does not have a DataSourceField.title','field.title and is not marked DataSourceField.hidden','hidden:true, by calling the method DataSource.getAutoTitle.
		 * Flags: IR */
		autoDeriveTitles: boolean;

		/** Causes Tree.discoverTree to be called on dsResponse.data in order to automatically discover tree structures in the response data. If autoDiscoverTree is set, discoverTree() is called after the default dsResponse.data has been derived (OperationBinding.recordXPath','recordXPath and DataSourceField.valueXPath','valueXPath have been applied) and after DataSource.transformResponse has been called. If a DataSourceField is declared with DataSourceField.childrenProperty','childrenProperty:true, discoverTree() will be invoked with DiscoverTreeSettings.newChildrenProperty','settings.newChildrenProperty set to the name of the field marked as the childrenField. Similarly, if the DataSource has a DataSource.titleField it will be used as the DiscoverTreeSettings.nameProperty','settings.nameProperty.
		 * Flags: IR */
		autoDiscoverTree: boolean;

		/** If true, causes all operations on this DataSource to automatically start or join a transaction associated with the current HttpServletRequest. This means that multiple operations sent to the server in a RPCManager.startQueue','request queue will be committed in a single transaction. Note that this includes fetch operations - setting this property to true has the same effect as a transaction policy of ALL for just this DataSource's operations - see the server-side RPCManager.setTransactionPolicy() for details of the different TransactionPolicy settings. If this property is explicitly false, this causes all operations on this DataSource to be committed individually - the same as a transaction policy of NONE, just for this DataSource's operations. In either case, you can override the setting for individual operations - see OperationBinding.autoJoinTransactions. If this property if null or not defined, we fall back to the default setting for this type of DataSource. These are defined in server_properties','server.properties as follows: Hibernate: hibernate.autoJoinTransactions JPA/JPA2: jpa.autoJoinTransactions SQL: There is one setting per configured database connection (DataSource.dbName','dbName). For example, the setting for the default MySQL connection is sql.Mysql.autoJoinTransactions If the setting is not defined at the DataSource-type level, we use the system global default, which is defined in server.properties as autoJoinTransactions. At the dbName and global system levels, you can set the autoJoinTransactions attribute to a valid Transaction Policy, rather than a simple true or false (although these values work too - true is the same as ALL, false is the same as NONE). For valid TransactionPolicy values and their meanings, see the server-side Javadoc for RPCManager.setTransactionPolicy() Note that the configuration settings discussed here can be overridden for a particular queue of requests by setting the server-side RPCManager's transaction policy. Look in the server-side Javadoc for RPCManager.getTransactionPolicy(). Transactions can also be initiated manually, separate from the RPCManager/HttpServletRequest lifecycle, useful for both multi-threaded web applications, and standalone applications that don't use a servlet container - see standaloneDataSourceUsage. NOTE: Setting this property to true does not cause a transactional persistence mechanism to automatically appear - you have to ensure that your DataSource supports transactions. The SmartClient built-in SQL, Hibernate and JPA DataSources support transactions, but note that they do so at the provider level. This means that you can combine updates to, say, an Oracle database and a MySQL database in the same queue, but they will be committed in <em>two</em> transactions - one per database. The SmartClient server will commit or rollback these two transactions as if they were one, so a failure in some Oracle update would cause all the updates to both databases to be rolled back. However, this is not a true atomic transaction; it is possible for one transaction to be committed whilst the other is not - in the case of hardware failure, for example. NOTE: Not all the supported SQL databases are supported for transactions. Databases supported in this release are: DB2 HSQLDB Firebird Informix Microsoft SQL Server MySQL (you must use InnoDB tables; the default MyISAM storage engine does not support transactions) Oracle PostgreSQL 
		 * Flags: IR */
		autoJoinTransactions: boolean;

		/** This property has different meanings depending on the DataSource.serverType','serverType: For SQL DataSources (DataSources with serverType "sql") If set, results from the database will be used to create one instance of the indicated Java bean per database row. Otherwise a Map is used to represent each row retrieved from SQL. With this feature active, a DSResponse from this DataSource will contain a Collection of instances of the indicated beanClassName, available via DSResponse.getData(). This creates a couple of possibilities: <dl> <dt>Add business logic for derived properties, such as computed formulas</dt> <dd>For example, declare a DataSourceField named "revenueProjection". By default this field will call getRevenueProjection() on your bean to retrieve the value to send to the client. Your implementation of getRevenueProjection() could apply some kind of formula to other values loaded from the database.</dd> <dt>Call business logic on retrieved beans via DMI</dt> <dd>By adding a dmiOverview','DMI method that calls DSRequest.execute() to retrieve a DSResponse, you have an opportunity to call business logic methods on the beans representing each row affected by the DSRequest. For example, notify a related BPEL process of changes to certain fields.</dd> </dl> By using beanClassName on a specific OperationBinding, you can: Use a bean to represent your data only when it matters; for example, avoid the overhead of using a bean for "fetch" operations, but do use a bean for "update" operations so that you can execute relevant business logic after the update completes. Skip the use of beans for complex reporting queries that produce results unrelated to your persistent object model. Set beanClassName to blank ("") on a specific operationBinding to override DataSource.beanClassName for that specific operation. For SQL joins that produce additional data fields, use a special, operation-specific bean that represents a join of multiple entities and contains business logic specific to that joined dataset Note that beanClassName affects what numeric field types will be used for inbound DSRequest data. For fields with numeric types, the DSRequest.data','record data in DSRequests will automatically be converted to the type of the target field, before the request is received in a DMI. For details, see dsRequestBeanTypes. Note that dmiOverview','DMI also has a built-in facility for populating a bean with the inbound DSRequest.data - just declare the bean as a method argument. For generic DataSources (DataSources with serverType "generic") visualBuilder','Visual Builder sets this property when it creates a generic DataSource using the Javabean Wizard. It has no built-in server-side effects. For Hibernate DataSources (DataSources with serverType "hibernate") The name of the Java bean or POJO class that is mapped in Hibernate. This will typically be the fully-qualified class name - eg com.foo.MyClass - but it may be the simple class name - just MyClass - or it may be some other value. It all depends on how your classes have been mapped in Hibernate. The declared Java bean will affect how its properties will be mapped to built-in numeric types, see hibernateIntegration','Hibernate Integration overview for details. Note: If you are intending to use Hibernate as a data-access layer only, you do not need to create Hibernate mappings or Java objects: SmartClient will generate everything it needs on the fly. For JPA DataSources (DataSources with serverType "jpa" or "jpa1") The fully qualified class name of the JPA annotated entity. NOTE for Hibernate and JPA users: When you use JPA, or use Hibernate as a full ORM system (ie, not just allowing SmartClient Server to drive Hibernate as a data access layer), the beans returned on the server-side are live. This means that if you make any changes to them, the ORM system will persist those changes. This is true even if the beans were created as part of a fetch operation. This causes a problem in the common case where you want to use a DMI or custom DataSource implementation to apply some post-processing to the beans fetched from the persistent store. If you change the values in the beans directly, those changes will be persisted. If you want to alter the data returned from a JPA or Hibernate persistent store as part of a fetch request just so you can alter what gets sent to the client, you can use the server-side DSResponse's getRecords() method. This will return your bean data in "record" format - ie, as a List of Maps. You can alter these records without affecting your persistent store, and then call setData() on the DSResponse), passing the altered list of records. See the server-side Javadocs for DSResponse for details of these two methods.
		 * Flags: IR */
		beanClassName: string /* String */;

		/** When DataSource.cacheAllData','cacheAllData mode is enabled and a DataSource.cacheAllOperationId has been set, this flag affects whether cached results are used for all "fetch" requests regardless of their DSRequest.operationId, or are used only for "fetch" requests that use the cacheAllOperationId, allowing other requests to go to server normally. Default of true means that the cacheAllOperationId will be used to fetch all rows, but the resulting cache will be used for all "fetch" operations regardless of the operationId specified on the request. Switching to "false" effectively creates caching just for one specific operationId - the cacheAllOperationId - while allowing all other requests to go to the server normally.
		 * Flags: IR, Group: clientData */
		cacheAcrossOperationIds: boolean /* Boolean */;

		/** Set this property to true to have a DataSource fetch all of its data client-side on the first fetch request. However, unlike a DataSource.clientOnly','clientOnly DataSource, this DataSource will still save changes normally, sending remote requests. You can manually set this attribute after initialization by calling DataSource.setCacheAllData; setting DataSource.autoCacheAllData:true causes a DataSource to automatically switch to cacheAllData:true when a fetch results in the entire dataset being brought client-side. To cause automatic cache updates, you can set DataSource.cacheMaxAge to a number of seconds and once data has been client-side for that length of time, the next fetch causes the cache to be dropped and a new cache retrieved. Note that multiple DataSource.operationBindings of type "fetch" which return distinct results will not work with cacheAllData: only one cache is created and is used for all fetch operations, regardless of whether DSRequest.operationId has been set. However, "fetch" operationBindings used as a OperationBinding.cacheSyncOperation will work normally, so long as they return all data fields that are returned by the default "fetch" operation, so that the cache can be updated. To specify which operationId to use for fetching all data, use DataSource.cacheAllOperationId','cacheAllOperationId. To use the cache only for requests that have the cacheAllOperationId, allowing any other operationId (or absence of an operationId) to contact the server as normal, set DataSource.cacheAcrossOperationIds','cacheAcrossOperationIds.
		 * Flags: IRW, Group: clientData */
		cacheAllData: boolean /* Boolean */;

		/** DSRequest.operationId to use for fetching data in case DataSource.cacheAllData','cacheAllData is true. By default a standard fetch operation is used (with no operationId specified).
		 * Flags: IR, Group: clientData */
		cacheAllOperationId: string /* String */;

		/** For a DataSource.cacheAllData or client-only DataSource, a set of records to use as a dataset, specified as an Array of JavaScript Objects representing records.
		 * Flags: IRW, Group: clientData */
		cacheData: Array<any> /* Array of Record */;

		/** The maximum time, in seconds, to maintain the client-side cache. If a fetch occurs after the cacheMaxAge has expired, the current cache will be dropped and another complete cache fetched.
		 * Flags: IRW, Group: clientData */
		cacheMaxAge: number /* Number */;

		/** Applies only to dataFormat: "json" and DataSource.dataTransport:"scriptInclude". Specifies the name of the query parameter that tells your JSON service what function to call as part of the response.
		 * Flags: IR, Group: clientDataIntegration */
		callbackParam: string /* String */;

		/** When true, indicates that this DataSource supports multi-level sorting.
		 * Flags: IR */
		canMultiSort: boolean;

		/** fieldName for a field in the dataSource expected to contain an explicit array of child nodes. Enables loading a databound tree as a hierarchical data structure, rather than a flat list of nodes linked by foreignKey. Note this is an alternative to setting DataSourceField.childrenProperty directly on the childrenField object. By default the children field will be assumed to be DataSourceField.multiple','multiple, for XML databinding. This implies that child data should be delivered in the format: &lt;childrenFieldName&gt; &lt;item name="firstChild" ...&gt; &lt;item name="secondChild" ...&gt; &lt;/childrenFieldName&gt; However data may also be delivered as a direct list of childrenFieldName elements: &lt;childrenFieldName name="firstChild" ...&gt; &lt;childrenFieldName name="secondChild" ...&gt; If you want to return your data in this format, you will need to explicitly set multiple to false in the appropriate dataSource field definition.
		 * Flags: IR, Group: dataSourceRelations */
		childrenField: string;

		/** A clientOnly DataSource simulates the behavior of a remote data store by manipulating a static dataset in memory as DSRequest','DSRequests are executed on it. Any changes are lost when the user reloads the page or navigates away. A clientOnly DataSource will return responses asynchronously, just as a DataSource accessing remote data does. This allows a clientOnly DataSource to be used as a temporary placeholder while a real DataSource is being implemented - if a clientOnly DataSource is replaced by a DataSource that accesses a remote data store, UI code for components that used the clientOnly DataSource will not need be changed. A clientOnly DataSource can also be used as a shared cache of modifiable data across multiple UI components when immediate saving is not desirable. In this case, several components may interact with a clientOnly DataSource and get the benefit of ResultSet behaviors such as automatic cache sync and in-browser data filtering and sorting. When it's finally time to save, DataSource.cacheData can be inspected for changes and data can be saved to the original DataSource via DataSource.addData, DataSource.updateData and DataSource.removeData, possibly in a RPCManager.startQueue','transactional queue. Note that DataSource.getClientOnlyDataSource lets you easily obtain a clientOnly DataSource representing a subset of the data available from a normal DataSource. See also DataSource.cacheAllData - a cacheAllData behaves like a write-through cache, performing fetch and filter operations locally while still performing remote save operations immediately. ClientOnly DataSources can be populated programmatically via DataSource.cacheData - see clientOnlyDataSources','this discussion for other ways to populate a client-only DataSource with data.
		 * Flags: IR, Group: clientOnlyDataSources */
		clientOnly: boolean /* Boolean */;

		/** For DataSources of DataSource.serverType','serverType "hibernate", the name of a Spring bean to query to obtain Hibernate Configuration for this particular DataSource. Note that this is intended for DataSource-specific configuration overrides for unusual circumstances, such as a DataSource whose physical data store is a completely different database to that used by other DataSources. See the hibernateIntegration','Integration with Hibernate article for more information
		 * Flags: IRA, Group: serverDataIntegration */
		configBean: string /* String */;

		/** Indicates that declarative security rules are waived for rows that were created by the current user. Practically, this means that when a security check fails, instead of a security exception being thrown, we alter the criteria to ensure that the request can only return or affect rows that were created by the current authenticated user. This allows you to create security regimes whereby users can see and edit data they created, but have access to other users' data forbidden or limited. In order for this to work, we require two things: The DataSource must specify a field of type "creator" - this field type is described on FieldType','this page The authentication regime in use must include the idea of a "current user". The authentication provided by the Servlet API is an example of such a regime. This setting can be overridden at operationBinding and field level, allowing extremely fine-grained control.
		 * Flags: IR, Group: fieldLevelAuth */
		creatorOverrides: boolean;

		/** Decides under what conditions the ResultSet cache should be dropped when the ResultSet.criteria changes.
		 * Flags: IRWA */
		criteriaPolicy: CriteriaPolicy;

		/** Name of the field that has the most pertinent numeric, date, or enum value, for use when a DataBoundComponent needs to show a short summary of a record. For example, for a DataSource of employees, good choices might be the "salary" field, "hire date" or "status" (active, vacation, on leave, etc). Unlike DataSource.titleField, dataField is not automatically determined in the absence of an explicit setting.
		 * Flags: IR, Group: dsSpecialFields */
		dataField: string /* String */;

		/** Indicates the format to be used for HTTP requests and responses when fulfilling DSRequests (eg, when DataSource.fetchData is called).
		 * Flags: IR, Group: clientDataIntegration */
		dataFormat: DSDataFormat;

		/** Controls the format in which inputs are sent to the dataURL when fulfilling DSRequests. May be overridden for individual request types using OperationBinding.dataProtocol','operation bindings.
		 * Flags: IR, Group: clientDataIntegration */
		dataProtocol: DSProtocol;

		/** Transport to use for all operations on this DataSource. Defaults to RPCManager.defaultTransport. This would typically only be set to enable "scriptInclude" transport for contacting DataSource.dataFormat','JSON web services hosted on servers other than the origin server. When using the "scriptInclude" transport, be sure to set DataSource.callbackParam or OperationBinding.callbackParam to match the name of the query parameter name expected by your JSON service provider.
		 * Flags: IR, Group: clientDataIntegration */
		dataTransport: RPCTransport;

		/** Default URL to contact to fulfill all DSRequests. Can also be set on a per-operationType basis via OperationBinding.dataURL. NOTE: Best practice is to use the same dataURL for all DataSources which fulfill DSRequests via the server-side RPCManager API. Otherwise, cross-DataSource RPCManager.startQueue','operation queuing will not be possible.
		 * Flags: IR, Group: clientDataIntegration */
		dataURL: string /* URL */;

		/** For DataSources using the sqlDataSource','SmartClient SQL engine for persistence, which database configuration to use. Database configurations can be created using the adminConsole','Admin Console. If unset, the default database configuration is used (which is also settable using the "Databases" tab).
		 * Flags: IR, Group: serverDataIntegration */
		dbName: string /* String */;

		/** Before we start editing values in DataBoundComponents bound to this dataSource, should we perform a deep clone of the underlying values (a "deep clone" is one created by traversing the original values object recursively, cloning the contents of nested objects and arrays). If this flag is explicitly set to false, we perform a shallow clone of the underlying values before edit (a "shallow clone" is a copy created by simply copying the top-level attributes of an object). If this flag is not explicitly set, it defaults to the value of the same-named static property, DataSource.deepCloneOnEdit. This flag can also be overridden per-component and per-field - see DataBoundComponent.deepCloneOnEdit and DataSourceField.deepCloneOnEdit. Note, this flag only has an effect if you are editing a values object that contains nested objects or arrays, using Canvas.dataPath','dataPaths. When editing "flat" data - the mainstream case - there is no difference between a deep clone and a shallow clone.
		 * Flags: IRWA */
		deepCloneOnEdit: boolean /* Boolean */;

		/** For DataSource.serverType','serverType:"sql" DataSources, sets the default DataSourceField.sqlStorageStrategy','sqlStorageStrategy to use for boolean fields where no sqlStorageStrategy has been declared on the field. Can also be set system-wide via the server_properties setting sql.defaultBooleanStorageStrategy, or for a particular database configuration by setting sql.dbName.defaultBooleanStorageStrategy (see adminConsole','Admin Console overview for more information on SQL configuration). Note that when this property is unset, the default DataSourceField.sqlStorageStrategy strategy is effectively "string".
		 * Flags: IR, Group: serverDataIntegration */
		defaultBooleanStorageStrategy: string /* String */;

		/** Controls when primary keys are required for "update" and "remove" server operations, when allowMultiUpdate has not been explicitly configured on either the OperationBinding.allowMultiUpdate','operationBinding.allowMultiUpdate or via the server-side API DSRequest.setAllowMultiUpdate(). Default value of null means this DataSource will use the system-wide default, which is set via datasources.defaultMultiUpdatePolicy in server_properties','server.properties, and defaults to allowing multi updates for requests associated with an RPCManager, see MultiUpdatePolicy for details.
		 * Flags: IR */
		defaultMultiUpdatePolicy: MultiUpdatePolicy;

		/** The default textMatchStyle to use for DSRequests that do not explicitly state a DSRequest.textMatchStyle','textMatchStyle. Note, however, that DSRequests issued by ListGrids and other DataBoundComponent','components will generally have a setting for textMatchStyle on the component itself (see ListGrid.autoFetchTextMatchStyle, for example).
		 * Flags: IR, Group: clientDataIntegration */
		defaultTextMatchStyle: TextMatchStyle;

		/** Name of the field that has a long description of the record, or has the primary text data value for a record that represents an email message, SMS, log or similar. For example, for a DataSource representing employees, a field containing the employee's "bio" might be a good choice, or for an email message, the message body. If descriptionField is unset, it defaults to any field named "description" or "desc" in the record, or the first long text field (greater than 255 characters) in the record, or null if no such field exists.
		 * Flags: IR, Group: dsSpecialFields */
		descriptionField: string /* String */;

		/** Settings to use when discoverTree() is automatcially called because DataSource.autoDiscoverTree is set to true for this DataSource
		 * Flags: IR */
		discoverTreeSettings: any /* DiscoverTreeSettings */;

		/** Indicates that for server responses, for any data being interpreted as DataSource records, only data that corresponds to declared fields should be retained; any extra fields should be discarded. For DataSource.dataFormat','JSON data, this means extra properties in selected objects are dropped. By default, for DMI DSResponses, DSResponse.data is filtered on the server to just the set of fields defined on the DataSource. This type of filtering can also be enabled for non-DMI DSResponses (see the overview in dmiOverview','DMI). Setting this property to false disables this filtering for this DataSource only. This setting overrides the configuration in server_properties','server.properties. This setting can be overridden by ServerObject.dropExtraFields.
		 * Flags: IR, Group: clientDataIntegration */
		dropExtraFields: boolean;

		/** If the criteria applied to a fetch type operation contain fields that are not present in the dataSource, should they be ignored when performing filtering on the client. This property is useful for cases where you custom server logic makes use of criteria values to determine what set of records to return to the client, but the data does not actually have record values for these fields and as such the client-side filtering logic should ignore them.
		 * Flags: IR */
		dropUnknownCriteria: boolean /* Boolean */;

		/** If we are DataSource.progressiveLoading','loading progressively, indicates the number of extra records SmartClient Server will advertise as being available, if it detects that there are more records to view (see DataSource.lookAhead','lookAhead). This property has no effect if we are not progressive-loading.
		 * Flags: IRW, Group: progressiveLoading */
		endGap: number /* int */;

		/** The name of the property this DataSource uses for constant name when translating Java enumerated types to and from Javascript, if the EnumTranslateStrategy is set to "bean". Defaults to "_constant" if not set. This property is only applicable if you are using the SmartClient server
		 * Flags: IA */
		enumConstantProperty: string /* String */;

		/** The name of the property this DataSource uses for ordinal number when translating Java enumerated types to and from Javascript, if the EnumTranslateStrategy is set to "bean". Defaults to "_ordinal" if not set. This property is only applicable if you are using the SmartClient server
		 * Flags: IA */
		enumOrdinalProperty: string /* String */;

		/** Sets the strategy this DataSource uses to translate Java enumerated types (objects of type enum) to and from Javascript. This property is only applicable if you are using the SmartClient server
		 * Flags: IA */
		enumTranslateStrategy: EnumTranslateStrategy;

		/** The list of fields that compose records from this DataSource. Each DataSource field can have type, user-visible title, validators, and other metadata attached. After a DataSource has been Class.create','created, access the list of fields via DataSource.getFieldNames and access individual fields via DataSource.getField. 
		 * Flags: IR, Group: fields */
		fields: Array<DataSourceField> /* Array of DataSourceField */;

		/** The native field name used by this DataSource on the server to represent the fileContents for fileSource','FileSource Operations. If the fileContentsField is not configured, then a field named "fileContents" or "contents" will be used, if it exists. <!-- If not found, the first field with a "binary" type will be used. TODO: Binary field support not working yet. --> If not found, the longest text field which is not the DataSource.fileNameField','fileNameField, DataSource.fileTypeField','fileTypeField or DataSource.fileFormatField','fileFormatField will be used. Note that the only method which will actually return the fileContents is DataSource.getFile','getFile() -- the other fileSource','FileSource methods omit the fileContents for the sake of efficiency.
		 * Flags: IR, Group: fileSource */
		fileContentsField: string /* String */;

		/** The native field name used by this DataSource on the server to represent the fileFormat for fileSource','FileSource Operations. If the fileFormatField is not configured, then a field named "fileFormat" will be used, if it exists. Otherwise, the DataSource will not track fileFormats -- this may be acceptable if, for instance, the fileFormat is always the same. The fileFormat is specified according to the extension that would have been used in the filesystem -- for instance, the fileFormat for employees.ds.xml would be "xml".
		 * Flags: IR, Group: fileSource */
		fileFormatField: string /* String */;

		/** The native field name used by this DataSource on the server to represent fileLastModified for fileSource','FileSource Operations. If the fileLastModifiedField is not configured, then a field named "fileLastModified" will be used, if it exists. <!-- TODO: Binary fields? --> Otherwise, the server will look for a field with a "modifierTimestamp" type. If that is not found, the DataSource will not keep track of the last modified date.
		 * Flags: IR, Group: fileSource */
		fileLastModifiedField: string /* String */;

		/** The native field name used by this DataSource on the server to represent the fileName for fileSource','FileSource Operations operations. Any extensions to the fileName to indicate type or format (e.g. ".ds.xml") are stored in the DataSource.fileTypeField','fileTypeField and DataSource.fileFormatField','fileFormatField, if specified for this DataSource. If not specified for a DataSource, the fileNameField will be inferred on the server as follows: <!-- f the DataSource.fileContentsField is binary, then we use the filename field which corresponds to the binary field, if it exists. TODO: Not implemented yet. --> If there is a field named "fileName", "name", or "title", then that field is used. Otherwise, if there is a single primary key, and it has the type "text", then that field is used. Otherwise, an error is logged 
		 * Flags: IR, Group: fileSource */
		fileNameField: string /* String */;

		/** The native field name used by this DataSource on the server to represent the fileType for fileSource','FileSource Operations. If the fileTypeField is not configured, then a field named "fileType" will be used, if it exists. Otherwise, the DataSource will not track fileTypes -- this may be acceptable if, for instance, you use a separate DataSource for each fileType. The fileType is specified according to the extension that would have been used in the filesystem -- for instance, the fileType for employees.ds.xml would be "ds".
		 * Flags: IR, Group: fileSource */
		fileTypeField: string /* String */;

		/** The native field name used by this DataSource on the server to represent fileVersion for fileSource','FileSource Operations. Automatic file versioning is configured by the presence of this property: if you want automatic versioning for a FileSource DataSource, it is sufficient to simply define a fileVersionField. When automatic versioning is on: Calls to DataSource.saveFile will save a new version of the file, retaining previous versions up to the maximum configured by DataSource.maxFileVersions; when that maximum is reached, the oldest version is overwritten The DataSource.getFile API always returns the most recent version The DataSource.listFiles API only includes the most recent version of any file You can view and retrieve earlier versions of a file with the DataSource.listFileVersions and DataSource.getFileVersion APIs. Note that retrieving a previous version of a file and then calling saveFile() goes through the normal process of saving a new version The fileVersion field is expected to be of type "datetime", and automatic versioning will not work otherwise. Note, to minimize the possibility of version timestamp collisions, we recommend that fileVersion fields specify DataSourceField.storeMilliseconds','storeMilliseconds: true. If the fileVersionField is not configured, no automatic file versioning will be done.
		 * Flags: IR, Group: fileSource */
		fileVersionField: string /* String */;

		/** Namespaces definitions to add to the root element of outbound XML messages sent to a web service, as a mapping from namespace prefix to namespace URI. The default value is: globalNamespaces : { xsi: "http://www.w3.org/2001/XMLSchema-instance", xsd: "http://www.w3.org/2001/XMLSchema" }, This default value allows the use of the xsi:type and xsi:nil attributes without further declarations. Note that some web services will only accept specific revisions of the XML Schema URI. If xsi-namespaced attributes seem to be ignored by an older webservice, try the URI "http://www.w3.org/1999/XMLSchema-instance" instead.
		 * Flags: IRW */
		globalNamespaces: any /* Object */;

		/** Value to use for the DataSource.ownerIdField','ownerIdField if no one has authenticated. This setting can be overridden at the operationBinding level.
		 * Flags: IR */
		guestUserId: string;

		/** Designates a field of FieldType','type:"image" as the field to use when rendering a record as an image, for example, in a TileGrid. For example, for a DataSource of employees, a "photo" field of type "image" should be designated as the iconField. If not explicitly set, iconField looks for fields named "picture", "thumbnail", "icon", "image" and "img", in that order, and will use any of these fields as the iconField if it exists and has type "image". To avoid any field being used as the iconField, set iconField to null.
		 * Flags: IR, Group: dsSpecialFields */
		iconField: string;

		/** Unique identifier for this DataSource. Required for all DataSources. DataSources will make themselves available as JavaScript globals under the same name as their ID only if DataSource.addGlobalId is set.
		 * Flags: IR, Group: identity */
		ID: string;

		/** For JPA and Hibernate DataSources this property indicates, that data source has composite primary key and specifies fully-qualified Java class: with @EmbeddedId you have to specify class name of declared id with @IdClass you have to specify class specified in annotation declaration
		 * Flags: IR, Group: fields */
		idClassName: string;

		/** For fields on this dataSource that specify DataSourceField.ignoreTextMatchStyle','ignoreTextMatchStyle true, the prevailing textMatchStyle is ignored and SmartClient matches exact values. This property dictates whether that match is case-sensitive like the "exactCase" textMatchStyle, or case-insensitive like the "exact" textMatchStyle (the default). Please see the TextMatchStyle','TextMatchStyle documentation for a discussion of the nuances of case-sensitive matching.
		 * Flags: IR */
		ignoreTextMatchStyleCaseSensitive: boolean /* Boolean */;

		/** Criteria that are implicitly applied to all fetches made through this DataSource. These criteria are never shown to or edited by the user and are cumulative with any other criteria provided on the DSRequest. For example, a DataSource might *always* implicitly limit its fetch results to records owned by the current user's department. Components and ResultSets requesting data from the DataSource can then apply further implicitCriteria of their own, separately from their regular, user-editable criteria. For instance, a grid bound to this dataSource might be further limited to implicitly show only the subset of records created by the current user. See DataBoundComponent.implicitCriteria and ResultSet.implicitCriteria for more on these localized options.
		 * Flags: IRW */
		implicitCriteria: Criteria;

		/** Name of the field that has the second most pertinent piece of textual information in the record, for use when a DataBoundComponent needs to show a short summary of a record. For example, for a DataSource of employees, a "job title" field would probably be the second most pertinent text field aside from the employee's "full name". Unlike DataSource.titleField, infoField is not automatically determined in the absence of an explicit setting.
		 * Flags: IR, Group: dsSpecialFields */
		infoField: string /* String */;

		/** For dataSources of DataSource.serverType','serverType "sql" and "hibrenate", specifies the inheritance mode to use. This property has no effect for any other type of DataSource.
		 * Flags: IR, Group: fields */
		inheritanceMode: DSInheritanceMode;

		/** ID of another DataSource this DataSource inherits its DataSource.fields from. Local fields (fields defined in this DataSource) are added to inherited fields to form the full set of fields. Fields with the same name are merged in the same way that DataBoundComponent.fields','databound component fields are merged with DataSource fields. The default order of the combined fields is new local fields first (including any fields present in the parent DataSource which the local DataSource re-declares), then parent fields. You can set DataSource.useParentFieldOrder to instead use the parent's field order, with new local fields appearing last. You can set DataSource.showLocalFieldsOnly to have all non-local fields hidden. Note that only fields are inherited - other properties such as dataURL and dataFormat are not. You can use ordinary inheritance, that is, creating a subclass of DataSource, in order to share properties such as dataURL across a series of DataSources that also inherit fields from each other via inheritsFrom. This feature can be used for: creating a customized view (eg, only certain fields shown) which will be used by multiple DataBoundComponent','databound components. adding presentation-specific attributes to metadata that has been automatically derived from XMLTools.loadXMLSchema','XML Schema or other metadata formats modeling object subclassing and extension in server-side code and storage systems modeling relational database joins, and the equivalents in other systems creating hooks for others to customize your application in a maintainable way. For example, if you have a dataSource "employee", you can create a dataSource "customizedEmployee" which inherits from "employee" but does not initially define any fields, and bind all DataBoundComponent','databound components to "customizedEmployee". Customizations of fields (including appearance changes, field order, new fields, hiding of fields, and custom validation rules) can be added to "customizedEmployee", so that they are kept separately from the original field data and have the best possible chance of working with future versions of the "employee" dataSource. 
		 * Flags: IR, Group: fields */
		inheritsFrom: string /* DataSource ID */;

		/** Allows you to specify an arbitrary prefix string to apply to all json format responses sent from the server to this application. The inclusion of such a prefix ensures your code is not directly executable outside of your application, as a preventative measure against <a href='http://www.google.com/search?q=javascript+hijacking' target='_blank'>javascript hijacking</a>. Only applies to responses formatted as json objects. Does not apply to responses returned via scriptInclude type transport. Note: If the prefix / suffix served by your backend is not a constant, you can use OperationBinding.dataFormat','dataFormat:"custom" instead and explicitly parse the prefix out as part of DataSource.transformResponse','transformResponse().
		 * Flags: IRA */
		jsonPrefix: string /* String */;

		/** Allows you to specify an arbitrary suffix string to apply to all json format responses sent from the server to this application. The inclusion of such a suffix ensures your code is not directly executable outside of your application, as a preventative measure against <a href='http://www.google.com/search?q=javascript+hijacking' target='_blank'>javascript hijacking</a>. Only applies to responses formatted as json objects. Does not apply to responses returned via scriptInclude type transport.
		 * Flags: IRA */
		jsonSuffix: string /* String */;

		/** If we are DataSource.progressiveLoading','loading progressively, indicates the number of extra records SmartClient Server will read beyond the end record requested by the client, in order to establish if there are more records to view. This property has no effect if we are not progressive-loading. This property can be tweaked in conjunction with DataSource.endGap','endGap to change behavior at the end of a dataset. For example, with the default values of lookAhead: 1 and endGap: 20, we can end up with the viewport shrinking if we get a case where there really was only one more record (because the client was initially told there were 20 more). This is not a problem per se, but it may be surprising to the user. You could prevent this happening (at the cost of larger reads) by setting lookAhead to be endGap+1.
		 * Flags: IRW, Group: progressiveLoading */
		lookAhead: number /* int */;

		/** If DataSource.fileVersionField','automatic file versioning is enabled for a FileSource DataSource, this property configures the maximum number of versions to retain.
		 * Flags: IR, Group: fileSource */
		maxFileVersions: number /* Integer */;

		/** When true, indicates that fields in this DataSource will never be positively updated to the null value; they may arrive at null values by being omitted, but we will not send actual null values in update requests. When false (the default), null is not treated in any special way. Setting this value causes null-assigned fields to be replaced with the field's DataSourceField.nullReplacementValue','nullReplacementValue, if one is declared. If no nullReplacementValue is declared for the field, the null assignment is replaced with the DataSource's DataSource.nullStringValue','nullStringValue, DataSource.nullIntegerValue','nullIntegerValue, DataSource.nullFloatValue','nullFloatValue or DataSource.nullDateValue','nullDateValue, depending on the field type. For "add" operations, setting DataSource.omitNullDefaultsOnAdd','omitNullDefaultsOnAdd causes null-valued fields to be removed from the request entirely, rather than replaced with default values as described above.
		 * Flags: IR */
		noNullUpdates: boolean;

		/** If DataSource.noNullUpdates is set, the value to use for any boolean field that has a null value assigned on an update operation, and does not specify an explicit DataSourceField.nullReplacementValue','nullReplacementValue.
		 * Flags: IR */
		nullBooleanValue: boolean;

		/** If DataSource.noNullUpdates is set, the value to use for any date or time field that has a null value assigned on an update operation, and does not specify an explicit DataSourceField.nullReplacementValue','nullReplacementValue. Unlike strings and numbers, there is no "natural" choice for a null replacement value for dates. The default value we have chosen is midnight on January 1st 1970, simply because this is "the epoch" - the value that is returned by calling "new Date(0)"
		 * Flags: IR */
		nullDateValue: Date;

		/** If DataSource.noNullUpdates is set, the value to use for any float field that has a null value assigned on an update operation, and does not specify an explicit DataSourceField.nullReplacementValue','nullReplacementValue.
		 * Flags: IR */
		nullFloatValue: number /* float */;

		/** If DataSource.noNullUpdates is set, the value to use for any integer field that has a null value assigned on an update operation, and does not specify an explicit DataSourceField.nullReplacementValue','nullReplacementValue.
		 * Flags: IR */
		nullIntegerValue: number /* int */;

		/** If DataSource.noNullUpdates is set, the value to use for any text field that has a null value assigned on an update operation, and does not specify an explicit DataSourceField.nullReplacementValue','nullReplacementValue.
		 * Flags: IR */
		nullStringValue: string /* String */;

		/** When true, and DataSource.noNullUpdates','noNullUpdates is also true, indicates that "add" requests on this DataSource will have null-valued fields removed from the request entirely before it is sent to the server, as opposed to the default behavior of replacing such null values with defaults.
		 * Flags: IR */
		omitNullDefaultsOnAdd: boolean;

		/** Optional array of OperationBindings, which provide instructions to the DataSource about how each DSOperation is to be performed. When using the SmartClient Server, OperationBindings are specified in your DataSource descriptor (.ds.xml file) and control server-side behavior such as what Java object to route DSRequest to (OperationBinding.serverObject) or customizations to SQL, JQL and HQL queries (OperationBinding.customSQL, OperationBinding.customJQL and OperationBinding.customHQL). See the javaDataIntegration', 'Java Integration samples. For DataSources bound to WSDL-described web services using DataSource.serviceNamespace, OperationBindings are used to bind each DataSource OperationBinding.operationType','operationType to an OperationBinding.wsOperation','operation of a WSDL-described WebService','web service, so that a DataSource can both fetch and save data to a web service. For example, this code accomplishes part of the binding to the <a href='http://www.google.com/search?q=sforce+partner+wsdl' target='_blank'>SalesForce partner web services</a> isc.DataSource.create({ serviceNamespace : "urn:partner.soap.sforce.com", operationBindings : [ { operationType:"fetch", wsOperation:"query", recordName: "sObject" }, { operationType:"update", wsOperation:"update", recordName: "SaveResult" }, { operationType:"add", wsOperation:"create", recordName: "SaveResult" }, { operationType:"remove", wsOperation:"delete", recordName: "DeleteResult" } ], ... }); NOTE: additional code is required to handle authentication and other details, see the complete code in smartclientSDK/examples/databinding/SalesForce. For DataSources that contact non-WSDL-described XML or JSON services, OperationBindings can be used to separately configure the URL, HTTP method, input and output processing for each operationType. This makes it possible to fetch JSON data from one URL for the "fetch" operationType and save to a web service for the "update" operationType, while appearing as a single integrated DataSource to a DataBoundComponent such as an ListGrid.canEdit','editable ListGrid. If no operationBinding is defined for a given DataSource operation, all of the properties which are valid on the operationBinding are checked for on the DataSource itself. This also means that for a read-only DataSource, that is, a DataSource only capable of fetch operations, operationBindings need not be specified, and instead all operationBinding properties can be set on the DataSource itself. An example of using OperationBinding properties directly on the DataSource in order to read an RSS feed can be found here: ${isc.DocUtils.linkForStandaloneExample('/examples/databinding/rss_databinding.html', '/examples/databinding/rss_databinding.html')}
		 * Flags: IR */
		operationBindings: Array<OperationBinding> /* Array of OperationBinding */;

		/** Requires that the currently authenticated user match the contents of this field, for client-initiated requests (i.e., where DSRequest.isClientRequest() returns true on the server). When a new row is added by a client-initiated DSRequest, the ownerIdField will be automatically populated with the currently authenticated user (clobbering any value supplied by the client). Client-initiated attempts to update the ownerIdField will also be prevented. If you wish to set the ownerIdField to a different value via an "add" or "update" operation, you can do so in server-side DMI code (possibly consulting DSRequest.getClientSuppliedValues() to get the value that was clobbered). For client-initiated "fetch", "update" or "remove" operations, the server will modify client-supplied criteria so that only rows whose ownerIdField matches the currently authenticated user can be read, updated or deleted. The ownerIdField setting can be overridden at the OperationBinding.ownerIdField level. If ownerIdField is specified, DataSource.requiresAuthentication','requiresAuthentication will default to true. If requiresAuthentication is explicitly set to false, then unauthenticated users will be able to see all records. To avoid this, you can use DataSource.guestUserId','guestUserId to specify a default user to apply when no one has authenticated.
		 * Flags: IR */
		ownerIdField: string;

		/** When using the patternOperators','pattern operators OperatorId','search operator, character that escapes the DataSource.patternSingleWildcard or DataSource.patternMultiWildcard if placed before it, so that it is treated as a literal character.
		 * Flags: IR */
		patternEscapeChar: string /* String */;

		/** When using the patternOperators','pattern operators OperatorId','search operator, character that matches a series of one or more characters. Pass multiple strings to provide multiple alternative wildcards.
		 * Flags: IR */
		patternMultiWildcard: Array<string> /* String | Array of String */;

		/** When using the patternOperators','pattern operators OperatorId','search operator, character that matches any single character. Pass multiple strings to provide multiple alternative wildcards.
		 * Flags: IR */
		patternSingleWildcard: Array<string> /* String | Array of String */;

		/** User-visible plural name for this DataSource. For example, for the supplyItem DataSource, "Supply Items". Defaults to dataSource.title + "s".
		 * Flags: IR, Group: titles */
		pluralTitle: string;

		/** If set, the DataSource will ensure that it never uses a cached HTTP response, even if the server marks the response as cacheable. Note that this does not disable caching at higher levels in the framework, for example, the caching performed by ResultSet.
		 * Flags: IR */
		preventHTTPCaching: boolean /* Boolean */;

		/** If true, causes SmartClient Server to use the "progressive loading" pattern for fetches on this dataSource, as described in the Paging and total dataset length section of the ResultSet','ResultSet documentation. Essentially, this means that we avoid issuing a row count query and instead advertise total rows as being slightly more than the number of rows we have already read (see DataSource.endGap','endGap). This allows users to load more of a dataset by scrolling past the end of the currently-loaded rows, but it prevents them from scrolling directly to the end of the dataset. Generally, progressive loading is appropriate when you have to deal with very large datasets. Note that by default, a dataSource will switch into progressive loading mode automatically when it detects that it is dealing with a dataset beyond a certain size - see DataSource.progressiveLoadingThreshold. This setting can be overridden for individual fetch operations with the OperationBinding.progressiveLoading property, and also at the level of the individual DSRequest.progressiveLoading','DSRequest. You can also specify progressiveLoading on DataBoundComponent.progressiveLoading','DataBoundComponents and certain types of FormItem - SelectItem.progressiveLoading','SelectItem and ComboBoxItem.progressiveLoading','ComboBoxItem. Currently, this property only applies to users of the built-in SQLDataSource, but you could use it in custom DataSource implementations to trigger the server behavior described in the ResultSet documentation linked to above.
		 * Flags: IRW, Group: progressiveLoading */
		progressiveLoading: boolean;

		/** Indicates the dataset size that will cause SmartClient Server to automatically switch into DataSource.progressiveLoading','progressive loading mode for this DataSource. To prevent automatic switching to progressive loading, set this property to -1.
		 * Flags: IRW, Group: progressiveLoading */
		progressiveLoadingThreshold: number /* int */;

		/** For DataSources with type DSServerType','projectFile, looks up the locations to use as DataSource.projectFileLocations','projectFileLocations from the project's configuration (i.e. project.properties, server_properties','server.properties etc.). For instance, to look up the value of project.datasources and use it for projectFileLocations, use "datasources" as the projectFileKey. If you specify both projectFileKey and projectFileLocations, then both with be used, with the projectFileLocations applied last.
		 * Flags: IR, Group: fileSource */
		projectFileKey: string /* String */;

		/** For DataSources with type DSServerType','projectFile, specifies locations for the project files. In XML, each location is expressed with a &lt;location&gt; tag, e.g.: &lt;projectFileLocations&gt; &lt;location&gt;[WEBROOT]/shared/ds&lt;/location&gt; &lt;location&gt;ds://datasources&lt;/location&gt; &lt;/projectFileLocations&gt; Directories should be specified as absolute paths on the server. If you want to construct a webroot-relative path, then prefix the path with [WEBROOT] (unlike in server_properties','server.properties, where you would use $webRoot as the prefix). To specify another DataSource to be used via fileSource','fileSource operations, use ds://dsName (where "dsName" is the name of the other DataSource). A projectFile DataSource uses the standard fileSource','fileSource field names: fileName, fileType, fileFormat, fileContents, fileSize and fileLastModified. When defining a projectFile DataSource, you can use DataSource.inheritsFrom','inheritsFrom with a value of "ProjectFile" to inherit definitions for these fields -- e.g.: &lt;DataSource ID="MyDataSources" type="projectFile" inheritsFrom="ProjectFile"&gt; &lt;projectFileLocations&gt; &lt;location&gt;[WEBROOT]/shared/ds&lt;/location&gt; &lt;location&gt;ds://datasources&lt;/location&gt; &lt;/projectFileLocations&gt; &lt;/DataSource&gt; For directory locations, the fileName is relative to the directory specified. Note that the fileName does not include any extension for type or format. For instance, for "employees.ds.xml", the fileName would be "employees", the fileType would be "ds" and the fileFormat would be "xml". A projectFile DataSource executes the various fileSource','fileSource operations in the following manner. The general rule is that fileName, fileType, and fileFormat are treated as primary keys. If files with the same combination of those attributes exist in more than one of the configured locations, the locations are considered in reverse order, with priority given to the location listed last. When modifying an existing file, the last location which contains the file will be used. When creating a new file, the file will be created in the last configured location. <dl> <dt>DataSource.listFiles','listFiles <dd>Returns a combined list of files from all configured locations. Note that listFiles does not recurse into subdirectories. If the same combination of fileName / fileType / fileFormat exists in more than one configured location, then the data for fileSize and fileLastModified will be taken from the last configured location which contains the file. <dt>DataSource.hasFile','hasFile <dd>Indicates whether the file exists in any of the configured locations. <dt>DataSource.getFile','getFile <dd>Returns file data by searching the locations in reverse order. <dt>DataSource.saveFile','saveFile <dd>If the file exists, it will be saved in the last location in which it exists. If it is a new file, it will be saved in the last configured location. <dt>DataSource.renameFile','renameFile <dd>The file will be renamed in the last location in which it exists. Note that if the file exists in more than one location, the rename will not affect other locations. Thus, a subsequent listFiles operation will return the file from the other location (as well as the renamed file). <dt>DataSource.removeFile','removeFile <dd>The file will be removed from the last location in which it exists. Note that if the file exists in more than one location, the removal will not affect other locations. Thus, a subsequent listFiles operation will return the file from the other location. </dl> For convenience, a projectFile DataSource also responds to the standard DataSource operations, in the following manner: <dl> <dt>add <dd>Executes a saveFile operation, either adding the file or updating an existing file. <dt>fetch <dd>Executes a listFiles operation. Note that the results will not include the fileContents. In order to obtain the fileContents, you must use a DataSource.getFile','getFile operation. <dt>update <dd>Executes a renameFile operation. Note that this will not update the fileContents -- for that, you need to use "add", or a DataSource.saveFile','saveFile operation. <dt>remove <dd>Executes a removeFile operation. </dl> If you specify both DataSource.projectFileKey','projectFileKey and projectFileLocations, then both with be used, with the projectFileLocations applied last.
		 * Flags: IR, Group: fileSource */
		projectFileLocations: Array<string> /* Array of String */;

		/** For dataSources of DataSource.serverType','serverType "sql", determines whether we qualify column names with table names in any SQL we generate. This property can be overridden on specific operationBindings.
		 * Flags: IR */
		qualifyColumnNames: boolean /* Boolean */;

		/** If set, tells the SQL engine to quote column names in all generated DML and DDL statements for this dataSource. This will ensure that queries generated against tables that do not follow the database product's natural column-naming conventions will still work. In general we recommend that you allow the database to use its natural naming scheme when creating tables (put more simply, just do not quote column names in the CREATE TABLE statement); if you do this, you will not need to worry about quoting column names when querying. However, if you are dealing with pre-existing tables, or do not have control over the database naming conventions used, this property may become necessary. This property may also be necessary if you are using field/column names that clash with reserved words in the underlying database (these vary by database, but a field called "date" or "timestamp" would have problems with most database products) Note: Only applicable to dataSources of DataSource.serverType','serverType "sql".
		 * Flags: IR */
		quoteColumnNames: boolean;

		/** For SQL DataSources, tells the framework whether to surround the associated DataSource.tableName','table name with quotation marks whenever it appears in generated queries. This is only required if you have to connect to a table with a name that is in breach of your database product's naming conventions. For example, some products (eg, Oracle) internally convert all unquoted references to upper case, so if you create a table called myTest, the database actually calls it MYTEST unless you quoted the name in the create command, like this: &nbsp;&nbsp;CREATE TABLE "myTest" If you <em>do</em> quote the name like this, or if you have to connect to a legacy table that has been named in this way, then you must set this property to tell the SQL engine that it must quote any references to this table name (this requirement depends on the database in use - as noted below, some are not affected by this problem). If you do not, you will see exceptions along the lines of "Table or view 'myTest' does not exist". Note, other database products (eg, Postgres) convert unquoted names to lower case, which leads to the same issues. Still others (eg, SQL Server) are not case sensitive and are not affected by this issue. Generally, we recommend that you avoid using this property unless you have a specific reason to do so. It is preferable to avoid the issue altogether by simply not quoting table names at creation time, if you are able to do so.
		 * Flags: IRA, Group: serverDataIntegration */
		quoteTableName: boolean /* Boolean */;

		/** Provides a default value for OperationBinding.recordName.
		 * Flags: IR, Group: clientDataIntegration */
		recordName: string /* String */;

		/** See OperationBinding.recordXPath. recordXPath can be specified directly on the DataSource for a simple read-only DataSource only capable of "fetch" operations.
		 * Flags: IR, Group: clientDataIntegration */
		recordXPath: string /* XPathExpression */;

		/** Additional properties to pass through to the DSRequests made by this DataSource. This must be set before any DSRequests are issued and before any component is bound to the DataSource. These properties are applied before DataSource.transformRequest is called.
		 * Flags: IRW, Group: clientDataIntegration */
		requestProperties: DSRequestProps /* DSRequest Properties */;

		/** The required message when a field that has been marked as DataSourceField.required','required is not filled in by the user. Note that DataSourceField.requiredMessage wins over this setting if both are set.
		 * Flags: IRW, Group: formTitles */
		requiredMessage: string /* HTMLString */;

		/** Indicates that the specified VelocityExpression must evaluate to true for a user to access this DataSource. See also OperationBinding.requires.
		 * Flags: IR, Group: auth */
		requires: string /* VelocityExpression */;

		/** Whether a user must be authenticated in order to access this DataSource. This establishes a default for the DataSource as a whole; individual DataSource.operationBindings within the DataSource may still override this setting by explicitly setting OperationBinding.requiresAuthentication. Whether the user is authenticated is determined by calling httpServletRequest.getRemoteUser(), hence works with both simple J2EE security (realms and form-based authentication) and JAAS (Java Authentication & Authorization Service). If you wish to use an authentication scheme that does not make use of the servlet API's standards, SmartClient Server also implements the setAuthenticated method on RPCManager. You can use this API to tell SmartClient that all the requests in the queue currently being processed are associated with an authenticated user; in this case, SmartClient will not attempt to authenticate the user via httpServletRequest.getRemoteUser() You can set the default value for this property via setting "authentication.defaultRequired" in server_properties','server.properties. This allows you to, for example, cause all DataSources to require authentication for all operations by default. Note that setting this property does not automatically cause an authentication mechanism to appear - you still need to separately configure an authentication system. Likewise, setting requiresAuthentication="false" does not automatically allow users to bypass your authentication mechanism - you need to set up a URL that will accept DSRequests and process them similar to the default "IDACall" servlet, and which is not protected by the authentication system. See servletDetails','Deploying SmartClient for details on the IDACall servlet.
		 * Flags: IR, Group: auth */
		requiresAuthentication: boolean;

		/** Similar to OperationBinding.requiresRole, but controls access to the DataSource as a whole.
		 * Flags: IR, Group: auth */
		requiresRole: string /* String */;

		/** Very advanced: for servers that do not support paging, and must return large numbers of XML records in one HTTP response, SmartClient breaks up the processing of the response in order to avoid the "script running slowly" dialog appearing for an end user. If you have a relatively small number of records with a great deal of properties or subobjects on each record, and you have not set DataSource.dropExtraFields to eliminate unused data, and you see the "script running slowly" dialog, you may need to set this number lower.
		 * Flags: IRWA */
		resultBatchSize: number /* int */;

		/** Class for ResultSets used by this datasource. If null, defaults to using ResultSet. This can be set to a custom subclass of ResultSet that, for example, hangs onto to extra information necessary for integration with web services.
		 * Flags: IRA */
		resultSetClass: string /* Class Object */;

		/** Class for ResultTrees used by this datasource. If null, defaults to using ResultTree. This can be set to a custom subclass of ResultTree that, for example, hangs on to extra information necessary for integration with web services.
		 * Flags: IRA */
		resultTreeClass: string /* Class Object */;

		/** This property only applies to the built-in SQL DataSource provided in Pro and better editions of SmartClient Defines the name of the schema we use to qualify the DataSource.tableName','tableName in generated SQL. If you do not provide this property, table names will not be qualified in generated SQL, and thus the default schema will be used. Support for multiple schemas (or schemata) varies quite significantly across the supported databases, as does the meaning of the phrase "default schema". In addition, some databases allow you to override the default schema in the JDBC connection URL, which is a preferable approach if all your tables are in the same (non-default) schema. The following table provides information by product: <table border="1" class="normal" width="90%"> <tr><td> Product</td><td width="90%"> Notes</td></tr> <tr><td> DB2</td><td> Arbitrarily named schemas are supported. The default schema is named after the connecting user, though this can be overridden by specifying the "currentSchema" property on the JDBC connection URL</td></tr> <tr><td> DB2 for iSeries</td><td> Arbitrarily named schemas are supported. "Schema" is synonymous with "library". The default schema depends on the setting of the "naming" connection property. When this is set to "sql", behavior is similar to other DB2 editions: the default schema is named after the connecting user, unless overridden by specifying a library name in the JDBC connection URL. When "naming" is set to "system", the schema of an unqualified table is resolved using a traditional search of the library list; the library list can be provided in the "libraries" property</td></tr> <tr><td> Firebird</td><td> Firebird does not support the concept of schema at all - all "schema objects" like tables and indexes belong directly to the database. In addition, Firebird actively rejects qualified table names in queries as syntax errors; therefore, you should not set the schema property for a DataSource that will be backed by a Firebird database </td></tr> <tr><td> HSQLDB</td><td> Arbitrarily named schemas are supported. The default schema is auto-created when the database is created; by default it is called "PUBLIC", but can be renamed. It is not possible to set the default schema in the JDBC connection URL</td></tr> <tr><td> Informix</td><td> Informix databases can be flagged as "ANSI mode" at creation time. ANSI-mode databases behave similarly to DB2 for schema support: arbitrarily named schemas are supported, and the default schema is the one named after the connected user. Non-ANSI databases have no real schema support at all. It is not possible to set the default schema in the JDBC connection URL with either type of database</td></tr> <tr><td> Microsoft SQL Server</td><td> Prior to SQL Server 2005, schema support is similar to Oracle: "schema" is synonymous with "owner". As of SQL Server 2005, schema is supported as a separate concept, and a user's default schema can be configured (though it still defaults to a schema with the same name as the user). It is not possible to set the default schema in the JDBC connection URL</td></tr> <tr><td> MySQL</td><td> MySQL does not have a separate concept of "schema"; it treats the terms "schema" and "database" interchangeably. In fact MySQL databases actually behave more like schemas, in that a connection to database X can refer to a table in database Y simply by qualifying the name in the query. Also, because schema and database are the same concept in MySQL, overriding the "default schema" is done implicitly when you specify which database to connect to in your JDBC connection URL</td></tr> <tr><td> Oracle</td><td> Arbitrarily named schemas are not supported; in Oracle, "schema" is synonymous with "user", so each valid user in the database is associated implicitly with a schema of the same name, and there are no other schemas possible. It is possible to refer to tables in another user's schema (assuming you have the privileges to do so) by simply qualifying the table name. The default schema is always implied by the connecting user and cannot be overridden.</td></tr> <tr><td> Postgres</td><td> Arbitrarily named schemas are supported. Rather than the concept of a "default schema", Postgres supports the idea of a search path of schemas, whereby unqualified table references cause a search of the list of schemas in order, and the first schema in the path is the "current" one for creation purposes. Unfortunately, there is no way to specify this search path on the JDBC connection URL, so the default schema comes from the user definition, ultimately defaulting to the default "public" schema</td></tr> </table>
		 * Flags: IR */
		schema: string /* String */;

		/** For DataSources that specify DataSource.autoDeriveSchema, this property indicates the name of the Spring bean, Hibernate mapping or fully-qualified Java class to use as parent schema.
		 * Flags: IR, Group: fields */
		schemaBean: string;

		/** For a DataSource derived from WSDL or XML schema, the XML namespace this schema belongs to. This is a read-only attribute automatically present on DataSources returned from SchemaSet.getSchema and WebService.getSchema.
		 * Flags: R, Group: wsdlBinding */
		schemaNamespace: string /* URN */;

		/** Default scriptlet to be executed on the server for each operation. If OperationBinding.script is specified, it will be executed for the operation binding in question instead of running this scriptlet. Scriptlets are used similarly to DMIs configured via DataSource.serverObject or OperationBinding.serverObject - they can add business logic by modifying the DSRequest before it's executed, modifying the default DSResponse, or taking other, unrelated actions. For example: &lt;DataSource&gt; &lt;script language="groovy"&gt; ... Groovy code ... &lt;/script&gt; ... other DataSource properties &lt;/DataSource&gt; Scriptlets can be written in any language supported by the "JSR 223" standard, including Java itself. See the dmiOverview','DMI Script Overview for rules on how to return data, add additional imports, and other settings. The following variables are available for DMI scriptlets: requestContext: RequestContext (from com.isomorphic.servlet) dataSource: the current DataSource (same as DSRequest.getDataSource()) dsRequest: the current DSRequest criteria: shortcut to DSRequest.getCriteria() (a Map) values: shortcut to DSRequest.getValues() (a Map) oldValues: shortcut to DSRequest.getOldValues() (a Map) sqlConnection: SQLDataSource only: the current SQLConnection object. If using DataSource.autoJoinTransactions','automatic transactions are enabled, this SQLConnection is in the context of the current transaction. rpcManager: the current RPCManager applicationContext: the Spring ApplicationContext (when applicable) beanFactory: the Spring BeanFactory (when applicable) Scriptlets also have access to a set of contextual variables related to the Servlets API, as follows: servletRequest: the current ServletRequest session: the current HttpSession servletResponse: the current ServletResponse (advanced use only) servletContext: the current ServletContext(advanced use only) As with DMI in general, be aware that if you write scriptlets that depend upon these variables, you preclude your DataSource from being used in the widest possible variety of circumstances. For example, adding a scriptlet that relies on the HttpSession prevents your DataSource from being used in a command-line process. Note that if a dataSource configuration has both a &lt;script&gt; block and a specified OperationBinding.serverObject','serverObject for some operation, the script block will be executed, and the serverObject ignored.
		 * Flags: IR */
		script: string /* String */;

		/** Analogous to DataSource.dropExtraFields, for data sent to the server. Setting this attribute to false ensures that for any records in the data object, only fields that correspond to declared dataSource fields will be present on the dsRequest data object passed to DataSource.transformRequest and ultimately sent to the server.
		 * Flags: IR, Group: clientDataIntegration */
		sendExtraFields: boolean /* Boolean */;

		/** Set this attribute if you need to send the dsRequest.parentNode to the server-side.
		 * Flags: IRWA */
		sendParentNode: boolean /* Boolean */;

		/** For fields of DataSourceField.type','type "sequence" in a dataSource of DataSource.serverType','serverType "sql", indicates the SequenceMode to use. This property has no effect for fields or dataSources of other types. You can set a default sequenceMode for all DataSources of a given database type by setting property "sql.{database_type}.default.sequence.mode" in server.properties. You set a global default sequenceMode that applies to all database types by setting property "sql.default.sequence.mode". For example: sql.mysql.default.sequence.mode: jdbcDriver 
		 * Flags: IR */
		sequenceMode: SequenceMode;

		/** This property allows you to write and use custom DataSource subclasses on the server, by specifying either the fully-qualified name of the DataSource subclass that should be instantiated server-side for this dataSource, or the token "spring:" followed by a valid Spring bean ID, if you wish to instantiate your custom dataSource object using Spring dependency injection. For example, "spring:MyDataSourceBean". See also serverInit for special concerns with framework initialization when using Spring. It is also particularly important that you read the discussion of caching and thread-safety linked to below, as there are special considerations in this area when using Spring. the token "cdi:" followed by a valid CDI bean name, if you wish to instantiate your custom dataSource object using CDI dependency injection. For example, "cdi:MyDataSourceBean". One reason you might wish to do this would be to override the validate() method to provide some arbitrary custom validation (such as complex database lookups, validation embedded in legacy applications, etc). It is also possible - though obviously a more substantial task - to override the execute() method in your custom DataSource. This is one way of creating a completely customized DataSource implementation. Note: If you use this property, you are responsible for making sure that it refers to a valid server-side class that extends com.isomorphic.datasource.BasicDataSource, or to a Spring bean of the same description. If your implementation relies on methods or state only present in certain specialized subclasses of DataSource (for example, you want the normal behavior and features of a HibernateDataSource, but with a specialized validate() method), then you should extend the subclass rather than the base class. NOTE: Please take note of the points made in serverDataSourceImplementation','this discussion of caching and thread-safety issues in server-side DataSources.
		 * Flags: IR */
		serverConstructor: string /* String */;

		/** For Direct Method Invocation (DMI) binding, declares the ServerObject to use as the default target for all DataSource.operationBindings. Specifying this attribute in an XML DataSource stored on the server enables DMI for this DataSource. Note that if a dataSource configuration has both a OperationBinding.script','&lt;script&gt; block and a specified serverObject for some operation, the script block will be executed, and the serverObject ignored.
		 * Flags: IR, Group: serverDataIntegration */
		serverObject: ServerObject;

		/** Setting a DataSource to be serverOnly="true" ensures that it will not be visible to the client. Any request through IDACall to this DataSource will return a failure response. Only requests which have been initiated on the server-side will be executed against this DataSource.
		 * Flags: IR */
		serverOnly: string /* String */;

		/** For a DataSource stored in .xml format on the SmartClient server, indicates what server-side connector to use to execute requests, that is, what happens if you call dsRequest.execute() in server code.
		 * Flags: IR, Group: serverDataIntegration */
		serverType: DSServerType;

		/** For an XML DataSource, URN of the WebService to use to invoke operations. This URN comes from the "targetNamespace" attribute of the &lt;wsdl:definitions&gt; element in a WSDL (Web Service Description Language) document, and serves as the unique identifier of the service. Having loaded a WebService using XMLTools.loadWSDL, setting serviceNamespace combined with specifying OperationBinding','operationBindings that set OperationBinding.wsOperation will cause a DataSource to invoke web service operations to fulfill DataSource requests (DSRequest','DSRequests). Setting serviceNamespace also defaults DataSource.dataURL','dataURL to the service's location, DataSource.dataFormat','dataFormat to "xml" and OperationBinding.dataProtocol','dataProtocol to "soap".
		 * Flags: IR, Group: wsdlBinding */
		serviceNamespace: string /* URN */;

		/** For a DataSource that inherits DataSource.fields from another DataSource (via DataSource.inheritsFrom), indicates that only the fields listed in this DataSource should be shown. All other inherited parent fields will be marked "hidden:true".
		 * Flags: IR, Group: fields */
		showLocalFieldsOnly: boolean;

		/** Whether RPCRequests sent by this DataSource should enable RPCRequest.showPrompt in order to block user interactions until the request completes. DataSource requests default to blocking UI interaction because, very often, if the user continues to interact with an application that is waiting for a server response, some kind of invalid or ambiguous situation can arise. Examples include pressing a "Save" button a second time before the first save completes, making further edits while edits are still being saved, or trying to initiate editing on a grid that hasn't loaded data. Defaulting to blocking the UI prevents these bad interactions, or alternatively, avoids the developer having to write repetitive code to block invalid interactions on every screen. If an operation should ever be non-blocking, methods that initiate DataSource requests (such as DataSource.fetchData) will generally have a requestProperties argument allowing showPrompt to be set to false for a specific request.
		 * Flags: IRW */
		showPrompt: boolean /* Boolean */;

		/** Sets what level of JSON validation will apply for this DataSource. Note that the point of "partial" validation mode is that if the JSON ihat's delivered is correct, we'll still need to validate to get "date" and such in the correct time, but shouldn't need to for the rest.
		 * Flags: IRW */
		skipJSONValidation: SkipJSONValidation;

		/** When true, indicates that any updates for this DataSource include only those fields that have actually changed (and primaryKey fields); when false (the default), all field values are included in updates, whether they have changed or not
		 * Flags: IR */
		sparseUpdates: boolean;

		/** The paging strategy to use for this DataSource. If this property is not set, the default paging strategy, specified with the server_properties','server.properties setting sql.defaultPaging, is used. This setting can be overridden with the OperationBinding.sqlPaging property. NOTE: Operations that involve a OperationBinding.customSQL','customSQL clause ignore this property, because customSQL operations usually need to be treated as special cases. For these operations, the paging strategy comes from the server_properties','server.properties setting sql.defaultCustomSQLPaging or sql.defaultCustomSQLProgressivePaging, depending on whether or not DataSource.progressiveLoading','progressiveLoading is in force. Note that these can always be overridden by a sqlPaging setting on the OperationBinding.
		 * Flags: IRW */
		sqlPaging: SQLPagingStrategy;

		/** If explicitly set true or left null, causes the server to use a "hint" in the SQL we generate for paged queries. If explicitly set false, forces off the use of hints. This property can be overridden per operationBinding - see OperationBinding.sqlUsePagingHint. Note this property is only applicable to DataSource.serverType','SQL DataSources, only when a DataSource.sqlPaging','paging strategy of "sqlLimit" is in force, and it only has an effect for those specific database products where we employ a native hint in the generated SQL in an attempt to improve performance.
		 * Flags: IR, Group: sqlPaging */
		sqlUsePagingHint: boolean;

		/** If set to true, both client and server-side advanced filtering used by SmartClient will follow SQL99 behavior for dealing with NULL values, which is often counter-intuitive to users. Specifically, when a field has NULL value, all of the following expressions are false: field == "someValue" (normally false) field != "someValue" (normally true) not (field == "someValue") (normally true) not (field != "someValue") (normally false) This property can be overridden per-query by specifying strictSQLFiltering directly as a property on the AdvancedCriteria. NOTE: On the server side, this property is only applicable if you are using the SQL DataSource; the other built-in types (Hibernate and JPA/JPA2) do not offer this mode.
		 * Flags: IRA */
		strictSQLFiltering: boolean /* Boolean */;

		/** Only applicable to the built-in SQL DataSource tableCode and the related properties DataSourceField.columnCode, DataSourceField.fkTableCode and DataSourceField.fkColumnCode are read-only attributes that are secure and unique cryptographic hashes of table and column names used by this DataSource. These properties are used automatically by client-side framework code to link dataSources together by DataSourceField.foreignKey','foreign key when a foreignKey is not explicitly declared, but is found in the SQL schema via the DataSource.autoDeriveSchema feature. A secure hash is used rather than the actual SQL table or column name for security reasons - sending the actual SQL table or column name to the client could aid in attempted SQL injection attacks. This feature can be disabled system-wide via setting datasource.autoLinkFKs to false in server_properties','server.properties.
		 * Flags: R */
		tableCode: string /* String */;

		/** For DataSources using the sqlDataSource','SmartClient SQL engine for persistence, what database table name to use. The default is to use the DataSource ID as the table name.
		 * Flags: IR, Group: serverDataIntegration */
		tableName: string /* String */;

		/** Tag name to use when serializing to XML. If unspecified, the dataSource.ID will be used.
		 * Flags: IRA, Group: clientDataIntegration */
		tagName: string /* String */;

		/** User-visible name for this DataSource. For example, for the supplyItem DataSource, "Supply Item". If is unset, getAutoTitle() method will be used with dataSource.ID. value in order to derive a default value for the title. For example "employee" ID will be derived to "Employee", "team_member" ID will be derived to "Team Member".
		 * Flags: IRW, Group: titles */
		title: string;

		/** Best field to use for a user-visible title for an individual record from this dataSource. For example, for a DataSource of employees, a "full name" field would probably most clearly label an employee record. If not explicitly set, titleField looks for fields named "title", "label", "name", and "id" in that order. If a field exists with one of those names, it becomes the titleField. If not, then the first field is designated as the titleField.
		 * Flags: IR, Group: titles */
		titleField: string;

		/** If set to "false", transformation of values for DataSourceField.multiple','multiple:true fields, normally controlled by DataSourceField.multipleStorage, is instead disabled for this entire DataSource.
		 * Flags: IR, Group: multipleField */
		transformMultipleFields: boolean;

		/** OperatorId','Search operators like "matchesPattern" use patterns like "foo*txt" to match text values. The patterns are similar to the patterns you use to match names of files in a command-line interface, or to the pattern allowed for the SQL "LIKE" operator. translatePatternOperators controls whether these pattern operators should be translated to a nested series of "startsWith"/"endsWidth"/"contains" operators before being sent to the server. This allows a server that only implements simple operators like "startsWith" to support pattern operators such as "matchesPattern" and "containsPattern", but with caveats: single-character wildcards are not supported multiple wildcards are not truly order-dependent, for example *1*2*3* will match 1,2,3 as interior characters in any order. may be less efficient than a direct server-side implementation that is able to translate the pattern directly to the underlying storage engine. Note that since "containsPattern" is essentially equivalent to "matchesPattern" but with "*" wildcards at the beginning and end of every pattern, the second limitation (pattern not really order dependent) may be fairly obvious to users when using this feature. For example, "m*t" will match "we meet" and "we teem". The following are examples of how patterns are translated to simpler operators. Note that the case sensitive version of the operator is referred to below, but of course "iMatchesPattern" and "iContainsPattern" will be translated to case-insensitive versions of these operators, such as "iStartsWith". *foo (endsWith) foo* (startsWith) *foo* (contains) *foo*bar (contains and endsWith) foo*bar* (startsWith and contains) foo*bar (startsWith and endsWith) *foo*bar* (multiple contains) Also supported: one startsWith, multiple contains, one endsWith.
		 * Flags: IR */
		translatePatternOperators: boolean;

		/** For this dataSource, should the millisecond portion of time and datetime values be trimmed off before before being sent from client to server or vice versa. By default, millisecond information is preserved (ie, it is not trimmed). You only need to consider trimming millisecond values if their presence causes a problem - for example, a custom server that is not expecting that extra information and so fails parsing. Note that there is no inherent support for millisecond precision in SmartClient widgets; if you need millisecond-precise visibility and editability of values in your client, you must write custom formatters and editors (or sponsor the addition of such things to the framework). Server-side, millisecond-precise values are delivered to and obtained from DataSources, so DataSource implementations that are capable of persisting and reading millisecond values should work transparently. Of the built-in DataSource types, the JPA and Hibernate DataSources will transparently handle millisecond-precise values as long as the underlying database supports millisecond precision, and the underlying column is of an appropriate type. The SQLDataSource provides accuracy to the nearest second by default; you can switch on millisecond precision per-field with the DataSourceField.storeMilliseconds','storeMilliseconds attribute.
		 * Flags: IR */
		trimMilliseconds: boolean;

		/** For DataSources using the sqlDataSource','SmartClient SQL engine for persistence, whether to use ANSI-style joins (ie, joins implemented with JOIN directives in the table clause, as opposed to additional join expressions in the where clause). The default value of null has the same meaning as setting this flag to false. Note, outer joins (see DataSourceField.joinType','joinType) only work with certain database products if you choose not to use ANSI joins. Other than that, the join strategies are equivalent. If you wish to switch on ANSI-style joins for every DataSource, without the need to manually set this property on all of them, set server_properties','server.properties flag sql.useAnsiJoins to true.
		 * Flags: IR, Group: serverDataIntegration */
		useAnsiJoins: boolean;

		/** Like DataBoundComponent.useFlatFields, but applies to all DataBound components that bind to this DataSource.
		 * Flags: IR, Group: fields */
		useFlatFields: boolean /* Boolean */;

		/** Like OperationBinding.useHttpProxy, but serves as a default for this DataSource that may be overridden by individual operationBindings.
		 * Flags: IR, Group: clientDataIntegration */
		useHttpProxy: boolean;

		/** Whether to attempt validation on the client at all for this DataSource. If unset (the default), client-side validation is enabled. Disabling client-side validation entirely is a good way to test server-side validation.
		 * Flags: IRWA, Group: validation */
		useLocalValidators: boolean;

		/** Whether we store server responses for this DataSource into Offline','browser-based offline storage, and then use those stored responses at a later time if we are offline (ie, the application cannot connect to the server). Note that by default we do NOT use offline storage for a dataSource.
		 * Flags: IRW, Group: offlineGroup */
		useOfflineStorage: boolean;

		/** For a DataSource that inherits DataSource.fields from another DataSource (via DataSource.inheritsFrom), indicates that the parent's field order should be used instead of the order of the fields as declared in this DataSource. New fields, if any, are placed at the end.
		 * Flags: IR, Group: fields */
		useParentFieldOrder: boolean;

		/** This flag is part of the Automatic Transactions feature; it is only applicable in Power Edition and above. If true, causes all transactional operations on this DataSource to use the current Spring-managed transaction, if one exists. If there is no current Spring transaction to use at the time of execution, a server-side Exception is thrown. Note, a "transactional operation" is one that would have joined the SmartClient shared transaction in the absence of Spring integration - see DataSource.autoJoinTransactions','auotJoinTransactions. This feature is primarily intended for situations where you have dmiOverview','DMI methods that make use of both Spring DAO operations and SmartClient DSRequest operations, and you would like all of them to share the same transaction. An example of the primary intended use case: &#x0040;Transactional(isolation=Isolation.READ_COMMITTED, propagation=Propagation.REQUIRED) public class WorldService { public DSResponse doSomeStuff(DSRequest dsReq, HttpServletRequest servletReq) throws Exception { ApplicationContext ac = (ApplicationContext)servletReq.getSession().getServletContext().getAttribute("applicationContext"); WorldDao dao = (WorldDao)ac.getBean("worldDao"); dao.insert(req.getValues()); DSRequest other = new DSRequest("MyOtherDataSource", "add"); // Set up the 'other' dsRequest with critiera, values, etc // ... // This dsRequest execution will use the same transaction that the DAO operation // above used; if it fails, the DAO operation will be rolled back other.execute(); return new DSResponse(); } } Note: if you want to rollback an integrated Spring-managed transaction, you can use any of the normal Spring methods for transaction rollback: Programmatically mark the transaction for rollback with the setRollbackOnly() API Throw a RuntimeException, or Throw an ordinary checked Exception. but configure Spring to rollback on that Exception. This can be done in the @Transactional annotation: &#x0040;Transactional(isolation=Isolation.READ_COMMITTED, propagation=Propagation.REQUIRED, rollbackFor=MyRollbackException.class) Spring's exception-handling model is different from SmartClient's, so care must be taken to get the correct error processing. If a transactional DSRequest fails, SmartClient code will throw an ordinary checked Exception; but Spring will ignore that Exception. So you can either: Wrap every DSRequest.execute() in a try/catch block. Catch Exception and throw a RuntimeException instead Just use the "rollbackFor" annotation to make your transactional method rollback for all instances of Exception Note: Spring transaction integration is conceptually different from SmartClient's DataSource.autoJoinTransactions','built-in transaction feature, because SmartClient transactions apply to a queue of DSRequests, whereas Spring transactions are scoped to a single method invocation. If you want to make a whole SmartClient queue share a single Spring-managed transaction, you can wrap the processing of an entire queue in a call to a transactional Spring method. See the <em>Using Spring Transactions with SmartClient DMI</em> section at the bottom of the springIntegration','Spring integration page for more details. You can set useSpringTransaction as the default setting for all dataSources for a given database provider by adding the property {dbName}.useSpringTransaction to your server.properties file. For example, Mysql.useSpringTransaction: true or hibernate.useSpringTransaction: true. You can set it as the default for all providers with a server.properties setting like this: useSpringTransaction: true. When useSpringTransaction is the default, you can switch it off for a specific dataSource by explicitly setting the flag to false for that DataSource. Finally, this setting can be overridden at the operationBinding level - see OperationBinding.useSpringTransaction <h3>Configuration</h3> When using Spring transactions, SmartClient needs a way to lookup the JNDI connection being used by Spring, and this needs to be configured. First, register a bean like this in your applicationContext.xml file: &lt;bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean"&gt; &lt;!-- Set this to the JNDI name Spring is using --&gt; &lt;property name="jndiName" value="isomorphic/jdbc/defaultDatabase"/&gt; &lt;/bean&gt; and then add a line like this to your server.properties: # Set this property to match the "id" of the JndiObjectFactoryBean registered in Spring sql.spring.jdbcDataSourceBean: dataSource 
		 * Flags: IR */
		useSpringTransaction: boolean;

		/** Should HTTP responses to requests by this dataSource be formatted using the strict JSON subset of the javascript language? If set to true, responses returned by the server should match the format described <a href='http://www.json.org/js.html' target='_blank'>here</a>. Only applies to dataSources which send requests to a server and have DataSource.dataFormat set to "json" or "iscServer". Note: using strict JSON avoids a known issue in Internet Explorer 9 where datasource transactions can leak memory due to a browser behavior where the native eval() method fails to clean up references when the objects go out of scope. See RPCManager.allowIE9Leak for more on this.
		 * Flags: IR */
		useStrictJSON: boolean;

		/** This property is only applicable to DataSource.serverType','SQL DataSources, and only for OperationBinding','operations that express a OperationBinding.customSQL','customSQL clause. In these circumstances, we generally switch off paging because we are unable to generate a "row count" query that tells the framework the size of the complete, unpaged resultset. The useSubselectForRowCount flag causes the framework to derive a rowcount query by simply wrapping the entire customSQL clause in a subselect, like so: &nbsp;&nbsp;&nbsp;&nbsp;SELECT COUNT(*) FROM ({customSQL clause here}) However, this is not guaranteed to give good results. Because the customSQL clause can contain anything that you can write in SQL, running it inside a subselect in order to count the rows might not work, might have unintended side-effects (if, for example, it is a stored procedure call that performs updates as part of its function), or it might just be a bad idea - for example, if the customSQL query is slow-running, you'll make it twice as slow with this flag, simply because you'll be running it twice. We recommend using this flag with care. NOTE: This setting can be overridden per-operation - see OperationBinding.useSubselectForRowCount. You can also set a global default for this setting, so you don't have to specify it in every dataSource - define useSubselectForRowCount as true in your server_properties','server.properties file.
		 * Flags: IR, Group: sqlPaging */
		useSubselectForRowCount: boolean;

		/** When set, causes a DataSource.clientOnly','client-only or DataSource.cacheAllData DataSource to create a second DataSource to perform it's one-time fetch. By default, this attribute will be considered true when clientOnly is true, cacheAllData is false or unset and a dataURL or testFileName is specified on the DataSource.
		 * Flags: IRW, Group: clientData */
		useTestDataFetch: boolean;

		/** If true, indicates that the SmartClient Server should automatically apply a ValidatorType of "hasRelatedRecord" to every field on this dataSource that has a DataSourceField.foreignKey','foreignKey defined.
		 * Flags: IR */
		validateRelatedRecords: boolean;

		/** Sets the XML namespace prefixes available for XPaths on a DataSource-wide basied. See OperationBinding.xmlNamespaces for details.
		 * Flags: IR, Group: clientDataIntegration */
		xmlNamespaces: any /* Object */;


		/* Instance Method Overrides */

		/** 
		 * Perform a "fetch" DataSource operation against this DataSource, sending search criteria and retrieving matching records. NOTE: do not attempt to override this method to create a custom DataSource. For a server-side custom DataSource, use the DataSource.serverConstructor attribute, and the customDataSource', 'Custom DataSource samples. For a client-side custom DataSource, see DataSource.dataProtocol','dataProtocol:"custom". In contrast to ListGrid.fetchData, which creates a ResultSet to manage the returned data, calling dataSource.fetchData() provides the returned data in the callback as a simple JavaScript Array of JavaScript Objects. Calling dataSource.fetchData() does not automatically update any visual components or caches: code in the callback passed to fetchData() decides what to do with the returned data. For example, given a ListGrid "myGrid" and a DataSource "employees", the following code would populate "myGrid" with data fetched from the DataSource: isc.DataSource.get("employees").fetchData(null, "myGrid.setData(data)"); Unlike calling myGrid.fetchData(), which creates a ResultSet, the data provided to the grid is "disconnected" data, unmanaged by SmartClient's databinding facilities and safe to directly modify. This is useful when, for example, a ListGrid is being used as a more sophisticated version of HTML's multi-select component. Disconnected datasets may be used to populate various visual components. For example, while an individual FormItem can be configured to fetch FormItem.valueMap','valueMap options from a DataSource via the FormItem.optionDataSource','optionDataSource property, the following code shows storing a dataset to derive valueMaps from later: isc.DataSource.get("countries").fetchData(null, "window.countries = data"); ... later, a form is created dynamically ... function showForm() { isc.DynamicForm.create({ items : [ { name:"country", title:"Pick Country", valueMap: window.countries.getValueMap("countryId", "countryName") }, ... You can also create a ResultSet from the data retrieved from fetchData(), like so: isc.DataSource.get("countries").fetchData(null, function (dsResponse, data) { isc.ResultSet.create({ dataSource:"countries", allRows:data }) } ) This gives you a dataset that supports client-side filtering (via ResultSet.setCriteria','setCriteria()), can provide ResultSet.getValueMap','filtered valueMaps, will ResultSet.disableCacheSync','automatically reflect updates to the DataSource made via other components, and can be re-used with multiple visual components. See also DataSource.getClientOnlyDataSource and DataSource.cacheAllData for similar capabilities for dealing with smaller datasets entirely within the browser, or working with modifiable caches representing subsets of the data available from a DataSource. See also the server-side com.isomorphic.js.JSTranslater class in the ${isc.DocUtils.linkForDocNode('javaServerReference', 'Java Server Reference')} for other, similar approaches involving dumping data into the page during initial page load. Note: care should be taken when using this approach. Large datasets degrade the basic performance of some browsers, so use PickList.optionDataSource','optionDataSource and similar facilities to manage datasets that may become very large. Data-Driven Visual Component Creation DataSource.fetchData() can also be used to create SmartClient components in a data-driven way. Many properties on SmartClient visual components are configured via an Array of Objects - the same data format that dataSource.fetchData() returns. These include ListGrid.fields, TabSet.tabs, DynamicForm.items, Facet.values and even DataSource.fields. For example, if you had a DataSource "myFormFields" whose fields included the basic properties of FormItem','FormItems (name, title, type, etc), this example code would create a form based on stored field definitions, loaded from the "myFormFields" DataSource on the fly: isc.DataSource.get("myFormFields").fetchData(null, "isc.DynamicForm.create({ items:data })" ) This capability to dynamically create visual components from dynamically fetched data provides a foundation for creating interfaces that can be customized by end users. See also the server-side API com.isomorphic.datasource.DataSource.addDynamicDSGenerator() for dynamically creating DataSources supporting all server-side DataSource features, and DataSource.inheritsFrom for sharing field definitions across multiple DataSources.
		 * @param {Criteria} criteria - search criteria
		 * @param {DSCallback} callback - callback to invoke on completion
		 * @param {DSRequestProps} requestProperties - additional properties to set on the DSRequest that will be issued
		 */
		fetchData?(criteria?:Criteria, callback?:DSCallback, requestProperties?:DSRequestProps /* DSRequest Properties */): void; 

		/** 
		 * Return the field definition object.
		 * @param {string} fieldName - Name of the field to retrieve
		 */
		getField?(fieldName:string /* String */): DataSourceField; 

		/** 
		 * Converts a list of Records to simple text formats with a Record per line and values separated by a configurable separator, including both tab-separated-values and comma-separated-values (aka CSV). In addition to the settings parameter for this method, DataSourceField.exportForceText can be set. If two or more different text exports are needed for the same DataSource creating a conflict for any DataSourceField setting, DataSource.inheritsFrom can be used to create a child DataSource where these settings can be changed without recapitulating all field definitions.
		 * @param {Array<any>} records - records to convert
		 * @param {TextExportSettingsProps} settings - settings for the export
		 */
		recordsAsText?(records:Array<any> /* Array of Record */, settings?:TextExportSettingsProps /* TextExportSettings Properties */): string /* String */; 

		/** 
		 * Perform a "remove" DataSource operation against this DataSource, to delete an existing DataSource record.
		 * @param {any} data - primary key values of record to delete, (or complete record)
		 * @param {DSCallback} callback - callback to invoke on completion
		 * @param {DSRequestProps} requestProperties - additional properties to set on the DSRequest that will be issued
		 */
		removeData?(data:any | any /* Record | PrimaryKeys */, callback?:DSCallback, requestProperties?:DSRequestProps /* DSRequest Properties */): void; 

		/** 
		 * Perform an "update" DataSource operation against this DataSource, to update values in an existing DataSource record.
		 * @param {any} updatedRecord - updated record
		 * @param {DSCallback} callback - callback to invoke on completion
		 * @param {DSRequestProps} requestProperties - additional properties to set on the DSRequest that will be issued
		 */
		updateData?(updatedRecord:any /* Record Properties */, callback?:DSCallback, requestProperties?:DSRequestProps /* DSRequest Properties */): void; 

	} // DataSource

	export interface DataSourceStatic<T, P> extends ClassStatic<T, P> {
		/** Provides the global default setting for deep or shallow cloning of objects prior to edit. See DataSource.deepCloneOnEdit for details of what this means. The default setting of null is the same as false; with this default in place, deepCloneOnEdit must be set explicitly set at dataSource, component or field level if you require deep cloning.
		 * Flags: IRWA */
		deepCloneOnEdit: boolean /* Boolean */;

		/** The URL where the DataSourceLoader servlet has been installed. Defaults to the Page.setIsomorphicDir','isomorphicDir plus "/DataSourceLoader". Change by calling calling DataSource.setLoaderURL
		 * Flags: RW */
		loaderURL: string /* URL */;

		/** A message returned by a DataSource when an uploaded file's size exceeded DataSourceField.maxFileSize. If this is not set, then Validator.maxFileSizeExceeded value will be used.
		 * Flags: IRW, Group: i18nMessages */
		maxFileSizeExceededMessage: string /* HTMLString */;

		/** A message returned by a DataSource when it is returning an empty dataset for a fetch because the browser is currently offline and there is no suitable cached offline response.
		 * Flags: IRW, Group: i18nMessages */
		offlineMessage: string;

		/** A message returned by a DataSource when an uploaded file was empty, but the field is DataSourceField.required','required.
		 * Flags: IRW, Group: i18nMessages */
		requiredFileMessage: string /* HTMLString */;

		/** Specifies how time field values should be serialized when being sent to the server for dataSources with dataFormat "xml" or "json". If false the time field will be serialized as a logical time object in UTC, using the standard truncated XML Schema format: "HH:MM:SS". If true the time field will be serialized as a complete dateTime object matching the value of the underlying JavaScript date object representing this time on the client.
		 * Flags: IRA */
		serializeTimeAsDatetime: boolean;


	/* Methods */

		/** 
		 * Lookup a DataSource by ID.
		 * @param {string} ID - DataSource ID
		 */
		getDataSource(ID:string /* identifier */): DataSource; 

	} // DataSourceStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a DataSourceField Props argument.
	 * This is derived from the methods in the DataSourceField class and it's parents and their properties marked with the I flag.
	 */
	export interface DataSourceFieldProps  {
		/** Affects whether client dsRequests can request summaries for this field. Default setting of null means that the DataSource-wide default setting DataSource.allowClientRequestedSummaries is used for this field.
		 * Flags: IR, Group: serverSummaries */
		allowClientRequestedSummaries?: boolean; // Flags=IR
		/** Setting audit to false explicitly indicates that this field will not be saved to the audit DataSource when DataSource.audit','auditing is enabled.
		 * Flags: IR */
		audit?: boolean; // Flags=IR
		/** Indicates that values for this field are automatically generated by the database or ORM provider. Setting this flag makes the field behave somewhat like a DataSourceField.sequenceName','sequence field, in that server-side logic does not expect client code to provide values for the field on "add" operations. However, it is not entirely the same as a sequence: Sequences must be integers, whereas autoGenerated fields can be of any type SmartClient Server's DataSource implementations are capable of discovering the value that was generated by the database for sequence fields, which may not be possible with an autoGenerated field. See the docs for DataSourceField.customInsertExpression','customInsertExpression for a discussion of this Unrelated to the autoGenerated flag, you have a general ability for field values to be generated by application code (as opposed to being generated by the database or ORM provider). For example, you can use dmiOverview','DMI methods, serverScript','server scripts, or customQuerying','custom SQL. (Note, if you want to have application code generate values for primaryKey fields, you may need to use an OperationBinding','operationBinding that specifies OperationBinding.providesMissingKeys','providesMissingKeys).
		 * Flags: IR, Group: dataType */
		autoGenerated?: boolean; // Flags=IR
		/** If explicitly set to false, switches off automatic quoting and escaping of values in custom expressions that are derived from Velocity evaluations. By default, any part of a DataSourceField.customSelectExpression','customSelectExpression, DataSourceField.customCriteriaExpression','customCriteriaExpression, DataSourceField.customUpdateExpression','customUpdateExpression or DataSourceField.customInsertExpression','customInsertExpression that comes ultimately from evaluating a Velocity expression, will be automatically quoted and escaped according to the syntax of the underlying database. We do this because "raw" values are vulnerable to <a href="http://en.wikipedia.org/wiki/SQL_injection">SQL injection attacks</a>. However, it is possible that the exact SQL logic you desire for a custom expression cannot be expressed without access to the raw, unquoted value. To work around this, you can either use the special velocitySupport','$rawValue context variable, or you can set this property to false to switch off auto-quoting completely for all custom expressions on this field. Warning: Bear in mind that it is dangerous to use raw values. There are some cases where using the raw value is necessary, but even so, all such cases are likely to be vulnerable to injection attacks. Generally, the presence of $rawValue in a custom expression, or any fields with autoQuoteCustomExpressions: false specified, should be viewed as a red flag.
		 * Flags: IR */
		autoQuoteCustomExpressions?: boolean; // Flags=IR
		/** Controls whether, by default, DataBoundComponents consider this field editable. Set to false to draw this field read-only. For a field that should never be changed from the UI, consider using DataSourceField.canSave instead, which will both mark a field as non-editable and reject any attempt to programmatically change the value on the server (when using the SmartClient Server). This attribute may not effect all dataBoundComponents - the DataBoundComponent.canEditFieldAttribute may be set at the component level to look for a different attribute on the dataSourceField, and components allow developers to explicitly override this default (see ListGridField.canEdit. FormItem.canEdit for example).
		 * Flags: IR, Group: componentBinding */
		canEdit?: boolean; // Flags=IR
		/** Dictates whether the data in this field be exported. Explicitly setting canExport to false overrides the setting on any component-fields, such as ListGridField.canExport','ListGrid fields.
		 * Flags: IR */
		canExport?: boolean /* Boolean */; // Flags=IR
		/** Should the user be able to filter data by this field? Affects whether this field will show up in dataBoundComponents with UI for filtering data. 
		 * Flags: IR */
		canFilter?: boolean; // Flags=IR
		/** Whether values in this field can be updated and saved to the dataSource. If set to false, this field will default to being non-editable in standard editing components (DynamicForm, editable ListGrid), but will be editable when displayed for filtering purposes only (in a SearchForm or ListGrid.showFilterEditor','ListGrid\n filter editor. If DataSourceField.canEdit','canEdit is explicitly specified it will take precedence over this client-side behavior, but the server will still enforce the no-save policy (described below). NOTE: If you are using SmartClient Server and have specified canSave: false for a field in a DataSource definition (.ds.xml file), this is enforced on the server. This means that we will strip out any attempt to set the value of such a field before trying to process any update or add request, similar to what happens when a DataSourceField.editRequiresAuthentication','field-level declarative security check fails.
		 * Flags: IR, Group: componentBinding */
		canSave?: boolean; // Flags=IR
		/** When true, this field can only be used for sorting if the data is entirely client-side.
		 * Flags: IRW */
		canSortClientOnly?: boolean; // Flags=IRW
		/** If false, this property indicates that this field is considered "server only". This means: Components cannot bind to the field; even if you explicitly add a field with the same name to your DataBoundComponent','dataBoundComponent, it will be dropped If you are using SmartClient Server, the client will never be sent a value for the field If you are using SmartClient Server, then similar to DataSourceField.canEdit','canEdit, no updates to the field are allowed from the client. If you explicitly add a value for the field to, eg, a record you are passing to DataSource.updateData, the server will strip the value out of the record before processing the update request. canView:false is not the same thing as DataSourceField.hidden','hidden. Use canView:false when you want to prevent the client from ever seeing a field's definition or values; use hidden:true if it is fine from a security perspective that a field's definition and values are sent to the browser, but the field should not by default appear in user interface elements (but could do in some cases, like a special screen for advanced users or administrators, for example). Note that this property must be set explicitly to false to have an effect; a null or undefined setting is treated the same as true. This property is used to implement field-level view security: failing a DataSourceField.viewRequiresAuthentication','viewRequiresAuthentication, DataSourceField.viewRequiresRole','viewRequiresRole or DataSourceField.viewRequires','viewRequires test is equivalent to setting canView:false on the field (and, indeed, from the client's perspective, the field <em>has</em> had canView:false set).
		 * Flags: IR, Group: componentBinding */
		canView?: boolean; // Flags=IR
		/** If true, this property indicates that this field will hold an explicit array of child nodes for the current node. This has the same effect as specifying DataSource.childrenField to this field's name.
		 * Flags: IR, Group: dataSourceRelations */
		childrenProperty?: boolean /* Boolean */; // Flags=IR
		/** For a field that is DataSourceField.multiple','multiple:"true", controls the name of the XML tag used for each subelement during DataSource.xmlSerialize. If unset, the default tag name is "value" for a field of simple type, and for a field of DataSource type, is the tagName or ID of the DataSource (as though xmlSerialize() were called on the child DataSource).
		 * Flags: IR, Group: xmlSerialize */
		childTagName?: string /* String */; // Flags=IR
		/** Indicates that normal declarative security rules specified on this field are waived for rows that were created by the current user, as described in the discussion of DataSource.creatorOverrides','dataSource.creatorOverrides. This setting overrides dataSource.creatorOverrides, for this field only. Note that field-level creatorOverrides is conceptually slightly different to the setting at DataSource and OperationBinding levels. To give the example of a fetch operation, at the other two levels, it results in a limited set of rows being returned, rather than a security exception being thrown. At the field-level, it results in values for individual fields being present in those rows, rather than them being stripped out on the server.
		 * Flags: IR, Group: fieldLevelAuth */
		creatorOverrides?: boolean; // Flags=IR
		/** This property indicates that this field should be represented by a custom expression embedded in the WHERE clause of the generated SQL, instead of the generated expression containing this field name that would ordinarily be used. You use this property when you have to accomodate some special way of using a field's value in criteria, other than by directly comparing it to the criteria. For example, if you have a column that contains bit-packed information you will generally need to perform a bitwise AND to filter on that column, rather than an equality check. In this case, you would use a customCriteriaExpression something like this (in Oracle): &nbsp;&nbsp;&nbsp;BITAND(myField, $criteria.myField)+0 = $criteria.myField Or this (in MySQL or SQL Server): &nbsp;&nbsp;&nbsp;myField & $criteria.myField = $criteria.myField As this example shows, a customCriteriaExpression is expected to be a complete logical expression that provides both sides of the comparison. After Velocity processing, this example would result in SQL similar to this (for the MySQL case); the colored part comes entirely from the customCriteriaExpression: SELECT myField, myOtherField FROM myTable WHERE <font color='blue'>myField & 32 = 32</font> customCriteriaExpression can also be used with AdvancedCriteria. Note that the point mentioned above, about a customCriteriaExpression being a complete logical expression that provides both sides of the comparison still applies. This means that when you use customCriteriaExpression in conjunction with AdvancedCriteria, you effectively switch off support for different OperatorIds to be used on that field, unless you use Velocity expressions containing the special $criteriaOperator variable (see below). When you use customCriteriaExpression with AdvancedCriteria, the way you access criteria values differs slightly. One option is to use the $advancedCriteria Velocity variable, as described in the "Using AdvancedCriteria" section of the customQuerying','custom querying overview. However, this variable only returns the value from the first Criterion that uses the field, as found by depth-first search. If your AdvancedCriteria contains multiple references to this field, this will not be satisfactory. Therefore, specifically for customCriteriaExpression, we provide another Velocity variable, $criteriaValue. This variable means "the value on a Criterion referencing this field". An example may serve to clarify this: Assume you need to extend the above example to filter records where a certain bit is set OR a certain other bit is set. An AdvancedCriteria like this would be required (note that the choice of "equals" as the operator in these clauses is completely arbitrary - as discussed above, the operator is ignored when we have a customCriteriaExpression, so it would make no difference to the end product if we had used different operators here): { _constructor: "AdvancedCriteria", operator: "or", criteria: [ { fieldName: "myField", operator: "equals", value: 32 }, { fieldName: "myField", operator: "equals", value: 64 }, ] } If you used the customCriteriaExpression from above unchanged with this criteria, the following SQL would be generated (in the MySQL case): SELECT myField, myOtherField FROM myTable WHERE myField & null = null OR myField & null = null This is because $criteria is a variable that only works correctly with simple criteria. If you changed the $criteria references in the expression to $advancedCriteria, the generated SQL would be: SELECT myField, myOtherField FROM myTable WHERE myField & 32 = 32 OR myField & 32 = 32 This is because $advancedCriteria always returns the first value it finds for a particular field, as described above. However, if you change the expression so it reads: &nbsp;&nbsp;&nbsp;myField & $criteriaValue = $criteriaValue you will now get the correct SQL generated: SELECT myField, myOtherField FROM myTable WHERE myField & 32 = 32 OR myField & 64 = 64 Similar to $criteriaValue, we provide a special variable, $criteriaOperator. This is intended for use in Velocity expressions, so that your customCriteriaExpression can process different operators in different ways. How you choose to interpret an operator is entirely up to you; this variable is both advanced and rarely used. This example is contrived and does not show a usage that would be remotely likely in a real application, but it does show how to use the variable in a Velocity expression: &nbsp;&nbsp;&nbsp;myField #if ($criteriaOperator == "greaterThan") & #else | #end $criteriaValue = $criteriaValue For simple criteria, note that $criteriaOperator will vary depending on field type and the TextMatchStyle','textMatchStyle in force, as follows: Text fields with textMatchStyle "substring" - "iContains" Text fields with textMatchStyle "startsWith" - "iStartsWith" Text fields with textMatchStyle "exact" - "iEquals" All other cases (including text fields with textMatchStyle "exactCase") - "equals" You can use Velocity expressions in your customCriteriaExpressions, and the velocitySupport','usual context variables are available. Note that the results of Velocity evaluations are automatically quoted and escaped by default; this behavior can be switched off - see DataSourceField.autoQuoteCustomExpressions','autoQuoteCustomExpressions, and particularly note the warnings about its use. Note that this property only applies to users of the SmartClient server using dataSources of type "sql".
		 * Flags: IR */
		customCriteriaExpression?: string; // Flags=IR
		/** This property is similar to DataSourceField.customUpdateExpression','customUpdateExpression; its value is used during "add" operations. If you do not specify this property, but do specify a customUpdateExpression, the customUpdateExpression is used instead. Everything that applies to customUpdateExpression also applies to this property, including the observation that fields which specify a DataSourceField.customSelectExpression','customSelectExpression but no corresponding customUpdateExpression or customInsertExpression, will be ignored when adding new records. As with customUpdateExpression, this property is only intended to be used when you have a need to customize the actual SQL. If you simply want to use a server-derived value in the query, you should use transactionChaining','Transaction Chaining, dmiOverview','DMI, or a serverScript','server script instead. <h3>customInsertExpression with primaryKey fields</h3> if you use customInsertExpression to derive a value for a DataSourceField.primaryKey','primaryKey field, the key value will not by default be available to the framework, so the built-in cache synchronization system will not work. It may be possible to to work around this with the DataSourceField.autoGenerated','autoGenerated flag, as described below, but otherwise you must also create a OperationBinding.cacheSyncOperation','cacheSyncOperation which can retrieve the record just added to the database. Please also see the documentation for SequenceMode','SequenceMode "none", which talks further about cacheSyncOperation. Typically, primaryKey fields that need to be auto-generated are implemented using a sequence field, which at the database level translates to either an actual sequence, or an auto-increment or "identity" column. JDBC drivers have special support for such columns, so we are able to determine the generated value. This is important for primaryKey fields because, without it, we cannot re-fetch the record just inserted for cache synchronization purposes, as described above. Where a value is generated by something other than a sequence field, this special ability is lost - or at least, it is no longer guaranteed to be present. There are use cases where this may seem to be a restriction. A common case would be where you wish to use a generated UUID as primaryKey value, rather than an ordinary ascending sequence. If you had intended to do this using the database itself - for example, specifying a customInsertExpression that calls something like MySQL's UUID() built-in function - this is potentially a problem. What we would recommend in this case and anything similar, is to use the general ability for field values to be generated by application code, as described above. (Note, if you want to have application code generate values for primaryKey fields, you may need to use an OperationBinding','operationBinding that specifies OperationBinding.providesMissingKeys','providesMissingKeys). That said, different database vendors implement their JDBC drivers in different ways, and with the SQLDataSource and certain database products it is possible to retrieve values that were generated at the database level by a customInsertExpression that expresses either a user-defined function call or an inline subselect, as long as the field is marked with the autoGenerated flag. Because this behavior is potentially useful, we do not inhibit it; however, we also do not recommend that you make use of it, because the behavior is not portable across databases, and may also not be portable across JDBC driver versions (because the behavior is unspecified and undocumented, and relies on implementation details that may change). Databases where this behavior has been observed to work include Oracle, Postgres and HSQLDB; databases where this behavior is known not to work include MySQL, SQL Server, DB2 and Firebird (the latter because its JDBC driver does not support the getGeneratedKeys() API) Note that this property only applies to users of the SmartClient server using dataSources of type "sql".
		 * Flags: IR */
		customInsertExpression?: string; // Flags=IR
		/** This property indicates that this field represents a custom expression that should be embedded in the generated SQL instead of a reference to this field. For example, if you have a field partialName where this value is set to SUBSTR(surname, 2), the generated SQL would look similar to this: SELECT ... SUBSTR(surname, 2) AS partialName ... Note that adding "AS partialName" as shown above is required - this is how the framework identifies the expression as producing a value for this particular DataSourceField when results are received from the database. Fields with customSelectExpression set can be used for sorting and filtering in the normal way, but they are only applicable to update-type operations if you also provide a corresponding DataSourceField.customUpdateExpression','customUpdateExpression and/or DataSourceField.customInsertExpression','customInsertExpression. See the documentation for those methods for the rules of how they are applied. You can use Velocity expressions in your customSelectExpressions, and the velocitySupport','usual context variables are available. Note that the results of Velocity evaluations are automatically quoted and escaped by default; this behavior can be switched off - see DataSourceField.autoQuoteCustomExpressions','autoQuoteCustomExpressions, and particularly note the warnings about its use. Note that this property only applies to users of the SmartClient server using dataSources of type "sql".
		 * Flags: IR */
		customSelectExpression?: string; // Flags=IR
		/** For a DataSource with DataSource.serverType','serverType "sql" or "hibernate", indicates that this field should be omitted by default from all SQL or Hibernate operations, and will only be used with customQuerying','custom queries. Having marked a field as customSQL you can refer to it via $criteria.fieldName or $values.fieldName in customized queries. The following are situations where you would not use customSQL: simple joins where you want to enable users to see and search on a field from another table; consider DataSourceField.includeFrom instead fields where you want to calculate or transform values in SQL on load or save, but always perform the same calculation for each operationType; consider instead DataSourceField.sqlStorageStrategy for some common cases, or DataSourceField.customSelectExpression, DataSourceField.customUpdateExpression and DataSourceField.customInsertExpression for full customization a special fetch is needed where the field needs to be excluded from the $defaultWhereClause so that it can be used in a custom &lt;whereClause&gt; - consider OperationBinding.excludeCriteriaFields instead Use customSQL in situations like: there are multiple variations of the "fetch" operation with different OperationBinding.operationId','operationIds, and the field is only used in some of them; in that case, consider using OperationBinding.customFields to selectively re-introduce SQL generation for the field only in operations where it's used. the field represents hidden criteria on a field in another table where the field is never shown to the user the field is a write-only value only saved in some operations more than one data access strategy is in use (eg direct SQL for fetch and bean-based persistence accessed via DMI for saves) and certain fields are not available in SQL 
		 * Flags: IR */
		customSQL?: boolean; // Flags=IR
		/** This property specifies the value to use to update this column on "update" operations. The value of this property will be passed through Velocity evaluation and then embedded directly in the SQL generated to perform the update. It can be used in conjunction with DataSourceField.customSelectExpression','customSelectExpression to provide bi-directional mapping between application data formats and persisted data formats. Or, it can be used unilaterally as a means of silently enforcing data rules - for example, ensuring that all values for a given field are in upper case. You can use Velocity expressions in your customUpdateExpressions, and the velocitySupport','usual context variables are available. Note that the results of Velocity evaluations are automatically quoted and escaped by default; this behavior can be switched off - see DataSourceField.autoQuoteCustomExpressions','autoQuoteCustomExpressions, and particularly note the warnings about its use. The value must be a string that will end up as a valid SQL snippet after Velocity evaluation. The following examples are valid: "SUBSTR(ANOTHER_COLUMN, 1, 10)" "SUBSTR($values.someTextField.toUpperCase(), 1, 10)" "SOME_NUMERIC_COLUMN * 1000" "$values.someTextField.toUpperCase()" (this is a technically valid but incorrect usage - see below) NOTE: although all these examples are valid, customUpdateExpression is intended to be used when you have a need to customize the actual SQL. If you simply want to use a server-derived value in the query (as is the case with the last of these examples), you should use transactionChaining','Transaction Chaining, dmiOverview','DMI, or a serverScript','server script instead. In the examples above, the first is an actual SQL snippet and must not be enclosed in quotes. The second shows an SQL snippet containing a literal - because the literal is the result of a Velocity evaluation, it will be automatically quoted so there is no need to do so manually. The third example yields a number, so it must not be quoted. The last example is also the result of a Velocity evaluation and thus does not need to be quoted. Note, however, that this example involves no SQL customization - this kind of usage should be avoided, as noted above. When an "update" operation runs, any fields that specify DataSourceField.customSelectExpression','customSelectExpression but do not specify customUpdateExpression will be ignored. When an "add" operation runs, this property acts as a default for any fields that do not specify a DataSourceField.customInsertExpression','customInsertExpression; similar to update, any fields that specify a customSelectExpression but do not specify either a customUpdateExpression or customInsertExpression, will be ignored when "add" operations run. Note that this property only applies to users of the SmartClient server using dataSources of type "sql".
		 * Flags: IR */
		customUpdateExpression?: string; // Flags=IR
		/** Preferred display format to use for date type values within this field. If this property is set on a field displayed in a databound component such as a DynamicForm or ListGrid it will be respected (See FormItem.dateFormatter and ListGridField.dateFormatter). Note that this property is also honored when exporting directly to Excel spreadsheets (ie, when using XLS or XLSX/OOXML form, not CSV); "date" and "datetime" fields with this property set will deliver real dates and formatting information to Excel, rather than formatted strings or unformatted dates.
		 * Flags: IRWA, Group: appearance */
		dateFormatter?: DateDisplayFormat; // Flags=IRWA
		/** Applies only to fields of type "float" and enforces a minimum number of digits shown after the decimal point. For example, a field value of 343.1, 343.104 and 343.09872677 would all be shown as 343.10 if decimalPad is 2. The original unpadded value is always shown when the value is edited.
		 * Flags: IRW, Group: appearance */
		decimalPad?: number; // Flags=IRW
		/** Applies only to fields of type "float" and affects how many significant digits are shown. For example, with decimalPrecision 3, if the field value is 343.672677, 343.673 is shown. If the value is 125.2, 125.2 is shown - decimalPrecision will not cause extra zeros to be added. Use DataSourceField.decimalPad for this. A number is always shown with its original precision when edited.
		 * Flags: IRW, Group: appearance */
		decimalPrecision?: number; // Flags=IRW
		/** Before we start editing this field in a DataBoundComponent, should we perform a deep clone of the underlying field value. See DataSource.deepCloneOnEdit for details of what this means. If this value is not explicitly set, it defaults first to the value of DataBoundComponent.deepCloneOnEdit, then to the value of DataSource.deepCloneOnEdit. Like the other deepCloneOnEdit settings, this flag only has an effect if you are editing a values object that contains nested objects or arrays, using Canvas.dataPath','dataPaths.
		 * Flags: IRWA */
		deepCloneOnEdit?: boolean /* Boolean */; // Flags=IRWA
		/** Whether this field should be considered a "detail" field by a DataBoundComponent. Detail fields won't be shown by default in a DataBoundComponent where DataBoundComponent.showDetailFields is false. This allows for some DataBound components, like a ListGrid, to show a summary view of records which displays only the most commonly viewed fields by default, while other DataBoundComponents, like a DetailViewer, show all fields by default. In addition, the FormItem.showIf','formItem.showIf property is supported in multiple components for conditional visibility - see for example ListGridField.showIf and FormItem.showIf).
		 * Flags: IR, Group: componentBinding */
		detail?: boolean; // Flags=IR
		/** Name of another field in this DataSource that should be used as the display value for this field. Typically used for editable DataSourceField.foreignKey','foreignKey fields: the foreignKey field stores an ID value, and this ID value is the right value to use when editing (typically by a SelectItem with SelectItem.optionDataSource','optionDataSource set). However, when the foreignKey field is viewed read-only, it should display a name, title or other friendly value from the related record. In order to accomplish this, a second, hidden field carries the display value, and the foreignKey field has displayField set to this second, hidden field. For a more in-depth discussion, see DataSourceField.includeFrom.
		 * Flags: IR, Group: dataSourceRelations */
		displayField?: string /* String */; // Flags=IR
		/** Sets the default FormItem to be used whenever this field is edited (whether in a grid, form, or other component). If unset, a FormItem will be automatically chosen based on the type of the field, by the rules explained FormItemType','here.
		 * Flags: IR, Group: componentBinding */
		editorType?: string /* FormItem className */; // Flags=IR
		/** Indicates that the specified VelocityExpression must evaluate to true if writes to this field are to be allowed. If the specified expression does not evaluate to true, the field will be removed from the request as described for DataSourceField.editRequiresAuthentication','editRequiresAuthentication. In addition to the normal context variables available to Velocity expressions in SmartClient, expressions you write for field-level requires clauses - editRequires, DataSourceField.viewRequires','viewRequires, DataSourceField.initRequires','initRequires and DataSourceField.updateRequires','updateRequires - can reference two additional variables: $fieldName and $dsName. These are the names of the dataSource and field currently undergoing requires checks. They are helpful because they allow you to write a generic checker function that can be used to handle requires checks for multiple fields and dataSources. NOTE: This property prevents both initialization and updates for a field. If you have a need to prevent <em>just</em> initialization or <em>just</em> updates, you can use DataSourceField.initRequires or DataSourceField.updateRequires.
		 * Flags: IR, Group: fieldLevelAuth */
		editRequires?: string /* VelocityExpression */; // Flags=IR
		/** Whether a user must be authenticated in order to write to this field. If this property is set and the user is not authenticated, the SmartClient Server will not allow this field to be updated or initialized. This property affects two things. Firstly, the server determines when the DataSource is first loaded if we have an authenticated user; if we don't, the field is marked canEdit: false. Secondly, when an insert or update request is received from the client, the server removes the field from the values clause before the request is processed. Note that you can override this behavior. The canEdit setting can be overridden on the the client-side DataSource like any other client-side property. The value-removing behavior can be overridden on a per-request basis by providing a DMI that re-adds values for the fields you want for that particular request to the values object (the values originally sent up by the client are available on the DSRequest). See the server-side Javadocs for DSRequest.getValues() and DSRequest.getClientSuppliedValues().
		 * Flags: IR, Group: fieldLevelAuth */
		editRequiresAuthentication?: boolean; // Flags=IR
		/** Comma-separated list of user roles that are allowed to write to this field. If the current user does not have any of the roles listed, the system will not allow this field to be initialized or updated. Please see OperationBinding.requiresRole for further details of SmartClient's declarative role-based security. Please also see DataSourceField.editRequiresAuthentication','editRequiresAuthentication for details of how declarative field-level security settings can be overridden per-request. NOTE: This property prevents both initialization and updates for a field. If you have a need to prevent <em>just</em> initialization or <em>just</em> updates, you can use DataSourceField.initRequiresRole or DataSourceField.updateRequiresRole.
		 * Flags: IR, Group: fieldLevelAuth */
		editRequiresRole?: string /* String */; // Flags=IR
		/** Text to be used for display by client-side components when this field has a null or undefined value. This value will be overridden by a component's emptyCellValue, if set.
		 * Flags: IR, Group: appearance */
		emptyDisplayValue?: string /* HTMLString */; // Flags=IR
		/** When set for a field with binary data, binary data will be delivered as a Base64 encoded string. When encodeInResponse is not set normal responses will not contain values for binary fields at all. Instead, UI components, such as TileGrid issue a second binary fetch for binary data when appropriate, and APIs such as DataSource.downloadFile','downloadFile() and DataSource.viewFile','viewFile() can be used to programmatically trigger downloads. Only applicable to fields of a type that are represented by binary data (currently "binary" and "imageFile", see FieldType).
		 * Flags: IRW */
		encodeInResponse?: boolean; // Flags=IRW
		/** When data values are displayed in DataBound components, by default strings will be interpreted as HTML by the browser in most cases. If set, this property will be picked up by components bound to this dataSource, notifying them that any HTML characters should be escaped when displaying values for this field.
		 * Flags: IR */
		escapeHTML?: boolean /* Boolean */; // Flags=IR
		/** If true, then this field is excluded from the bound component's view state. In addition, the field will not be selected as the default title field by DataBoundComponent.getTitleField if DataBoundComponent.titleField is not provided.
		 * Flags: IR, Group: viewState */
		excludeFromState?: boolean /* Boolean */; // Flags=IR
		/** An optional FormatString for this field, for use when DataBoundComponent.exportData','exporting data to spreadsheet formats (XLS and OOXML/XLSX), XML, JSON or CSV. You can use this property to override the normal DataSourceField.format','format of this field, if any, specifically for exports. Note, for server-driven exports you can specify default formats for date, time and datetime fields by specifying properties export.format.default.date, export.format.default.time and export.format.default.datetime in your server.properties file. These formats will be used for fields that do not have a "format" or "exportFormat" property specified in the .ds.xml file. Specifically when exporting to spreadsheet formats, the FormatString is translated to the type of format string used by spreadsheet programs like Excel. A handful of features are not present in Excel format strings, and some features behave slightly differently. These differences are explained below. <h3>Excel cannot handle dates prior to January 1st 1900</h3> This is a well-known limitation of Excel dates; it is not a formatting issue as such. <h3>Currency symbols become fixed to the current locale at export time</h3> The placeholder currency symbol "&#x00A4" (\u00A4) in a numeric format string is rendered as the NumberUtil.currencySymbol','localized currency symbol. When exporting, the format string provided to Excel contains the currency symbol for the current locale of the SmartClient application, and not a placeholder currency symbol that would make Excel pick up a currency symbol based on the operating system locale. We do this to ensure that the spreadsheet reflects the <em>application's</em> localization, rather than the localization of the current user's computer, because they may be different. <h3>Rounding differences</h3> The approach to rounding a positive number to a set number of decimal places is fairly universally agreed upon for non-specialized requirements: add 0.5 (or 0.05, or 0.005, or whatever) to the number and then truncate. This leads to the well understood convention that numbers exactly halfway between two possible rounding outcomes, go to the larger one. So 7.5 becomes 8 and 7.15 becomes 7.2. However, there is no such universal agreement when it come to rounding negative numbers. Some take the view that you should round by taking the number to the larger absolute value, so -7.15 becomes -7.2. Others feel that you should round by taking the number to the larger value in the sense of it being "less negative", so -7.15 becomes -7.1. SmartClient formatting takes the first approach and rounds negative numbers away from zero. We do this simply because that is what Java DecimalFormat does. Unfortunately, Excel does the opposite. Therefore, you will see rounding differences on negative numbers on exact 50% boundaries: SmartClient will format -7.15 as -7.2, while Excel will format the same value as -7.1. <h3>Different treatment of '#'</h3> Both SmartClient and Excel use '#' to mean "digit, do not show zeroes". However, Excel does not implement this strictly in the integer part when the number it is formatting has a value of 0 in the integer part. So, with a format of "#.##", the value 0.25 is formatted as "0.25". SmartClient (like Java DecimalFormat) is strict: with that format, 0.25 is formatted as ".25"; if you want to match Excel's output, you must use the format "0.##". <h3>Miscellaneous edge cases</h3> There is quite a lot of variation in behavior between Java DecimalFormat and Excel around the edges. For actual error cases - for example, a format string that just contains nonsense - it is normal and expected that the SmartClient behavior and the Excel behavior do not match - this is just two systems producing different garbage out for the same garbage in, which is to be expected. For valid but weird usages - for example, a format with multiple percent signs - SmartClient's formatting is in line with what DecimalFormat does, unless DecimalFormat throws an Exception, in which case we just do the thing that seems most sensible, or the thing that was easiest to implement. Known differences in behavior in edge cases include: SmartClient ignores formatting characters in the number part of the format string, whereas Excel rejects the format (this behavior may vary with different releases of Excel and supposedly compatible libraries: POI, for example, will accept such format strings). If you attempt to format 5.175 with the format string "#b0.#a#", SmartClient will return "5.72", and Excel will reject the format SmartClient ignores quoted characters in the number part of the format string, whereas Excel preserves them. If you attempt to format 5.175 with the format string "#'b'0.#'a'#", SmartClient will return "5.72", and Excel will return "b5.7a2" If you specify the empty string as a format string, SmartClient returns the result of calling toString() on the number; Excel uses the built-in "General" format. These two approaches will generally give the same or very similar results, but that is really a coincidence: the correct way to obtain matching results in the browser and the spreadsheet is to specify a valid format string If you specify a format string that contains no number part (ie, no '#' or '0' characters), SmartClient does what DecimalFormat does, which is to output the integer part of the number alongside the fixed part of the format. Excel just outputs the fixed part. So, if you attempt to format -5.3 with the format string "'Hello world'", SmartClient will output "-Hello world5", whereas Excel will output just "Hello world" If you specify multiple percent signs in the format, SmartClient treats all but the first one as static text, so 0.5 formatted with "#%%%" is "50%%%" (ie, all the signs are preserved but there is only one multiplcation by 100). Excel multiplies for each percent sign, so 0.5 formatted with "#%%%" is "500000%%%" <h3>Date format functionality not supported by Excel</h3> The following date/time/datetime functionality is not supported by Excel; if you use formatters that use any of this functionality, your values will be exported to Excel incorrectly formatted. In cases like this, we recommend that you use a separate exportFormat, with the intent of exporting your values in a way that is similar to your application formatting (which would be specified with the DataSourceField.format','format property), but within the confines of what Excel supports. Fiscal year, week and day (LL, LLLL, C, CC, c, cc) Week in year (w, ww) Day in year (D, DD) Day number in week (u) Explicit control over whether to use 12- or 24-hour notation. In Excel, this is implied by the presence or absence of the AM/PM designator If the user's operating system locale is different to the locale in use in the SmartClient application, day and month names may be different in the spreadsheet <h3>Number format functionality not supported by Excel</h3> The only SmartClient number-formatting functionality not supported for export to Excel is "multiply by 1000 and show as per mille". <h3>Limit on number of custom Excel formats</h3> Excel limits the number of custom format strings in a single spreadsheet to somewhere between 200 and 250, depending on your locale and language. Hitting this limit in an export would require hundreds of field definitions, each defining unique FormatStrings. If you do hit the limit, the only workaround is to use fewer unique FormatStrings.
		 * Flags: IRW */
		exportFormat?: string /* FormatString */; // Flags=IRW
		/** Optional different field-title used for exports.
		 * Flags: IR */
		exportTitle?: string /* String */; // Flags=IR
		/** Sets the default FormItem to be used for this field if it appears in a filter row, and DataSourceField.canFilter is not false. Note: If this is not specified, the edit-formItem type may be derived from the DataSourceField.editorType property, or from the field's DataSourceField.type.
		 * Flags: IR, Group: componentBinding */
		filterEditorType?: string /* FormItem className */; // Flags=IR
		/** Name of another field in a separate dataSource that should be used as the display value for this field in the case where a foreignKey relationship exists. This property is useful for fields being edited in a FormItem where options are being retrieved from an FormItem.optionDataSource, for the case where a separate DataSourceField.displayField name is used within the local dataSource than the field name for the display field within the foreign dataSource. See FormItem.foreignDisplayField for more on this, and see DataSourceField.includeFrom for a discussion about picking up dataSource field values from a related dataSource.
		 * Flags: IR, Group: dataSourceRelations */
		foreignDisplayField?: string /* String */; // Flags=IR
		/** Declares that this field holds values that can be matched to values from another DataSource field, to create a relationship between records from different DataSources or even records within the same DataSource. The format of foreignKey is dataSourceId.fieldName. For a foreignKey within the same dataSource, you can omit the dataSourceId and just specify fieldName. For example, to create a tree relationship within a DataSource: isc.DataSource.create({ ID:"supplyItem", fields : [ {name:"itemId", type:"sequence", primaryKey:true}, {name:"parentId", type:"integer", foreignKey:"itemId"}, ... ] }); foreignKey declarations also allow other automatic behaviors by DataBoundComponent','DataBoundComponents, such as ListGrid.fetchRelatedData. For SQLDataSources foreign keys can be automatically discovered from SQL tables if DataSource.autoDeriveSchema','autoDeriveSchema is set.
		 * Flags: IR, Group: dataSourceRelations */
		foreignKey?: string /* String */; // Flags=IR
		/** Format string to use when rendering the value in any DataBoundComponent or when exporting via DataSource.exportData or ListGrid.exportData or ListGrid.exportClientData. Supported for fields of type "date", "time", "datetime", "int", "float" or any derived SimpleType. To configure a different format for export, use DataSourceField.exportFormat. This is a per-field setting; you can alternatively set a default format for all "date", "time" or "datetime" fields via DateUtil.setNormalDatetimeDisplayFormat and related methods on Date. See also localizedNumberFormatting for built-in FieldType','FieldTypes that handle localized currency formatting. Also note, this property takes precedence over any specified DataSourceField.dateFormatter','dateFormatter, but can be overridden on a per-component basis by providing a formatter directly on the component, for example, via ListGrid.formatCellValue or FormItem.formatValue.
		 * Flags: IRW */
		format?: string /* FormatString */; // Flags=IRW
		/** For use in componentSchema, indicates what group to place the property in when editing in Visual Builder.
		 * Flags: IR, Group: componentSchema */
		group?: string; // Flags=IR
		/** Whether this field should be hidden from users by default within a DataBound component. This is generally used for internal IDs and other fields not meaningful to users. See DataSourceField.detail for fields that should be hidden in a summary view such as a ListGrid, but still available to the user. NOTE: This property is not a security setting - data for hidden fields is still delivered to the client, it just isn't shown to the user. If you wish to make sure that only appropriate data reaches the client, use OperationBinding.outputs, DataSourceField.canView:false on the field, or a field-level declarative security setting like DataSourceField.viewRequiresRole.
		 * Flags: IR, Group: componentBinding */
		hidden?: boolean; // Flags=IR
		/** Whether this field should be completely excluded from this dataSource, as if it had never been defined. If set to true, the field will be entirely omitted when serving a DataSource derived from a server-side definition (typically a .ds.xml file) to the client.
		 * Flags: IR, Group: componentBinding */
		ignore?: boolean; // Flags=IR
		/** NOTE: Only applicable to DataSource.clientOnly','clientOnly DataSources and the built-in sqlDataSource','SQL, jpaIntegration','JPA and hibernateIntegration','Hibernate DataSources available in Pro, Power and Enterprise versions of SmartClient. Use this flag to inhibit the normal use of TextMatchStyle for this field. A field with this flag set will always be tested for exact equality in generated queries, even for filter-style queries where normal behavior would be to use a substring match or similar. Whether or not the exact match is case-sensitive is determined by the DataSource's DataSource.ignoreTextMatchStyleCaseSensitive','ignoreTextMatchStyleCaseSensitive setting.
		 * Flags: IRW */
		ignoreTextMatchStyle?: boolean /* Boolean */; // Flags=IRW
		/** Height of the image-content of this field. If set as a string, represents the name of another field in the record that holds the imageHeight. Applicable only to fields of image type or fields that use a ViewFileItem','ViewFileItem as an editor.
		 * Flags: IR */
		imageHeight?: number | string /* number or String */; // Flags=IR
		/** Width and height of the image-content of this field. If set as a string, represents the name of another field in the record that holds the imageSize. Applicable only to fields of image type or fields that use a ViewFileItem','ViewFileItem as an editor.
		 * Flags: IR */
		imageSize?: number | string /* number or String */; // Flags=IR
		/** Width of the image-content of this field. If set as a string, represents the name of another field in the record that holds the imageWidth. Applicable only to fields of image type or fields that use a ViewFileItem','ViewFileItem as an editor.
		 * Flags: IR */
		imageWidth?: number | string /* number or String */; // Flags=IR
		/** For a field of FieldType','type "sequence" on a DataSource with DataSource.serverType','serverType:"sql", this flag indicates that the field is implicitly bound to a sequence. This setting means that SmartClient does not expect to find a value for the field in "add" operations, even if it is marked as a DataSourceField.primaryKey','primaryKey, as such fields usually are. It also means that SmartClient does not attempt to retrieve the field value from an actual database sequence, instead relying on the JDBC driver to return the generated value (see the note on sequenceMode below). Implicitly bound columns are a syntactic convenience provided by some databases to simulate the "auto-increment" or "identity" columns available natively in other products, without the underlying sequence having to be explicitly referenced in SQL queries. Currently, these database products support this idea: PostgreSQL has had a "serial" column type for a long time - <a href=http://www.postgresql.org/docs/9.3/static/datatype-numeric.html#DATATYPE-SERIAL> http://www.postgresql.org/docs/9.3/static/datatype-numeric.html#DATATYPE-SERIAL</a> DB2 has long supported a "GENERATED AS IDENTITY" notation for numeric fields. This may or may not be implemented with a sequence - the documentation does not specify - but we support it via the implicitSequence mechanism because it is so similar to the implicit sequence approach in Oracle. <a href="http://publib.boulder.ibm.com/infocenter/dzichelp/v2r2/index.jsp?topic=/com.ibm.db2z10.doc.apsg/src/tpc/db2z_identitycols.htm"> http://publib.boulder.ibm.com/infocenter/dzichelp/v2r2/index.jsp?topic=/com.ibm.db2z10.doc.apsg/src/tpc/db2z_identitycols.htm</a> Oracle introduced a "GENERATED AS IDENTITY" notation for numeric fields in version 12c - <a href=http://www.oracle-base.com/articles/12c/identity-columns-in-oracle-12cr1.php> http://www.oracle-base.com/articles/12c/identity-columns-in-oracle-12cr1.php</a> If you have columns like these in your database, declare them as type "sequence" and mark them with the implicitSequence flag. NOTE: If you use this property, you should also set the DataSource.sequenceMode','DataSource sequenceMode to "jdbcDriver". This is necessary because SmartClient cannot directly query the implicit sequence that is being used behind the scenes, so we must rely on the JDBC driver to do that. If you use DataSource.autoDeriveSchema','autoDeriveSchema to automatically derive a dataSource from table metadata, SmartClient attempts to identify these special Oracle and Postgres columns by heuristic examination of the metadata. When it identifies such a column, it marks the corresponding dataSourceField implicitSequence: true, and changes the sequenceMode on the DataSource to "jdbcDriver". If your table contains one of these columns and SmartClient does not automatically identify it, bear in mind that you can always set this flag manually, even if you are using autoDeriveSchema. This setting has no effect for non-SQL dataSources, or for databases other than those mentioned above.
		 * Flags: IR, Group: sqlDataSource */
		implicitSequence?: boolean /* Boolean */; // Flags=IR
		/** Declares the FieldImportStrategy for this field. The default setting of null has the same meaning as "auto". Note, this attribute only has an effect if all of the following are true: The field declares a DataSourceField.foreignKey','foreignKey The field declares a DataSourceField.displayField','displayField The displayField so declared is DataSourceField.includeFrom','included from the same DataSource that the foreignKey declaration refers to In any other circumstances, this attribute is ignored. importStrategy is applied by the server-side DataImport.importToRows() method, which is in turn used by BatchUploader and several other DataImport APIs such as importToDataSource(), importDataSourceRecords() and importAndValidateDSRows(). See the server-side documentation for details of these APIs. The actual data transformation is carried out by the server-side API DataSource.transformImportValue(); this method can be overridden to carry out any other transformation you may require.
		 * Flags: IR */
		importStrategy?: FieldImportStrategy; // Flags=IR
		/** For use in componentSchema, a field DataSource.inheritsFrom','inherited from another schema can be redeclared with this property set in order to indicate that the property should not be used. This is primarily used to influence visualBuilder. For simple type properties, this avoids the property appearing in the Component Editor. For fields that hold subcomponents, this prevents inappropriate drag and drop. For example, a custom class called MyDialog may automatically create a series of children, and not allow arbitrary other children to be added. In this case, the inherited property Canvas.children should be marked inapplicable in order to prevent arbitrary components being dropped onto a MyDialog instance.
		 * Flags: IR, Group: componentSchema */
		inapplicable?: boolean; // Flags=IR
		/** Indicates this field should be fetched from another, related DataSource. The incluedFrom attribute should be of the form "dataSourceId.fieldName", for example: &lt;field includeFrom="supplyItem.itemName"/&gt; A DataSourceField.foreignKey declaration must exist between the two DataSources, establishing either a 1-to-1 relationship or a many-to-1 relationship from this DataSource to the related DataSource. The inclusion can be indirect (traverse multiple DataSources) so long as there is a chain of foreignKey declarations from the target DataSource to the DataSource where the includeFrom field is declared. For including from a related DataSource where there are multiple related records, see DataSourceField.includeSummaryFunction','includeSummaryFunction. DataSourceField.name will default to the name of the included field, or you can specify a different name. If both DataSources are SQLDataSources, HibernateDataSources or JPADataSources (with Hibernate as the provider) the related data will be retrieved via a SQL join and criteria and sort directions applied to the field work normally (they become part of the generated SQL query). Otherwise, the related data will be retrieved via performing a DSRequest against the related DataSource once the data from the primary DataSource has been retrieved. In this case, criteria or sorting directions applied to the included field are only allowed if data paging is not in use (for example ListGrid.dataFetchMode:"basic"); otherwise, criteria and sort direction are ignored for the included field and a warning is logged on the server. Editing included fields An included field is DataSourceField.canEdit','canEdit:false by default. Note that included fields are not updatable, even if you set canEdit:true; the server will simply drop values for included fields if client code sends them. When thinking about editing an included field value, typically what is really intended is to edit the value of the foreignKey field. For example, take the scenario of a system that tracks accounts and the employees assigned to manage them. Given a DataSource "account" related one-to-one with DataSource "employee" by a "managerId" foreignKey field, we might declare an includeFrom so that the name of the account manager can be shown with each "account" record. Editing the manager's name while viewing the account would be intended to pick a new account manager, and not to change the legal name of the employee who happens to be the current account manager. To correctly set up this scenario, declare an includeFrom field that is hidden, but is used as the DataSourceField.displayField','displayField for the foreign key field. Setting useLocalDisplayFieldValue to true will ensure the display field value is picked up from the record currently being edited: &lt;field name="managerId" foreignKey="employee.id" displayField="managerName" useLocalDisplayFieldValue="true"/&gt; &lt;field name="managerName" includeFrom="employee.name" hidden="true"/&gt; Now: the "managerId" foreignKey field is shown in grids and forms, but takes its displayed value from the hidden includeFrom field. the automatically chosen editor will be a SelectItem with SelectItem.optionDataSource','optionDataSource set to "employees": it will allow picking a different "employee" record from the "employee" DataSource saving will save the ID of a new "employee" record to the "managerId" foreign key field, as intended You can alternatively set editorType="ComboBoxItem" on the "managerId" field to allow typeahead search of the "employee" DataSource. Note that the DataSourceField.foreignDisplayField attribute allows developers to have a different fieldName be used locally as a displayField from the field name for the display field in the foreign dataSource.
		 * Flags: IR, Group: dataSourceRelations */
		includeFrom?: string /* String */; // Flags=IR
		/** For a field that uses DataSourceField.includeFrom, specifies which DataSourceField.foreignKey','foreignKey field should be used to find records in the related DataSource. includeVia only needs to be set when you have more than one foreignKey to the same related DataSource. If you have multiple foreignKeys to multiple different DataSources, there is no need to set includeVia. For example, perhaps you have a DataSource "moneyTransfer" where each record represents a money transfer, where the source and payment currencies are different, and the list of currencies is stored in a related DataSource "currency". Each "moneyTransfer" record is linked to 2 "currency" records, through two different foreignKey fields, "sourceCurrencyId" and "paymentCurrencyId". The following declarations would be required to use includeFrom to get a include the field "currencySymbol" from each of the two related "currency" records. &lt;field name="sourceCurrencyId" foreignKey="currency.id"/&gt; &lt;field name="paymentCurrencyId" foreignKey="currency.id"/&gt; &lt;field name="sourceCurrencySymbol" includeFrom="currency.currencySymbol" includeVia="sourceCurrencyId"/&gt; &lt;field name="paymentCurrencySymbol" includeFrom="currency.currencySymbol" includeVia="paymentCurrencyId"/&gt; <h3>SQL Templating and includeVia</h3> The includeVia feature uses SQL table aliases in the generated SQL when generating multiple SQL joins to the same SQL table. When using customQuerying','SQL Templating, it's sometimes necessary to know the names of the aliases in the generated SQL. The table alias used can be configured via setting DataSourceField.relatedTableAlias on the foreignKey field, for example, using the declarations below, aliases "source" and "payment" would be used for the two "currency" tables. &lt;field name="sourceCurrencyId" foreignKey="currency.id" relatedTableAlias="source"/&gt; &lt;field name="paymentCurrencyId" foreignKey="currency.id" relatedTableAlias="payment"/&gt; &lt;field name="sourceCurrencySymbol" includeFrom="currency.currencySymbol" includeVia="sourceCurrencyId"/&gt; &lt;field name="paymentCurrencySymbol" includeFrom="currency.currencySymbol" includeVia="paymentCurrencyId"/&gt; <h3>Multiple indirection and relatedTableAlias</h3> Sometimes you may have two includeFrom fields that include a field which is itself included from another DataSource, for example: &lt;field name="sourceCurId" nativeName="sourceCurrencyId" foreignKey="currency.id" relatedTableAlias="source"/&gt; &lt;field name="sourceCurrencySymbol" includeFrom="currency.currencySymbol" includeVia="sourceCurId"/&gt; &lt;field name="sourceCurrencyGroup" includeFrom="currency.groupName" includeVia="sourceCurId"/&gt; &lt;field name="paymentCurId" nativeName="paymentCurrencyId" foreignKey="currency.id" relatedTableAlias="payment"/&gt; &lt;field name="paymentCurrencySymbol" includeFrom="currency.currencySymbol" includeVia="paymentCurId"/&gt; &lt;field name="paymentCurrencyGroup" includeFrom="currency.groupName" includeVia="paymentCurId"/&gt; .. where the "currency" DataSource used above is related to the "currencyGroup" DataSource via fields: &lt;field name="groupId" type="integer" foreignKey="currencyGroup.id" relatedTableAlias="group"/&gt; &lt;field name="groupName" type="text" includeFrom="currencyGroup.groupName"/&gt; Fields "sourceCurrencyGroup" and "paymentCurrencyGroup" include a field that is itself an included field. In this case "currencyGroup" table will be referenced two times, and its relatedTableAlias defined in "currency" DataSource will be prefixed with the includeVia value to make aliases unique in generated SQL: "sourceCurId_group" and "paymentCurId_group". The same aliases would be used if "sourceCurrencyGroup" and "paymentCurrencyGroup" fields were to include "currencyGroup.groupName" indirectly: &lt;field name="sourceCurrencyGroup" includeFrom="currency.currencyGroup.groupName" includeVia="sourceCurId"/&gt; &lt;field name="paymentCurrencyGroup" includeFrom="currency.currencyGroup.groupName" includeVia="paymentCurId"/&gt; This works the same for more complex relationships. If we add a "moneyTransferDetail" DataSource to the sample above which has multiple references to "moneyTransfer" DataSource and would include fields from "currency" and "currencyGroup" DataSources: &lt;field name="mtId" nativeName="moneyTransferId" type="integer" foreignKey="moneyTransfer.id" relatedTableAlias="main" /&gt; &lt;field name="mainTransferName" includeFrom="moneyTransfer.name" includeVia="mtId" /&gt; &lt;field name="mainSourceSymbol" includeFrom="moneyTransfer.sourceCurrencySymbol" includeVia="mtId" /&gt; &lt;field name="mainSourceGroup" includeFrom="moneyTransfer.sourceCurrencyGroup" includeVia="mtId" /&gt; &lt;field name="mainPaymentSymbol" includeFrom="moneyTransfer.paymentCurrencySymbol" includeVia="mtId" /&gt; &lt;field name="mainPaymentGroup" includeFrom="moneyTransfer.paymentCurrencyGroup" includeVia="mtId" /&gt; &lt;field name="mtPrevId" nativeName="moneyTransferPreviousId" type="integer" foreignKey="moneyTransfer.id" relatedTableAlias="prev" /&gt; &lt;field name="previousTransferName" includeFrom="moneyTransfer.name" includeVia="mtPrevId" /&gt; &lt;field name="previousSourceSymbol" includeFrom="moneyTransfer.sourceCurrencySymbol" includeVia="mtPrevId" /&gt; &lt;field name="previousSourceGroup" includeFrom="moneyTransfer.sourceCurrencyGroup" includeVia="mtPrevId" /&gt; &lt;field name="previousPaymentSymbol" includeFrom="moneyTransfer.paymentCurrencySymbol" includeVia="mtPrevId" /&gt; &lt;field name="previousPaymentGroup" includeFrom="moneyTransfer.paymentCurrencyGroup" includeVia="mtPrevId" /&gt; In this scenario the "currencyGroup" table will be joined 4 times - for all main/prev transfer and payment/source currency combinations. So, aliases will be prefixed with both intermediate includeVia values: "mtId_sourceCurId_group", "mtId_paymentCurId_group", "mtPrevId_sourceCurId_group", "mtPrevId_paymentCurId_group". It is also allowed to specify a series of FK fields in includeVia, for example "moneyTransferDetail" could declare: &lt;field name="mainSourceCurrencyGroup" includeFrom="moneyTransfer.currency.currencyGroup.groupName" includeVia="mtId.sourceCurId"/&gt; &lt;field name="mainPaymentCurrencyGroup" includeFrom="moneyTransfer.currency.currencyGroup.groupName" includeVia="mtId.paymentCurId"/&gt; In this case the prefix used for table aliases will be the includeVia value with "_" substituted for ".", so the table aliases will be "mtId_sourceCurId_group" and "mtId_paymentCurId_group". Note that if DataSourceField.relatedTableAlias','related table alias is not specified, then we don't make any guarantees what alias will be generated. Note that Oracle has a limit of 30 characters on identifier names. We limit table aliases to 30 characters all databases despite actual database in use to support portability across databases. If the generated table alias would exceed 30 chars, we instead use a generated and unpredictable value like "a123". To avoid hitting this limit for the advanced cases discussed above: use relatively short strings for relatedTableAlias for rare, multi-step inclusion scenarios where multiple field names are used as a prefix, if field names are very long in order to match database column names, you can use a shorter field name and use DataSourceField.nativeName to specify the underlying column name (this is demonstrated in samples above - note field "mtPrevId") 
		 * Flags: IR, Group: dataSourceRelations */
		includeVia?: string /* String */; // Flags=IR
		/** Indicates that the specified VelocityExpression must evaluate to true if initializations of this field are to be allowed. If the specified expression does not evaluate to true, the field will be removed from the request as described for DataSourceField.editRequiresAuthentication','editRequiresAuthentication. In addition to the normal context variables available to Velocity expressions in SmartClient, expressions you write for field-level requires clauses - initRequires, DataSourceField.viewRequires','viewRequires, DataSourceField.editRequires','editRequires and DataSourceField.updateRequires','updateRequires - can reference two additional variables: $fieldName and $dsName. These are the names of the dataSource and field currently undergoing requires checks. They are helpful because they allow you to write a generic checker function that can be used to handle requires checks for multiple fields and dataSources. NOTE: This property only prevents initialization of a field; updates will still be allowed. You should only use this property if you have a special requirement; ordinarily, use DataSourceField.editRequires, which applies security for both types of write.
		 * Flags: IR, Group: fieldLevelAuth */
		initRequires?: string /* VelocityExpression */; // Flags=IR
		/** Whether a user must be authenticated in order to initialize to this field. If this property is set and the user is not authenticated, the SmartClient Server will not allow this field to be initialized.
		 * Flags: IR, Group: fieldLevelAuth */
		initRequiresAuthentication?: boolean; // Flags=IR
		/** Comma-separated list of user roles that are allowed to initialize this field. If the current user does not have any of the roles listed, the system will not allow this field to be initialized. NOTE: This property only prevents initialization of a field; updates will still be allowed. You should only use this property if you have a special requirement; ordinarily, use DataSourceField.editRequiresRole, which applies security for both types of write.
		 * Flags: IR, Group: fieldLevelAuth */
		initRequiresRole?: string /* String */; // Flags=IR
		/** Explicitly declares the Java class that should be used when data from the client is validated by the SmartClient server and/or applied to Java Beans / POJOs via the server-side API com.isomorphic.datasource.DataSource.setProperties(). This includes auto-populating POJO arguments of a dmiOverview','DMI method, or populating JPA/Hibernate beans with data when using the built-in JPA and Hibernate DataSources. For DataSources that do not use Java Beans, fields declared to be of type "integer" or "float" can use javaClass to force a particular numeric representation for validated DSRequest data (e.g. data passed to a DMI). Valid settings include "BigInteger", "Long", "Integer", "Short", "Byte", "AtomicInteger", "AtomicLong", "BigDecimal", "Double", "Float". When populating Java Beans/ POJOs, javaClass does not normally have to specified: SmartClient will use Java reflection to inspect the type of argument expected by a setter method and will attempt conversion of inbound data to that type. As described in the documentation for DataTools.setProperties(), this works for almost all typical cases. However field.javaClass is useful for: subobject of abstract or interface type: in this case Java Reflection is not sufficient to discover the concrete type that should be instantiated, and javaClass should be set instead. subobject of Collection or Map type, when Java generics are not used or the Collection member type or Map value type is abstract. When Java generics are used (for example the setter takes an argument is of type Collection&lt;SomePOJO&gt; or Map&lt;KeyType,SomePOJO&gt;, SmartClient will automatically attempt to convert inbound data to the type of the members of the Collection or values of the Map. Without generics, javaClass needs to be specified. Note that javaClass will take precedence over generics if both are used. Also note that DataSourceField.javaCollectionClass can be specified if a particular Collection or Map type is needed, and DataSourceField.javaKeyClass can be specified for a field of type java.util.Map. NOTE: It is also possible to make SmartClient Server determine the javaClass to use dynamically at runtime. See the description of DataSource.getPropertyJavaClass() in the server documentation for details.
		 * Flags: IR */
		javaClass?: string /* String */; // Flags=IR
		/** See DataSourceField.javaClass - when auto-populating of Java Beans / POJOs based on inbound DSRequest data, for a field of type Collection or Map, javaCollectionClass can be used to specify a particular concrete class to use. If not specified, and a concrete Collection or Map class cannot be discovered using Java Reflection, the following concrete classes are used: java.util.ArrayList is used for fields of type List java.util.HashSet is used for fields of type Set java.util.LinkedList is used for fields of type Queue org.apache.commons.collections.map.LinkedMap is used for fields of type Map java.util.ArrayList is used for fields that are otherwise of type Collection Note that this value is used even if the target Collection or Map is declared as a concrete class. So, for example, if you set javaCollectionClass to java.util.LinkedList but your setter method accepts a java.util.ArrayList, you will get a ClassCastException.
		 * Flags: IR */
		javaCollectionClass?: string /* String */; // Flags=IR
		/** See DataSourceField.javaClass - when auto-populating of Java Beans / POJOs based on inbound DSRequest data, for a field of Map type, javaKeyClass can be used to specify a particular concrete class for the map keys. If not specified, and a concrete type cannot be discovered using Java Reflection, java.lang.Object is used. Note that javaKeyClass take precedence over generics if both are used.
		 * Flags: IR */
		javaKeyClass?: string /* String */; // Flags=IR
		/** Defines prefix before concatenated values if field is used with serverSummaries','Server summaries feature and the SummaryFunction','summary function is "concat".
		 * Flags: IR, Group: serverSummaries */
		joinPrefix?: string /* String */; // Flags=IR
		/** Defines the delimiter between concatenated values if field is used with serverSummaries','Server summaries feature and the SummaryFunction','summary function is "concat". The default value is ", ".
		 * Flags: IR, Group: serverSummaries */
		joinString?: string /* String */; // Flags=IR
		/** Defines suffix after concatenated values if field is used with serverSummaries','Server summaries feature and the SummaryFunction','summary function is "concat".
		 * Flags: IR, Group: serverSummaries */
		joinSuffix?: string /* String */; // Flags=IR
		/** This property is only applicable to fields of SQL DataSources that also specify a DataSourceField.foreignKey','foreignKey property; it is ignored for all other fields. Indicates the type of join to make between the tables underlying this DataSource and the other DataSource referred to in the foreignKey property, when resolving DataSourceField.includeFrom','includeFrom fields. The default value of null is the same as specifying "inner". Note, outer joins are allowed for all supported database products only if you are using DataSource.useAnsiJoins','ANSI-style joins, which is not the case by default. If you are using the older strategy of additional join expressions in the WHERE clause, outer joins are only supported for database products that provide a proprietary native syntax for expressing outer joins. Those products are: Oracle Versions of Microsoft SQL Server earlier than 2012, and running in compatibility mode 80 
		 * Flags: IR, Group: dataSourceRelations */
		joinType?: JoinType; // Flags=IR
		/** Maximum number of characters allowed. Applicable only to fields of text type. For fields of this type a ValidatorType','length range validator will be automatically generated on both the client and server side to enforce this maximum length (unless such a validator is explicitly present for the field already). The TextItem.enforceLength attribute can also explicitly limit user input for freeform text items editing fields with an explicit length specified. NOTE: For DataSources of type "sql", this property has a bearing on the type of column we use when the underlying table is created by a DataSource sqlDataSource','import in the adminConsole','Admin Console. Below a certain length (which is database-specific, see below), we use standard VARCHAR columns; above that length, we use an alternate strategy (again, database-specific). For these long fields, we sometimes also generate different SQL for "update" and "add" operations, using JDBC "?" replacement parameters rather than embedding values directly in the generated SQL; whether or not this is done depends entirely on what the underlying database product and/or JDBC driver will allow. Table of field length limits for supported databases: <table style="font-size:10px;text-align:center;border:1px solid black;"> <tr><td style="color:white;background-color:black;">Database product</td> <td style="color:white;background-color:black;">VARCHAR limit *</td> <td style="color:white;background-color:black;">Type used above limit</td></tr> <tr><td>HSQLDB</td><td>None</td><td>-</td></tr> <tr><td>IBM DB2</td><td>4000</td><td>CLOB</td></tr> <tr><td>Firebird</td><td>32767</td><td>BLOB with subtype 1</td></tr> <tr><td>Informix</td><td>255 / 32739</td><td>LVARCHAR / TEXT ** </td></tr> <tr><td> Microsoft SQL Server </td><td>8000</td><td>TEXT</td></tr> <tr><td>MySQL</td><td> 255 / 65535 / 16M </td><td> TEXT / MEDIUMTEXT / LONGTEXT *** </td></tr> <tr><td>Oracle</td><td>4000</td><td>CLOB</td></tr> <tr><td>PostgreSQL</td><td>4000</td><td>TEXT</td></tr> </table> * The "VARCHAR limit" referred to here is a limit used by the SmartClient Server; it is not necessarily imposed by the database. For example, DB2's VARCHAR limit is not 4000 characters; it actually varies from about 4K to about 32K, depending on how the server has been configured. ** Informix has a limit of just 255 characters for VARCHAR, but has a native LVARCHAR type which supports nearly 32K characters without needing to fall back on long datatypes. Therefore, with that one product, we have two thresholds for a change in storage type. *** MySQL has a limit of 255 characters for VARCHAR, 65,535 characters for TEXT and 16,777,215 for MEDIUMTEXT; therefore, with that one product, we have three thresholds for a change in storage type.
		 * Flags: IR, Group: dataType */
		length?: number; // Flags=IR
		/** For fields of a type that are represented by binary data initially uploaded from a file (currently "binary" and "imageFile", see FieldType), this sets the maximum file size allowed, in bytes.
		 * Flags: IR */
		maxFileSize?: number /* Integer */; // Flags=IR
		/** For a binaryFields','binary field, sets a fixed mime type for all files stored to this field. Should be set to a standard mime type string, for example, "text/plain" for a .txt file. This is useful if a binary field only stored one type of file and you chose not to store filenames, since the extension of the file name is normally used to determine the mime type.
		 * Flags: IR */
		mimeType?: string /* String */; // Flags=IR
		/** Indicates that this field should always be Array-valued. If the value derived from DataSource.dataFormat','XML or JSON data is singular, it will be wrapped in an Array. JPA and Hibernate DataSources use multiple:true as part of the declaration of One-To-Many and Many-to-Many relations - see jpaHibernateRelations for details. <h4>Criteria on multiple:true fields: client-side filtering</h4> For simple Criteria, the criteria value is compared to each field value in the multiple:true field, according to the DSRequest.textMatchStyle','textMatchStyle. If any field value matches the filter value, the field is considered to match the criteria. For AdvancedCriteria, for normal OperatorId','search operators the field value is considered as matching the Criterion if any of the field values match the Criterion. Specifically, this is true of all operators that have an OperatorValueType','operatorValueType of "fieldType" or "valueRange". For operators that compare against other fields in same record, such as "equalsField", if the other field is not multiple:true, matching works the same as for normal operators, that is, as if criterion.value directly contained the value rather than the name of another field. If the other field is also multiple:true, only "equalsField", "notEqualsField", "iEqualsField" and "iNotEqualsField" are allowed (any other operator will cause a warning and be ignored) and the set of values in the field must be identical (aside from case, for operators prefixed with "i") and in identical order to match. For the inSet operator, the field matches if there is any intersection between the field values and the array of values provided in criterion.value. notInSet is the reverse. Finally, for "isBlank", "notBlank", "isNull" and "notNull", an empty Array is considered non-null. For example, if you use dataFormat:"json" and the field value is provided to the browser as [] (JSON for an empty Array), the field is considered non-null. <h4>Server-side Representation and Storage</h4> Values for multiple:true fields appear as Java Lists when received in server code such as a DMI. The SmartClient Server supports simple storage of values that are multiple:true, controlled via the DataSourceField.multipleStorage setting. For server-side behavior of JPA and Hibernate relation fields that are multiple:true, see jpaHibernateRelations. For non-relation fields, the SmartClient Server supports simple storage of values that are multiple:true, controlled via the DataSourceField.multipleStorage setting, with some limited support for server-side filtering, as described in the DataSourceField.multipleStorage docs. For the built-in SQL, Hibernate and JPA connectors, if criteria are specified for a multiple:true field where multipleStorage is null or "none", the SmartClient server knows nothing about how the multiple values are stored, so as a fallback the criteria will operate as though the field were a normal, non-multiple "text" field. This will generally not match the client-side filtering behavior described above, so filtering should either be performed entirely on the client (for example, via ListGrid.dataFetchMode','dataFetchMode:"local" or entirely on the server (via ResultSet.useClientFiltering:"false") The server-side filtering is done through a criteria transform which happens with DataSource.transformMultipleFields','transformMultipleFields. <h4>XML Serialization</h4> Specifically for XML serialization and deserialization, multiple:true behaves similarly to the <a href='http://www.google.com/search?hl=en&q=soap+array' target='_blank'>SOAP array idiom</a>, that is, there will be a "wrapper element" named after the field name, whose contents will be several elements of the specified DataSourceField.type','field.type. For example, Layout.members is declared with type:"Canvas", multiple:true. The correct XML format is thus: &lt;VLayout&gt; &lt;members&gt; &lt;Canvas ID="myCanvas" ... /&gt; &lt;ListGrid ID="myGrid" .../&gt; &lt;Toolstrip ID="myToolStrip" ... /&gt; &lt;/members&gt; &lt;/VLayout&gt; See DataSourceField.childTagName for customizing the tagName used for subelements.
		 * Flags: IR, Group: xmlSerialize */
		multiple?: boolean /* Boolean */; // Flags=IR
		/** How values for a DataSourceField.multiple','multiple:true field should be stored. On the server, field values for multiple:true fields are represented as Java Lists in DSRequest and DSResponse objects, but when multipleStorage is used, are ultimately stored as Strings. This storage mechanism is "denormalized" in the sense of <a href='http://en.wikipedia.org/wiki/Database_normalization' target='_blank'>database normalization</a> because the field contains a compound value rather than an atomic value. Specifically, this makes the field harder to use with database features like SQL joins, since its value cannot be directly compared to other, singular fields. For this reason, there's really only a narrow set of cases where it makes sense to use this storage mechanism, consider it if: the values don't appear in any other tables or columns elsewhere in your database (so joins and other comparisons wouldn't be possible anyway) there is no authoritative list of all possible values, or even of popular values; it's basically freeform, like arbitrary, uncurated "tags" applied to photos or links A multiple:true field can be of any SimpleType, including "date", "time", "datetime", "float", "int" etc. Type will be preserved across a store and reload cycle, so for example a List of values for a field of type "int" will arrive at the server in a DSRequest as a List of Integer, be stored as a String, but appear again as a List of Integer inside a DSResponse. When storing "date", "time" or "datetime" values as Strings, XML schema formats are used - the same that are used for transmission in XML or JSON (see dateFormatAndStorage','Date and Time Format and Storage overview for details). The multipleStorage feature works by transforming from List to String and back inside the server-side DataSource.execute() method. Specifically, inbound DSRequests are transformed before methods that perform actual storage are called (executeUpdate() et al), and DSResponses received from these methods have multiple:true field values transformed back into Lists before DataSource.execute() returns the DSResponse. This transformation approach means that the built-in SQL, JPA and Hibernate connectors all support multipleStorage, and multipleStorage is also automatically available for any custom DataSource that is capable of storing String values, and implements its storage methods via overrides of executeUpdate(), executeAdd() et al as described in the writeCustomDataSource','custom DataSource overview. Note that when using the built-in SQL, JPA and Hibernate connectors, the underlying SQL column should be of 'text' type. The dbConfigTool','Database Configuration Tool will automatically generate columns of the correct type for a SQLDataSource. For JPA or Hibernate DataSources, just ensure the type of the Java bean property on your Java object is String. The default multipleStorage setting of null means that the "simpleString" MultipleFieldStorage approach will be used if: the field is of a known SimpleType the field is not a DataSourceField.foreignKey Otherwise, MultipleFieldStorage "none" will be used. <h4>Criteria and AdvancedCriteria handling</h4> For the built-in SQL, JPA and Hibernate connectors, when multipleStorage:"simpleString" or "json" is used, criteria are transformed to replicate the client-side filtering behavior for multiple:true fields, where possible. The following operators are supported with the same behavior as client-side filtering: all String-oriented operators including patternOperators','pattern operators, but not regexp/iRegexp isBlank / notBlank isNull / notNull inSet / notInSet equalsField / notEqualsField / iEqualsField / iNotEqualsField The following operators, which are supported for client-side filtering of multiple:true fields, are not supported for server filtering when using multipleStorage: greaterThan/lessThan(OrEqual) "between" and all other operators with OperatorValueType of "valueRange" regexp / iRegexp as noted above Note that for string-based filtering operators such as "equals", no characters which are part of the DataSourceField.multipleStorageSeparator may be used in the filter string. If any characters from the multipleStorageSeparator are present in the filter value, it will always fail to match. For "json" mode, the multipleStorageSeparator is effectively the String '","'.
		 * Flags: IR, Group: multipleField */
		multipleStorage?: MultipleFieldStorage; // Flags=IR
		/** For fields that are DataSourceField.multiple','multiple:true and use DataSourceField.multipleStorage, the separator used in the "simpleString" MultipleFieldStorage mode. Default value of null means the DataSourceField.multipleValueSeparator is used instead.
		 * Flags: IR, Group: multipleField */
		multipleStorageSeparator?: string /* String */; // Flags=IR
		/** For fields that are DataSourceField.multiple','multiple:true, the separator used between values when they are displayed.
		 * Flags: IR, Group: multipleField */
		multipleValueSeparator?: string /* String */; // Flags=IR
		/** Name for this field. The field name is also the property in each DataSource record which holds the value for this field. Must be unique across all fields within the DataSource as well as a valid JavaScript identifier, as specified by ECMA-262 Section 7.6. NOTE: The String.isValidID function can be used to test whether a name is a valid JavaScript identifier.
		 * Flags: IR, Group: basics */
		name?: string /* identifier */; // Flags=IR
		/** Only applicable to "sql" dataSources. If set, this property indicates that the field is bound to the column named in the property. It is used to bind a DataSourceField to a database column with a different name. nativeName is useful for disambiguating in cases where you have customized SQL. For example, assume you are joining two tables - call them product and supplier - that both contain a column called "name". Only one field in the DataSource can be called "name"; to disambiguate, we need to specify both DataSourceField.tableName','tableName and nativeName. A field declaration like this would be needed: &lt;field name="supplierName" type="text" tableName="supplier" nativeName="name" /> You may also wish to use this property to map legacy column names to more meaningful field names in the DataSource. For example: &lt;field name="productName" type="text" nativeName="PRDNM" /> Note that it is not allowed to have multiple fields with the same nativeName bound to the same database table.
		 * Flags: IR */
		nativeName?: string; // Flags=IR
		/** Controls whether an explicit null-valued Record attribute for this field should result in xsi:nil being used to transmit the value when serializing to XML, like so: &lt;book&gt; &lt;title&gt;Beowulf&lt;/title&gt; &lt;author xsi:nil="true"/&gt; &lt;/book&gt; If nillable is not set, no XML element will be generated for the explicit null value.
		 * Flags: IR, Group: dataType */
		nillable?: boolean; // Flags=IR
		/** If DataSource.noNullUpdates is set, the value to use for this field when a null value is assigned to it on an update operation. This property overrides the DataSource-level properties DataSource.nullStringValue','nullStringValue, DataSource.nullIntegerValue','nullIntegerValue, DataSource.nullFloatValue','nullFloatValue and DataSource.nullDateValue','nullDateValue, for this field only. NOTE: If you use this property, you are responsible for ensuring that the replacement value is appropriate and valid.
		 * Flags: IR */
		nullReplacementValue?: any /* Any */; // Flags=IR
		/** Applies only to fields of type "float" or "integer" and affects how many significant digits are shown. For example, a field value of 343.1, 343.104 and 343.09872677 would all be shown as 343.10 if precision is 5. The original value is always shown when the value is edited.
		 * Flags: IRW, Group: appearance */
		precision?: number; // Flags=IRW
		/** Indicates either that this field holds a value unique across all records in this DataSource, or that it is one of a number of fields marked as primary keys, and the combination of the values held in all of those fields is unique across all records in the DataSource. Note that the latter usage - so-called "composite" or "multipart" keys - is intended for support of legacy databases only: if you are able to choose an approach, Isomorphic recommends the use of one primaryKey field per DataSource, and ideally this field should be of DataSourceField.type','type "sequence". If you have control of the underlying tables, there is nothing to stop you from adding a field like this (a so-called "synthetic" or "surrogate" key), even for tables that already have a set of columns that could combine to make a composite key (a so-called "natural" key). Also, it is neither necessary nor correct to use a composite primaryKey because you want to enforce uniqueness across that combination of fields. You can achieve that by declaring a unique constraint in the table schema, or use an ValidatorType','isUnique validator with validator.criteriaFields, or both; there is no need to use a composite key to enforce uniqueness Note that composite primaryKeys are not supported in tree-structured datasets (Tree and ResultTree) or components (TreeGrid, ColumnTree). Tree-structured data requires that nodes have a unique Tree.idField','idField, with the parent/child relationship expressed through the Tree.parentIdField','parentIdField. This implies that binding a Tree to a DataSource requires that the DataSource have a singular primaryKey, and that the primaryKey field is also the idField, as described in the treeDataBinding','tree databinding overview A DataSource that can only perform the "fetch" operation does not require a primaryKey unless it contains binaryFields','binary fields. If a DataSource allows modification of DataSource records through add, update and remove DataSource operations, or it contains one or more binary fields, one or more fields must be marked as the primary key. SmartClient requires a primary key value to uniquely identify records when communicating updates or deletions to the server. There is no requirement that the primaryKey field be mapped to an actual "primary key" in your object model, web service, or database (though this is the most obvious and natural thing to do, of course). The only requirement is that the combined values of the primaryKey fields be unique for a given browser instance for the lifetime of the page. If using SmartClient's sqlDataSource','SQL engine and generating SQL tables using the dbConfigTool','Database Configuration Tool, the table column generated from a primaryKey field will have a unique constraint applied in the database table and, if the field is of type "sequence", the database column will also be created as an "identity column" in those databases that implement sequence-type handling with identity columns.
		 * Flags: IR, Group: dataSourceRelations */
		primaryKey?: boolean; // Flags=IR
		/** For use in componentSchema for fields that contain other components, this flag suppresses auto-construction for subcomponents that appear under this field. For example, the VLayout schema sets this for its Layout.members','members property, so that when a VLayout is constructed via XML as follows: &lt;VLayout&gt; &lt;members&gt; &lt;ListGrid ID="myGrid" .../&gt; &lt;Toolstrip ID="myToolStrip" ... /&gt; &lt;/members&gt; &lt;/VLayout&gt; The ListGrid and ToolStrip do not construct themselves automatically. Instead, the VLayout receives the properties of the ListGrid and ToolStrip as ordinary JavaScript Objects, with the special property _constructor set to the name of the class that should be constructed.
		 * Flags: IR, Group: componentSchema */
		propertiesOnly?: boolean; // Flags=IR
		/** Sets the default FormItem to be used if this field is marked as DataSourceField.canEdit','canEdit false and displayed in an editor component such as a DynamicForm. This property may also be specified at the type level by specifying SimpleType.readOnlyEditorType.
		 * Flags: IR, Group: componentBinding */
		readOnlyEditorType?: string /* FormItem className */; // Flags=IR
		/** For a sqlDataSource','SQL DataSource field that specifies a DataSourceField.foreignKey','foreignKey, this property defines the table alias name to use in generated SQL. Aliasing is necessary when the same table appears more than once in a query. This can happen when using DataSourceField.includeVia','Multiple includeFrom \n fields referring to the same related DataSource. It can also happen when a DataSourceField.foreignKey','foreignKey definition references the same dataSource that the field is defined in; this happens with hierarchical structures, for example where every Employee reports to another Employee. This is a so-called "self join", and it <em>always</em> requires relatedTableAlias to be specified; failure to do so will result in invalid SQL.
		 * Flags: IR, Group: dataSourceRelations */
		relatedTableAlias?: string /* String */; // Flags=IR
		/** Indicates this field must be non-null in order for a record to pass validation. Or, in the case of a "binary" field, a non-empty file must be uploaded. Setting this property has the same effect as giving the field a ValidatorType','"required" validator. Note that required should not be set for a server-generated field, such as a sequence, or validation will fail on the client. <h3>Conditionally required fields</h3> Adding an Validator.applyWhen','applyWhen condition to a required validator introduces subtle complexities to the process of validating an existing record. The client is not guaranteed to know the the full and complete state of the record it is editing because it is common for a DynamicForm to be editing a subset of fields. When a field is unconditionally required, things are simple: if the DynamicForm has a FormItem for that field, then the required validation passes if that FormItem has a value, and fails if it does not. If the form has no FormItem for the field, it can assume that the field has a value because otherwise it would have failed validation when we attempted to add it (when we are adding a record, we of course do know the full and complete state of the record - it is whatever we are about to add). When a field is conditionally required, the client can no longer assume that all required fields will have a value. It may be the case that the condition of requirement was not met when the record was added, but now it is. For example, consider these field definitions: &lt;field name="yearsAtCurrentAddress" type="integer" /&gt; &lt;field name="previousAddress" type="text" &gt; &lt;validator type="required" errorMessage="Previous address is required if you have been at your current address less than three years"&gt; &lt;applyWhen operator="and"&gt; &lt;criteria&gt; &lt;criterion fieldName="yearsAtCurrentAddress" operator="lessThan" value="3" /&gt; &lt;/criteria&gt; &lt;/applyWhen&gt; &lt;/validator&gt; &lt;/field&gt; Imagine a record for this DataSource is added where the user has entered a value of "3" for "yearsAtCurrentAddress", and no previous address. Later, the value of that field is changed to "2". If this is done using a form that is also showing the "previousAddress" field, we will know that "previousAddress" has not been provided, so we can fail the validation and the user will get a helpful error message explaining what the problem is. However, if the form does not also show the "previousAddress" field, we may choose to use an OperationBinding that uses OperationBinding.outputs','outputs to trim the record down to just the fields the form does contain, in the interests of avoiding information leakage. Or perhaps that value is automatically culled from the record before the client sees it by the application of a DataSourceField.viewRequires','declarative security rule. Whatever the reason, if the client does not have the complete record, it is not possible for the client to sensibly apply this validation. And because the client has no way of knowing if a value is missing because it is genuinely null, or because it has been trimmed away by the server, we must treat any null value with suspicion (unless it has a matching FormItem - the presence of the FormItem means that the user can edit the value, so it would make no sense to pair it with a trimmed record that excludes that field value). When this happens, we mark the validation as having passed on the client, but in need of running on the server. The server validation makes use of the "storedRecord" facility (look for the description of $storedRecord in the velocitySupport','Velocity support overview) to overlay the changed record on top of the existing record as it currently exists in the database. This gives the validator the complete record including both changed and unchanged values, so it is able to carry out the required check in a meaningful way. However, you should be aware that the combination of conditional "required" validators and DynamicForms that edit partial records can result in a validation that cannot run on the client and must do both a server roundtrip and a database fetch.
		 * Flags: IR, Group: dataType */
		required?: boolean; // Flags=IR
		/** The required message when a field that has been marked as DataSourceField.required','required is not filled in by the user. Note that this setting wins over DataSource.requiredMessage if both are set.
		 * Flags: IRW, Group: formTitles */
		requiredMessage?: string; // Flags=IRW
		/** For a field that is a foreignKey establishing a tree relationship, what value indicates a root-level node. Defaults to null. Note that the rootValue may be overridden on a specific ResultTree instance by setting ResultTree.rootNode, or if the ResultTree is auto-generated by a TreeGrid, by setting TreeGrid.treeRootValue. This allows a component to navigate a subtree of the hierarchical data from this dataSource starting at a particular node.
		 * Flags: IR, Group: dataSourceRelations */
		rootValue?: any; // Flags=IR
		/** For a DataSource with DataSource.serverType','serverType:"sql" with a field of type "sequence", the name of the SQL sequence that should be used when inserting new records into this table. Note that this is never required for SQL tables that are generated from SmartClient DataSources (a default sequence name of tableName + "_" + columnName is chosen, but see the notes below regarding this), and is never required for databases where inserting null into a sequence column is sufficient (MySQL, SQL Server, DB2 and others). You would only need to set sequenceName if you are integrating with a pre-existing table stored in a database where the sequence must be named for insertion to work (Oracle, Postgres, Firebird) OR you are trying to use the same sequence across multiple DataSources. Note: If you specify the sql.{database type}.sequence.name.prefix and/or sql.{database type}.sequence.name.suffix properties in your server_properties','server.properties file,the generated sequence name will include the prefix and/or suffix. For example, with a prefix of "order_system_" and a suffix of "_seq", the sequence generated for column "orderNumber" on table "orders" would be: order_system_orders_orderNumber_seq 
		 * Flags: IR, Group: sqlDataSource */
		sequenceName?: string /* String */; // Flags=IR
		/** For a field of type:"imageFile", indicates whether to stream the image and display it inline or to display the View and Download icons.
		 * Flags: IR */
		showFileInline?: boolean; // Flags=IR
		/** Causes values for this field to be sorted according to values for another field, for both client- and server-side sorting. This can be used to establish a sort order for a field that is not the normal sorting order indicated by the field value, typically by having the sortByField as a DataSourceField.hidden','hidden field. If using SQLDataSource, consider using a DataSourceField.customSelectExpression as an efficient way to populate the sortByField with the results of a SQL expression.
		 * Flags: IR */
		sortByField?: string /* String */; // Flags=IR
		/** For fields of type "date", "time", and "datetime" that specify an DataSourceField.sqlStorageStrategy','sqlStorageStrategy of "number" or "text", this property allows you to specify the format SmartClient should use to map to/from the underlying value stored in the database. The string provided must be a valid <a href=http://download.oracle.com/javase/1.4.2/docs/api/java/text/SimpleDateFormat.html> SimpleDateFormat pattern string</a>. For fields of type "datetime" and "time" that specify an DataSourceField.sqlStorageStrategy','sqlStorageStrategy of "number", two special sqlDateFormat values are supported: "epoch" - The datetime or time value is stored as the number of full seconds that have elapsed since January 1, 1970, 00:00:00 GMT. "epochms" - The datetime or time value is stored as the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 GMT. Millisecond precision is preserved through database roundtrips with this setting This property and the "number" and "text" strategies for date/datetime fields are provided to allow transparent two-way mapping of legacy date values that are stored in numeric or text columns respectively rather than a true "date" column. You would not ordinarily use them in the absence of a legacy database. Note that this property only applies to users of SmartClient server and data sources of type "sql".
		 * Flags: IR */
		sqlDateFormat?: string /* String */; // Flags=IR
		/** For fields of type "boolean" that specify a DataSourceField.sqlStorageStrategy','sqlStorageStrategy of "singleChar", this is the value to persist for false values. Note that the common use cases of storing booleans as T/F, Y/N and 1/0 are already catered for without the need for this property. For fields of type "boolean" that specify a DataSourceField.sqlStorageStrategy','sqlStorageStrategy of "string", this is the value to persist for false values that require using the entire value.
		 * Flags: IR */
		sqlFalseValue?: string /* String */; // Flags=IR
		/** For certain field types, indicates the strategy to be used to store values to the underlying SQL column. Fields of type "boolean" The default strategy for boolean fields is to assume the underlying type of the field is text and store boolean true and false values as the character strings "true" and "false". The following additional strategies are available: "number" or "integer": store true as 1, false as 0 "singleChar10": store true as "1", false as "0" "singleCharYN": store true as "Y", false as "N" "singleCharTF": store true as "T", false as "F" "singleChar": store as a single character, using the values defined by DataSourceField.sqlTrueValue','sqlTrueValue and DataSourceField.sqlFalseValue','sqlFalseValue "string": store the entire values defined by DataSourceField.sqlTrueValue','sqlTrueValue and DataSourceField.sqlFalseValue','sqlFalseValue Fields of type "date", "time", and "datetime" The default strategy for these types is to use a native type that supports date and time values to the nearest second; the actual type used varies by database. The following additional strategies are available: "nativeDate": Use a native SQL DATE type "number" or "integer": Store the value as a plain numeric value "text": Store the value as a plain text value The "number" and "text" strategies for date/time/datetime fields are provided to allow transparent two-way mapping of legacy date values; you would not ordinarily use them in the absence of a legacy database. In both cases, the actual format of the number or text string is determined by specifying a DataSourceField.sqlDateFormat','sqlDateFormat on the field; if no format is specified, the framework defaults to "yyyyMMdd". Fields of type "text" <em>NOTE: This section is only applicable for users of Microsoft SQL Server. The "ntext" strategy is ignored for all other databases.</em> If you are integrating with Microsoft SQL Server, you may run into an issue with that database and double-byte character sets. Although the documentation indicates that string values are sent to the database as Unicode by default, they may undergo conversion at the database end, depending on the collation settings of the database. <a href=http://support.microsoft.com/kb/239530>This Microsoft support article</a> describes the situation, which is that Unicode is converted to the code page of the database before being used, in order to "provide backward compatibility with existing applications". To work around this, we provide an sqlStorageStrategy of "ntext". Fields that declare this strategy are inserted into queries using the "N syntax", like so: &nbsp;&nbsp;&nbsp;UPDATE MyTable SET MyTextColumn = N'some text' WHERE MyPK = N'some key' This syntax overrides defaults and forces the database to treat strings as Unicode. Note that declaring a field to be of FieldType','type "ntext" is exactly equivalent to specifying type "text" and an sqlStorageStrategy of "ntext". If you declare a field of type "ntext" when the back-end database is something other than SQL Server, it will be treated as a normal field of type "text". This property only applies to users of the SmartClient server using dataSources of type "sql".
		 * Flags: IR */
		sqlStorageStrategy?: string /* String */; // Flags=IR
		/** For fields of type "boolean" that specify a DataSourceField.sqlStorageStrategy','sqlStorageStrategy of "singleChar", this is the value to persist for true values. Note that the common use cases of storing booleans as T/F, Y/N and 1/0 are already catered for without the need for this property. For fields of type "boolean" that specify a DataSourceField.sqlStorageStrategy','sqlStorageStrategy of "string", this is the value to persist for true values that require using the entire value.
		 * Flags: IR */
		sqlTrueValue?: string /* String */; // Flags=IR
		/** For fields of type "datetime", indicates whether the framework should attempt to preserve the millisecond part when persisting to native SQL datetime-type columns. Whether this is possible depends on the type and version of the underlying database product; some databases - for example SQL Server earlier than 2008 and MySQL versions earlier than 5.6 - do not provide fractional seconds support. If you set this flag when your underlying database cannot support fractional seconds, it will be ignored. Other than the two cases just mentioned which are known to fail, storeMilliseconds has been tested and is officially supported with the following products and minimum versions: Oracle 10g Microsoft SQL Server 2008 MySQL 5.6 PostgreSQL 9.1 HSQLDB 2.2 DB2 for Unix/Linux 9.7 Firebird 11.2 Informix IDS 11.5 Note that you can use DataSourceField.sqlStorageStrategy','sqlStorageStrategy to store a datetime value with sub-second precision in <em>any</em> database - see below. When the system generates SQL to insert or update datetime values including a millisecond element, it does so using a database-specific format string specified in property defaultDateTimeFormatWithMilliseconds in your server.properties file. These format strings should conform to the rules of the <a href=http://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html> Java SimpleDateFormat class</a>. Suitable format strings are provided for all default databases out of the box; if you need to override one or provide a new one, you do so as shown in this example: sql.MyNewDatabase.defaultDateTimeFormatWithMilliseconds: yy-MM-dd'T'hh.mm.ss.SSS Note that this property only controls the persistence of milliseconds into the database; there is no built-in support for sub-second elements of datetimes in any SmartClient visual components. See also the documentation for DataSource.trimMilliseconds for more details of how sub-second datetime elements are handled in the client-server flow. This property is only applicable to DataSources of DSServerType','serverType "sql" and fields of FieldType','type "datetime". It is ignored in all other cases. However, note that the built-in JPA and Hibernate dataSources will always persist millisecond values automatically if the underlying Java type, database and column support it. Finally, note that this property only has an effect on <em>native</em> datetime-type fields. When you use DataSourceField.sqlStorageStrategy','sqlStorageStrategy to store a temporal value in a text or number column, it is the DataSourceField.sqlDateFormat','sqlDateFormat you use that dictates the precision. For example, a field with sqlStorageStrategy:"text" and sqlDateFormat:"yyyy-MM-dd hh:mm:ss.SSS" would store and retrieve with millisecond precsion; the same field with sqlDateFormat:"yyyy-MM-dd hh:mm" would store and retrieve with precision to the nearest minute only.
		 * Flags: IR */
		storeMilliseconds?: boolean /* Boolean */; // Flags=IR
		/** If set, causes the field to be securely hashed before saving on an "add" or "update" operation.
		 * Flags: IR */
		storeWithHash?: HashAlgorithm; // Flags=IR
		/** Server-side setting that causes values for fields of type "integer" or "float" to be represented as Strings when delivered to a web browser, in order to avoid mangling values which cannot be represented faithfully in JavaScript. JavaScript has a single "Number" type which internally stores numbers in a format equivalent to Java's "Double" - double-precision floating point. This means it cannot represent the full range of Java's Long type: Java Longs can represent integral values between -2^63 to 2^63-1, whereas JavaScript Number can only represent exact integer values between -2^53 and 2^53. Similarly, JavaScript's Number type cannot represent Java's unlimited-size BigInteger or unlimited-precision BigDecimal objects at all. The stringInBrowser setting can be used to deliver numeric values as Strings to the browser. This is intended to allow read-only display and successful round-tripping of the numeric value, however, it will not cause number-oriented features such as SpinnerItem, Slider, ListGrid.showGridSummary','ListGrid summaries or range-checking Validator','validators or AdvancedCriteria','criteria to actually work. If stringInBrowser is not set, the default behavior is configured by the server.properties setting datasource.defaultStringInBrowser. If this flag is false, numeric values are delivered to the client as numbers, even where this will lead to a loss of precision. If the flag is true (which is the the default), the behavior is to prevent range overflow for numeric values: Java values of type Long, BigInteger and BigDecimal will be delivered as String only if they exceed JavaScript's number range. Client-side validation will allow inputs that are outside of JavaScript's normal integer range, and such numbers will remain as Strings after validation, instead of being converted to Numbers Values submitted to the server will be converted to BigInteger if they exceed the range of Java's Long type. This happens during DSRequest validation, before any defined dmiOverview','DMI methods are called. This default set of behaviors is intended to automatically deal with cases like numeric DataSourceField.primaryKey or DataSourceField.foreignKey values that are never used as numbers, but happen to use the full Java Long range. To disable the above behaviors, set stringInBrowser="false". If stringInBrowser is explicitly set to true: the value for the field will always be delivered to the browser as a String (no attempt is made to detect the value as out of range / too high precision) client-side validation will do a check for valid format only, and always leave the value as a String. Numeric range validators are ignored client-side (always pass), but are still active server-side. AdvancedCriteria OperatorId','operators that check if values are in a particular range will always pass the field is treated as though DataSourceField.canFilter','canFilter:false were set, to avoid showing non-functional search interfaces to the user. Set canFilter="true" to avoid this effect This setting is recommended for presenting out-of-range issues or precision loss on fields that represent actual quantities (as opposed to primaryKey or foreignKey fields, which really represent IDs). To ensure unlimited-precision BigDecimal values are preserved, you should also set DataSourceField.javaClass. Note that responses delivered as JSON or XML, such as responses from the servletDetails','RESTHandler servlet, are not affected. This setting applies only to responses delivered to a web browser. The entirety of stringInBrowser processing can be completely disabled by setting server.properties flag datasource.disableStringInBrowser to true. This will cause all numeric values to be delivered as numbers without even attempting to detect if this will lead to a loss of precision. This setting overrides both the stringInBrowser field setting and the datasource.defaultStringInBrowser server.properties flag.
		 * Flags: IR */
		stringInBrowser?: boolean /* Boolean */; // Flags=IR
		/** If ListGrid.showGridSummary or ListGrid.showGroupSummary is true, this attribute can be used to specify an explicit SummaryFunction for calculating the summary value to display. If an array of summaryFunctions is specified, they will be executed in turn and the grid will show multiple summary rows at the grid or group level (or both) containing the resulting values.
		 * Flags: IR */
		summaryFunction?: SummaryFunction; // Flags=IR
		/** Title to show in a SummaryFunction','Summary of type "title" for this field. If unspecified title summaries will show the DataSourceField.title for the field.
		 * Flags: IR */
		summaryValueTitle?: string /* String */; // Flags=IR
		/** Only applicable to "sql" dataSources, setting tableName indicates that this field will be coming from another table by way of a customQuerying','customized SQL query. By default, the SQL generator will not include this field in generated SQL for "add" or "update" operations. It will include the field in the SELECT clause and WHERE clause of customized "fetch" operations, where it is expected that you will make the table available via a custom &lt;tableClause&gt; as shown in largeValueMapSQL', 'this sample. The table name will also be used to qualifying the column name unless DataSource.qualifyColumnNames or OperationBinding.qualifyColumnNames has been disabled. Note: This property is only required when including fields from tables other than the default table specified by DataSource.tableName.
		 * Flags: IR */
		tableName?: string /* String */; // Flags=IR
		/** Preferred time-format to apply to date type values within this field. If this property is specified on a field displayed within a dataBound component such as a ListGrid or DynamicForm, any dates displayed in this field will be formatted as times using the appropriate format. This is most commonly only applied to fields specified as type "time" though if no explicit FormItem.dateFormatter is specified it will be respected for other fields as well. See ListGridField.timeFormatter and FormItem.timeFormatter for more information.
		 * Flags: IRWA, Group: appearance */
		timeFormatter?: TimeDisplayFormat; // Flags=IRWA
		/** Default user-visible title for this field. This will be picked up by DataBound components and other views over this DataSource. Note this property frequently does not need to be set since DataSource.autoDeriveTitles (on by default) usually picks an appropriate user-visible title if you have a reasonable naming convention for your field names. Note that if this field is being displayed in a ListGrid bound to this dataSource, the ListGridField.headerTitle attribute may be used to specify a different string for display in the listGrid column header.
		 * Flags: IR, Group: componentBinding */
		title?: string /* String */; // Flags=IR
		/** Type of this field. Required for all DataSource fields. Field type may imply automatic validators (for example, an integer field cannot accept the value "foo"). Field type also affects the default behaviors of DataBound components, for example, if a field is declared as type "date", components that edit that field will automatically choose a date-editing interface with pop-up date picker.
		 * Flags: IR, Group: basics */
		type?: FieldType; // Flags=IR
		/** Indicates that the specified VelocityExpression must evaluate to true if updates to this field are to be allowed. If the specified expression does not evaluate to true, the field will be removed from the request as described for DataSourceField.editRequiresAuthentication','editRequiresAuthentication. In addition to the normal context variables available to Velocity expressions in SmartClient, expressions you write for field-level requires clauses - updateRequires, DataSourceField.viewRequires','viewRequires, DataSourceField.editRequires','editRequires and DataSourceField.initRequires','initRequires - can reference two additional variables: $fieldName and $dsName. These are the names of the dataSource and field currently undergoing requires checks. They are helpful because they allow you to write a generic checker function that can be used to handle requires checks for multiple fields and dataSources. NOTE: This property only prevents update of a field; initialization will still be allowed. You should only use this property if you have a special requirement; ordinarily, use DataSourceField.editRequires, which applies security for both types of write.
		 * Flags: IR, Group: fieldLevelAuth */
		updateRequires?: string /* VelocityExpression */; // Flags=IR
		/** Whether a user must be authenticated in order to update to this field. If this property is set and the user is not authenticated, the SmartClient Server will not allow this field to be updated.
		 * Flags: IR, Group: fieldLevelAuth */
		updateRequiresAuthentication?: boolean; // Flags=IR
		/** Comma-separated list of user roles that are allowed to update this field. If the current user does not have any of the roles listed, the system will not allow this field to be updated. NOTE: This property only prevents a field from being updated; initialization will still be allowed. You should only use this property if you have a special requirement; ordinarily, use DataSourceField.editRequiresRole, which applies security for both types of write.
		 * Flags: IR, Group: fieldLevelAuth */
		updateRequiresRole?: string /* String */; // Flags=IR
		/** Used by the BatchUploader to map a field in an upload file to this dataSourceField. This is only necessary if the dataSourceField's name and title differ from the name of the field in the upload file (SmartClient will automatically map upload fields using the dataSourceField's title, if possible, if it does not get a direct match on field name).
		 * Flags: IR */
		uploadFieldName?: string /* String */; // Flags=IR
		/** If this field has a specified DataSourceField.displayField, this attribute allows you to explicitly tell editor components to pick up the display-field value from the record currently being edited, rather than fetching against a specified FormItem.optionDataSource. See FormItem.useLocalDisplayFieldValue for more detail. Note that for the common pattern described DataSourceField.includeFrom','here of having an editable foreignKey field with a static display value (derived from a displayField with 'includeFrom' set), the framework will automatically default this property to true if not explicitly specified in the dataSource configuration file.
		 * Flags: IR */
		useLocalDisplayFieldValue?: boolean /* Boolean */; // Flags=IR
		/** Validators to be applied to this field. Validators are applied whenever there is an attempt to save changes to a field. For the available set of built-in validators, and how to define a custom validator, see the Validator class.
		 * Flags: IR, Group: dataType */
		validators?: Array<Validator> /* Array of Validator */; // Flags=IR
		/** List of operators valid on this field. If not specified, all operators that are valid for the field type are allowed.
		 * Flags: IR, Group: advancedFilter */
		validOperators?: Array<OperatorId> /* Array of OperatorId */; // Flags=IR
		/** A ValueMap is a set of legal values for a field. The valueMap can be specified as either an Array of legal values, or as an Object where each property maps a stored value to a user-displayable value. To enforce that a field should be constrained to only the values in the valueMap, either declare DataSourceField.type','field.type as "enum", or use a ValidatorType of "isOneOf" with explicitly listed values. Otherwise, although a normal SelectItem control will only allow values from the valueMap to be entered, other controls such as a ComboBoxItem','ComboBox will allow other values to be entered. In XML, a valueMap that specifies only a list of legal values is specified as follows: &lt;valueMap&gt; &lt;value&gt;Pens &amp; Pencils&lt;/value&gt; &lt;value&gt;Stationery&lt;/value&gt; &lt;value&gt;Computer Products&lt;/value&gt; &lt;value&gt;Furniture&lt;/value&gt; &lt;value&gt;Misc&lt;/value&gt; &lt;/valueMap&gt; A ValueMap that specifies stored values mapped to user-visible values is specified as follows: &lt;valueMap&gt; &lt;value ID="1"&gt;Pens &amp; Pencils&lt;/value&gt; &lt;value ID="2"&gt;Stationery&lt;/value&gt; &lt;value ID="3"&gt;Computer Products&lt;/value&gt; &lt;value ID="4"&gt;Furniture&lt;/value&gt; &lt;value ID="5"&gt;Misc&lt;/value&gt; &lt;/valueMap&gt; 
		 * Flags: IR, Group: dataType */
		valueMap?: ValueMap; // Flags=IR
		/** Fully qualified Java className of an Enum that should be used to derive this field's ValueMap. This has the same behavior of auto-deriving a valueMap from a Java Enum as DataSource.autoDeriveSchema except it applies only to one field. If you enable autoDeriveSchema there is no need to set valueMapEnum for Enum fields unless you want to actually override the behavior to use a different Enum for the field (eg, a superclass Enum that is more restrictive).
		 * Flags: IR */
		valueMapEnum?: string /* String */; // Flags=IR
		/** Alternative XPath expression used to set the field's value. If is not set, then DataSourceField.valueXPath','dataSourceField.valueXPath is used, see its description for details.
		 * Flags: IR, Group: clientDataIntegration */
		valueWriteXPath?: string /* XPathExpression */; // Flags=IR
		/** XPath expression used to retrieve the field's value. This XPath expression will be evaluated in the scope of the record objects selected by the DataSource.recordXPath. For XML data (DataSource.dataFormat','dataFormat:"xml") this means a call to XMLTools.selectString passing the selected XML element. For JSON data (DataSource.dataFormat','dataFormat:"json"), this means a call to XMLTools.selectObjects passing the selected JSON object. In the absence of a valueXPath, for JSON data the value for the field will be the value of the same-named property in the record object selected by DataSource.recordXPath','recordXPath. For XML data, the value will be the attribute or subelement named after the field name. For example, for a field "author" on a record element &lt;book&gt;, the following structures require no valueXPath: &lt;book author="Mark Jones"/&gt; &lt;book&gt; &lt;author&gt;Mark Jones&lt;/author&gt; &lt;/book&gt; If valueXPath is not required for your field because of the default handling described above, don't specify it, as it's slightly slower. To learn about XPath, try the following search: <a href="http://www.google.com/search?q=xpath+tutorial" target="_blank" >http://www.google.com/search?q=xpath+tutorial</a> Using valueXPath with the SmartClient server If you're using the SmartClient server to return data via the DSResponse object (or indirectly doing so using DataSource DMI), the valueXPath you specify on the DataSource fields will be applied to the data you return via the <a href='http://commons.apache.org/jxpath/' target='_blank'>JXPath</a> library. If you are returning Java Beans as your DSResponse data, normally each dataSource field receives the value of the same-named Java Bean property, that is, a field "zipCode" is populated by looking for "getZipCode()" on the objects passed as DSResponse data. You can use valueXPath to retrieve properties from subobjects, so long as a chain of getter methods exists that corresponds to the valueXPath. For example, a valueXPath of "address/zipCode" expects to call "getAddress()" on the bean(s) passed to DSResponse.setData(), followed by "getZipCode()" on whatever object "getAddress()" returns. When you are saving data, the inbound DSRequest values, available as a Java Map, will use just dataSource field names as Map keys, not the valueXPath used to derive them. However, to achieve bidirectional valueXPath binding, you can use the server-side method dataSource.setProperties() to use the valueXPath when setting properties on your server object model. When applied as a setter, an XPath like "address/zipCode" attempts "getAddress()" followed by "setZipCode()" on the returned object. JXPath also has some ability to auto-create intervening objects if they are missing, such as auto-creating an "address" subobject when applying "address/zipCode" as a valueXPath. See the <a href='http://jakarta.apache.org/commons/jxpath/' target='_blank'>JXPath</a> library documentation for complete details, including other types of server object models supported, such as server-side XML.
		 * Flags: IR, Group: clientDataIntegration */
		valueXPath?: string /* XPathExpression */; // Flags=IR
		/** Indicates that the specified VelocityExpression must evaluate to true if values for the field are to be fetched. If the specified expression does not evaluate to true, the field will be dropped as described for DataSourceField.viewRequiresAuthentication','viewRequiresAuthentication. In addition to the normal context variables available to Velocity expressions in SmartClient, expressions you write for field-level requires clauses - viewRequires, DataSourceField.editRequires','editRequires, DataSourceField.initRequires','initRequires and DataSourceField.updateRequires','updateRequires - can reference two additional variables: $fieldName and $dsName. These are the names of the dataSource and field currently undergoing requires checks. They are helpful because they allow you to write a generic checker function that can be used to handle requires checks for multiple fields and dataSources.
		 * Flags: IR, Group: fieldLevelAuth */
		viewRequires?: string /* VelocityExpression */; // Flags=IR
		/** Whether a user must be authenticated in order to fetch this field. If this property is set and the user is not authenticated, SmartClient Server will not return values for this field to the client. The way this behavior works is to remove the field from the expressed or implied list of fields to return. A list of fields can be expressed using OperationBinding.outputs or DSRequest.outputs; in the absence of those, the entire set of fields defined in the DataSource is implied. You can override this behavior on a per-request basis by providing a DMI that just re-adds the names of the fields you want for that particular request to the "consolidated outputs". See the server-side Javadoc for DSRequest.getConsolidatedOutputs(). In addition to this behavior of trimming off values in fetched records, a field that fails a field-level security check (either this one or one of the two more specific checks, DataSourceField.viewRequiresRole','viewRequiresRole and DataSourceField.viewRequires','viewRequires) will be altered in the version of the dataSource returned to the client by the loadDSTag','&lt;loadDS&gt; JSP tag or dataSourceDeclaration','DataSourceLoader servlet. If the field is also not editable (see the discussion of this below), it will be marked DataSourceField.canView','canView:false, and thus effectively be inert and unusable on the client If the field is editable, it will be marked DataSourceField.hidden','hidden. By default, this means that DataBoundComponents will not show the field, though this can be overridden for individual components. If you do choose to unhide the field, bear in mind that it will never actually show any data, because the underlying security test has still failed By default, view constraints automatically imply edit constraints - almost all of the time, if a user is not allowed to view a field, he should not be allowed to update it either. If you specify a view constraint, the system behaves as if you had also specified the corresponding edit constraint - so viewRequiresAuthentication on a field implies DataSourceField.editRequiresAuthentication','editRequiresAuthentication. You override this behavior simply by specifying some kind of edit constraint for the field, either a different one (eg, "users" can view a field, but only "managers" can update it) or a blank one (if you have some unusual requirement whereby users are not allowed to view a field, but they can update it).
		 * Flags: IR, Group: fieldLevelAuth */
		viewRequiresAuthentication?: boolean; // Flags=IR
		/** Comma-separated list of user roles that are allowed to fetch this field. If the current user has any of the roles listed, values for the field will be fetched. Please see OperationBinding.requiresRole for further details of SmartClient's declarative role-based security. Please also see DataSourceField.viewRequiresAuthentication','viewRequiresAuthentication for details of how declarative field-level security settings can be overridden per-request.
		 * Flags: IR, Group: fieldLevelAuth */
		viewRequiresRole?: string /* String */; // Flags=IR
		/** Indicates that DataSource.xmlSerialize should serialize this value as an XML attribute. Note this does not need to be declared in order for DataSource records to be derived from XML data: a field will be populated with either an attribute or subelement with matching name.
		 * Flags: IR, Group: xmlSerialize */
		xmlAttribute?: boolean; // Flags=IR

		/* Method Overrides */

	} // DataSourceFieldProps


	/**
	 * Metadata about a DataSourceField, including its type and validators. 
	 */
	export interface DataSourceField  {
		/** Affects whether client dsRequests can request summaries for this field. Default setting of null means that the DataSource-wide default setting DataSource.allowClientRequestedSummaries is used for this field.
		 * Flags: IR, Group: serverSummaries */
		allowClientRequestedSummaries: boolean;

		/** Setting audit to false explicitly indicates that this field will not be saved to the audit DataSource when DataSource.audit','auditing is enabled.
		 * Flags: IR */
		audit: boolean;

		/** Indicates that values for this field are automatically generated by the database or ORM provider. Setting this flag makes the field behave somewhat like a DataSourceField.sequenceName','sequence field, in that server-side logic does not expect client code to provide values for the field on "add" operations. However, it is not entirely the same as a sequence: Sequences must be integers, whereas autoGenerated fields can be of any type SmartClient Server's DataSource implementations are capable of discovering the value that was generated by the database for sequence fields, which may not be possible with an autoGenerated field. See the docs for DataSourceField.customInsertExpression','customInsertExpression for a discussion of this Unrelated to the autoGenerated flag, you have a general ability for field values to be generated by application code (as opposed to being generated by the database or ORM provider). For example, you can use dmiOverview','DMI methods, serverScript','server scripts, or customQuerying','custom SQL. (Note, if you want to have application code generate values for primaryKey fields, you may need to use an OperationBinding','operationBinding that specifies OperationBinding.providesMissingKeys','providesMissingKeys).
		 * Flags: IR, Group: dataType */
		autoGenerated: boolean;

		/** If explicitly set to false, switches off automatic quoting and escaping of values in custom expressions that are derived from Velocity evaluations. By default, any part of a DataSourceField.customSelectExpression','customSelectExpression, DataSourceField.customCriteriaExpression','customCriteriaExpression, DataSourceField.customUpdateExpression','customUpdateExpression or DataSourceField.customInsertExpression','customInsertExpression that comes ultimately from evaluating a Velocity expression, will be automatically quoted and escaped according to the syntax of the underlying database. We do this because "raw" values are vulnerable to <a href="http://en.wikipedia.org/wiki/SQL_injection">SQL injection attacks</a>. However, it is possible that the exact SQL logic you desire for a custom expression cannot be expressed without access to the raw, unquoted value. To work around this, you can either use the special velocitySupport','$rawValue context variable, or you can set this property to false to switch off auto-quoting completely for all custom expressions on this field. Warning: Bear in mind that it is dangerous to use raw values. There are some cases where using the raw value is necessary, but even so, all such cases are likely to be vulnerable to injection attacks. Generally, the presence of $rawValue in a custom expression, or any fields with autoQuoteCustomExpressions: false specified, should be viewed as a red flag.
		 * Flags: IR */
		autoQuoteCustomExpressions: boolean;

		/** Controls whether, by default, DataBoundComponents consider this field editable. Set to false to draw this field read-only. For a field that should never be changed from the UI, consider using DataSourceField.canSave instead, which will both mark a field as non-editable and reject any attempt to programmatically change the value on the server (when using the SmartClient Server). This attribute may not effect all dataBoundComponents - the DataBoundComponent.canEditFieldAttribute may be set at the component level to look for a different attribute on the dataSourceField, and components allow developers to explicitly override this default (see ListGridField.canEdit. FormItem.canEdit for example).
		 * Flags: IR, Group: componentBinding */
		canEdit: boolean;

		/** Dictates whether the data in this field be exported. Explicitly setting canExport to false overrides the setting on any component-fields, such as ListGridField.canExport','ListGrid fields.
		 * Flags: IR */
		canExport: boolean /* Boolean */;

		/** Should the user be able to filter data by this field? Affects whether this field will show up in dataBoundComponents with UI for filtering data. 
		 * Flags: IR */
		canFilter: boolean;

		/** Whether values in this field can be updated and saved to the dataSource. If set to false, this field will default to being non-editable in standard editing components (DynamicForm, editable ListGrid), but will be editable when displayed for filtering purposes only (in a SearchForm or ListGrid.showFilterEditor','ListGrid\n filter editor. If DataSourceField.canEdit','canEdit is explicitly specified it will take precedence over this client-side behavior, but the server will still enforce the no-save policy (described below). NOTE: If you are using SmartClient Server and have specified canSave: false for a field in a DataSource definition (.ds.xml file), this is enforced on the server. This means that we will strip out any attempt to set the value of such a field before trying to process any update or add request, similar to what happens when a DataSourceField.editRequiresAuthentication','field-level declarative security check fails.
		 * Flags: IR, Group: componentBinding */
		canSave: boolean;

		/** When true, this field can only be used for sorting if the data is entirely client-side.
		 * Flags: IRW */
		canSortClientOnly: boolean;

		/** If false, this property indicates that this field is considered "server only". This means: Components cannot bind to the field; even if you explicitly add a field with the same name to your DataBoundComponent','dataBoundComponent, it will be dropped If you are using SmartClient Server, the client will never be sent a value for the field If you are using SmartClient Server, then similar to DataSourceField.canEdit','canEdit, no updates to the field are allowed from the client. If you explicitly add a value for the field to, eg, a record you are passing to DataSource.updateData, the server will strip the value out of the record before processing the update request. canView:false is not the same thing as DataSourceField.hidden','hidden. Use canView:false when you want to prevent the client from ever seeing a field's definition or values; use hidden:true if it is fine from a security perspective that a field's definition and values are sent to the browser, but the field should not by default appear in user interface elements (but could do in some cases, like a special screen for advanced users or administrators, for example). Note that this property must be set explicitly to false to have an effect; a null or undefined setting is treated the same as true. This property is used to implement field-level view security: failing a DataSourceField.viewRequiresAuthentication','viewRequiresAuthentication, DataSourceField.viewRequiresRole','viewRequiresRole or DataSourceField.viewRequires','viewRequires test is equivalent to setting canView:false on the field (and, indeed, from the client's perspective, the field <em>has</em> had canView:false set).
		 * Flags: IR, Group: componentBinding */
		canView: boolean;

		/** If true, this property indicates that this field will hold an explicit array of child nodes for the current node. This has the same effect as specifying DataSource.childrenField to this field's name.
		 * Flags: IR, Group: dataSourceRelations */
		childrenProperty: boolean /* Boolean */;

		/** For a field that is DataSourceField.multiple','multiple:"true", controls the name of the XML tag used for each subelement during DataSource.xmlSerialize. If unset, the default tag name is "value" for a field of simple type, and for a field of DataSource type, is the tagName or ID of the DataSource (as though xmlSerialize() were called on the child DataSource).
		 * Flags: IR, Group: xmlSerialize */
		childTagName: string /* String */;

		/** See DataSource.tableCode.
		 * Flags: R */
		columnCode: string /* String */;

		/** Indicates that normal declarative security rules specified on this field are waived for rows that were created by the current user, as described in the discussion of DataSource.creatorOverrides','dataSource.creatorOverrides. This setting overrides dataSource.creatorOverrides, for this field only. Note that field-level creatorOverrides is conceptually slightly different to the setting at DataSource and OperationBinding levels. To give the example of a fetch operation, at the other two levels, it results in a limited set of rows being returned, rather than a security exception being thrown. At the field-level, it results in values for individual fields being present in those rows, rather than them being stripped out on the server.
		 * Flags: IR, Group: fieldLevelAuth */
		creatorOverrides: boolean;

		/** This property indicates that this field should be represented by a custom expression embedded in the WHERE clause of the generated SQL, instead of the generated expression containing this field name that would ordinarily be used. You use this property when you have to accomodate some special way of using a field's value in criteria, other than by directly comparing it to the criteria. For example, if you have a column that contains bit-packed information you will generally need to perform a bitwise AND to filter on that column, rather than an equality check. In this case, you would use a customCriteriaExpression something like this (in Oracle): &nbsp;&nbsp;&nbsp;BITAND(myField, $criteria.myField)+0 = $criteria.myField Or this (in MySQL or SQL Server): &nbsp;&nbsp;&nbsp;myField & $criteria.myField = $criteria.myField As this example shows, a customCriteriaExpression is expected to be a complete logical expression that provides both sides of the comparison. After Velocity processing, this example would result in SQL similar to this (for the MySQL case); the colored part comes entirely from the customCriteriaExpression: SELECT myField, myOtherField FROM myTable WHERE <font color='blue'>myField & 32 = 32</font> customCriteriaExpression can also be used with AdvancedCriteria. Note that the point mentioned above, about a customCriteriaExpression being a complete logical expression that provides both sides of the comparison still applies. This means that when you use customCriteriaExpression in conjunction with AdvancedCriteria, you effectively switch off support for different OperatorIds to be used on that field, unless you use Velocity expressions containing the special $criteriaOperator variable (see below). When you use customCriteriaExpression with AdvancedCriteria, the way you access criteria values differs slightly. One option is to use the $advancedCriteria Velocity variable, as described in the "Using AdvancedCriteria" section of the customQuerying','custom querying overview. However, this variable only returns the value from the first Criterion that uses the field, as found by depth-first search. If your AdvancedCriteria contains multiple references to this field, this will not be satisfactory. Therefore, specifically for customCriteriaExpression, we provide another Velocity variable, $criteriaValue. This variable means "the value on a Criterion referencing this field". An example may serve to clarify this: Assume you need to extend the above example to filter records where a certain bit is set OR a certain other bit is set. An AdvancedCriteria like this would be required (note that the choice of "equals" as the operator in these clauses is completely arbitrary - as discussed above, the operator is ignored when we have a customCriteriaExpression, so it would make no difference to the end product if we had used different operators here): { _constructor: "AdvancedCriteria", operator: "or", criteria: [ { fieldName: "myField", operator: "equals", value: 32 }, { fieldName: "myField", operator: "equals", value: 64 }, ] } If you used the customCriteriaExpression from above unchanged with this criteria, the following SQL would be generated (in the MySQL case): SELECT myField, myOtherField FROM myTable WHERE myField & null = null OR myField & null = null This is because $criteria is a variable that only works correctly with simple criteria. If you changed the $criteria references in the expression to $advancedCriteria, the generated SQL would be: SELECT myField, myOtherField FROM myTable WHERE myField & 32 = 32 OR myField & 32 = 32 This is because $advancedCriteria always returns the first value it finds for a particular field, as described above. However, if you change the expression so it reads: &nbsp;&nbsp;&nbsp;myField & $criteriaValue = $criteriaValue you will now get the correct SQL generated: SELECT myField, myOtherField FROM myTable WHERE myField & 32 = 32 OR myField & 64 = 64 Similar to $criteriaValue, we provide a special variable, $criteriaOperator. This is intended for use in Velocity expressions, so that your customCriteriaExpression can process different operators in different ways. How you choose to interpret an operator is entirely up to you; this variable is both advanced and rarely used. This example is contrived and does not show a usage that would be remotely likely in a real application, but it does show how to use the variable in a Velocity expression: &nbsp;&nbsp;&nbsp;myField #if ($criteriaOperator == "greaterThan") & #else | #end $criteriaValue = $criteriaValue For simple criteria, note that $criteriaOperator will vary depending on field type and the TextMatchStyle','textMatchStyle in force, as follows: Text fields with textMatchStyle "substring" - "iContains" Text fields with textMatchStyle "startsWith" - "iStartsWith" Text fields with textMatchStyle "exact" - "iEquals" All other cases (including text fields with textMatchStyle "exactCase") - "equals" You can use Velocity expressions in your customCriteriaExpressions, and the velocitySupport','usual context variables are available. Note that the results of Velocity evaluations are automatically quoted and escaped by default; this behavior can be switched off - see DataSourceField.autoQuoteCustomExpressions','autoQuoteCustomExpressions, and particularly note the warnings about its use. Note that this property only applies to users of the SmartClient server using dataSources of type "sql".
		 * Flags: IR */
		customCriteriaExpression: string;

		/** This property is similar to DataSourceField.customUpdateExpression','customUpdateExpression; its value is used during "add" operations. If you do not specify this property, but do specify a customUpdateExpression, the customUpdateExpression is used instead. Everything that applies to customUpdateExpression also applies to this property, including the observation that fields which specify a DataSourceField.customSelectExpression','customSelectExpression but no corresponding customUpdateExpression or customInsertExpression, will be ignored when adding new records. As with customUpdateExpression, this property is only intended to be used when you have a need to customize the actual SQL. If you simply want to use a server-derived value in the query, you should use transactionChaining','Transaction Chaining, dmiOverview','DMI, or a serverScript','server script instead. <h3>customInsertExpression with primaryKey fields</h3> if you use customInsertExpression to derive a value for a DataSourceField.primaryKey','primaryKey field, the key value will not by default be available to the framework, so the built-in cache synchronization system will not work. It may be possible to to work around this with the DataSourceField.autoGenerated','autoGenerated flag, as described below, but otherwise you must also create a OperationBinding.cacheSyncOperation','cacheSyncOperation which can retrieve the record just added to the database. Please also see the documentation for SequenceMode','SequenceMode "none", which talks further about cacheSyncOperation. Typically, primaryKey fields that need to be auto-generated are implemented using a sequence field, which at the database level translates to either an actual sequence, or an auto-increment or "identity" column. JDBC drivers have special support for such columns, so we are able to determine the generated value. This is important for primaryKey fields because, without it, we cannot re-fetch the record just inserted for cache synchronization purposes, as described above. Where a value is generated by something other than a sequence field, this special ability is lost - or at least, it is no longer guaranteed to be present. There are use cases where this may seem to be a restriction. A common case would be where you wish to use a generated UUID as primaryKey value, rather than an ordinary ascending sequence. If you had intended to do this using the database itself - for example, specifying a customInsertExpression that calls something like MySQL's UUID() built-in function - this is potentially a problem. What we would recommend in this case and anything similar, is to use the general ability for field values to be generated by application code, as described above. (Note, if you want to have application code generate values for primaryKey fields, you may need to use an OperationBinding','operationBinding that specifies OperationBinding.providesMissingKeys','providesMissingKeys). That said, different database vendors implement their JDBC drivers in different ways, and with the SQLDataSource and certain database products it is possible to retrieve values that were generated at the database level by a customInsertExpression that expresses either a user-defined function call or an inline subselect, as long as the field is marked with the autoGenerated flag. Because this behavior is potentially useful, we do not inhibit it; however, we also do not recommend that you make use of it, because the behavior is not portable across databases, and may also not be portable across JDBC driver versions (because the behavior is unspecified and undocumented, and relies on implementation details that may change). Databases where this behavior has been observed to work include Oracle, Postgres and HSQLDB; databases where this behavior is known not to work include MySQL, SQL Server, DB2 and Firebird (the latter because its JDBC driver does not support the getGeneratedKeys() API) Note that this property only applies to users of the SmartClient server using dataSources of type "sql".
		 * Flags: IR */
		customInsertExpression: string;

		/** This property indicates that this field represents a custom expression that should be embedded in the generated SQL instead of a reference to this field. For example, if you have a field partialName where this value is set to SUBSTR(surname, 2), the generated SQL would look similar to this: SELECT ... SUBSTR(surname, 2) AS partialName ... Note that adding "AS partialName" as shown above is required - this is how the framework identifies the expression as producing a value for this particular DataSourceField when results are received from the database. Fields with customSelectExpression set can be used for sorting and filtering in the normal way, but they are only applicable to update-type operations if you also provide a corresponding DataSourceField.customUpdateExpression','customUpdateExpression and/or DataSourceField.customInsertExpression','customInsertExpression. See the documentation for those methods for the rules of how they are applied. You can use Velocity expressions in your customSelectExpressions, and the velocitySupport','usual context variables are available. Note that the results of Velocity evaluations are automatically quoted and escaped by default; this behavior can be switched off - see DataSourceField.autoQuoteCustomExpressions','autoQuoteCustomExpressions, and particularly note the warnings about its use. Note that this property only applies to users of the SmartClient server using dataSources of type "sql".
		 * Flags: IR */
		customSelectExpression: string;

		/** For a DataSource with DataSource.serverType','serverType "sql" or "hibernate", indicates that this field should be omitted by default from all SQL or Hibernate operations, and will only be used with customQuerying','custom queries. Having marked a field as customSQL you can refer to it via $criteria.fieldName or $values.fieldName in customized queries. The following are situations where you would not use customSQL: simple joins where you want to enable users to see and search on a field from another table; consider DataSourceField.includeFrom instead fields where you want to calculate or transform values in SQL on load or save, but always perform the same calculation for each operationType; consider instead DataSourceField.sqlStorageStrategy for some common cases, or DataSourceField.customSelectExpression, DataSourceField.customUpdateExpression and DataSourceField.customInsertExpression for full customization a special fetch is needed where the field needs to be excluded from the $defaultWhereClause so that it can be used in a custom &lt;whereClause&gt; - consider OperationBinding.excludeCriteriaFields instead Use customSQL in situations like: there are multiple variations of the "fetch" operation with different OperationBinding.operationId','operationIds, and the field is only used in some of them; in that case, consider using OperationBinding.customFields to selectively re-introduce SQL generation for the field only in operations where it's used. the field represents hidden criteria on a field in another table where the field is never shown to the user the field is a write-only value only saved in some operations more than one data access strategy is in use (eg direct SQL for fetch and bean-based persistence accessed via DMI for saves) and certain fields are not available in SQL 
		 * Flags: IR */
		customSQL: boolean;

		/** This property specifies the value to use to update this column on "update" operations. The value of this property will be passed through Velocity evaluation and then embedded directly in the SQL generated to perform the update. It can be used in conjunction with DataSourceField.customSelectExpression','customSelectExpression to provide bi-directional mapping between application data formats and persisted data formats. Or, it can be used unilaterally as a means of silently enforcing data rules - for example, ensuring that all values for a given field are in upper case. You can use Velocity expressions in your customUpdateExpressions, and the velocitySupport','usual context variables are available. Note that the results of Velocity evaluations are automatically quoted and escaped by default; this behavior can be switched off - see DataSourceField.autoQuoteCustomExpressions','autoQuoteCustomExpressions, and particularly note the warnings about its use. The value must be a string that will end up as a valid SQL snippet after Velocity evaluation. The following examples are valid: "SUBSTR(ANOTHER_COLUMN, 1, 10)" "SUBSTR($values.someTextField.toUpperCase(), 1, 10)" "SOME_NUMERIC_COLUMN * 1000" "$values.someTextField.toUpperCase()" (this is a technically valid but incorrect usage - see below) NOTE: although all these examples are valid, customUpdateExpression is intended to be used when you have a need to customize the actual SQL. If you simply want to use a server-derived value in the query (as is the case with the last of these examples), you should use transactionChaining','Transaction Chaining, dmiOverview','DMI, or a serverScript','server script instead. In the examples above, the first is an actual SQL snippet and must not be enclosed in quotes. The second shows an SQL snippet containing a literal - because the literal is the result of a Velocity evaluation, it will be automatically quoted so there is no need to do so manually. The third example yields a number, so it must not be quoted. The last example is also the result of a Velocity evaluation and thus does not need to be quoted. Note, however, that this example involves no SQL customization - this kind of usage should be avoided, as noted above. When an "update" operation runs, any fields that specify DataSourceField.customSelectExpression','customSelectExpression but do not specify customUpdateExpression will be ignored. When an "add" operation runs, this property acts as a default for any fields that do not specify a DataSourceField.customInsertExpression','customInsertExpression; similar to update, any fields that specify a customSelectExpression but do not specify either a customUpdateExpression or customInsertExpression, will be ignored when "add" operations run. Note that this property only applies to users of the SmartClient server using dataSources of type "sql".
		 * Flags: IR */
		customUpdateExpression: string;

		/** Preferred display format to use for date type values within this field. If this property is set on a field displayed in a databound component such as a DynamicForm or ListGrid it will be respected (See FormItem.dateFormatter and ListGridField.dateFormatter). Note that this property is also honored when exporting directly to Excel spreadsheets (ie, when using XLS or XLSX/OOXML form, not CSV); "date" and "datetime" fields with this property set will deliver real dates and formatting information to Excel, rather than formatted strings or unformatted dates.
		 * Flags: IRWA, Group: appearance */
		dateFormatter: DateDisplayFormat;

		/** Applies only to fields of type "float" and enforces a minimum number of digits shown after the decimal point. For example, a field value of 343.1, 343.104 and 343.09872677 would all be shown as 343.10 if decimalPad is 2. The original unpadded value is always shown when the value is edited.
		 * Flags: IRW, Group: appearance */
		decimalPad: number;

		/** Applies only to fields of type "float" and affects how many significant digits are shown. For example, with decimalPrecision 3, if the field value is 343.672677, 343.673 is shown. If the value is 125.2, 125.2 is shown - decimalPrecision will not cause extra zeros to be added. Use DataSourceField.decimalPad for this. A number is always shown with its original precision when edited.
		 * Flags: IRW, Group: appearance */
		decimalPrecision: number;

		/** Before we start editing this field in a DataBoundComponent, should we perform a deep clone of the underlying field value. See DataSource.deepCloneOnEdit for details of what this means. If this value is not explicitly set, it defaults first to the value of DataBoundComponent.deepCloneOnEdit, then to the value of DataSource.deepCloneOnEdit. Like the other deepCloneOnEdit settings, this flag only has an effect if you are editing a values object that contains nested objects or arrays, using Canvas.dataPath','dataPaths.
		 * Flags: IRWA */
		deepCloneOnEdit: boolean /* Boolean */;

		/** Whether this field should be considered a "detail" field by a DataBoundComponent. Detail fields won't be shown by default in a DataBoundComponent where DataBoundComponent.showDetailFields is false. This allows for some DataBound components, like a ListGrid, to show a summary view of records which displays only the most commonly viewed fields by default, while other DataBoundComponents, like a DetailViewer, show all fields by default. In addition, the FormItem.showIf','formItem.showIf property is supported in multiple components for conditional visibility - see for example ListGridField.showIf and FormItem.showIf).
		 * Flags: IR, Group: componentBinding */
		detail: boolean;

		/** Name of another field in this DataSource that should be used as the display value for this field. Typically used for editable DataSourceField.foreignKey','foreignKey fields: the foreignKey field stores an ID value, and this ID value is the right value to use when editing (typically by a SelectItem with SelectItem.optionDataSource','optionDataSource set). However, when the foreignKey field is viewed read-only, it should display a name, title or other friendly value from the related record. In order to accomplish this, a second, hidden field carries the display value, and the foreignKey field has displayField set to this second, hidden field. For a more in-depth discussion, see DataSourceField.includeFrom.
		 * Flags: IR, Group: dataSourceRelations */
		displayField: string /* String */;

		/** Sets the default FormItem to be used whenever this field is edited (whether in a grid, form, or other component). If unset, a FormItem will be automatically chosen based on the type of the field, by the rules explained FormItemType','here.
		 * Flags: IR, Group: componentBinding */
		editorType: string /* FormItem className */;

		/** Indicates that the specified VelocityExpression must evaluate to true if writes to this field are to be allowed. If the specified expression does not evaluate to true, the field will be removed from the request as described for DataSourceField.editRequiresAuthentication','editRequiresAuthentication. In addition to the normal context variables available to Velocity expressions in SmartClient, expressions you write for field-level requires clauses - editRequires, DataSourceField.viewRequires','viewRequires, DataSourceField.initRequires','initRequires and DataSourceField.updateRequires','updateRequires - can reference two additional variables: $fieldName and $dsName. These are the names of the dataSource and field currently undergoing requires checks. They are helpful because they allow you to write a generic checker function that can be used to handle requires checks for multiple fields and dataSources. NOTE: This property prevents both initialization and updates for a field. If you have a need to prevent <em>just</em> initialization or <em>just</em> updates, you can use DataSourceField.initRequires or DataSourceField.updateRequires.
		 * Flags: IR, Group: fieldLevelAuth */
		editRequires: string /* VelocityExpression */;

		/** Whether a user must be authenticated in order to write to this field. If this property is set and the user is not authenticated, the SmartClient Server will not allow this field to be updated or initialized. This property affects two things. Firstly, the server determines when the DataSource is first loaded if we have an authenticated user; if we don't, the field is marked canEdit: false. Secondly, when an insert or update request is received from the client, the server removes the field from the values clause before the request is processed. Note that you can override this behavior. The canEdit setting can be overridden on the the client-side DataSource like any other client-side property. The value-removing behavior can be overridden on a per-request basis by providing a DMI that re-adds values for the fields you want for that particular request to the values object (the values originally sent up by the client are available on the DSRequest). See the server-side Javadocs for DSRequest.getValues() and DSRequest.getClientSuppliedValues().
		 * Flags: IR, Group: fieldLevelAuth */
		editRequiresAuthentication: boolean;

		/** Comma-separated list of user roles that are allowed to write to this field. If the current user does not have any of the roles listed, the system will not allow this field to be initialized or updated. Please see OperationBinding.requiresRole for further details of SmartClient's declarative role-based security. Please also see DataSourceField.editRequiresAuthentication','editRequiresAuthentication for details of how declarative field-level security settings can be overridden per-request. NOTE: This property prevents both initialization and updates for a field. If you have a need to prevent <em>just</em> initialization or <em>just</em> updates, you can use DataSourceField.initRequiresRole or DataSourceField.updateRequiresRole.
		 * Flags: IR, Group: fieldLevelAuth */
		editRequiresRole: string /* String */;

		/** Text to be used for display by client-side components when this field has a null or undefined value. This value will be overridden by a component's emptyCellValue, if set.
		 * Flags: IR, Group: appearance */
		emptyDisplayValue: string /* HTMLString */;

		/** When set for a field with binary data, binary data will be delivered as a Base64 encoded string. When encodeInResponse is not set normal responses will not contain values for binary fields at all. Instead, UI components, such as TileGrid issue a second binary fetch for binary data when appropriate, and APIs such as DataSource.downloadFile','downloadFile() and DataSource.viewFile','viewFile() can be used to programmatically trigger downloads. Only applicable to fields of a type that are represented by binary data (currently "binary" and "imageFile", see FieldType).
		 * Flags: IRW */
		encodeInResponse: boolean;

		/** When data values are displayed in DataBound components, by default strings will be interpreted as HTML by the browser in most cases. If set, this property will be picked up by components bound to this dataSource, notifying them that any HTML characters should be escaped when displaying values for this field.
		 * Flags: IR */
		escapeHTML: boolean /* Boolean */;

		/** If true, then this field is excluded from the bound component's view state. In addition, the field will not be selected as the default title field by DataBoundComponent.getTitleField if DataBoundComponent.titleField is not provided.
		 * Flags: IR, Group: viewState */
		excludeFromState: boolean /* Boolean */;

		/** An optional FormatString for this field, for use when DataBoundComponent.exportData','exporting data to spreadsheet formats (XLS and OOXML/XLSX), XML, JSON or CSV. You can use this property to override the normal DataSourceField.format','format of this field, if any, specifically for exports. Note, for server-driven exports you can specify default formats for date, time and datetime fields by specifying properties export.format.default.date, export.format.default.time and export.format.default.datetime in your server.properties file. These formats will be used for fields that do not have a "format" or "exportFormat" property specified in the .ds.xml file. Specifically when exporting to spreadsheet formats, the FormatString is translated to the type of format string used by spreadsheet programs like Excel. A handful of features are not present in Excel format strings, and some features behave slightly differently. These differences are explained below. <h3>Excel cannot handle dates prior to January 1st 1900</h3> This is a well-known limitation of Excel dates; it is not a formatting issue as such. <h3>Currency symbols become fixed to the current locale at export time</h3> The placeholder currency symbol "&#x00A4" (\u00A4) in a numeric format string is rendered as the NumberUtil.currencySymbol','localized currency symbol. When exporting, the format string provided to Excel contains the currency symbol for the current locale of the SmartClient application, and not a placeholder currency symbol that would make Excel pick up a currency symbol based on the operating system locale. We do this to ensure that the spreadsheet reflects the <em>application's</em> localization, rather than the localization of the current user's computer, because they may be different. <h3>Rounding differences</h3> The approach to rounding a positive number to a set number of decimal places is fairly universally agreed upon for non-specialized requirements: add 0.5 (or 0.05, or 0.005, or whatever) to the number and then truncate. This leads to the well understood convention that numbers exactly halfway between two possible rounding outcomes, go to the larger one. So 7.5 becomes 8 and 7.15 becomes 7.2. However, there is no such universal agreement when it come to rounding negative numbers. Some take the view that you should round by taking the number to the larger absolute value, so -7.15 becomes -7.2. Others feel that you should round by taking the number to the larger value in the sense of it being "less negative", so -7.15 becomes -7.1. SmartClient formatting takes the first approach and rounds negative numbers away from zero. We do this simply because that is what Java DecimalFormat does. Unfortunately, Excel does the opposite. Therefore, you will see rounding differences on negative numbers on exact 50% boundaries: SmartClient will format -7.15 as -7.2, while Excel will format the same value as -7.1. <h3>Different treatment of '#'</h3> Both SmartClient and Excel use '#' to mean "digit, do not show zeroes". However, Excel does not implement this strictly in the integer part when the number it is formatting has a value of 0 in the integer part. So, with a format of "#.##", the value 0.25 is formatted as "0.25". SmartClient (like Java DecimalFormat) is strict: with that format, 0.25 is formatted as ".25"; if you want to match Excel's output, you must use the format "0.##". <h3>Miscellaneous edge cases</h3> There is quite a lot of variation in behavior between Java DecimalFormat and Excel around the edges. For actual error cases - for example, a format string that just contains nonsense - it is normal and expected that the SmartClient behavior and the Excel behavior do not match - this is just two systems producing different garbage out for the same garbage in, which is to be expected. For valid but weird usages - for example, a format with multiple percent signs - SmartClient's formatting is in line with what DecimalFormat does, unless DecimalFormat throws an Exception, in which case we just do the thing that seems most sensible, or the thing that was easiest to implement. Known differences in behavior in edge cases include: SmartClient ignores formatting characters in the number part of the format string, whereas Excel rejects the format (this behavior may vary with different releases of Excel and supposedly compatible libraries: POI, for example, will accept such format strings). If you attempt to format 5.175 with the format string "#b0.#a#", SmartClient will return "5.72", and Excel will reject the format SmartClient ignores quoted characters in the number part of the format string, whereas Excel preserves them. If you attempt to format 5.175 with the format string "#'b'0.#'a'#", SmartClient will return "5.72", and Excel will return "b5.7a2" If you specify the empty string as a format string, SmartClient returns the result of calling toString() on the number; Excel uses the built-in "General" format. These two approaches will generally give the same or very similar results, but that is really a coincidence: the correct way to obtain matching results in the browser and the spreadsheet is to specify a valid format string If you specify a format string that contains no number part (ie, no '#' or '0' characters), SmartClient does what DecimalFormat does, which is to output the integer part of the number alongside the fixed part of the format. Excel just outputs the fixed part. So, if you attempt to format -5.3 with the format string "'Hello world'", SmartClient will output "-Hello world5", whereas Excel will output just "Hello world" If you specify multiple percent signs in the format, SmartClient treats all but the first one as static text, so 0.5 formatted with "#%%%" is "50%%%" (ie, all the signs are preserved but there is only one multiplcation by 100). Excel multiplies for each percent sign, so 0.5 formatted with "#%%%" is "500000%%%" <h3>Date format functionality not supported by Excel</h3> The following date/time/datetime functionality is not supported by Excel; if you use formatters that use any of this functionality, your values will be exported to Excel incorrectly formatted. In cases like this, we recommend that you use a separate exportFormat, with the intent of exporting your values in a way that is similar to your application formatting (which would be specified with the DataSourceField.format','format property), but within the confines of what Excel supports. Fiscal year, week and day (LL, LLLL, C, CC, c, cc) Week in year (w, ww) Day in year (D, DD) Day number in week (u) Explicit control over whether to use 12- or 24-hour notation. In Excel, this is implied by the presence or absence of the AM/PM designator If the user's operating system locale is different to the locale in use in the SmartClient application, day and month names may be different in the spreadsheet <h3>Number format functionality not supported by Excel</h3> The only SmartClient number-formatting functionality not supported for export to Excel is "multiply by 1000 and show as per mille". <h3>Limit on number of custom Excel formats</h3> Excel limits the number of custom format strings in a single spreadsheet to somewhere between 200 and 250, depending on your locale and language. Hitting this limit in an export would require hundreds of field definitions, each defining unique FormatStrings. If you do hit the limit, the only workaround is to use fewer unique FormatStrings.
		 * Flags: IRW */
		exportFormat: string /* FormatString */;

		/** Optional different field-title used for exports.
		 * Flags: IR */
		exportTitle: string /* String */;

		/** Sets the default FormItem to be used for this field if it appears in a filter row, and DataSourceField.canFilter is not false. Note: If this is not specified, the edit-formItem type may be derived from the DataSourceField.editorType property, or from the field's DataSourceField.type.
		 * Flags: IR, Group: componentBinding */
		filterEditorType: string /* FormItem className */;

		/** See DataSource.tableCode.
		 * Flags: R */
		fkColumnCode: string /* String */;

		/** See DataSource.tableCode.
		 * Flags: R */
		fkTableCode: string /* String */;

		/** Name of another field in a separate dataSource that should be used as the display value for this field in the case where a foreignKey relationship exists. This property is useful for fields being edited in a FormItem where options are being retrieved from an FormItem.optionDataSource, for the case where a separate DataSourceField.displayField name is used within the local dataSource than the field name for the display field within the foreign dataSource. See FormItem.foreignDisplayField for more on this, and see DataSourceField.includeFrom for a discussion about picking up dataSource field values from a related dataSource.
		 * Flags: IR, Group: dataSourceRelations */
		foreignDisplayField: string /* String */;

		/** Declares that this field holds values that can be matched to values from another DataSource field, to create a relationship between records from different DataSources or even records within the same DataSource. The format of foreignKey is dataSourceId.fieldName. For a foreignKey within the same dataSource, you can omit the dataSourceId and just specify fieldName. For example, to create a tree relationship within a DataSource: isc.DataSource.create({ ID:"supplyItem", fields : [ {name:"itemId", type:"sequence", primaryKey:true}, {name:"parentId", type:"integer", foreignKey:"itemId"}, ... ] }); foreignKey declarations also allow other automatic behaviors by DataBoundComponent','DataBoundComponents, such as ListGrid.fetchRelatedData. For SQLDataSources foreign keys can be automatically discovered from SQL tables if DataSource.autoDeriveSchema','autoDeriveSchema is set.
		 * Flags: IR, Group: dataSourceRelations */
		foreignKey: string /* String */;

		/** Format string to use when rendering the value in any DataBoundComponent or when exporting via DataSource.exportData or ListGrid.exportData or ListGrid.exportClientData. Supported for fields of type "date", "time", "datetime", "int", "float" or any derived SimpleType. To configure a different format for export, use DataSourceField.exportFormat. This is a per-field setting; you can alternatively set a default format for all "date", "time" or "datetime" fields via DateUtil.setNormalDatetimeDisplayFormat and related methods on Date. See also localizedNumberFormatting for built-in FieldType','FieldTypes that handle localized currency formatting. Also note, this property takes precedence over any specified DataSourceField.dateFormatter','dateFormatter, but can be overridden on a per-component basis by providing a formatter directly on the component, for example, via ListGrid.formatCellValue or FormItem.formatValue.
		 * Flags: IRW */
		format: string /* FormatString */;

		/** For use in componentSchema, indicates what group to place the property in when editing in Visual Builder.
		 * Flags: IR, Group: componentSchema */
		group: string;

		/** Whether this field should be hidden from users by default within a DataBound component. This is generally used for internal IDs and other fields not meaningful to users. See DataSourceField.detail for fields that should be hidden in a summary view such as a ListGrid, but still available to the user. NOTE: This property is not a security setting - data for hidden fields is still delivered to the client, it just isn't shown to the user. If you wish to make sure that only appropriate data reaches the client, use OperationBinding.outputs, DataSourceField.canView:false on the field, or a field-level declarative security setting like DataSourceField.viewRequiresRole.
		 * Flags: IR, Group: componentBinding */
		hidden: boolean;

		/** Whether this field should be completely excluded from this dataSource, as if it had never been defined. If set to true, the field will be entirely omitted when serving a DataSource derived from a server-side definition (typically a .ds.xml file) to the client.
		 * Flags: IR, Group: componentBinding */
		ignore: boolean;

		/** NOTE: Only applicable to DataSource.clientOnly','clientOnly DataSources and the built-in sqlDataSource','SQL, jpaIntegration','JPA and hibernateIntegration','Hibernate DataSources available in Pro, Power and Enterprise versions of SmartClient. Use this flag to inhibit the normal use of TextMatchStyle for this field. A field with this flag set will always be tested for exact equality in generated queries, even for filter-style queries where normal behavior would be to use a substring match or similar. Whether or not the exact match is case-sensitive is determined by the DataSource's DataSource.ignoreTextMatchStyleCaseSensitive','ignoreTextMatchStyleCaseSensitive setting.
		 * Flags: IRW */
		ignoreTextMatchStyle: boolean /* Boolean */;

		/** Height of the image-content of this field. If set as a string, represents the name of another field in the record that holds the imageHeight. Applicable only to fields of image type or fields that use a ViewFileItem','ViewFileItem as an editor.
		 * Flags: IR */
		imageHeight: number | string /* number or String */;

		/** Width and height of the image-content of this field. If set as a string, represents the name of another field in the record that holds the imageSize. Applicable only to fields of image type or fields that use a ViewFileItem','ViewFileItem as an editor.
		 * Flags: IR */
		imageSize: number | string /* number or String */;

		/** Width of the image-content of this field. If set as a string, represents the name of another field in the record that holds the imageWidth. Applicable only to fields of image type or fields that use a ViewFileItem','ViewFileItem as an editor.
		 * Flags: IR */
		imageWidth: number | string /* number or String */;

		/** For a field of FieldType','type "sequence" on a DataSource with DataSource.serverType','serverType:"sql", this flag indicates that the field is implicitly bound to a sequence. This setting means that SmartClient does not expect to find a value for the field in "add" operations, even if it is marked as a DataSourceField.primaryKey','primaryKey, as such fields usually are. It also means that SmartClient does not attempt to retrieve the field value from an actual database sequence, instead relying on the JDBC driver to return the generated value (see the note on sequenceMode below). Implicitly bound columns are a syntactic convenience provided by some databases to simulate the "auto-increment" or "identity" columns available natively in other products, without the underlying sequence having to be explicitly referenced in SQL queries. Currently, these database products support this idea: PostgreSQL has had a "serial" column type for a long time - <a href=http://www.postgresql.org/docs/9.3/static/datatype-numeric.html#DATATYPE-SERIAL> http://www.postgresql.org/docs/9.3/static/datatype-numeric.html#DATATYPE-SERIAL</a> DB2 has long supported a "GENERATED AS IDENTITY" notation for numeric fields. This may or may not be implemented with a sequence - the documentation does not specify - but we support it via the implicitSequence mechanism because it is so similar to the implicit sequence approach in Oracle. <a href="http://publib.boulder.ibm.com/infocenter/dzichelp/v2r2/index.jsp?topic=/com.ibm.db2z10.doc.apsg/src/tpc/db2z_identitycols.htm"> http://publib.boulder.ibm.com/infocenter/dzichelp/v2r2/index.jsp?topic=/com.ibm.db2z10.doc.apsg/src/tpc/db2z_identitycols.htm</a> Oracle introduced a "GENERATED AS IDENTITY" notation for numeric fields in version 12c - <a href=http://www.oracle-base.com/articles/12c/identity-columns-in-oracle-12cr1.php> http://www.oracle-base.com/articles/12c/identity-columns-in-oracle-12cr1.php</a> If you have columns like these in your database, declare them as type "sequence" and mark them with the implicitSequence flag. NOTE: If you use this property, you should also set the DataSource.sequenceMode','DataSource sequenceMode to "jdbcDriver". This is necessary because SmartClient cannot directly query the implicit sequence that is being used behind the scenes, so we must rely on the JDBC driver to do that. If you use DataSource.autoDeriveSchema','autoDeriveSchema to automatically derive a dataSource from table metadata, SmartClient attempts to identify these special Oracle and Postgres columns by heuristic examination of the metadata. When it identifies such a column, it marks the corresponding dataSourceField implicitSequence: true, and changes the sequenceMode on the DataSource to "jdbcDriver". If your table contains one of these columns and SmartClient does not automatically identify it, bear in mind that you can always set this flag manually, even if you are using autoDeriveSchema. This setting has no effect for non-SQL dataSources, or for databases other than those mentioned above.
		 * Flags: IR, Group: sqlDataSource */
		implicitSequence: boolean /* Boolean */;

		/** Declares the FieldImportStrategy for this field. The default setting of null has the same meaning as "auto". Note, this attribute only has an effect if all of the following are true: The field declares a DataSourceField.foreignKey','foreignKey The field declares a DataSourceField.displayField','displayField The displayField so declared is DataSourceField.includeFrom','included from the same DataSource that the foreignKey declaration refers to In any other circumstances, this attribute is ignored. importStrategy is applied by the server-side DataImport.importToRows() method, which is in turn used by BatchUploader and several other DataImport APIs such as importToDataSource(), importDataSourceRecords() and importAndValidateDSRows(). See the server-side documentation for details of these APIs. The actual data transformation is carried out by the server-side API DataSource.transformImportValue(); this method can be overridden to carry out any other transformation you may require.
		 * Flags: IR */
		importStrategy: FieldImportStrategy;

		/** For use in componentSchema, a field DataSource.inheritsFrom','inherited from another schema can be redeclared with this property set in order to indicate that the property should not be used. This is primarily used to influence visualBuilder. For simple type properties, this avoids the property appearing in the Component Editor. For fields that hold subcomponents, this prevents inappropriate drag and drop. For example, a custom class called MyDialog may automatically create a series of children, and not allow arbitrary other children to be added. In this case, the inherited property Canvas.children should be marked inapplicable in order to prevent arbitrary components being dropped onto a MyDialog instance.
		 * Flags: IR, Group: componentSchema */
		inapplicable: boolean;

		/** Indicates this field should be fetched from another, related DataSource. The incluedFrom attribute should be of the form "dataSourceId.fieldName", for example: &lt;field includeFrom="supplyItem.itemName"/&gt; A DataSourceField.foreignKey declaration must exist between the two DataSources, establishing either a 1-to-1 relationship or a many-to-1 relationship from this DataSource to the related DataSource. The inclusion can be indirect (traverse multiple DataSources) so long as there is a chain of foreignKey declarations from the target DataSource to the DataSource where the includeFrom field is declared. For including from a related DataSource where there are multiple related records, see DataSourceField.includeSummaryFunction','includeSummaryFunction. DataSourceField.name will default to the name of the included field, or you can specify a different name. If both DataSources are SQLDataSources, HibernateDataSources or JPADataSources (with Hibernate as the provider) the related data will be retrieved via a SQL join and criteria and sort directions applied to the field work normally (they become part of the generated SQL query). Otherwise, the related data will be retrieved via performing a DSRequest against the related DataSource once the data from the primary DataSource has been retrieved. In this case, criteria or sorting directions applied to the included field are only allowed if data paging is not in use (for example ListGrid.dataFetchMode:"basic"); otherwise, criteria and sort direction are ignored for the included field and a warning is logged on the server. Editing included fields An included field is DataSourceField.canEdit','canEdit:false by default. Note that included fields are not updatable, even if you set canEdit:true; the server will simply drop values for included fields if client code sends them. When thinking about editing an included field value, typically what is really intended is to edit the value of the foreignKey field. For example, take the scenario of a system that tracks accounts and the employees assigned to manage them. Given a DataSource "account" related one-to-one with DataSource "employee" by a "managerId" foreignKey field, we might declare an includeFrom so that the name of the account manager can be shown with each "account" record. Editing the manager's name while viewing the account would be intended to pick a new account manager, and not to change the legal name of the employee who happens to be the current account manager. To correctly set up this scenario, declare an includeFrom field that is hidden, but is used as the DataSourceField.displayField','displayField for the foreign key field. Setting useLocalDisplayFieldValue to true will ensure the display field value is picked up from the record currently being edited: &lt;field name="managerId" foreignKey="employee.id" displayField="managerName" useLocalDisplayFieldValue="true"/&gt; &lt;field name="managerName" includeFrom="employee.name" hidden="true"/&gt; Now: the "managerId" foreignKey field is shown in grids and forms, but takes its displayed value from the hidden includeFrom field. the automatically chosen editor will be a SelectItem with SelectItem.optionDataSource','optionDataSource set to "employees": it will allow picking a different "employee" record from the "employee" DataSource saving will save the ID of a new "employee" record to the "managerId" foreign key field, as intended You can alternatively set editorType="ComboBoxItem" on the "managerId" field to allow typeahead search of the "employee" DataSource. Note that the DataSourceField.foreignDisplayField attribute allows developers to have a different fieldName be used locally as a displayField from the field name for the display field in the foreign dataSource.
		 * Flags: IR, Group: dataSourceRelations */
		includeFrom: string /* String */;

		/** When DataSourceField.includeFrom','field.includeFrom is specified and multiple records exist in the related DataSource per record in the including DataSource, includeSummaryFunction indicates which SummaryFunction is used to produce the field value. This feature is available with Power or better licenses only. See <a href="http://smartclient.com/product">smartclient.com/product</a> for details. For example, give a DataSource "order" and related DataSource "orderItem", the "itemCount" field below will show the total number of items in each order. &lt;DataSource ID="order"&gt; &lt;fields&gt; &lt;field name="orderID" type="integer" primaryKey="true" foreignKey="orderItem.orderID" /&gt; &lt;field name="customerName" type="text" /&gt; &lt;field name="orderDate" type="date" /&gt; &lt;field name="itemsCount" includeFrom="orderItem.quantity" includeSummaryFunction="sum" /&gt; &lt;/fields&gt; &lt;/DataSource&gt; This is analogous to the following SQL statement: SELECT order.orderID, order.customerName, order.orderDate, (select sum(orderItem.quantity) from orderItem where orderItem.orderID = order.orderID) as itemsCount FROM order Some other common uses: using "max" to show the most recent "order" for a "customer" using "avg" to show the average order size for a "customer" using "concat" to show the names of all "salesReps" involved in an "order" (note: "concat" has limited support - see SummaryFunction). NOTE: includeSummaryFunction and serverSummaries','Server Summaries cannot be used in the same DSRequest. If both configurations are present, Server Summaries settings always take priority.
		 * Flags: R, Group: serverSummaries */
		includeSummaryFunction: SummaryFunction;

		/** For a field that uses DataSourceField.includeFrom, specifies which DataSourceField.foreignKey','foreignKey field should be used to find records in the related DataSource. includeVia only needs to be set when you have more than one foreignKey to the same related DataSource. If you have multiple foreignKeys to multiple different DataSources, there is no need to set includeVia. For example, perhaps you have a DataSource "moneyTransfer" where each record represents a money transfer, where the source and payment currencies are different, and the list of currencies is stored in a related DataSource "currency". Each "moneyTransfer" record is linked to 2 "currency" records, through two different foreignKey fields, "sourceCurrencyId" and "paymentCurrencyId". The following declarations would be required to use includeFrom to get a include the field "currencySymbol" from each of the two related "currency" records. &lt;field name="sourceCurrencyId" foreignKey="currency.id"/&gt; &lt;field name="paymentCurrencyId" foreignKey="currency.id"/&gt; &lt;field name="sourceCurrencySymbol" includeFrom="currency.currencySymbol" includeVia="sourceCurrencyId"/&gt; &lt;field name="paymentCurrencySymbol" includeFrom="currency.currencySymbol" includeVia="paymentCurrencyId"/&gt; <h3>SQL Templating and includeVia</h3> The includeVia feature uses SQL table aliases in the generated SQL when generating multiple SQL joins to the same SQL table. When using customQuerying','SQL Templating, it's sometimes necessary to know the names of the aliases in the generated SQL. The table alias used can be configured via setting DataSourceField.relatedTableAlias on the foreignKey field, for example, using the declarations below, aliases "source" and "payment" would be used for the two "currency" tables. &lt;field name="sourceCurrencyId" foreignKey="currency.id" relatedTableAlias="source"/&gt; &lt;field name="paymentCurrencyId" foreignKey="currency.id" relatedTableAlias="payment"/&gt; &lt;field name="sourceCurrencySymbol" includeFrom="currency.currencySymbol" includeVia="sourceCurrencyId"/&gt; &lt;field name="paymentCurrencySymbol" includeFrom="currency.currencySymbol" includeVia="paymentCurrencyId"/&gt; <h3>Multiple indirection and relatedTableAlias</h3> Sometimes you may have two includeFrom fields that include a field which is itself included from another DataSource, for example: &lt;field name="sourceCurId" nativeName="sourceCurrencyId" foreignKey="currency.id" relatedTableAlias="source"/&gt; &lt;field name="sourceCurrencySymbol" includeFrom="currency.currencySymbol" includeVia="sourceCurId"/&gt; &lt;field name="sourceCurrencyGroup" includeFrom="currency.groupName" includeVia="sourceCurId"/&gt; &lt;field name="paymentCurId" nativeName="paymentCurrencyId" foreignKey="currency.id" relatedTableAlias="payment"/&gt; &lt;field name="paymentCurrencySymbol" includeFrom="currency.currencySymbol" includeVia="paymentCurId"/&gt; &lt;field name="paymentCurrencyGroup" includeFrom="currency.groupName" includeVia="paymentCurId"/&gt; .. where the "currency" DataSource used above is related to the "currencyGroup" DataSource via fields: &lt;field name="groupId" type="integer" foreignKey="currencyGroup.id" relatedTableAlias="group"/&gt; &lt;field name="groupName" type="text" includeFrom="currencyGroup.groupName"/&gt; Fields "sourceCurrencyGroup" and "paymentCurrencyGroup" include a field that is itself an included field. In this case "currencyGroup" table will be referenced two times, and its relatedTableAlias defined in "currency" DataSource will be prefixed with the includeVia value to make aliases unique in generated SQL: "sourceCurId_group" and "paymentCurId_group". The same aliases would be used if "sourceCurrencyGroup" and "paymentCurrencyGroup" fields were to include "currencyGroup.groupName" indirectly: &lt;field name="sourceCurrencyGroup" includeFrom="currency.currencyGroup.groupName" includeVia="sourceCurId"/&gt; &lt;field name="paymentCurrencyGroup" includeFrom="currency.currencyGroup.groupName" includeVia="paymentCurId"/&gt; This works the same for more complex relationships. If we add a "moneyTransferDetail" DataSource to the sample above which has multiple references to "moneyTransfer" DataSource and would include fields from "currency" and "currencyGroup" DataSources: &lt;field name="mtId" nativeName="moneyTransferId" type="integer" foreignKey="moneyTransfer.id" relatedTableAlias="main" /&gt; &lt;field name="mainTransferName" includeFrom="moneyTransfer.name" includeVia="mtId" /&gt; &lt;field name="mainSourceSymbol" includeFrom="moneyTransfer.sourceCurrencySymbol" includeVia="mtId" /&gt; &lt;field name="mainSourceGroup" includeFrom="moneyTransfer.sourceCurrencyGroup" includeVia="mtId" /&gt; &lt;field name="mainPaymentSymbol" includeFrom="moneyTransfer.paymentCurrencySymbol" includeVia="mtId" /&gt; &lt;field name="mainPaymentGroup" includeFrom="moneyTransfer.paymentCurrencyGroup" includeVia="mtId" /&gt; &lt;field name="mtPrevId" nativeName="moneyTransferPreviousId" type="integer" foreignKey="moneyTransfer.id" relatedTableAlias="prev" /&gt; &lt;field name="previousTransferName" includeFrom="moneyTransfer.name" includeVia="mtPrevId" /&gt; &lt;field name="previousSourceSymbol" includeFrom="moneyTransfer.sourceCurrencySymbol" includeVia="mtPrevId" /&gt; &lt;field name="previousSourceGroup" includeFrom="moneyTransfer.sourceCurrencyGroup" includeVia="mtPrevId" /&gt; &lt;field name="previousPaymentSymbol" includeFrom="moneyTransfer.paymentCurrencySymbol" includeVia="mtPrevId" /&gt; &lt;field name="previousPaymentGroup" includeFrom="moneyTransfer.paymentCurrencyGroup" includeVia="mtPrevId" /&gt; In this scenario the "currencyGroup" table will be joined 4 times - for all main/prev transfer and payment/source currency combinations. So, aliases will be prefixed with both intermediate includeVia values: "mtId_sourceCurId_group", "mtId_paymentCurId_group", "mtPrevId_sourceCurId_group", "mtPrevId_paymentCurId_group". It is also allowed to specify a series of FK fields in includeVia, for example "moneyTransferDetail" could declare: &lt;field name="mainSourceCurrencyGroup" includeFrom="moneyTransfer.currency.currencyGroup.groupName" includeVia="mtId.sourceCurId"/&gt; &lt;field name="mainPaymentCurrencyGroup" includeFrom="moneyTransfer.currency.currencyGroup.groupName" includeVia="mtId.paymentCurId"/&gt; In this case the prefix used for table aliases will be the includeVia value with "_" substituted for ".", so the table aliases will be "mtId_sourceCurId_group" and "mtId_paymentCurId_group". Note that if DataSourceField.relatedTableAlias','related table alias is not specified, then we don't make any guarantees what alias will be generated. Note that Oracle has a limit of 30 characters on identifier names. We limit table aliases to 30 characters all databases despite actual database in use to support portability across databases. If the generated table alias would exceed 30 chars, we instead use a generated and unpredictable value like "a123". To avoid hitting this limit for the advanced cases discussed above: use relatively short strings for relatedTableAlias for rare, multi-step inclusion scenarios where multiple field names are used as a prefix, if field names are very long in order to match database column names, you can use a shorter field name and use DataSourceField.nativeName to specify the underlying column name (this is demonstrated in samples above - note field "mtPrevId") 
		 * Flags: IR, Group: dataSourceRelations */
		includeVia: string /* String */;

		/** Indicates that the specified VelocityExpression must evaluate to true if initializations of this field are to be allowed. If the specified expression does not evaluate to true, the field will be removed from the request as described for DataSourceField.editRequiresAuthentication','editRequiresAuthentication. In addition to the normal context variables available to Velocity expressions in SmartClient, expressions you write for field-level requires clauses - initRequires, DataSourceField.viewRequires','viewRequires, DataSourceField.editRequires','editRequires and DataSourceField.updateRequires','updateRequires - can reference two additional variables: $fieldName and $dsName. These are the names of the dataSource and field currently undergoing requires checks. They are helpful because they allow you to write a generic checker function that can be used to handle requires checks for multiple fields and dataSources. NOTE: This property only prevents initialization of a field; updates will still be allowed. You should only use this property if you have a special requirement; ordinarily, use DataSourceField.editRequires, which applies security for both types of write.
		 * Flags: IR, Group: fieldLevelAuth */
		initRequires: string /* VelocityExpression */;

		/** Whether a user must be authenticated in order to initialize to this field. If this property is set and the user is not authenticated, the SmartClient Server will not allow this field to be initialized.
		 * Flags: IR, Group: fieldLevelAuth */
		initRequiresAuthentication: boolean;

		/** Comma-separated list of user roles that are allowed to initialize this field. If the current user does not have any of the roles listed, the system will not allow this field to be initialized. NOTE: This property only prevents initialization of a field; updates will still be allowed. You should only use this property if you have a special requirement; ordinarily, use DataSourceField.editRequiresRole, which applies security for both types of write.
		 * Flags: IR, Group: fieldLevelAuth */
		initRequiresRole: string /* String */;

		/** Explicitly declares the Java class that should be used when data from the client is validated by the SmartClient server and/or applied to Java Beans / POJOs via the server-side API com.isomorphic.datasource.DataSource.setProperties(). This includes auto-populating POJO arguments of a dmiOverview','DMI method, or populating JPA/Hibernate beans with data when using the built-in JPA and Hibernate DataSources. For DataSources that do not use Java Beans, fields declared to be of type "integer" or "float" can use javaClass to force a particular numeric representation for validated DSRequest data (e.g. data passed to a DMI). Valid settings include "BigInteger", "Long", "Integer", "Short", "Byte", "AtomicInteger", "AtomicLong", "BigDecimal", "Double", "Float". When populating Java Beans/ POJOs, javaClass does not normally have to specified: SmartClient will use Java reflection to inspect the type of argument expected by a setter method and will attempt conversion of inbound data to that type. As described in the documentation for DataTools.setProperties(), this works for almost all typical cases. However field.javaClass is useful for: subobject of abstract or interface type: in this case Java Reflection is not sufficient to discover the concrete type that should be instantiated, and javaClass should be set instead. subobject of Collection or Map type, when Java generics are not used or the Collection member type or Map value type is abstract. When Java generics are used (for example the setter takes an argument is of type Collection&lt;SomePOJO&gt; or Map&lt;KeyType,SomePOJO&gt;, SmartClient will automatically attempt to convert inbound data to the type of the members of the Collection or values of the Map. Without generics, javaClass needs to be specified. Note that javaClass will take precedence over generics if both are used. Also note that DataSourceField.javaCollectionClass can be specified if a particular Collection or Map type is needed, and DataSourceField.javaKeyClass can be specified for a field of type java.util.Map. NOTE: It is also possible to make SmartClient Server determine the javaClass to use dynamically at runtime. See the description of DataSource.getPropertyJavaClass() in the server documentation for details.
		 * Flags: IR */
		javaClass: string /* String */;

		/** See DataSourceField.javaClass - when auto-populating of Java Beans / POJOs based on inbound DSRequest data, for a field of type Collection or Map, javaCollectionClass can be used to specify a particular concrete class to use. If not specified, and a concrete Collection or Map class cannot be discovered using Java Reflection, the following concrete classes are used: java.util.ArrayList is used for fields of type List java.util.HashSet is used for fields of type Set java.util.LinkedList is used for fields of type Queue org.apache.commons.collections.map.LinkedMap is used for fields of type Map java.util.ArrayList is used for fields that are otherwise of type Collection Note that this value is used even if the target Collection or Map is declared as a concrete class. So, for example, if you set javaCollectionClass to java.util.LinkedList but your setter method accepts a java.util.ArrayList, you will get a ClassCastException.
		 * Flags: IR */
		javaCollectionClass: string /* String */;

		/** See DataSourceField.javaClass - when auto-populating of Java Beans / POJOs based on inbound DSRequest data, for a field of Map type, javaKeyClass can be used to specify a particular concrete class for the map keys. If not specified, and a concrete type cannot be discovered using Java Reflection, java.lang.Object is used. Note that javaKeyClass take precedence over generics if both are used.
		 * Flags: IR */
		javaKeyClass: string /* String */;

		/** Defines prefix before concatenated values if field is used with serverSummaries','Server summaries feature and the SummaryFunction','summary function is "concat".
		 * Flags: IR, Group: serverSummaries */
		joinPrefix: string /* String */;

		/** Defines the delimiter between concatenated values if field is used with serverSummaries','Server summaries feature and the SummaryFunction','summary function is "concat". The default value is ", ".
		 * Flags: IR, Group: serverSummaries */
		joinString: string /* String */;

		/** Defines suffix after concatenated values if field is used with serverSummaries','Server summaries feature and the SummaryFunction','summary function is "concat".
		 * Flags: IR, Group: serverSummaries */
		joinSuffix: string /* String */;

		/** This property is only applicable to fields of SQL DataSources that also specify a DataSourceField.foreignKey','foreignKey property; it is ignored for all other fields. Indicates the type of join to make between the tables underlying this DataSource and the other DataSource referred to in the foreignKey property, when resolving DataSourceField.includeFrom','includeFrom fields. The default value of null is the same as specifying "inner". Note, outer joins are allowed for all supported database products only if you are using DataSource.useAnsiJoins','ANSI-style joins, which is not the case by default. If you are using the older strategy of additional join expressions in the WHERE clause, outer joins are only supported for database products that provide a proprietary native syntax for expressing outer joins. Those products are: Oracle Versions of Microsoft SQL Server earlier than 2012, and running in compatibility mode 80 
		 * Flags: IR, Group: dataSourceRelations */
		joinType: JoinType;

		/** Maximum number of characters allowed. Applicable only to fields of text type. For fields of this type a ValidatorType','length range validator will be automatically generated on both the client and server side to enforce this maximum length (unless such a validator is explicitly present for the field already). The TextItem.enforceLength attribute can also explicitly limit user input for freeform text items editing fields with an explicit length specified. NOTE: For DataSources of type "sql", this property has a bearing on the type of column we use when the underlying table is created by a DataSource sqlDataSource','import in the adminConsole','Admin Console. Below a certain length (which is database-specific, see below), we use standard VARCHAR columns; above that length, we use an alternate strategy (again, database-specific). For these long fields, we sometimes also generate different SQL for "update" and "add" operations, using JDBC "?" replacement parameters rather than embedding values directly in the generated SQL; whether or not this is done depends entirely on what the underlying database product and/or JDBC driver will allow. Table of field length limits for supported databases: <table style="font-size:10px;text-align:center;border:1px solid black;"> <tr><td style="color:white;background-color:black;">Database product</td> <td style="color:white;background-color:black;">VARCHAR limit *</td> <td style="color:white;background-color:black;">Type used above limit</td></tr> <tr><td>HSQLDB</td><td>None</td><td>-</td></tr> <tr><td>IBM DB2</td><td>4000</td><td>CLOB</td></tr> <tr><td>Firebird</td><td>32767</td><td>BLOB with subtype 1</td></tr> <tr><td>Informix</td><td>255 / 32739</td><td>LVARCHAR / TEXT ** </td></tr> <tr><td> Microsoft SQL Server </td><td>8000</td><td>TEXT</td></tr> <tr><td>MySQL</td><td> 255 / 65535 / 16M </td><td> TEXT / MEDIUMTEXT / LONGTEXT *** </td></tr> <tr><td>Oracle</td><td>4000</td><td>CLOB</td></tr> <tr><td>PostgreSQL</td><td>4000</td><td>TEXT</td></tr> </table> * The "VARCHAR limit" referred to here is a limit used by the SmartClient Server; it is not necessarily imposed by the database. For example, DB2's VARCHAR limit is not 4000 characters; it actually varies from about 4K to about 32K, depending on how the server has been configured. ** Informix has a limit of just 255 characters for VARCHAR, but has a native LVARCHAR type which supports nearly 32K characters without needing to fall back on long datatypes. Therefore, with that one product, we have two thresholds for a change in storage type. *** MySQL has a limit of 255 characters for VARCHAR, 65,535 characters for TEXT and 16,777,215 for MEDIUMTEXT; therefore, with that one product, we have three thresholds for a change in storage type.
		 * Flags: IR, Group: dataType */
		length: number;

		/** For fields of a type that are represented by binary data initially uploaded from a file (currently "binary" and "imageFile", see FieldType), this sets the maximum file size allowed, in bytes.
		 * Flags: IR */
		maxFileSize: number /* Integer */;

		/** For a binaryFields','binary field, sets a fixed mime type for all files stored to this field. Should be set to a standard mime type string, for example, "text/plain" for a .txt file. This is useful if a binary field only stored one type of file and you chose not to store filenames, since the extension of the file name is normally used to determine the mime type.
		 * Flags: IR */
		mimeType: string /* String */;

		/** Indicates that this field should always be Array-valued. If the value derived from DataSource.dataFormat','XML or JSON data is singular, it will be wrapped in an Array. JPA and Hibernate DataSources use multiple:true as part of the declaration of One-To-Many and Many-to-Many relations - see jpaHibernateRelations for details. <h4>Criteria on multiple:true fields: client-side filtering</h4> For simple Criteria, the criteria value is compared to each field value in the multiple:true field, according to the DSRequest.textMatchStyle','textMatchStyle. If any field value matches the filter value, the field is considered to match the criteria. For AdvancedCriteria, for normal OperatorId','search operators the field value is considered as matching the Criterion if any of the field values match the Criterion. Specifically, this is true of all operators that have an OperatorValueType','operatorValueType of "fieldType" or "valueRange". For operators that compare against other fields in same record, such as "equalsField", if the other field is not multiple:true, matching works the same as for normal operators, that is, as if criterion.value directly contained the value rather than the name of another field. If the other field is also multiple:true, only "equalsField", "notEqualsField", "iEqualsField" and "iNotEqualsField" are allowed (any other operator will cause a warning and be ignored) and the set of values in the field must be identical (aside from case, for operators prefixed with "i") and in identical order to match. For the inSet operator, the field matches if there is any intersection between the field values and the array of values provided in criterion.value. notInSet is the reverse. Finally, for "isBlank", "notBlank", "isNull" and "notNull", an empty Array is considered non-null. For example, if you use dataFormat:"json" and the field value is provided to the browser as [] (JSON for an empty Array), the field is considered non-null. <h4>Server-side Representation and Storage</h4> Values for multiple:true fields appear as Java Lists when received in server code such as a DMI. The SmartClient Server supports simple storage of values that are multiple:true, controlled via the DataSourceField.multipleStorage setting. For server-side behavior of JPA and Hibernate relation fields that are multiple:true, see jpaHibernateRelations. For non-relation fields, the SmartClient Server supports simple storage of values that are multiple:true, controlled via the DataSourceField.multipleStorage setting, with some limited support for server-side filtering, as described in the DataSourceField.multipleStorage docs. For the built-in SQL, Hibernate and JPA connectors, if criteria are specified for a multiple:true field where multipleStorage is null or "none", the SmartClient server knows nothing about how the multiple values are stored, so as a fallback the criteria will operate as though the field were a normal, non-multiple "text" field. This will generally not match the client-side filtering behavior described above, so filtering should either be performed entirely on the client (for example, via ListGrid.dataFetchMode','dataFetchMode:"local" or entirely on the server (via ResultSet.useClientFiltering:"false") The server-side filtering is done through a criteria transform which happens with DataSource.transformMultipleFields','transformMultipleFields. <h4>XML Serialization</h4> Specifically for XML serialization and deserialization, multiple:true behaves similarly to the <a href='http://www.google.com/search?hl=en&q=soap+array' target='_blank'>SOAP array idiom</a>, that is, there will be a "wrapper element" named after the field name, whose contents will be several elements of the specified DataSourceField.type','field.type. For example, Layout.members is declared with type:"Canvas", multiple:true. The correct XML format is thus: &lt;VLayout&gt; &lt;members&gt; &lt;Canvas ID="myCanvas" ... /&gt; &lt;ListGrid ID="myGrid" .../&gt; &lt;Toolstrip ID="myToolStrip" ... /&gt; &lt;/members&gt; &lt;/VLayout&gt; See DataSourceField.childTagName for customizing the tagName used for subelements.
		 * Flags: IR, Group: xmlSerialize */
		multiple: boolean /* Boolean */;

		/** How values for a DataSourceField.multiple','multiple:true field should be stored. On the server, field values for multiple:true fields are represented as Java Lists in DSRequest and DSResponse objects, but when multipleStorage is used, are ultimately stored as Strings. This storage mechanism is "denormalized" in the sense of <a href='http://en.wikipedia.org/wiki/Database_normalization' target='_blank'>database normalization</a> because the field contains a compound value rather than an atomic value. Specifically, this makes the field harder to use with database features like SQL joins, since its value cannot be directly compared to other, singular fields. For this reason, there's really only a narrow set of cases where it makes sense to use this storage mechanism, consider it if: the values don't appear in any other tables or columns elsewhere in your database (so joins and other comparisons wouldn't be possible anyway) there is no authoritative list of all possible values, or even of popular values; it's basically freeform, like arbitrary, uncurated "tags" applied to photos or links A multiple:true field can be of any SimpleType, including "date", "time", "datetime", "float", "int" etc. Type will be preserved across a store and reload cycle, so for example a List of values for a field of type "int" will arrive at the server in a DSRequest as a List of Integer, be stored as a String, but appear again as a List of Integer inside a DSResponse. When storing "date", "time" or "datetime" values as Strings, XML schema formats are used - the same that are used for transmission in XML or JSON (see dateFormatAndStorage','Date and Time Format and Storage overview for details). The multipleStorage feature works by transforming from List to String and back inside the server-side DataSource.execute() method. Specifically, inbound DSRequests are transformed before methods that perform actual storage are called (executeUpdate() et al), and DSResponses received from these methods have multiple:true field values transformed back into Lists before DataSource.execute() returns the DSResponse. This transformation approach means that the built-in SQL, JPA and Hibernate connectors all support multipleStorage, and multipleStorage is also automatically available for any custom DataSource that is capable of storing String values, and implements its storage methods via overrides of executeUpdate(), executeAdd() et al as described in the writeCustomDataSource','custom DataSource overview. Note that when using the built-in SQL, JPA and Hibernate connectors, the underlying SQL column should be of 'text' type. The dbConfigTool','Database Configuration Tool will automatically generate columns of the correct type for a SQLDataSource. For JPA or Hibernate DataSources, just ensure the type of the Java bean property on your Java object is String. The default multipleStorage setting of null means that the "simpleString" MultipleFieldStorage approach will be used if: the field is of a known SimpleType the field is not a DataSourceField.foreignKey Otherwise, MultipleFieldStorage "none" will be used. <h4>Criteria and AdvancedCriteria handling</h4> For the built-in SQL, JPA and Hibernate connectors, when multipleStorage:"simpleString" or "json" is used, criteria are transformed to replicate the client-side filtering behavior for multiple:true fields, where possible. The following operators are supported with the same behavior as client-side filtering: all String-oriented operators including patternOperators','pattern operators, but not regexp/iRegexp isBlank / notBlank isNull / notNull inSet / notInSet equalsField / notEqualsField / iEqualsField / iNotEqualsField The following operators, which are supported for client-side filtering of multiple:true fields, are not supported for server filtering when using multipleStorage: greaterThan/lessThan(OrEqual) "between" and all other operators with OperatorValueType of "valueRange" regexp / iRegexp as noted above Note that for string-based filtering operators such as "equals", no characters which are part of the DataSourceField.multipleStorageSeparator may be used in the filter string. If any characters from the multipleStorageSeparator are present in the filter value, it will always fail to match. For "json" mode, the multipleStorageSeparator is effectively the String '","'.
		 * Flags: IR, Group: multipleField */
		multipleStorage: MultipleFieldStorage;

		/** For fields that are DataSourceField.multiple','multiple:true and use DataSourceField.multipleStorage, the separator used in the "simpleString" MultipleFieldStorage mode. Default value of null means the DataSourceField.multipleValueSeparator is used instead.
		 * Flags: IR, Group: multipleField */
		multipleStorageSeparator: string /* String */;

		/** For fields that are DataSourceField.multiple','multiple:true, the separator used between values when they are displayed.
		 * Flags: IR, Group: multipleField */
		multipleValueSeparator: string /* String */;

		/** Name for this field. The field name is also the property in each DataSource record which holds the value for this field. Must be unique across all fields within the DataSource as well as a valid JavaScript identifier, as specified by ECMA-262 Section 7.6. NOTE: The String.isValidID function can be used to test whether a name is a valid JavaScript identifier.
		 * Flags: IR, Group: basics */
		name: string /* identifier */;

		/** Only applicable to "sql" dataSources. If set, this property indicates that the field is bound to the column named in the property. It is used to bind a DataSourceField to a database column with a different name. nativeName is useful for disambiguating in cases where you have customized SQL. For example, assume you are joining two tables - call them product and supplier - that both contain a column called "name". Only one field in the DataSource can be called "name"; to disambiguate, we need to specify both DataSourceField.tableName','tableName and nativeName. A field declaration like this would be needed: &lt;field name="supplierName" type="text" tableName="supplier" nativeName="name" /> You may also wish to use this property to map legacy column names to more meaningful field names in the DataSource. For example: &lt;field name="productName" type="text" nativeName="PRDNM" /> Note that it is not allowed to have multiple fields with the same nativeName bound to the same database table.
		 * Flags: IR */
		nativeName: string;

		/** Controls whether an explicit null-valued Record attribute for this field should result in xsi:nil being used to transmit the value when serializing to XML, like so: &lt;book&gt; &lt;title&gt;Beowulf&lt;/title&gt; &lt;author xsi:nil="true"/&gt; &lt;/book&gt; If nillable is not set, no XML element will be generated for the explicit null value.
		 * Flags: IR, Group: dataType */
		nillable: boolean;

		/** If DataSource.noNullUpdates is set, the value to use for this field when a null value is assigned to it on an update operation. This property overrides the DataSource-level properties DataSource.nullStringValue','nullStringValue, DataSource.nullIntegerValue','nullIntegerValue, DataSource.nullFloatValue','nullFloatValue and DataSource.nullDateValue','nullDateValue, for this field only. NOTE: If you use this property, you are responsible for ensuring that the replacement value is appropriate and valid.
		 * Flags: IR */
		nullReplacementValue: any /* Any */;

		/** Applies only to fields of type "float" or "integer" and affects how many significant digits are shown. For example, a field value of 343.1, 343.104 and 343.09872677 would all be shown as 343.10 if precision is 5. The original value is always shown when the value is edited.
		 * Flags: IRW, Group: appearance */
		precision: number;

		/** Indicates either that this field holds a value unique across all records in this DataSource, or that it is one of a number of fields marked as primary keys, and the combination of the values held in all of those fields is unique across all records in the DataSource. Note that the latter usage - so-called "composite" or "multipart" keys - is intended for support of legacy databases only: if you are able to choose an approach, Isomorphic recommends the use of one primaryKey field per DataSource, and ideally this field should be of DataSourceField.type','type "sequence". If you have control of the underlying tables, there is nothing to stop you from adding a field like this (a so-called "synthetic" or "surrogate" key), even for tables that already have a set of columns that could combine to make a composite key (a so-called "natural" key). Also, it is neither necessary nor correct to use a composite primaryKey because you want to enforce uniqueness across that combination of fields. You can achieve that by declaring a unique constraint in the table schema, or use an ValidatorType','isUnique validator with validator.criteriaFields, or both; there is no need to use a composite key to enforce uniqueness Note that composite primaryKeys are not supported in tree-structured datasets (Tree and ResultTree) or components (TreeGrid, ColumnTree). Tree-structured data requires that nodes have a unique Tree.idField','idField, with the parent/child relationship expressed through the Tree.parentIdField','parentIdField. This implies that binding a Tree to a DataSource requires that the DataSource have a singular primaryKey, and that the primaryKey field is also the idField, as described in the treeDataBinding','tree databinding overview A DataSource that can only perform the "fetch" operation does not require a primaryKey unless it contains binaryFields','binary fields. If a DataSource allows modification of DataSource records through add, update and remove DataSource operations, or it contains one or more binary fields, one or more fields must be marked as the primary key. SmartClient requires a primary key value to uniquely identify records when communicating updates or deletions to the server. There is no requirement that the primaryKey field be mapped to an actual "primary key" in your object model, web service, or database (though this is the most obvious and natural thing to do, of course). The only requirement is that the combined values of the primaryKey fields be unique for a given browser instance for the lifetime of the page. If using SmartClient's sqlDataSource','SQL engine and generating SQL tables using the dbConfigTool','Database Configuration Tool, the table column generated from a primaryKey field will have a unique constraint applied in the database table and, if the field is of type "sequence", the database column will also be created as an "identity column" in those databases that implement sequence-type handling with identity columns.
		 * Flags: IR, Group: dataSourceRelations */
		primaryKey: boolean;

		/** For use in componentSchema for fields that contain other components, this flag suppresses auto-construction for subcomponents that appear under this field. For example, the VLayout schema sets this for its Layout.members','members property, so that when a VLayout is constructed via XML as follows: &lt;VLayout&gt; &lt;members&gt; &lt;ListGrid ID="myGrid" .../&gt; &lt;Toolstrip ID="myToolStrip" ... /&gt; &lt;/members&gt; &lt;/VLayout&gt; The ListGrid and ToolStrip do not construct themselves automatically. Instead, the VLayout receives the properties of the ListGrid and ToolStrip as ordinary JavaScript Objects, with the special property _constructor set to the name of the class that should be constructed.
		 * Flags: IR, Group: componentSchema */
		propertiesOnly: boolean;

		/** Sets the default FormItem to be used if this field is marked as DataSourceField.canEdit','canEdit false and displayed in an editor component such as a DynamicForm. This property may also be specified at the type level by specifying SimpleType.readOnlyEditorType.
		 * Flags: IR, Group: componentBinding */
		readOnlyEditorType: string /* FormItem className */;

		/** For a sqlDataSource','SQL DataSource field that specifies a DataSourceField.foreignKey','foreignKey, this property defines the table alias name to use in generated SQL. Aliasing is necessary when the same table appears more than once in a query. This can happen when using DataSourceField.includeVia','Multiple includeFrom \n fields referring to the same related DataSource. It can also happen when a DataSourceField.foreignKey','foreignKey definition references the same dataSource that the field is defined in; this happens with hierarchical structures, for example where every Employee reports to another Employee. This is a so-called "self join", and it <em>always</em> requires relatedTableAlias to be specified; failure to do so will result in invalid SQL.
		 * Flags: IR, Group: dataSourceRelations */
		relatedTableAlias: string /* String */;

		/** Indicates this field must be non-null in order for a record to pass validation. Or, in the case of a "binary" field, a non-empty file must be uploaded. Setting this property has the same effect as giving the field a ValidatorType','"required" validator. Note that required should not be set for a server-generated field, such as a sequence, or validation will fail on the client. <h3>Conditionally required fields</h3> Adding an Validator.applyWhen','applyWhen condition to a required validator introduces subtle complexities to the process of validating an existing record. The client is not guaranteed to know the the full and complete state of the record it is editing because it is common for a DynamicForm to be editing a subset of fields. When a field is unconditionally required, things are simple: if the DynamicForm has a FormItem for that field, then the required validation passes if that FormItem has a value, and fails if it does not. If the form has no FormItem for the field, it can assume that the field has a value because otherwise it would have failed validation when we attempted to add it (when we are adding a record, we of course do know the full and complete state of the record - it is whatever we are about to add). When a field is conditionally required, the client can no longer assume that all required fields will have a value. It may be the case that the condition of requirement was not met when the record was added, but now it is. For example, consider these field definitions: &lt;field name="yearsAtCurrentAddress" type="integer" /&gt; &lt;field name="previousAddress" type="text" &gt; &lt;validator type="required" errorMessage="Previous address is required if you have been at your current address less than three years"&gt; &lt;applyWhen operator="and"&gt; &lt;criteria&gt; &lt;criterion fieldName="yearsAtCurrentAddress" operator="lessThan" value="3" /&gt; &lt;/criteria&gt; &lt;/applyWhen&gt; &lt;/validator&gt; &lt;/field&gt; Imagine a record for this DataSource is added where the user has entered a value of "3" for "yearsAtCurrentAddress", and no previous address. Later, the value of that field is changed to "2". If this is done using a form that is also showing the "previousAddress" field, we will know that "previousAddress" has not been provided, so we can fail the validation and the user will get a helpful error message explaining what the problem is. However, if the form does not also show the "previousAddress" field, we may choose to use an OperationBinding that uses OperationBinding.outputs','outputs to trim the record down to just the fields the form does contain, in the interests of avoiding information leakage. Or perhaps that value is automatically culled from the record before the client sees it by the application of a DataSourceField.viewRequires','declarative security rule. Whatever the reason, if the client does not have the complete record, it is not possible for the client to sensibly apply this validation. And because the client has no way of knowing if a value is missing because it is genuinely null, or because it has been trimmed away by the server, we must treat any null value with suspicion (unless it has a matching FormItem - the presence of the FormItem means that the user can edit the value, so it would make no sense to pair it with a trimmed record that excludes that field value). When this happens, we mark the validation as having passed on the client, but in need of running on the server. The server validation makes use of the "storedRecord" facility (look for the description of $storedRecord in the velocitySupport','Velocity support overview) to overlay the changed record on top of the existing record as it currently exists in the database. This gives the validator the complete record including both changed and unchanged values, so it is able to carry out the required check in a meaningful way. However, you should be aware that the combination of conditional "required" validators and DynamicForms that edit partial records can result in a validation that cannot run on the client and must do both a server roundtrip and a database fetch.
		 * Flags: IR, Group: dataType */
		required: boolean;

		/** The required message when a field that has been marked as DataSourceField.required','required is not filled in by the user. Note that this setting wins over DataSource.requiredMessage if both are set.
		 * Flags: IRW, Group: formTitles */
		requiredMessage: string;

		/** For a field that is a foreignKey establishing a tree relationship, what value indicates a root-level node. Defaults to null. Note that the rootValue may be overridden on a specific ResultTree instance by setting ResultTree.rootNode, or if the ResultTree is auto-generated by a TreeGrid, by setting TreeGrid.treeRootValue. This allows a component to navigate a subtree of the hierarchical data from this dataSource starting at a particular node.
		 * Flags: IR, Group: dataSourceRelations */
		rootValue: any;

		/** For a DataSource with DataSource.serverType','serverType:"sql" with a field of type "sequence", the name of the SQL sequence that should be used when inserting new records into this table. Note that this is never required for SQL tables that are generated from SmartClient DataSources (a default sequence name of tableName + "_" + columnName is chosen, but see the notes below regarding this), and is never required for databases where inserting null into a sequence column is sufficient (MySQL, SQL Server, DB2 and others). You would only need to set sequenceName if you are integrating with a pre-existing table stored in a database where the sequence must be named for insertion to work (Oracle, Postgres, Firebird) OR you are trying to use the same sequence across multiple DataSources. Note: If you specify the sql.{database type}.sequence.name.prefix and/or sql.{database type}.sequence.name.suffix properties in your server_properties','server.properties file,the generated sequence name will include the prefix and/or suffix. For example, with a prefix of "order_system_" and a suffix of "_seq", the sequence generated for column "orderNumber" on table "orders" would be: order_system_orders_orderNumber_seq 
		 * Flags: IR, Group: sqlDataSource */
		sequenceName: string /* String */;

		/** For a field of type:"imageFile", indicates whether to stream the image and display it inline or to display the View and Download icons.
		 * Flags: IR */
		showFileInline: boolean;

		/** Causes values for this field to be sorted according to values for another field, for both client- and server-side sorting. This can be used to establish a sort order for a field that is not the normal sorting order indicated by the field value, typically by having the sortByField as a DataSourceField.hidden','hidden field. If using SQLDataSource, consider using a DataSourceField.customSelectExpression as an efficient way to populate the sortByField with the results of a SQL expression.
		 * Flags: IR */
		sortByField: string /* String */;

		/** For fields of type "date", "time", and "datetime" that specify an DataSourceField.sqlStorageStrategy','sqlStorageStrategy of "number" or "text", this property allows you to specify the format SmartClient should use to map to/from the underlying value stored in the database. The string provided must be a valid <a href=http://download.oracle.com/javase/1.4.2/docs/api/java/text/SimpleDateFormat.html> SimpleDateFormat pattern string</a>. For fields of type "datetime" and "time" that specify an DataSourceField.sqlStorageStrategy','sqlStorageStrategy of "number", two special sqlDateFormat values are supported: "epoch" - The datetime or time value is stored as the number of full seconds that have elapsed since January 1, 1970, 00:00:00 GMT. "epochms" - The datetime or time value is stored as the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 GMT. Millisecond precision is preserved through database roundtrips with this setting This property and the "number" and "text" strategies for date/datetime fields are provided to allow transparent two-way mapping of legacy date values that are stored in numeric or text columns respectively rather than a true "date" column. You would not ordinarily use them in the absence of a legacy database. Note that this property only applies to users of SmartClient server and data sources of type "sql".
		 * Flags: IR */
		sqlDateFormat: string /* String */;

		/** For fields of type "boolean" that specify a DataSourceField.sqlStorageStrategy','sqlStorageStrategy of "singleChar", this is the value to persist for false values. Note that the common use cases of storing booleans as T/F, Y/N and 1/0 are already catered for without the need for this property. For fields of type "boolean" that specify a DataSourceField.sqlStorageStrategy','sqlStorageStrategy of "string", this is the value to persist for false values that require using the entire value.
		 * Flags: IR */
		sqlFalseValue: string /* String */;

		/** For certain field types, indicates the strategy to be used to store values to the underlying SQL column. Fields of type "boolean" The default strategy for boolean fields is to assume the underlying type of the field is text and store boolean true and false values as the character strings "true" and "false". The following additional strategies are available: "number" or "integer": store true as 1, false as 0 "singleChar10": store true as "1", false as "0" "singleCharYN": store true as "Y", false as "N" "singleCharTF": store true as "T", false as "F" "singleChar": store as a single character, using the values defined by DataSourceField.sqlTrueValue','sqlTrueValue and DataSourceField.sqlFalseValue','sqlFalseValue "string": store the entire values defined by DataSourceField.sqlTrueValue','sqlTrueValue and DataSourceField.sqlFalseValue','sqlFalseValue Fields of type "date", "time", and "datetime" The default strategy for these types is to use a native type that supports date and time values to the nearest second; the actual type used varies by database. The following additional strategies are available: "nativeDate": Use a native SQL DATE type "number" or "integer": Store the value as a plain numeric value "text": Store the value as a plain text value The "number" and "text" strategies for date/time/datetime fields are provided to allow transparent two-way mapping of legacy date values; you would not ordinarily use them in the absence of a legacy database. In both cases, the actual format of the number or text string is determined by specifying a DataSourceField.sqlDateFormat','sqlDateFormat on the field; if no format is specified, the framework defaults to "yyyyMMdd". Fields of type "text" <em>NOTE: This section is only applicable for users of Microsoft SQL Server. The "ntext" strategy is ignored for all other databases.</em> If you are integrating with Microsoft SQL Server, you may run into an issue with that database and double-byte character sets. Although the documentation indicates that string values are sent to the database as Unicode by default, they may undergo conversion at the database end, depending on the collation settings of the database. <a href=http://support.microsoft.com/kb/239530>This Microsoft support article</a> describes the situation, which is that Unicode is converted to the code page of the database before being used, in order to "provide backward compatibility with existing applications". To work around this, we provide an sqlStorageStrategy of "ntext". Fields that declare this strategy are inserted into queries using the "N syntax", like so: &nbsp;&nbsp;&nbsp;UPDATE MyTable SET MyTextColumn = N'some text' WHERE MyPK = N'some key' This syntax overrides defaults and forces the database to treat strings as Unicode. Note that declaring a field to be of FieldType','type "ntext" is exactly equivalent to specifying type "text" and an sqlStorageStrategy of "ntext". If you declare a field of type "ntext" when the back-end database is something other than SQL Server, it will be treated as a normal field of type "text". This property only applies to users of the SmartClient server using dataSources of type "sql".
		 * Flags: IR */
		sqlStorageStrategy: string /* String */;

		/** For fields of type "boolean" that specify a DataSourceField.sqlStorageStrategy','sqlStorageStrategy of "singleChar", this is the value to persist for true values. Note that the common use cases of storing booleans as T/F, Y/N and 1/0 are already catered for without the need for this property. For fields of type "boolean" that specify a DataSourceField.sqlStorageStrategy','sqlStorageStrategy of "string", this is the value to persist for true values that require using the entire value.
		 * Flags: IR */
		sqlTrueValue: string /* String */;

		/** For fields of type "datetime", indicates whether the framework should attempt to preserve the millisecond part when persisting to native SQL datetime-type columns. Whether this is possible depends on the type and version of the underlying database product; some databases - for example SQL Server earlier than 2008 and MySQL versions earlier than 5.6 - do not provide fractional seconds support. If you set this flag when your underlying database cannot support fractional seconds, it will be ignored. Other than the two cases just mentioned which are known to fail, storeMilliseconds has been tested and is officially supported with the following products and minimum versions: Oracle 10g Microsoft SQL Server 2008 MySQL 5.6 PostgreSQL 9.1 HSQLDB 2.2 DB2 for Unix/Linux 9.7 Firebird 11.2 Informix IDS 11.5 Note that you can use DataSourceField.sqlStorageStrategy','sqlStorageStrategy to store a datetime value with sub-second precision in <em>any</em> database - see below. When the system generates SQL to insert or update datetime values including a millisecond element, it does so using a database-specific format string specified in property defaultDateTimeFormatWithMilliseconds in your server.properties file. These format strings should conform to the rules of the <a href=http://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html> Java SimpleDateFormat class</a>. Suitable format strings are provided for all default databases out of the box; if you need to override one or provide a new one, you do so as shown in this example: sql.MyNewDatabase.defaultDateTimeFormatWithMilliseconds: yy-MM-dd'T'hh.mm.ss.SSS Note that this property only controls the persistence of milliseconds into the database; there is no built-in support for sub-second elements of datetimes in any SmartClient visual components. See also the documentation for DataSource.trimMilliseconds for more details of how sub-second datetime elements are handled in the client-server flow. This property is only applicable to DataSources of DSServerType','serverType "sql" and fields of FieldType','type "datetime". It is ignored in all other cases. However, note that the built-in JPA and Hibernate dataSources will always persist millisecond values automatically if the underlying Java type, database and column support it. Finally, note that this property only has an effect on <em>native</em> datetime-type fields. When you use DataSourceField.sqlStorageStrategy','sqlStorageStrategy to store a temporal value in a text or number column, it is the DataSourceField.sqlDateFormat','sqlDateFormat you use that dictates the precision. For example, a field with sqlStorageStrategy:"text" and sqlDateFormat:"yyyy-MM-dd hh:mm:ss.SSS" would store and retrieve with millisecond precsion; the same field with sqlDateFormat:"yyyy-MM-dd hh:mm" would store and retrieve with precision to the nearest minute only.
		 * Flags: IR */
		storeMilliseconds: boolean /* Boolean */;

		/** If set, causes the field to be securely hashed before saving on an "add" or "update" operation.
		 * Flags: IR */
		storeWithHash: HashAlgorithm;

		/** Server-side setting that causes values for fields of type "integer" or "float" to be represented as Strings when delivered to a web browser, in order to avoid mangling values which cannot be represented faithfully in JavaScript. JavaScript has a single "Number" type which internally stores numbers in a format equivalent to Java's "Double" - double-precision floating point. This means it cannot represent the full range of Java's Long type: Java Longs can represent integral values between -2^63 to 2^63-1, whereas JavaScript Number can only represent exact integer values between -2^53 and 2^53. Similarly, JavaScript's Number type cannot represent Java's unlimited-size BigInteger or unlimited-precision BigDecimal objects at all. The stringInBrowser setting can be used to deliver numeric values as Strings to the browser. This is intended to allow read-only display and successful round-tripping of the numeric value, however, it will not cause number-oriented features such as SpinnerItem, Slider, ListGrid.showGridSummary','ListGrid summaries or range-checking Validator','validators or AdvancedCriteria','criteria to actually work. If stringInBrowser is not set, the default behavior is configured by the server.properties setting datasource.defaultStringInBrowser. If this flag is false, numeric values are delivered to the client as numbers, even where this will lead to a loss of precision. If the flag is true (which is the the default), the behavior is to prevent range overflow for numeric values: Java values of type Long, BigInteger and BigDecimal will be delivered as String only if they exceed JavaScript's number range. Client-side validation will allow inputs that are outside of JavaScript's normal integer range, and such numbers will remain as Strings after validation, instead of being converted to Numbers Values submitted to the server will be converted to BigInteger if they exceed the range of Java's Long type. This happens during DSRequest validation, before any defined dmiOverview','DMI methods are called. This default set of behaviors is intended to automatically deal with cases like numeric DataSourceField.primaryKey or DataSourceField.foreignKey values that are never used as numbers, but happen to use the full Java Long range. To disable the above behaviors, set stringInBrowser="false". If stringInBrowser is explicitly set to true: the value for the field will always be delivered to the browser as a String (no attempt is made to detect the value as out of range / too high precision) client-side validation will do a check for valid format only, and always leave the value as a String. Numeric range validators are ignored client-side (always pass), but are still active server-side. AdvancedCriteria OperatorId','operators that check if values are in a particular range will always pass the field is treated as though DataSourceField.canFilter','canFilter:false were set, to avoid showing non-functional search interfaces to the user. Set canFilter="true" to avoid this effect This setting is recommended for presenting out-of-range issues or precision loss on fields that represent actual quantities (as opposed to primaryKey or foreignKey fields, which really represent IDs). To ensure unlimited-precision BigDecimal values are preserved, you should also set DataSourceField.javaClass. Note that responses delivered as JSON or XML, such as responses from the servletDetails','RESTHandler servlet, are not affected. This setting applies only to responses delivered to a web browser. The entirety of stringInBrowser processing can be completely disabled by setting server.properties flag datasource.disableStringInBrowser to true. This will cause all numeric values to be delivered as numbers without even attempting to detect if this will lead to a loss of precision. This setting overrides both the stringInBrowser field setting and the datasource.defaultStringInBrowser server.properties flag.
		 * Flags: IR */
		stringInBrowser: boolean /* Boolean */;

		/** If ListGrid.showGridSummary or ListGrid.showGroupSummary is true, this attribute can be used to specify an explicit SummaryFunction for calculating the summary value to display. If an array of summaryFunctions is specified, they will be executed in turn and the grid will show multiple summary rows at the grid or group level (or both) containing the resulting values.
		 * Flags: IR */
		summaryFunction: SummaryFunction;

		/** Title to show in a SummaryFunction','Summary of type "title" for this field. If unspecified title summaries will show the DataSourceField.title for the field.
		 * Flags: IR */
		summaryValueTitle: string /* String */;

		/** Only applicable to "sql" dataSources, setting tableName indicates that this field will be coming from another table by way of a customQuerying','customized SQL query. By default, the SQL generator will not include this field in generated SQL for "add" or "update" operations. It will include the field in the SELECT clause and WHERE clause of customized "fetch" operations, where it is expected that you will make the table available via a custom &lt;tableClause&gt; as shown in largeValueMapSQL', 'this sample. The table name will also be used to qualifying the column name unless DataSource.qualifyColumnNames or OperationBinding.qualifyColumnNames has been disabled. Note: This property is only required when including fields from tables other than the default table specified by DataSource.tableName.
		 * Flags: IR */
		tableName: string /* String */;

		/** Preferred time-format to apply to date type values within this field. If this property is specified on a field displayed within a dataBound component such as a ListGrid or DynamicForm, any dates displayed in this field will be formatted as times using the appropriate format. This is most commonly only applied to fields specified as type "time" though if no explicit FormItem.dateFormatter is specified it will be respected for other fields as well. See ListGridField.timeFormatter and FormItem.timeFormatter for more information.
		 * Flags: IRWA, Group: appearance */
		timeFormatter: TimeDisplayFormat;

		/** Default user-visible title for this field. This will be picked up by DataBound components and other views over this DataSource. Note this property frequently does not need to be set since DataSource.autoDeriveTitles (on by default) usually picks an appropriate user-visible title if you have a reasonable naming convention for your field names. Note that if this field is being displayed in a ListGrid bound to this dataSource, the ListGridField.headerTitle attribute may be used to specify a different string for display in the listGrid column header.
		 * Flags: IR, Group: componentBinding */
		title: string /* String */;

		/** Type of this field. Required for all DataSource fields. Field type may imply automatic validators (for example, an integer field cannot accept the value "foo"). Field type also affects the default behaviors of DataBound components, for example, if a field is declared as type "date", components that edit that field will automatically choose a date-editing interface with pop-up date picker.
		 * Flags: IR, Group: basics */
		type: FieldType;

		/** Indicates that the specified VelocityExpression must evaluate to true if updates to this field are to be allowed. If the specified expression does not evaluate to true, the field will be removed from the request as described for DataSourceField.editRequiresAuthentication','editRequiresAuthentication. In addition to the normal context variables available to Velocity expressions in SmartClient, expressions you write for field-level requires clauses - updateRequires, DataSourceField.viewRequires','viewRequires, DataSourceField.editRequires','editRequires and DataSourceField.initRequires','initRequires - can reference two additional variables: $fieldName and $dsName. These are the names of the dataSource and field currently undergoing requires checks. They are helpful because they allow you to write a generic checker function that can be used to handle requires checks for multiple fields and dataSources. NOTE: This property only prevents update of a field; initialization will still be allowed. You should only use this property if you have a special requirement; ordinarily, use DataSourceField.editRequires, which applies security for both types of write.
		 * Flags: IR, Group: fieldLevelAuth */
		updateRequires: string /* VelocityExpression */;

		/** Whether a user must be authenticated in order to update to this field. If this property is set and the user is not authenticated, the SmartClient Server will not allow this field to be updated.
		 * Flags: IR, Group: fieldLevelAuth */
		updateRequiresAuthentication: boolean;

		/** Comma-separated list of user roles that are allowed to update this field. If the current user does not have any of the roles listed, the system will not allow this field to be updated. NOTE: This property only prevents a field from being updated; initialization will still be allowed. You should only use this property if you have a special requirement; ordinarily, use DataSourceField.editRequiresRole, which applies security for both types of write.
		 * Flags: IR, Group: fieldLevelAuth */
		updateRequiresRole: string /* String */;

		/** Used by the BatchUploader to map a field in an upload file to this dataSourceField. This is only necessary if the dataSourceField's name and title differ from the name of the field in the upload file (SmartClient will automatically map upload fields using the dataSourceField's title, if possible, if it does not get a direct match on field name).
		 * Flags: IR */
		uploadFieldName: string /* String */;

		/** If this field has a specified DataSourceField.displayField, this attribute allows you to explicitly tell editor components to pick up the display-field value from the record currently being edited, rather than fetching against a specified FormItem.optionDataSource. See FormItem.useLocalDisplayFieldValue for more detail. Note that for the common pattern described DataSourceField.includeFrom','here of having an editable foreignKey field with a static display value (derived from a displayField with 'includeFrom' set), the framework will automatically default this property to true if not explicitly specified in the dataSource configuration file.
		 * Flags: IR */
		useLocalDisplayFieldValue: boolean /* Boolean */;

		/** Validators to be applied to this field. Validators are applied whenever there is an attempt to save changes to a field. For the available set of built-in validators, and how to define a custom validator, see the Validator class.
		 * Flags: IR, Group: dataType */
		validators: Array<Validator> /* Array of Validator */;

		/** List of operators valid on this field. If not specified, all operators that are valid for the field type are allowed.
		 * Flags: IR, Group: advancedFilter */
		validOperators: Array<OperatorId> /* Array of OperatorId */;

		/** A ValueMap is a set of legal values for a field. The valueMap can be specified as either an Array of legal values, or as an Object where each property maps a stored value to a user-displayable value. To enforce that a field should be constrained to only the values in the valueMap, either declare DataSourceField.type','field.type as "enum", or use a ValidatorType of "isOneOf" with explicitly listed values. Otherwise, although a normal SelectItem control will only allow values from the valueMap to be entered, other controls such as a ComboBoxItem','ComboBox will allow other values to be entered. In XML, a valueMap that specifies only a list of legal values is specified as follows: &lt;valueMap&gt; &lt;value&gt;Pens &amp; Pencils&lt;/value&gt; &lt;value&gt;Stationery&lt;/value&gt; &lt;value&gt;Computer Products&lt;/value&gt; &lt;value&gt;Furniture&lt;/value&gt; &lt;value&gt;Misc&lt;/value&gt; &lt;/valueMap&gt; A ValueMap that specifies stored values mapped to user-visible values is specified as follows: &lt;valueMap&gt; &lt;value ID="1"&gt;Pens &amp; Pencils&lt;/value&gt; &lt;value ID="2"&gt;Stationery&lt;/value&gt; &lt;value ID="3"&gt;Computer Products&lt;/value&gt; &lt;value ID="4"&gt;Furniture&lt;/value&gt; &lt;value ID="5"&gt;Misc&lt;/value&gt; &lt;/valueMap&gt; 
		 * Flags: IR, Group: dataType */
		valueMap: ValueMap;

		/** Fully qualified Java className of an Enum that should be used to derive this field's ValueMap. This has the same behavior of auto-deriving a valueMap from a Java Enum as DataSource.autoDeriveSchema except it applies only to one field. If you enable autoDeriveSchema there is no need to set valueMapEnum for Enum fields unless you want to actually override the behavior to use a different Enum for the field (eg, a superclass Enum that is more restrictive).
		 * Flags: IR */
		valueMapEnum: string /* String */;

		/** Alternative XPath expression used to set the field's value. If is not set, then DataSourceField.valueXPath','dataSourceField.valueXPath is used, see its description for details.
		 * Flags: IR, Group: clientDataIntegration */
		valueWriteXPath: string /* XPathExpression */;

		/** XPath expression used to retrieve the field's value. This XPath expression will be evaluated in the scope of the record objects selected by the DataSource.recordXPath. For XML data (DataSource.dataFormat','dataFormat:"xml") this means a call to XMLTools.selectString passing the selected XML element. For JSON data (DataSource.dataFormat','dataFormat:"json"), this means a call to XMLTools.selectObjects passing the selected JSON object. In the absence of a valueXPath, for JSON data the value for the field will be the value of the same-named property in the record object selected by DataSource.recordXPath','recordXPath. For XML data, the value will be the attribute or subelement named after the field name. For example, for a field "author" on a record element &lt;book&gt;, the following structures require no valueXPath: &lt;book author="Mark Jones"/&gt; &lt;book&gt; &lt;author&gt;Mark Jones&lt;/author&gt; &lt;/book&gt; If valueXPath is not required for your field because of the default handling described above, don't specify it, as it's slightly slower. To learn about XPath, try the following search: <a href="http://www.google.com/search?q=xpath+tutorial" target="_blank" >http://www.google.com/search?q=xpath+tutorial</a> Using valueXPath with the SmartClient server If you're using the SmartClient server to return data via the DSResponse object (or indirectly doing so using DataSource DMI), the valueXPath you specify on the DataSource fields will be applied to the data you return via the <a href='http://commons.apache.org/jxpath/' target='_blank'>JXPath</a> library. If you are returning Java Beans as your DSResponse data, normally each dataSource field receives the value of the same-named Java Bean property, that is, a field "zipCode" is populated by looking for "getZipCode()" on the objects passed as DSResponse data. You can use valueXPath to retrieve properties from subobjects, so long as a chain of getter methods exists that corresponds to the valueXPath. For example, a valueXPath of "address/zipCode" expects to call "getAddress()" on the bean(s) passed to DSResponse.setData(), followed by "getZipCode()" on whatever object "getAddress()" returns. When you are saving data, the inbound DSRequest values, available as a Java Map, will use just dataSource field names as Map keys, not the valueXPath used to derive them. However, to achieve bidirectional valueXPath binding, you can use the server-side method dataSource.setProperties() to use the valueXPath when setting properties on your server object model. When applied as a setter, an XPath like "address/zipCode" attempts "getAddress()" followed by "setZipCode()" on the returned object. JXPath also has some ability to auto-create intervening objects if they are missing, such as auto-creating an "address" subobject when applying "address/zipCode" as a valueXPath. See the <a href='http://jakarta.apache.org/commons/jxpath/' target='_blank'>JXPath</a> library documentation for complete details, including other types of server object models supported, such as server-side XML.
		 * Flags: IR, Group: clientDataIntegration */
		valueXPath: string /* XPathExpression */;

		/** Indicates that the specified VelocityExpression must evaluate to true if values for the field are to be fetched. If the specified expression does not evaluate to true, the field will be dropped as described for DataSourceField.viewRequiresAuthentication','viewRequiresAuthentication. In addition to the normal context variables available to Velocity expressions in SmartClient, expressions you write for field-level requires clauses - viewRequires, DataSourceField.editRequires','editRequires, DataSourceField.initRequires','initRequires and DataSourceField.updateRequires','updateRequires - can reference two additional variables: $fieldName and $dsName. These are the names of the dataSource and field currently undergoing requires checks. They are helpful because they allow you to write a generic checker function that can be used to handle requires checks for multiple fields and dataSources.
		 * Flags: IR, Group: fieldLevelAuth */
		viewRequires: string /* VelocityExpression */;

		/** Whether a user must be authenticated in order to fetch this field. If this property is set and the user is not authenticated, SmartClient Server will not return values for this field to the client. The way this behavior works is to remove the field from the expressed or implied list of fields to return. A list of fields can be expressed using OperationBinding.outputs or DSRequest.outputs; in the absence of those, the entire set of fields defined in the DataSource is implied. You can override this behavior on a per-request basis by providing a DMI that just re-adds the names of the fields you want for that particular request to the "consolidated outputs". See the server-side Javadoc for DSRequest.getConsolidatedOutputs(). In addition to this behavior of trimming off values in fetched records, a field that fails a field-level security check (either this one or one of the two more specific checks, DataSourceField.viewRequiresRole','viewRequiresRole and DataSourceField.viewRequires','viewRequires) will be altered in the version of the dataSource returned to the client by the loadDSTag','&lt;loadDS&gt; JSP tag or dataSourceDeclaration','DataSourceLoader servlet. If the field is also not editable (see the discussion of this below), it will be marked DataSourceField.canView','canView:false, and thus effectively be inert and unusable on the client If the field is editable, it will be marked DataSourceField.hidden','hidden. By default, this means that DataBoundComponents will not show the field, though this can be overridden for individual components. If you do choose to unhide the field, bear in mind that it will never actually show any data, because the underlying security test has still failed By default, view constraints automatically imply edit constraints - almost all of the time, if a user is not allowed to view a field, he should not be allowed to update it either. If you specify a view constraint, the system behaves as if you had also specified the corresponding edit constraint - so viewRequiresAuthentication on a field implies DataSourceField.editRequiresAuthentication','editRequiresAuthentication. You override this behavior simply by specifying some kind of edit constraint for the field, either a different one (eg, "users" can view a field, but only "managers" can update it) or a blank one (if you have some unusual requirement whereby users are not allowed to view a field, but they can update it).
		 * Flags: IR, Group: fieldLevelAuth */
		viewRequiresAuthentication: boolean;

		/** Comma-separated list of user roles that are allowed to fetch this field. If the current user has any of the roles listed, values for the field will be fetched. Please see OperationBinding.requiresRole for further details of SmartClient's declarative role-based security. Please also see DataSourceField.viewRequiresAuthentication','viewRequiresAuthentication for details of how declarative field-level security settings can be overridden per-request.
		 * Flags: IR, Group: fieldLevelAuth */
		viewRequiresRole: string /* String */;

		/** Indicates that DataSource.xmlSerialize should serialize this value as an XML attribute. Note this does not need to be declared in order for DataSource records to be derived from XML data: a field will be populated with either an attribute or subelement with matching name.
		 * Flags: IR, Group: xmlSerialize */
		xmlAttribute: boolean;


		/* Instance Method Overrides */

	} // DataSourceField

	export interface DataSourceFieldStatic<T, P> extends ClassStatic<T, P> {
	} // DataSourceFieldStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a DetailViewer Props argument.
	 * This is derived from the methods in the DetailViewer class and it's parents and their properties marked with the I flag.
	 */
	export interface DetailViewerProps extends CanvasProps {
		/** If true, when this component is first drawn, automatically call this.fetchData(). Criteria for this fetch may be picked up from DetailViewer.initialCriteria, and textMatchStyle may be specified via ListGrid.autoFetchTextMatchStyle','autoFetchTextMatchStyle. <span style='color:red'>NOTE:</span> if autoFetchData is set, calling ListGrid.fetchData','fetchData() before draw will cause two requests to be issued, one from the manual call to fetchData() and one from the autoFetchData setting. The second request will use only DetailViewer.initialCriteria and not any other criteria or settings from the first request. Generally, turn off autoFetchData if you are going to manually call ListGrid.fetchData','fetchData() at any time.
		 * Flags: IR, Group: databinding */
		autoFetchData?: boolean; // Flags=IR
		/** A string (HTML acceptable) that will be written to a page to separate blocks.
		 * Flags: IRW, Group: appearance */
		blockSeparator?: string /* HTMLString */; // Flags=IRW
		/** CSS style for each block (one record's worth of data).
		 * Flags: IRW, Group: appearance */
		blockStyle?: string /* CSSStyleName */; // Flags=IRW
		/** If set, right-clicking on the DetailViewer will show a context menu that offers to bring up a FieldPicker for configuring which fields are displayed and their order.
		 * Flags: IR */
		canPickFields?: boolean /* Boolean */; // Flags=IR
		/** CSS style for a normal value
		 * Flags: IRW, Group: appearance */
		cellStyle?: string /* CSSStyleName */; // Flags=IRW
		/** The title for the Configure Fields menu item.
		 * Flags: IR, Group: i18nMessages */
		configureFieldsText?: string /* String */; // Flags=IR
		/** A single record object or an array of them, specifying data. Note that DetailViewers do not observe changes to the data array (in other words they will not automatically re-draw when the data provided via this property is altered).
		 * Flags: IRW, Group: basics */
		data?: Array<any> /* Array[] of DetailViewerRecord | Array[] of Record | RecordList */; // Flags=IRW
		/** DetailViewers do not yet support paging, and will fetch and render all available records.
		 * Flags: IRW, Group: databinding */
		dataFetchMode?: FetchMode; // Flags=IRW
		/** The DataSource that this component should bind to for default fields and for performing DSRequest','DataSource requests. Can be specified as either a DataSource instance or the String ID of a DataSource.
		 * Flags: IRW, Group: databinding */
		dataSource?: DataSource | string /* DataSource or ID */; // Flags=IRW
		/** How should Date type values be displayed in this DetailViewer by default? This property specifies the default DateDisplayFormat to apply to Date values displayed in this grid for all fields except those of DetailViewerField.type','type "time" (See also DetailViewer.timeFormatter). If DetailViewer.datetimeFormatter is specified, that will be applied by default to fields of type "datetime". Note that if DetailViewerField.dateFormatter or DetailViewerField.timeFormatter are specified those properties will take precedence over the component level settings. If unset, date values will be formatted according to the system wide DateUtil.setNormalDisplayFormat','normal display format.
		 * Flags: IRW */
		dateFormatter?: DateDisplayFormat; // Flags=IRW
		/** Display format to use for fields specified as type 'datetime'. Default is to use the system-wide default long ("normal") date time format, configured via DateUtil.setNormalDatetimeDisplayFormat. Specify any valid DateDisplayFormat to change the display format for datetimes used by this viewer. May be specified as a function. If specified as a function, this function will be executed in the scope of the Date and should return the formatted string. May also be specified at the field level via DetailViewerField.dateFormatter
		 * Flags: IRW, Group: appearance */
		datetimeFormatter?: DateDisplayFormat; // Flags=IRW
		/** Default class used to construct the EditProxy for this component when the component is Canvas.setEditMode','first placed into edit mode.
		 * Flags: IR */
		editProxyConstructor?: string /* SCClassName */; // Flags=IR
		/** Text to show for an empty cell
		 * Flags: IRWA, Group: appearance */
		emptyCellValue?: string /* HTMLString */; // Flags=IRWA
		/** The string to display in the body of a detailViewer with no records.
		 * Flags: IRW, Group: emptyMessage */
		emptyMessage?: string /* HTMLString */; // Flags=IRW
		/** CSS style to display this message in
		 * Flags: IRWA, Group: emptyMessage */
		emptyMessageStyle?: string /* CSSStyleName */; // Flags=IRWA
		/** Name of the field in the DetailViewerRecord which specifies the data property for that record.
		 * Flags: IRWA */
		fieldIdProperty?: string; // Flags=IRWA
		/** Names of properties on DetailViewerField for which the FieldPicker should show an editing interface, for convenience. For example, specify ["decimalPad", "decimalPrecision"] to allow end users to modify DetailViewerField.decimalPad and DetailViewerField.decimalPrecision respectively.
		 * Flags: IR */
		fieldPickerFieldProperties?: Array<string> /* Array of String */; // Flags=IR
		/** Instance of FieldPickerWindow used if DetailViewer.canPickFields is set.
		 * Flags: IR */
		fieldPickerWindow?:  FieldPickerWindow /* AutoChild FieldPickerWindow */; // Flags=IR
		/** An array of field objects, specifying the order and type of fields to display in this DetailViewer. In DetailViewers, the fields specify rows.
		 * Flags: IRW */
		fields?: Array<DetailViewerField> /* Array of DetailViewerField */; // Flags=IRW
		/** CSS style for a header
		 * Flags: IRW, Group: appearance */
		headerStyle?: string /* CSSStyleName */; // Flags=IRW
		/** Height for hilite icons for this listGrid. Overrides DetailViewer.hiliteIconSize','hiliteIconSize. Can be overridden at the field level
		 * Flags: IRW, Group: hiliting */
		hiliteIconHeight?: number; // Flags=IRW
		/** How much padding should there be on the left of DetailViewer.hiliteIcons','hilite icons by default? Can be overridden at the field level
		 * Flags: IRW, Group: hiliting */
		hiliteIconLeftPadding?: number; // Flags=IRW
		/** When DetailViewer.hiliteIcons','hiliteIcons are present, where the hilite icon will be placed relative to the field value. See HiliteIconPosition. Can be overridden at the field level.
		 * Flags: IR, Group: hiliting */
		hiliteIconPosition?: HiliteIconPosition; // Flags=IR
		/** How much padding should there be on the right of DetailViewer.hiliteIcons','hilite icons by default? Can be overridden at the field level
		 * Flags: IRW, Group: hiliting */
		hiliteIconRightPadding?: number; // Flags=IRW
		/** Specifies a list of icons that can be used in DataBoundComponent.editHilites','hilites. hiliteIcons should be specified as an Array of SCImgURL. When present, the hilite editing interface shown when DataBoundComponent.editHilites is called will offer the user a drop down for picking one of these icons when defining either a simple or advanced hilite rule. If the user picks an icon, the created hiliting rule will have Hilite.icon set to the chosen icon. DataBoundComponent.hiliteIconPosition controls where the icon will appear for that field -- the default is that it appears in front of the normal cell content. This can also be overridden at the field level.
		 * Flags: IR, Group: hiliting */
		hiliteIcons?: Array<string> /* Array of String */; // Flags=IR
		/** Default width and height of DetailViewer.hiliteIcons','hilite icons for this component. Can be overridden at the component level via explicit DetailViewer.hiliteIconWidth','hiliteIconWidth and DetailViewer.hiliteIconHeight','hiliteIconHeight, or at the field level via ListGridField.hiliteIconSize','hiliteIconSize, ListGridField.hiliteIconWidth','hiliteIconWidth and ListGridField.hiliteIconHeight','hiliteIconHeight
		 * Flags: IRW, Group: hiliting */
		hiliteIconSize?: number; // Flags=IRW
		/** Width for hilite icons for this component. Overrides DetailViewer.hiliteIconSize','hiliteIconSize. Can be overridden at the field level.
		 * Flags: IRW, Group: hiliting */
		hiliteIconWidth?: number; // Flags=IRW
		/** Criteria to be used when DetailViewer.autoFetchData is set. This property supports dynamicCriteria - use Criterion.valuePath to refer to values in the Canvas.ruleScope.
		 * Flags: IR, Group: searchCriteria */
		initialCriteria?: Criteria; // Flags=IR
		/** Horizontal alignment of value-labels in this viewer. If unspecified, defaults to "left" when in RTL mode and "right" otherwise.
		 * Flags: IRW, Group: labels */
		labelAlign?: Alignment; // Flags=IRW
		/** text to put before a label
		 * Flags: IRW, Group: labels */
		labelPrefix?: string /* HTMLString */; // Flags=IRW
		/** CSS style for a normal detail label
		 * Flags: IRW, Group: appearance */
		labelStyle?: string /* CSSStyleName */; // Flags=IRW
		/** text to put after a label
		 * Flags: IRW, Group: labels */
		labelSuffix?: string /* HTMLString */; // Flags=IRW
		/** Property name on a record that will hold the link text for that record. This property is configurable to avoid possible collision with data values in the record. Use DetailViewerField.linkTextProperty if you have more than one link field and the fields' records do not use the same property to store the linkText.
		 * Flags: IRW */
		linkTextProperty?: string; // Flags=IRW
		/** The string to display in the body of a detailViewer which is loading records. Use "&#36;{loadingImage}" to include Canvas.loadingImageSrc','a loading image.
		 * Flags: IRW, Group: emptyMessage */
		loadingMessage?: string /* HTMLString */; // Flags=IRW
		/** CSS style to use for the DetailViewer.loadingMessage.
		 * Flags: IRWA, Group: emptyMessage */
		loadingMessageStyle?: string /* CSSStyleName */; // Flags=IRWA
		/** Optional CSS style for a cell in printable HTML for this component. If unset DetailViewer.cellStyle will be used for printing as well as normal presentation.
		 * Flags: IRW, Group: printing */
		printCellStyle?: string /* CSSStyleName */; // Flags=IRW
		/** Optional CSS style for a header in printable HTML for this component. If unset DetailViewer.headerStyle will be used for printing as well as normal presentation.
		 * Flags: IRW, Group: printing */
		printHeaderStyle?: string /* CSSStyleName */; // Flags=IRW
		/** Optional CSS style for a label cell in printable HTML for this component. If unset DetailViewer.labelStyle will be used for printing as well as normal presentation.
		 * Flags: IRW, Group: printing */
		printLabelStyle?: string /* CSSStyleName */; // Flags=IRW
		/** The number of records to display in a block. A block is a horizontal row on a page containing one or more records, as specified by the value of recordsPerBlock. The height of a block is equal to the height of a single record. The default setting of 1 causes each record to appear by itself in a vertical row. Setting recordsPerBlock to 2 would cause records to appear side by side in groups of two. Use a value of "*" to indicate all records.
		 * Flags: IRW, Group: appearance */
		recordsPerBlock?: number; // Flags=IRW
		/** Height of rows rendered by the DetailViewer. Acts as a minimum - the DetailViewer never clips values. This attribute can be set as null.
		 * Flags: IRW */
		rowHeight?: number /* int */; // Flags=IRW
		/** CSS style for a separator
		 * Flags: IRW, Group: appearance */
		separatorStyle?: string /* CSSStyleName */; // Flags=IRW
		/** Whether to show fields marked detail:true when a DataBoundComponent is given a DataSource but no component.fields. The detail property is used on DataSource fields to mark fields that shouldn't appear by default in a view that tries to show many records in a small space.
		 * Flags: IR, Group: databinding */
		showDetailFields?: boolean /* Boolean */; // Flags=IR
		/** Whether to show the field when the value is null
		 * Flags: IRWA, Group: appearance */
		showEmptyField?: boolean /* Boolean */; // Flags=IRWA
		/** Show DetailViewer.emptyMessage when there is no data to display?
		 * Flags: IRWA, Group: emptyMessage */
		showEmptyMessage?: boolean /* Boolean */; // Flags=IRWA
		/** CSS style for the component as a whole.
		 * Flags: IRW, Group: appearance */
		styleName?: string /* CSSStyleName */; // Flags=IRW
		/** Display format to use for fields specified as type 'time'. May also be specified at the field level via DetailViewerField.timeFormatter. If unset, time fields will be formatted based on the system wide Time.setNormalDisplayFormat
		 * Flags: IRW, Group: appearance */
		timeFormatter?: TimeDisplayFormat; // Flags=IRW
		/** Horizontal alignment of values in this viewer. If unspecified, defaults to "right" when in RTL mode and "left" otherwise.
		 * Flags: IRW, Group: values */
		valueAlign?: Alignment; // Flags=IRW
		/** Should the label be allowed to wrap, or be fixed to one line no matter how long
		 * Flags: IRW, Group: labels */
		wrapLabel?: boolean /* Boolean */; // Flags=IRW
		/** Whether values should be allowed to wrap by default, or should be shown on one line regardless of length.
		 * Flags: IR, Group: labels */
		wrapValues?: boolean /* Boolean */; // Flags=IR

		/* Method Overrides */

		/** 
		 * Return CSS text for styling this cell, which will be applied in addition to the CSS class for the cell, as overrides. "CSS text" means semicolon-separated style settings, suitable for inclusion in a CSS stylesheet or in a STYLE attribute of an HTML element.
		 * @param {any} value - actual value of this cell
		 * @param {DetailViewerField} field - field object for this cell
		 * @param {any} record - record object for this cell
		 * @param {DetailViewer} viewer - the viewer instance to which this cell belongs
		 */
		getCellCSSText?(value:any, field:DetailViewerField, record:any /* Record */, viewer:DetailViewer): string /* CSSText */; 

		/** 
		 * Returns a snapshot of the current view state of this DetailViewer. This includes the field, sort and hilite state of the grid, returned as a DetailViewerViewState object. This object can be passed to DetailViewer.setViewState to reset this detail viewer's view state to the current state (assuming the same data / fields are present in the detail viewer).
		 */
		getViewState?(): string /* DetailViewerViewState */; 

		/** 
		 * Reset this detail viewer's view state to match the DetailViewerViewState object passed in. Used to restore previous state retrieved from the detail viewer by a call to DetailViewer.getViewState.
		 * @param {string} viewState - Object describing the desired view state for the detail viewer
		 */
		setViewState?(viewState:string /* DetailViewerViewState */): void; 

	} // DetailViewerProps


	/**
	 * Displays one or more records "horizontally" with one property per line. 
	 */
	export interface DetailViewer extends Canvas {
		/** If true, when this component is first drawn, automatically call this.fetchData(). Criteria for this fetch may be picked up from DetailViewer.initialCriteria, and textMatchStyle may be specified via ListGrid.autoFetchTextMatchStyle','autoFetchTextMatchStyle. <span style='color:red'>NOTE:</span> if autoFetchData is set, calling ListGrid.fetchData','fetchData() before draw will cause two requests to be issued, one from the manual call to fetchData() and one from the autoFetchData setting. The second request will use only DetailViewer.initialCriteria and not any other criteria or settings from the first request. Generally, turn off autoFetchData if you are going to manually call ListGrid.fetchData','fetchData() at any time.
		 * Flags: IR, Group: databinding */
		autoFetchData: boolean;

		/** A string (HTML acceptable) that will be written to a page to separate blocks.
		 * Flags: IRW, Group: appearance */
		blockSeparator: string /* HTMLString */;

		/** CSS style for each block (one record's worth of data).
		 * Flags: IRW, Group: appearance */
		blockStyle: string /* CSSStyleName */;

		/** If set, right-clicking on the DetailViewer will show a context menu that offers to bring up a FieldPicker for configuring which fields are displayed and their order.
		 * Flags: IR */
		canPickFields: boolean /* Boolean */;

		/** CSS style for a normal value
		 * Flags: IRW, Group: appearance */
		cellStyle: string /* CSSStyleName */;

		/** The title for the Configure Fields menu item.
		 * Flags: IR, Group: i18nMessages */
		configureFieldsText: string /* String */;

		/** A single record object or an array of them, specifying data. Note that DetailViewers do not observe changes to the data array (in other words they will not automatically re-draw when the data provided via this property is altered).
		 * Flags: IRW, Group: basics */
		data: Array<any> /* Array[] of DetailViewerRecord | Array[] of Record | RecordList */;

		/** DetailViewers do not yet support paging, and will fetch and render all available records.
		 * Flags: IRW, Group: databinding */
		dataFetchMode: FetchMode;

		/** The DataSource that this component should bind to for default fields and for performing DSRequest','DataSource requests. Can be specified as either a DataSource instance or the String ID of a DataSource.
		 * Flags: IRW, Group: databinding */
		dataSource: DataSource | string /* DataSource or ID */;

		/** How should Date type values be displayed in this DetailViewer by default? This property specifies the default DateDisplayFormat to apply to Date values displayed in this grid for all fields except those of DetailViewerField.type','type "time" (See also DetailViewer.timeFormatter). If DetailViewer.datetimeFormatter is specified, that will be applied by default to fields of type "datetime". Note that if DetailViewerField.dateFormatter or DetailViewerField.timeFormatter are specified those properties will take precedence over the component level settings. If unset, date values will be formatted according to the system wide DateUtil.setNormalDisplayFormat','normal display format.
		 * Flags: IRW */
		dateFormatter: DateDisplayFormat;

		/** Display format to use for fields specified as type 'datetime'. Default is to use the system-wide default long ("normal") date time format, configured via DateUtil.setNormalDatetimeDisplayFormat. Specify any valid DateDisplayFormat to change the display format for datetimes used by this viewer. May be specified as a function. If specified as a function, this function will be executed in the scope of the Date and should return the formatted string. May also be specified at the field level via DetailViewerField.dateFormatter
		 * Flags: IRW, Group: appearance */
		datetimeFormatter: DateDisplayFormat;

		/** Default class used to construct the EditProxy for this component when the component is Canvas.setEditMode','first placed into edit mode.
		 * Flags: IR */
		editProxyConstructor: string /* SCClassName */;

		/** Text to show for an empty cell
		 * Flags: IRWA, Group: appearance */
		emptyCellValue: string /* HTMLString */;

		/** The string to display in the body of a detailViewer with no records.
		 * Flags: IRW, Group: emptyMessage */
		emptyMessage: string /* HTMLString */;

		/** CSS style to display this message in
		 * Flags: IRWA, Group: emptyMessage */
		emptyMessageStyle: string /* CSSStyleName */;

		/** Name of the field in the DetailViewerRecord which specifies the data property for that record.
		 * Flags: IRWA */
		fieldIdProperty: string;

		/** Names of properties on DetailViewerField for which the FieldPicker should show an editing interface, for convenience. For example, specify ["decimalPad", "decimalPrecision"] to allow end users to modify DetailViewerField.decimalPad and DetailViewerField.decimalPrecision respectively.
		 * Flags: IR */
		fieldPickerFieldProperties: Array<string> /* Array of String */;

		/** Instance of FieldPickerWindow used if DetailViewer.canPickFields is set.
		 * Flags: IR */
		fieldPickerWindow:  FieldPickerWindow /* AutoChild FieldPickerWindow */;

		/** An array of field objects, specifying the order and type of fields to display in this DetailViewer. In DetailViewers, the fields specify rows.
		 * Flags: IRW */
		fields: Array<DetailViewerField> /* Array of DetailViewerField */;

		/** CSS style for a header
		 * Flags: IRW, Group: appearance */
		headerStyle: string /* CSSStyleName */;

		/** Height for hilite icons for this listGrid. Overrides DetailViewer.hiliteIconSize','hiliteIconSize. Can be overridden at the field level
		 * Flags: IRW, Group: hiliting */
		hiliteIconHeight: number;

		/** How much padding should there be on the left of DetailViewer.hiliteIcons','hilite icons by default? Can be overridden at the field level
		 * Flags: IRW, Group: hiliting */
		hiliteIconLeftPadding: number;

		/** When DetailViewer.hiliteIcons','hiliteIcons are present, where the hilite icon will be placed relative to the field value. See HiliteIconPosition. Can be overridden at the field level.
		 * Flags: IR, Group: hiliting */
		hiliteIconPosition: HiliteIconPosition;

		/** How much padding should there be on the right of DetailViewer.hiliteIcons','hilite icons by default? Can be overridden at the field level
		 * Flags: IRW, Group: hiliting */
		hiliteIconRightPadding: number;

		/** Specifies a list of icons that can be used in DataBoundComponent.editHilites','hilites. hiliteIcons should be specified as an Array of SCImgURL. When present, the hilite editing interface shown when DataBoundComponent.editHilites is called will offer the user a drop down for picking one of these icons when defining either a simple or advanced hilite rule. If the user picks an icon, the created hiliting rule will have Hilite.icon set to the chosen icon. DataBoundComponent.hiliteIconPosition controls where the icon will appear for that field -- the default is that it appears in front of the normal cell content. This can also be overridden at the field level.
		 * Flags: IR, Group: hiliting */
		hiliteIcons: Array<string> /* Array of String */;

		/** Default width and height of DetailViewer.hiliteIcons','hilite icons for this component. Can be overridden at the component level via explicit DetailViewer.hiliteIconWidth','hiliteIconWidth and DetailViewer.hiliteIconHeight','hiliteIconHeight, or at the field level via ListGridField.hiliteIconSize','hiliteIconSize, ListGridField.hiliteIconWidth','hiliteIconWidth and ListGridField.hiliteIconHeight','hiliteIconHeight
		 * Flags: IRW, Group: hiliting */
		hiliteIconSize: number;

		/** Width for hilite icons for this component. Overrides DetailViewer.hiliteIconSize','hiliteIconSize. Can be overridden at the field level.
		 * Flags: IRW, Group: hiliting */
		hiliteIconWidth: number;

		/** Criteria to be used when DetailViewer.autoFetchData is set. This property supports dynamicCriteria - use Criterion.valuePath to refer to values in the Canvas.ruleScope.
		 * Flags: IR, Group: searchCriteria */
		initialCriteria: Criteria;

		/** Horizontal alignment of value-labels in this viewer. If unspecified, defaults to "left" when in RTL mode and "right" otherwise.
		 * Flags: IRW, Group: labels */
		labelAlign: Alignment;

		/** text to put before a label
		 * Flags: IRW, Group: labels */
		labelPrefix: string /* HTMLString */;

		/** CSS style for a normal detail label
		 * Flags: IRW, Group: appearance */
		labelStyle: string /* CSSStyleName */;

		/** text to put after a label
		 * Flags: IRW, Group: labels */
		labelSuffix: string /* HTMLString */;

		/** Property name on a record that will hold the link text for that record. This property is configurable to avoid possible collision with data values in the record. Use DetailViewerField.linkTextProperty if you have more than one link field and the fields' records do not use the same property to store the linkText.
		 * Flags: IRW */
		linkTextProperty: string;

		/** The string to display in the body of a detailViewer which is loading records. Use "&#36;{loadingImage}" to include Canvas.loadingImageSrc','a loading image.
		 * Flags: IRW, Group: emptyMessage */
		loadingMessage: string /* HTMLString */;

		/** CSS style to use for the DetailViewer.loadingMessage.
		 * Flags: IRWA, Group: emptyMessage */
		loadingMessageStyle: string /* CSSStyleName */;

		/** Optional CSS style for a cell in printable HTML for this component. If unset DetailViewer.cellStyle will be used for printing as well as normal presentation.
		 * Flags: IRW, Group: printing */
		printCellStyle: string /* CSSStyleName */;

		/** Optional CSS style for a header in printable HTML for this component. If unset DetailViewer.headerStyle will be used for printing as well as normal presentation.
		 * Flags: IRW, Group: printing */
		printHeaderStyle: string /* CSSStyleName */;

		/** Optional CSS style for a label cell in printable HTML for this component. If unset DetailViewer.labelStyle will be used for printing as well as normal presentation.
		 * Flags: IRW, Group: printing */
		printLabelStyle: string /* CSSStyleName */;

		/** The number of records to display in a block. A block is a horizontal row on a page containing one or more records, as specified by the value of recordsPerBlock. The height of a block is equal to the height of a single record. The default setting of 1 causes each record to appear by itself in a vertical row. Setting recordsPerBlock to 2 would cause records to appear side by side in groups of two. Use a value of "*" to indicate all records.
		 * Flags: IRW, Group: appearance */
		recordsPerBlock: number;

		/** Height of rows rendered by the DetailViewer. Acts as a minimum - the DetailViewer never clips values. This attribute can be set as null.
		 * Flags: IRW */
		rowHeight: number /* int */;

		/** CSS style for a separator
		 * Flags: IRW, Group: appearance */
		separatorStyle: string /* CSSStyleName */;

		/** Whether to show fields marked detail:true when a DataBoundComponent is given a DataSource but no component.fields. The detail property is used on DataSource fields to mark fields that shouldn't appear by default in a view that tries to show many records in a small space.
		 * Flags: IR, Group: databinding */
		showDetailFields: boolean /* Boolean */;

		/** Whether to show the field when the value is null
		 * Flags: IRWA, Group: appearance */
		showEmptyField: boolean /* Boolean */;

		/** Show DetailViewer.emptyMessage when there is no data to display?
		 * Flags: IRWA, Group: emptyMessage */
		showEmptyMessage: boolean /* Boolean */;

		/** CSS style for the component as a whole.
		 * Flags: IRW, Group: appearance */
		styleName: string /* CSSStyleName */;

		/** Display format to use for fields specified as type 'time'. May also be specified at the field level via DetailViewerField.timeFormatter. If unset, time fields will be formatted based on the system wide Time.setNormalDisplayFormat
		 * Flags: IRW, Group: appearance */
		timeFormatter: TimeDisplayFormat;

		/** Horizontal alignment of values in this viewer. If unspecified, defaults to "right" when in RTL mode and "left" otherwise.
		 * Flags: IRW, Group: values */
		valueAlign: Alignment;

		/** Should the label be allowed to wrap, or be fixed to one line no matter how long
		 * Flags: IRW, Group: labels */
		wrapLabel: boolean /* Boolean */;

		/** Whether values should be allowed to wrap by default, or should be shown on one line regardless of length.
		 * Flags: IR, Group: labels */
		wrapValues: boolean /* Boolean */;


		/* Instance Method Overrides */

		/** 
		 * Return CSS text for styling this cell, which will be applied in addition to the CSS class for the cell, as overrides. "CSS text" means semicolon-separated style settings, suitable for inclusion in a CSS stylesheet or in a STYLE attribute of an HTML element.
		 * @param {any} value - actual value of this cell
		 * @param {DetailViewerField} field - field object for this cell
		 * @param {any} record - record object for this cell
		 * @param {DetailViewer} viewer - the viewer instance to which this cell belongs
		 */
		getCellCSSText?(value:any, field:DetailViewerField, record:any /* Record */, viewer:DetailViewer): string /* CSSText */; 

		/** 
		 * Returns a snapshot of the current view state of this DetailViewer. This includes the field, sort and hilite state of the grid, returned as a DetailViewerViewState object. This object can be passed to DetailViewer.setViewState to reset this detail viewer's view state to the current state (assuming the same data / fields are present in the detail viewer).
		 */
		getViewState?(): string /* DetailViewerViewState */; 

		/** 
		 * Reset this detail viewer's view state to match the DetailViewerViewState object passed in. Used to restore previous state retrieved from the detail viewer by a call to DetailViewer.getViewState.
		 * @param {string} viewState - Object describing the desired view state for the detail viewer
		 */
		setViewState?(viewState:string /* DetailViewerViewState */): void; 

	} // DetailViewer

	export interface DetailViewerStatic<T, P> extends CanvasStatic<T, P> {
	} // DetailViewerStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a Dialog Props argument.
	 * This is derived from the methods in the Dialog class and it's parents and their properties marked with the I flag.
	 */
	export interface DialogProps extends WindowProps {
		/** Icon to show in the isc.ask dialog.
		 * Flags: IR */
		askIcon?: string /* SCImgURL */; // Flags=IR
		/** If a toolbar is showing, automatically place keyboard focus in the first button.
		 * Flags: IR, Group: appearance */
		autoFocus?: boolean /* Boolean */; // Flags=IR
		/** Array of Buttons to show in the Dialog.showToolbar','toolbar, if shown. The set of buttons to use is typically set by calling one of the shortcuts such as isc.say or isc.confirm. A custom set of buttons can be passed to these shortcuts methods via the "properties" argument, or to a directly created Dialog. In both cases, a mixture of DialogButtons','built-in buttons, custom buttons, and other components (such as a LayoutSpacer) can be passed. Built-in buttons can be referred to as isc.Dialog.OK, for example: isc.Dialog.create({ buttons:[ isc.Dialog.OK, isc.Dialog.CANCEL, isc.LayoutSpacer.create({width:50}), { title:"Not now", click:"doSomething()" } ] }) Built-in buttons will call standard methods on the Dialog itself, such as Dialog.cancelClick, as explained in the DialogButtons','list of built-in buttons. 
		 * Flags: IR */
		buttons?: Array<Button> /* Array of Button or Button Properties */; // Flags=IR
		/** Icon to show in the isc.confirm dialog.
		 * Flags: IR */
		confirmIcon?: string /* SCImgURL */; // Flags=IR
		defaultWidth?: number /* int */; // Flags=IR
		/** Icon to show in this dialog - see Dialog.message.
		 * Flags: IR */
		icon?: string /* SCImgURL */; // Flags=IR
		/** Size of the icon to show in this dialog.
		 * Flags: IR */
		iconSize?: number /* int */; // Flags=IR
		/** Message to show in this dialog. If a message is set the primary purpose of the dialog will be assumed to be to show a message with buttons - auto-sizing to the message text will be enabled, and, if Dialog.icon has also been set, the Dialog.messageLabel','messageLabel and Dialog.messageIcon','messageIcon AutoChildren will be created and placed together in the Dialog.messageStack','messageStack AutoChild, with the toolbar underneath as usual. If any of these behaviors are inconvenient or you want more precise control over a message and some custom widgets, start from the superclass Window instead, and add controls via Window.addItem. The message string may contain "${loadingImage}", if so, the standard loading spinner will appear at that location in the text (see Canvas.loadingImageSrc). The message will be styled with the Dialog.messageStyle.
		 * Flags: IR */
		message?: string /* HTMLString */; // Flags=IR
		/** AutoChild that shows Dialog.icon.
		 * Flags: IR */
		messageIcon?: Img  /* Img AutoChild */; // Flags=IR
		/** AutoChild that shows Dialog.message.
		 * Flags: IR */
		messageLabel?: Label  /* Label AutoChild */; // Flags=IR
		/** AutoChild that combines Dialog.message and Dialog.icon.
		 * Flags: IR */
		messageStack?: Layout  /* Layout AutoChild */; // Flags=IR
		/** Style to apply to the message text shown in the center of the dialog
		 * Flags: IR */
		messageStyle?: string /* CSSStyle */; // Flags=IR
		/** Icon to show in the isc.say dialog.
		 * Flags: IR */
		sayIcon?: string /* SCImgURL */; // Flags=IR
		/** Whether to show a toolbar of buttons at the bottom of the Dialog. Default of null will cause the value to be resolved automatically to true or false when the Dialog is first drawn according as Dialog.toolbarButtons contains buttons or not.
		 * Flags: IR, Group: appearance */
		showToolbar?: boolean; // Flags=IR
		/** Style of the Dialog background
		 * Flags: IRW, Group: appearance */
		styleName?: string /* CSSStyleName */; // Flags=IRW
		/** AutoChild of type Toolbar used to create the Dialog.toolbarButtons.
		 * Flags: IR */
		toolbar?:  Toolbar /* AutoChild Toolbar */; // Flags=IR
		/** This is a synonym for Dialog.buttons
		 * Flags: IR */
		toolbarButtons?: Array<Button> /* Array of Button or Button Properties */; // Flags=IR
		/** Icon to show in the isc.warn dialog.
		 * Flags: IR */
		warnIcon?: string /* SCImgURL */; // Flags=IR

		/* Method Overrides */

		/** 
		 * Handles a click on the close button of this window. The default implementation calls Window.close','close() and returns false to prevent bubbling of the click event. Override this method if you want other actions to be taken. Custom implementations may call close() to trigger the default behavior.
		 */
		closeClick?(): boolean /* Boolean */; 

	} // DialogProps


	/**
	 * Dialogs are a specialized version of Window used for small windows that contain just a text message or a text mesage with some standard buttons. Many typical modal dialogs such as alerts and confirmations are built into the system with convenience APIs - see isc.say, isc.warn and isc.askForValue. Dialogs can be modal or non-modal according to Window.isModal','isModal. NOTE: If you are building a dialog that will involve more than just buttons and a message, consider starting from the Window class instead, where arbitrary components can be added to the body area via Window.addItem. This is an example of creating a custom dialog: isc.Dialog.create({ message : "Please choose whether to proceed", icon:"[SKIN]ask.png", buttons : [ isc.Button.create({ title:"OK" }), isc.Button.create({ title:"Cancel" }) ], buttonClick : function (button, index) { this.hide(); } });  
	 */
	export interface Dialog extends Window {
		/** Icon to show in the isc.ask dialog.
		 * Flags: IR */
		askIcon: string /* SCImgURL */;

		/** If a toolbar is showing, automatically place keyboard focus in the first button.
		 * Flags: IR, Group: appearance */
		autoFocus: boolean /* Boolean */;

		/** Array of Buttons to show in the Dialog.showToolbar','toolbar, if shown. The set of buttons to use is typically set by calling one of the shortcuts such as isc.say or isc.confirm. A custom set of buttons can be passed to these shortcuts methods via the "properties" argument, or to a directly created Dialog. In both cases, a mixture of DialogButtons','built-in buttons, custom buttons, and other components (such as a LayoutSpacer) can be passed. Built-in buttons can be referred to as isc.Dialog.OK, for example: isc.Dialog.create({ buttons:[ isc.Dialog.OK, isc.Dialog.CANCEL, isc.LayoutSpacer.create({width:50}), { title:"Not now", click:"doSomething()" } ] }) Built-in buttons will call standard methods on the Dialog itself, such as Dialog.cancelClick, as explained in the DialogButtons','list of built-in buttons. 
		 * Flags: IR */
		buttons: Array<Button> /* Array of Button or Button Properties */;

		/** Icon to show in the isc.confirm dialog.
		 * Flags: IR */
		confirmIcon: string /* SCImgURL */;

		defaultWidth: number /* int */;

		/** Icon to show in this dialog - see Dialog.message.
		 * Flags: IR */
		icon: string /* SCImgURL */;

		/** Size of the icon to show in this dialog.
		 * Flags: IR */
		iconSize: number /* int */;

		/** Message to show in this dialog. If a message is set the primary purpose of the dialog will be assumed to be to show a message with buttons - auto-sizing to the message text will be enabled, and, if Dialog.icon has also been set, the Dialog.messageLabel','messageLabel and Dialog.messageIcon','messageIcon AutoChildren will be created and placed together in the Dialog.messageStack','messageStack AutoChild, with the toolbar underneath as usual. If any of these behaviors are inconvenient or you want more precise control over a message and some custom widgets, start from the superclass Window instead, and add controls via Window.addItem. The message string may contain "${loadingImage}", if so, the standard loading spinner will appear at that location in the text (see Canvas.loadingImageSrc). The message will be styled with the Dialog.messageStyle.
		 * Flags: IR */
		message: string /* HTMLString */;

		/** AutoChild that shows Dialog.icon.
		 * Flags: IR */
		messageIcon: Img  /* Img AutoChild */;

		/** AutoChild that shows Dialog.message.
		 * Flags: IR */
		messageLabel: Label  /* Label AutoChild */;

		/** AutoChild that combines Dialog.message and Dialog.icon.
		 * Flags: IR */
		messageStack: Layout  /* Layout AutoChild */;

		/** Style to apply to the message text shown in the center of the dialog
		 * Flags: IR */
		messageStyle: string /* CSSStyle */;

		/** Icon to show in the isc.say dialog.
		 * Flags: IR */
		sayIcon: string /* SCImgURL */;

		/** Whether to show a toolbar of buttons at the bottom of the Dialog. Default of null will cause the value to be resolved automatically to true or false when the Dialog is first drawn according as Dialog.toolbarButtons contains buttons or not.
		 * Flags: IR, Group: appearance */
		showToolbar: boolean;

		/** Style of the Dialog background
		 * Flags: IRW, Group: appearance */
		styleName: string /* CSSStyleName */;

		/** AutoChild of type Toolbar used to create the Dialog.toolbarButtons.
		 * Flags: IR */
		toolbar:  Toolbar /* AutoChild Toolbar */;

		/** This is a synonym for Dialog.buttons
		 * Flags: IR */
		toolbarButtons: Array<Button> /* Array of Button or Button Properties */;

		/** Icon to show in the isc.warn dialog.
		 * Flags: IR */
		warnIcon: string /* SCImgURL */;


		/* Instance Method Overrides */

		/** 
		 * Handles a click on the close button of this window. The default implementation calls Window.close','close() and returns false to prevent bubbling of the click event. Override this method if you want other actions to be taken. Custom implementations may call close() to trigger the default behavior.
		 */
		closeClick?(): boolean /* Boolean */; 

	} // Dialog

	export interface DialogStatic<T, P> extends WindowStatic<T, P> {
		/** Title for the "Apply" button.
		 * Flags: IRW, Group: i18nMessages */
		APPLY_BUTTON_TITLE: string /* HTML */;

		/** A singleton Dialog instance that will be shown in response to a isc.askForValue call. Notes: Because this is a singleton object, properties set on the Ask object directly will persist each time it is shown. Developers should use the askForValue() method to show this object rather than manipulating the Dialog directly.
		 * Flags: A, Group: Prompting */
		Ask: DialogProps /* Dialog Properties */;

		/** Default title for the dialog displayed by isc.askForValue. A custom title can alternatively be specified as the title attribute of the properties parameter passed to that method.
		 * Flags: IRW, Group: i18nMessages */
		ASK_FOR_VALUE_TITLE: string /* HTML */;

		/** Default title for the dialog displayed in response to the isc.ask method. Note that a custom title can be specified as the title attribute of the properties parameter passed to that method.
		 * Flags: IRW, Group: i18nMessages */
		ASK_TITLE: string /* HTML */;

		/** Title for the "Cancel" button.
		 * Flags: IRW, Group: i18nMessages */
		CANCEL_BUTTON_TITLE: string /* HTML */;

		/** Default title for the dialog displayed in response to the isc.confirm method. Note that a custom title can be specified as the title attribute of the properties parameter passed to that method.
		 * Flags: IRW, Group: i18nMessages */
		CONFIRM_TITLE: string /* HTML */;

		/** Title for the "Done" button.
		 * Flags: IRW, Group: i18nMessages */
		DONE_BUTTON_TITLE: string /* HTML */;

		/** Title for the "No" button.
		 * Flags: IRW, Group: i18nMessages */
		NO_BUTTON_TITLE: string /* HTML */;

		/** Title for the "OK" button.
		 * Flags: IRW, Group: i18nMessages */
		OK_BUTTON_TITLE: string /* HTML */;

		/** The "Prompt" object on the dialog class is a singleton Dialog instance. The Prompt is used to show text to the user in a modal fashion - it will expand to show all the text that you put into it. By default this Dialog has no end-user controls and is expected to be programmatically dismissed. Common use-case: During server-interactions, the Prompt will be used to display a suitable wait message, and suppress user input. Notes: Because this is a singleton object, properties set on the Prompt directly will persist each time it is shown. Developers should use the showPrompt() and clearPrompt() methods to show and hide the prompt rather than manipulating the prompt directly.
		 * Flags: A, Group: Prompting */
		Prompt: DialogProps /* Dialog Properties */;

		/** Default title for the dialog displayed in response to the isc.say method. Note that a custom title can be specified as the title attribute of the properties parameter passed to that method.
		 * Flags: IRW, Group: i18nMessages */
		SAY_TITLE: string /* HTML */;

		/** A singleton Dialog instance that will show text to the user and provide buttons for their response. The Dialog will expand to show all the text that you put into it. This dialog is shown in response to calls to isc.say, isc.warn, isc.ask and isc.confirm. This can be used in cases where a developer would alternatively make use of the native JavaScript alert() and confirm() methods. The main differences between those methods and using the Warn object are: - The Warn object can be customized by modifying which buttons are visible, the style applied to it, etc. - The isc.ask() and isc.warn() methods are asynchronous - rather than returning a value indicating the user's response, a callback method will be fired when the user interacts with the dialog. Notes: Because this is a singleton object, properties set on the Warn object directly will persist each time it is shown. Developers should use the warn() or ask() methods to show and hide this object rather than manipulating the Dialog directly.
		 * Flags: A, Group: Prompting */
		Warn: DialogProps /* Dialog Properties */;

		/** Default title for the dialog displayed in response to the isc.warn method. Note that a custom title can be specified as the title attribute of the properties parameter passed to that method.
		 * Flags: IRW, Group: i18nMessages */
		WARN_TITLE: string /* HTML */;

		/** Title for the "Yes" button.
		 * Flags: IRW, Group: i18nMessages */
		YES_BUTTON_TITLE: string /* HTML */;

	} // DialogStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a DSRequest Props argument.
	 * This is derived from the methods in the DSRequest class and it's parents and their properties marked with the I flag.
	 */
	export interface DSRequestProps extends RPCRequestProps {
		/** For fetch, add or update operation, an optional comma separated list of fields to fetch from another, related DataSource. Fields should be specified in the format "localFieldName!relatedDataSourceID.relatedDataSourceFieldName". where relatedDataSourceID is the ID of the related dataSource, and relatedDataSourceFieldName is the field for which you want to fetch related values. The returned field values will be stored on the data returned to the client under the specified localFieldName. Note that this will be applied in addition to any specified DSRequest.outputs. Note that as with DataSourceField.includeFrom, the related dataSource must be linked to the primary datasource via a foreignKey relationship. Note additionalOutputs sent in request from the browser can be completely disabled in server_properties','server.properties by setting datasource.allowClientAdditionalOutputs: datasource.allowClientAdditionalOutputs: false In this case DSRequest.additionalOutputs sent from the browser will be cleared before executing request. Note that programatically configured additionalOutputs are always allowed, but you can't modify them from within a DMI method, so the only way to execute a request with additionalOutputs that differ from what was sent by the client is to create a new DSRequest
		 * Flags: IRA */
		additionalOutputs?: string /* String */; // Flags=IRA
		/** A callback method that will be called with an instance of DSResponse, as sent by the server. Queuing does not affect callbacks in any way - your specified callback will be invoked for each DSRequest that contained a callback regardless of whether the request was sent as part of a queue or not. Note that if the request encounters an error (such as 500 server error), by default the callback will not be fired. Instead, RPCManager.handleError is called to invoke the default system-wide error handling. Set RPCRequest.willHandleError','willHandleError:true to have your callback invoked regardless of whether there are errors; however, make sure your callback properly handles malformed responses when RPCResponse.status is non-zero. See the errorHandling','error handling overview below for more details.
		 * Flags: IR, Group: errorHandling */
		callback?: DSCallback; // Flags=IR
		/** An object to be held onto for the duration of the DSRequest turnaround to track application-specific context. When a DataSource request completes, the clientContext is available in the DSCallback as dsResponse.clientContext. The clientContext is never sent to the server. The clientContext is useful for holding onto state that will be used when the DSCallback fires, such as the name of a component that will receive the returned data.
		 * Flags: IRW */
		clientContext?: any /* Object */; // Flags=IRW
		/** For requests submitted by a DataBoundComponent, the Canvas.ID of the submitting component. This ID will be present for operations including automatic saves by a ListGrid editing','during editing, or calls to DynamicForm.saveData','form.saveData(). It will not be present for a direct call to a DataSource method such as DataSource.fetchData. Note this is the component's String ID - you can retrieve the component itself via Canvas.getById. This property should be used for debugging purposes only - do not use it to trigger differences in server-side behavior, instead, use DSRequest.operationId because only operationId is considered when assessing dsRequestEquivalence','request equivalence.
		 * Flags: IR */
		componentId?: string /* String */; // Flags=IR
		/** Data, such as search criteria or an updated record, to be acted upon. Contents differ by operationType, see dataSourceOperations','DataSource Operations for details. This field is generally filled in by passing the "data" argument to methods such as ListGrid.fetchData.
		 * Flags: IR */
		data?: Array<any> /* Object or Array of Object */; // Flags=IR
		/** DataSource.dataProtocol','DataProtocol for this particular request. Note: Typically developers should use DataSource.operationBindings','operation bindings to specify an explicit data protocol for a request. One exception: advanced developers may wish to have a custom DataSource.transformRequest','request transformer with entirely client-side handling for some requests. This may be achieved by setting the request's dataProtocol to DSProtocol','"clientCustom" within transformRequest, and also triggering application code which will fire DataSource.processResponse when complete. The DataSource.getDataProtocol method may be used to determine what data protocol will be used to handle a specific request based on this property (if set), otherwise the settings at the OperationBinding.dataProtocol','operationBinding or DataSource.dataProtocol','dataSource levels.
		 * Flags: IRW */
		dataProtocol?: DSProtocol; // Flags=IRW
		/** DataSource this DSRequest will act on. This property is generally automatically populated, for example when calling DataSource.fetchData the dataSource property is set to the target DataSource.
		 * Flags: IR */
		dataSource?: string /* String */; // Flags=IR
		/** End row of requested results, used only with fetch operations. Note that startRow and endRow are zero-based, inclusive at the beginning and exclusive at the end (like substring), so startRow: 0, endRow: 1 is a request for the first record.
		 * Flags: IR, Group: paging */
		endRow?: number; // Flags=IR
		/** The format in which the data should be exported. See ExportFormat for more information.
		 * Flags: IR */
		exportAs?: ExportFormat; // Flags=IR
		/** When using RPCManager.exportContent to produce a .pdf from a SmartClient UI, this property allows dynamic CSS to be passed to the server. Since the exportContent() system already provides a way to specify a custom skin or additional stylesheet for export, exportCSS should only be used for small bits of CSS that are necessarily dynamic. For example, when printing a very wide page, such as a grid with many columns or a very wide chart, you could send the string "@page {size: A4 landscape; }" as exportCSS to cause the generated PDF to use landscape mode, so that all content fits without clipping.
		 * Flags: IR */
		exportCSS?: string /* String */; // Flags=IR
		/** Only applies to request properties passed to ListGrid.exportClientData. If specified this property contains an arbitrary set of data to be exported.
		 * Flags: IR */
		exportData?: Array<any> /* Array of Record */; // Flags=IR
		/** When exporting via ListGrid.exportClientData to an XLS or OOXML spreadsheet, forces dates to export as a string rather than a true date value. If a date value is provided to a spreadsheet as a string, Excel or other spreadsheet applications may not recognize them as being date values that are valid for use in date-specific functions in formulas, filters, etc. For this reason, the default behavior of exportClientData is to provide date values to the spreadsheet as true date values. If FormatString','Format Strings are provided via properties like DataSourceField.format','dataSourceField.format these will be translated to Excel / OpenOffice format strings and used when generating spreadsheets. Other formatting logic, such as ListGridField.formatCellValue','cell formatters, will not be used since they cannot be automatically translated to an Excel format string. If no translatable format string is available, date values will be provided to the spreadsheet with no formatter and the spreadsheet program's default formatting for date values will be used. If exportDatesAsFormattedString is set to true, date fields will appear as strings that exactly match the formatting shown in the DataBoundComponent. As noted above, this means the spreadsheet program will not recognize the value as a date.
		 * Flags: IR, Group: exportFormatting */
		exportDatesAsFormattedString?: boolean; // Flags=IR
		/** The character to use as a field-separator in CSV exports. The default delimiter is comma.
		 * Flags: IR */
		exportDelimiter?: string /* String */; // Flags=IR
		/** Specifies whether the exported data will be downloaded as an attachment or displayed in a new browser window. See ExportDisplay for more information.
		 * Flags: IR */
		exportDisplay?: ExportDisplay; // Flags=IR
		/** The list of field names to export. If provided, the field list in the exported output is limited and sorted as per the list. If exportFields is not provided: If we are exporting via DSRequest.exportData','exportData(), the field list in the exported output is every non-hidden field defined in the DataSource, in DataSource definition order If we are exporting via ListGrid.exportClientData','exportClientData() and we are not exporting to OOXML, or we are exporting to OOXML but we are not DSRequest.exportStreaming','streaming, the field list in the exported output is based on the client data sent up, taking every row into account (so if there is a value for field "foo" only in row 57, we will output a column "foo", the cells of which are empty except for row 57) If we are exporting via ListGrid.exportClientData','exportClientData() and we are exporting to OOXML and streaming is in force (the default for OOXML), the field list in the exported output is based on the client data sent up, taking just the first row into account (so if there is a value for field "foo" only in row 57, we will not output a column "foo" at all) 
		 * Flags: IR */
		exportFields?: Array<string> /* Array of String */; // Flags=IR
		/** The name of the file to save the exported data into. If DSRequest.exportToFilesystem','exportToFilesystem is set, this is the name of the file the server creates on its filesystem. If DSRequest.exportToClient','exportToClient is set, this is the filename that will appear to the browser. If the exportFilename that you specify does not include an extension, one will be added to it based on the ExportFormat specified by DSRequest.exportAs.
		 * Flags: IR */
		exportFilename?: string /* String */; // Flags=IR
		/** Optional text to appear at the end of the file.
		 * Flags: IR */
		exportFooter?: string /* String */; // Flags=IR
		/** Optional text to appear at the beginning of the file.
		 * Flags: IR */
		exportHeader?: string /* String */; // Flags=IR
		/** This property allows omitting column names from CSV and Excel exports (no effect on JSON or XML exports).
		 * Flags: IRW */
		exportHeaderless?: boolean /* Boolean */; // Flags=IRW
		/** The image format in which the SVG graphic should be exported.
		 * Flags: IR */
		exportImageFormat?: ExportImageFormat; // Flags=IR
		/** If exporting in ExportImageFormat','JPEG format, the output JPEG quality level. This is a number from 0 to 1, with 1 representing the best quality and 0 representing the least quality but smallest file size.
		 * Flags: IR */
		exportImageQuality?: number /* float */; // Flags=IR
		/** If DSRequest.exportToFilesystem','exportToFilesystem is set, optionally specifies a path to use when saving the file. This path is relative to the default export path, which is set using the server_properties','server.properties setting export.location; this is the project webRoot by default. For example, with the default setting of export.location, an exportPath of "shared/ds" and an DSRequest.exportFilename','exportFilename of "exportedData.csv", SmartClient Server would export to file $webRoot/shared/ds/exportedData.csv. If you do not specify this property, SmartClient Server will export to the file indicated by exportFilename directly in the default export location. This property is only applicable when DSRequest.exportToFilesystem','exportToFilesystem is set.
		 * Flags: IR */
		exportPath?: string /* String */; // Flags=IR
		/** Determines the PropertyIdentifier to be used in the exported data. This essentially means, should we export internal field names like "countryCode" or "EMPLOYEE_NO", or localized descriptive field titles like "code du pays" or "Employee Number". This setting has a lot in common with DSRequest.exportRawValues; both are largely dependent on whether the exported data is intended for direct consumption by an end user (in which case it is appropriate to export formatted values and localized field titles), or for interface to some downstream computer system (in which case you probably want raw, unformatted values and internal field names). If this property is not set, the following defaults apply: If the export format is a native spreadsheet format (XLS or OOXML), localized field titles are used If the export format is CSV, XML or JSON and this is a client-driven export (ie it was initiated by a call to ListGrid.exportClientData','exportClientData()), localized field titles are used If the export format is CSV, XML or JSON and this is not a client-driven export, internal field names are used 
		 * Flags: IRW, Group: exportFormatting */
		exportPropertyIdentifier?: PropertyIdentifier; // Flags=IRW
		/** Whether formatting settings should be applied to data being exported. Default behavior and the effect of setting of exportRawValues is described in the exportFormatting','Export Formatting overview.
		 * Flags: IRW, Group: exportFormatting */
		exportRawValues?: boolean /* Boolean */; // Flags=IRW
		/** When set, causes the results of the DSRequest to be exported to a file, whose name and format are indicated by DSRequest.exportFilename and DSRequest.exportAs respectively. When no exportFilename is provided, the default is Results.csv and the default value of exportAs is csv. The export field-list can also be configured, see DSRequest.exportFields. Formats for exported date and numeric are controlled by several settings - see exportFormatting for an overview. Once the operation completes, DSRequest.exportDisplay specifies whether the exported data should be downloaded to the file-system or displayed in a new window. The default value of exportDisplay is "download" which displays the Save As dialog. See ExportDisplay for more information. You can configure the style of LineBreakStyle','line-breaks to use when generating the output, the DSRequest.exportDelimiter','delimiter to use when exporting to CSV and the DSRequest.exportTitleSeparatorChar','separator-character to use in field-titles when exporting to XML. Additionally, you can output arbitrary text before and after the exported data by setting DSRequest.exportHeader','exportHeader and DSRequest.exportFooter','exportFooter. Note that for security reasons, an export initiated using dsRequest properties does not provide support for JSON format (see <a href="http://forums.smartclient.com/showthread.php?t=235">this post</a> for more detail). However, you can use operationBinding.exportAs:"json" in a server-side .ds.xml file to force JSON export to be allowed. As well as setting dsRequest.exportResults and related properties, exports can be initiated in two other ways, via OperationBindings and via custom server code which sets export-related properties on the DSResponse. Both of those methods support exporting to JSON format. Format Examples XML format &lt;List&gt; &lt;Object&gt; &lt;id&gt;10101&lt;/id&gt; &lt;displayName&gt;Record 10101&lt;/displayName&gt; &lt;/Object&gt; &lt;/List&gt; JSON Format [ { id: 10101, displayName: "Record 10101" } ] CSV Format id,displayName 10101,"Record 10101" 
		 * Flags: IR */
		exportResults?: boolean /* Boolean */; // Flags=IR
		/** When you erxport a ListGrid that has ListGrid.headerSpans','headerSpans, should headerSpans also be exported. See DSRequest.exportSpanTitleSeparator for details of of what it means to export headerSpans to different export targets.
		 * Flags: IR */
		exportShowHeaderSpanTitles?: boolean /* Boolean */; // Flags=IR
		/** When you export a ListGrid that has ListGrid.headerSpans','headerSpans defined and DSRequest.exportShowHeaderSpanTitles is true, the behavior is dependent on the export type. Direct exports to Excel formats (both XLS and OOXML) place the headerSpans in merged cells in the spreadsheet, giving the same visual effect as the original ListGrid. This is not possible with exports to CSV format; instead, we alter the exported headers so that they contain the titles of the ancestor headerSpan(s). For example, if you had a field titled "Population" inside a headerSpan titled "National", nested inside another headerSpan titled "Demographics", that would result in the exported field being titled "Demographics - National - Population". The exportSpanTitleSeparator property allows you to override the separator string used when constructing these amalgamated headers.
		 * Flags: IR */
		exportSpanTitleSeparator?: string /* String */; // Flags=IR
		/** When exporting to OOXML format (this is the standard file format used by Excel 2007 and later), we default to using streaming mode, for memory efficiency. You can override this for individual exports by setting this flag false. You may wish to do this if you need to grab the spreadsheet object in a DMI and do something with it. The underlying object in use - POI's SXSSFWorkbook - is intended for write only and cannot usefully be read. You can switch off Excel streaming altogether by setting "excel.useStreaming" false in server.properties. Note, OOXML is the only native Excel format that supports streaming: when exporting to the older XLS format, we build the spreadsheet in its entirety in server-side memory before writing it to disk or returning it to the client. This is unlikely to change: streaming the XLS format is impractical bcause it is a self-referential binary format, and in any case the problem of huge exports overflowing JVM memory is less likely to arise with XLS, because it is innately limited to 65535 rows.
		 * Flags: IR */
		exportStreaming?: boolean; // Flags=IR
		/** The character with which to replace spaces in field-titles when exporting to XML. If not specified in the request, the server uses "".
		 * Flags: IR */
		exportTitleSeparatorChar?: string /* String */; // Flags=IR
		/** If set, SmartClient Server will export data back to the client, either as a file download or as content in a new browser window, depending on the setting of DSRequest.exportDisplay','exportDisplay. Note that it is perfectly valid to specify both this property and DSRequest.exportToFilesystem','exportToFilesystem; in this case the data is both exported to a file on the server filesystem, and downloaded to the client. If you specify <em>neither</em> property, the export no-ops.
		 * Flags: IR */
		exportToClient?: boolean /* Boolean */; // Flags=IR
		/** If set, SmartClient Server will export data to a file on the server filesystem. The file we export to is determined by the DSRequest.exportFilename','exportFilename and DSRequest.exportPath','exportPath. Note that filesystem exports are disabled by default, for security reasons. To enable them, set export.allow.filesystem to true in your server.properties file. If you enable filesystem exports, you should also consider setting a default export path, as described in the DSRequest.exportPath','exportPath documentation. Note that it is perfectly valid to specify both this property and DSRequest.exportToClient','exportToClient; in this case the data is both exported to a file on the server filesystem <em>and</em> downloaded to the client. If you specify <em>neither</em> property, the export no-ops. It is possible to redirect the filesystem export to make use of an OutputStream you provide. You use this when you want to make some use of the export document other than writing it to a disk file - for example, attaching it to an email or writing it to a database table. See the server-side Javadocs for DSRequest.setExportTo().
		 * Flags: IR */
		exportToFilesystem?: boolean /* Boolean */; // Flags=IR
		/** For server-side export with ExportFormat "xls" or "ooxml" only, timezone to use when saving values from FieldType "datetime" to the spreadsheet. This setting exists because MS Excel&trade; has no concept of providing a true datetime value that is timezone-independent and will display in the local timezone where the Excel program is launched. Instead, datetime values must be provided as a rendered string, which implies rendering in a particular timezone when the spreadsheet is generated. exportTZ can either be specified as a timezone offset in the same format expected by Time.setDefaultDisplayTimezone (for example, "+01:00" for one hour after GMT) or as the special constants "client" (meaning the current client display timezone) or "server" (meaning the timezone of the server). Default if unspecified is "server". This setting does not affect fields of type "date" or "time", which are timezone-independent values. See dateFormatAndStorage for more information on how SmartClient handles date, time and datetime values. All non-spreadsheet export formats always use UTC. This setting also does not affect client-driven exports (DataSource.exportClientData), which always use client-side time.
		 * Flags: IR, Group: exportFormatting */
		exportTZ?: string /* String */; // Flags=IR
		/** This flag has a different meaning depending on whether you are doing a client-driven or server-driven export. For ListGrid.exportClientData','exportClientData() calls (client-driven), ordinarily any fields that have a ListGridField.displayField','displayField defined have the value of that displayField exported, rather than the underlying value in the ListGridField.valueField','valueField. If you set the exportValueFields property, we export both the underlying value and the displayField value. Again for exportClientData() calls, any fields that have a ListGridField.valueMap','valueMap defined ordinarily have the mapped value of the field exported, rather than the underlying data value. If you set the exportValueFields property, we instead export the underlying data value. Note, there is only one field in this scenario, not a valueField and a separate displayField, so we export either the underlying data value or the mapped value, not both as in the displayField/valueField case described above. For DataBoundComponent.exportData','exportData() calls (server-driven), we ordinarily export the underlying data value of all fields. However, if you set the exportValueFields property explicitly to false, any fields that have a DataSource-defined DataSourceField.valueMap','valueMap will have the mapped value exported instead. This is similar to the client-side treatment of valueMaps, except that the defaults are reversed.
		 * Flags: IR */
		exportValueFields?: boolean; // Flags=IR
		/** A set of key:value pairs, mapping field names to expressions that will be evaluated server-side to derive a value for that field. This property allows for client-driven transactionChaining','Transaction Chaining, with some restrictions for security reasons: Normal OperationBinding.values','server-side Transaction Chaining settings for a field take precedence over this property, so server-defined rules cannot be overridden from the client Arbitrary Velocity expressions are not allowed in DSRequests sent from the client (fieldValueExpressions is also a valid property on a server-side DSRequest, and normal Velocity expressions <em>are</em> allowed in that case - see the server-side Javadoc for DSRequest.setFieldValueExpressions()). For client-originated requests, only the following bindings are allowed - see the velocitySupport','Velocity overview for details of what these values mean: $currentDate $transactionDate $userId $masterId - see DSRequestModifier.value for details References to specific fields in prior responses, via $responseData.first and $responseData.last, with or without parameters. For example, $responseData.first("myDataSource", "fetch")[0].myField. See the velocitySupport','Velocity overview for details of $responseData References to certain metadata properties of prior responses, via $responses.first and $responses.last, with or without parameters. For example, $responses.last("myDataSource", "fetch").totalRows. Note that the only properties allowed in a client-driven fieldValueExpression are: "startRow", "endRow", "totalRows" and "status"; this restriction does not apply to server-driven fieldValueExpressions. See the Velocity overview for details of $responses Normal DataSourceField.editRequiresRole','declarative security rules apply: if a field is not valid for writing, its fieldValueExpression will be ignored. Again, this only applies to client-originated requests. Note, it is possible to globally disable fieldValueExpression in client-originated requests by setting a flag in your server.properties file: dataSource.allowClientFieldValueExpressions: false
		 * Flags: IRW, Group: transactionChaining */
		fieldValueExpressions?: any /* Object */; // Flags=IRW
		/** Specifies should related updates have to be generated. If not set (or set to null) then related updates will be generated only for "add" and "update" operations. This property has to be explicitly set to true to generate related updates for "remove" operation.<p/> This functionality loads related objects from database thus affecting operation performance. For "add" and "update" operations related objects are loaded anyway and performance impact is minimal. Simple "remove" operation does not need to load related objects. Depending on database structure performance impact can be significant if this property is set to true. Note this feature works only with Hibernate/JPA data sources, see jpaHibernateRelations','JPA & Hibernate Relations for instructions how to set up relations. Table below uses "country -&gt; cities" sample data model. <table border=1 class="normal"> <tr> <td width="20%">Relation and Operation type</td> <td width="40%">Loading complete related objects</td> <td width="40%">Loading related IDs</td> </tr> <tr> <td>Many-to-one (cities -&gt; country): ADD/UPDATE</td> <td>If operation affected country, for example new city added with existing countryId, then relatedUpdate is generated. Otherwise if city is added or updated without countryId set, relatedUpdate is not generated. Note that if provided countryId does not exist, it is created.</td> <td>Same as with complete related objects, except if provided countryId does not exist, then it is not created, but reset to NULL.</td> </tr> <tr> <td>Many-to-one (cities -&gt; country): REMOVE</td> <td colSpan=2>Removes record, depending on setting generates or not relatedUpdate for parent record. For example if city record is removed and countryId is sent to the server in remove request, then country record will be generated in relatedUpdates.</td> </tr> <tr> <td>One-to-many (country -&gt; cities): ADD/UPDATE</td> <td>If add or update operation provides value sets for cities as well as for country, then cities are created/updated if necessary and relatedUpdates are generated. Note that all fields in cities value sets can be sent to server. <td>Same as with complete related objects, except you can only sent primary key values for cities.</td> <tr> <td>One-to-many (country -&gt; cities): REMOVE</td> <td colSpan=2>Removes country, depending on setting returns or not relatedUpdates for the cities of removed country, which can be either REMOVE operations of all cities if cascade enabled, or UPDATE operations setting countryId=null to all cities if cascade is disabled</td> </tr> </table> Note that Many-to-Many works the same way as One-to-Many.
		 * Flags: IRW */
		generateRelatedUpdates?: boolean; // Flags=IRW
		/** List of fields to group by when using serverSummaries','server-side summarization. Valid only for an operation of type "fetch". See the serverSummaries','Server Summaries overview for details and examples of usage.
		 * Flags: IR, Group: serverSummaries */
		groupBy?: Array<string> /* Array of String */; // Flags=IR
		/** For DataSources using SOAP messaging with a WSDL web service, data to be serialized to form SOAP headers, as a map from the header part name to the data. See WSRequest.headerData for more information. SOAP headers typically contain request metadata such as a session id for authentication, and so dsRequest.headerData is typically populated by DataSource.transformRequest, or, for data that applies to every request sent to the server, by WebService.getHeaderData. Note that this only applies to SOAP headers. General HTTP headers for requests may be modified using RPCRequest.httpHeaders.
		 * Flags: IRW */
		headerData?: any /* Object */; // Flags=IRW
		/** This property is for advanced use in integrating trees that TreeGrid.loadDataOnDemand','load data on demand using data paging. When this flag is set, a server fetch operation is expected to return all of the tree nodes that either match the provided criteria or have one or more children that match the criteria. A ResultTree with ResultTree.fetchMode','fetchMode:"paged" and with ResultTree.keepParentsOnFilter','keepParentsOnFilter enabled will automatically set this property to true on all DSRequests that it sends to the server. Currently, no built-in server-side connectors (SQL, JPA, Hibernate) implement support for the keepParentsOnFilter flag.
		 * Flags: IRW, Group: treeDataBinding */
		keepParentsOnFilter?: boolean /* Boolean */; // Flags=IRW
		/** The style of line-breaks to use in the exported output. See LineBreakStyle for more information.
		 * Flags: IR */
		lineBreakStyle?: string /* String */; // Flags=IR
		/** For an update or remove operation, the original values from the record that is being updated or removed. oldValues is automatically added to DSRequests submitted by DataBound Components. Available on the server via DSRequest.getOldValues(). The server can compare the oldValues to the most recent stored values in order to detect that the user was looking at stale values when the user submitted changes (NOTE: this means of detecting concurrent edit is sometimes called "optimistic concurrency" or "long transactions"). In applications where a policy of "last update wins" is not appropriate when updating certain fields, special UI can be shown for this case. For example, on detecting concurrent edit, the server may send back a special dsResponse.status code that the client application detects, offering the user a choice of proceeding with the operation, discarding edits, or reconciling new and old values in a special interface.
		 * Flags: IR */
		oldValues?: any /* Record */; // Flags=IR
		/** When a DataBoundComponent sends a DSRequest, the dsRequest.operationId will be automatically picked up from the fetchOperation, addOperation, etc properties of the DataBoundComponent. The operationId serves as an identifier that you can use to create variations on the 4 basic DataSource operations that are used by different components in different parts of your application. For example, you may be using a standard fetch operation in one part of your application, however on another screen you want to perform a fetch operation on the same DataSource but interpret search criteria differently (eg full text search). If you declare more than one OperationBinding for the same OperationBinding.operationType, you can specify an operationId OperationBinding.operationId','on the operationBinding which will cause that operationBinding to be used for dsRequests containing a matching operationId. This allows all the possible settings of an operationBinding, including OperationBinding.wsOperation','wsOperation or dmiOverview','DMI settings, to be switched on a per-component or per-request basis. For example, by setting the fetchOperation on a particular ListGrid, you could cause it to invoke a different server method via DMI, different OperationBinding.dataURL','dataURL or different OperationBinding.wsOperation','web service operation. The operationId can also be directly received by the server in order to affect behavior. When using the SmartClient Server, operationId can be accessed via dsRequest.getOperationId(). The RestDataSource will also send the operationId to the server as part of the RestDataSource.metaDataPrefix','request metadata. Note that if you DataSource.fetchData','manually invoke a DataSource operation, you can also specify operationId via the requestProperties parameter. Note that the operationId has special significance in terms of whether two DSRequests are considered equivalent for caching and synchronization purposes - see dsRequestEquivalence.
		 * Flags: IR, Group: operations */
		operationId?: string /* String */; // Flags=IR
		/** Type of operation being performed: "fetch", "add", "remove", "update" or "custom". This property is generally automatically populated, for example when calling fetchData() on a DataSource or DataBound component the operationType is automatically set to "fetch". Note that "custom" operations are never generated automatically, they are always fired by your code.
		 * Flags: IR */
		operationType?: DSOperationType; // Flags=IR
		/** The list of fields to return in the response, specified as a comma-separated string (eg, "foo, bar, baz"). You can use this property to indicate to the server that you are only interested in a subset of the fields that would normally be returned. Note that you cannot use this property to request a <em>superset</em> of the fields that would normally be returned, because that would be a security hole. It is possible to configure individual OperationBindings to return extra fields, but this must be done in the server's DataSource descriptor; it cannot be altered on the fly from the client side.
		 * Flags: IR */
		outputs?: string /* String */; // Flags=IR
		/** Indicates that a validation request is being made for a record that will ultimately be saved with an "add" request, as opposed to an "update" request. This context is necessary for some validators because the nature of the validation depends on whether we are adding or updating a record. The system sets this flag when processing interim validations, such as those fired when DynamicForm.validateOnChange is in force.
		 * Flags: IR */
		pendingAdd?: boolean; // Flags=IR
		/** Sets DataSource.progressiveLoading','progressive loading mode for this specific request, overriding the OperationBinding- and DataSource-level settings. Note that this setting applies only to fetch requests - it has no effect if specified on any other kind of request.
		 * Flags: IRW, Group: progressiveLoading */
		progressiveLoading?: boolean; // Flags=IRW
		/** This is a per-request flag for explicitly controlling whether the cache is used (bypassing it when not wanted, or using it when settings would indicate otherwise). See DataSource.cacheAllData, DataSource.cacheAllOperationId and DataSource.cacheAcrossOperationIds for caching management for all requests of a dataSource.
		 * Flags: IRW */
		shouldUseCache?: boolean; // Flags=IRW
		/** Fieldname to sortBy, prefixed with optional "-" indicating descending sort. For example, to sort by the field "userName" in ascending order, set sortBy to just "userName". For descending sort on "userName", set sortBy to "-userName". To sort by multiple fields, an Array of Strings is also supported. For example, to sort by the field "department" in ascending order, followed by the field "userName" in descending order, set sortBy to: [ "department", "-userName" ] Additionally, this property supports an array of SortSpecifier objects. Setting sortBy to the following SortSpecifier array results in the same multi-level sort mentioned above: [ &nbsp;&nbsp;{ property: "department", direction: "ascending" }, &nbsp;&nbsp;{ property: "userName", direction: "descending" } ] 
		 * Flags: IR */
		sortBy?: Array<SortSpecifier> /* String | Array of String or Array of SortSpecifiers */; // Flags=IR
		/** Starting row of requested results, used only with fetch operations. If unset, 0 is assumed. Note that startRow and endRow are zero-based, inclusive at the beginning and exclusive at the end (like substring), so startRow: 0, endRow: 1 is a request for the first record.
		 * Flags: IR, Group: paging */
		startRow?: number; // Flags=IR
		/** If true, results will be streamed on the server, rather than all records being read into server memory at once; this approach is appropriate for retrieving or exporting large datasets without swamping the server. Although this property can be set without any particular concerns (small datasets can be streamed just as readily as large ones), bear in mind that although streaming enables the processing of very large datasets, processing and downloading very large datasets in a normal client/server flow will very rarely give an acceptable user experience. Streaming is of more practical use in a batch setting - for example, a disconnected DSRequest.exportToFilesystem','export. Note that streaming requires specific server support; of SmartClient's built-in DataSource types, only SQLDataSource is able to stream results. This property is ignored by other DataSource types. If you wish to implement the necessary server-side behavior to support streaming with a custom DataSource, see the the server-side Javadocs for DSResponse.hasNextRecord() and DSResponse.nextRecordAsObject(). See also the server-side documentation for DSResponse, SQLDataSource and StreamingResponseIterator. Note, that streaming results does not support fields with SummaryFunction','"concat" summary function on non-Oracle databases. Such fields will be skipped.
		 * Flags: IR */
		streamResults?: boolean; // Flags=IR
		/** A mapping from field names to SummaryFunction','summary functions to be applied to each field. Valid only for an operation of type "fetch". See the serverSummaries','Server Summaries overview for examples of usage.
		 * Flags: IR, Group: serverSummaries */
		summaryFunctions?: any /* Object<String,SummaryFunction> */; // Flags=IR
		/** For "fetch" operations, how search criteria should be interpreted for text fields: one of "exact" for exact match, "exactCase" for case-sensitive exact match, "startsWith" for matching at the beginning only, or "substring" for substring match. All textMatchStyle settings except "exactCase" are case-insensitive; use AdvancedCriteria for greater control over matching. This property defaults to the value of DataSource.defaultTextMatchStyle if it is not explicitly provided on the DSRequest. Note, however, that DSRequests issued by ListGrids and other DataBoundComponent','components will generally have a setting for textMatchStyle on the component itself (see ListGrid.autoFetchTextMatchStyle, for example). This setting is respected by the built-in server-side connectors for SQL, JPA and Hibernate. A custom server-side DataSource implementation should generally respect this flag as well, or server-side filtering will not match client-side filtering, which will require ResultSet.useClientFiltering','disabling client-side filtering, a huge performance loss.
		 * Flags: IR */
		textMatchStyle?: TextMatchStyle; // Flags=IR
		/** When useFlatFields is set for a request to be sent to a WSDL web service, when creating the input XML message to send to the web service, properties in DSRequest.data','request.data will be used as the values for XML elements of the same name, at any level of nesting. useFlatFields allows you to ignore gratuitous XML message structure, such as extra levels of nested elements, and provides some insulation against changes in the required structure of the input message. For example, given this input message: &lt;FindServices&gt; &lt;searchFor&gt;search text&lt;/searchFor&gt; &lt;Options&gt; &lt;caseSensitive&gt;false&lt;/caseSensitive&gt; &lt;/Options&gt; &lt;IncludeInSearch&gt; &lt;serviceName&gt;true&lt;/serviceName&gt; &lt;documentation&gt;true&lt;/documentation&gt; &lt;keywords&gt;true&lt;/keywords&gt; &lt;/IncludeInSearch&gt; &lt;/FindServices&gt; If useFlatFields were not set, in order to fill out this message correctly, request.data would need to be: { searchFor: "search text", Options : { caseSensitive: false, }, IncludeInSearch : { serviceName: true, documentation : true, keywords : true } } However if useFlatFields were set, request.data could be just: { searchFor: "search text", caseSensitive: false, serviceName: true, documentation : true, keywords : true } useFlatFields is often set when the input data comes from a DynamicForm to avoid the cumbersome and fragile process of mapping input fields to an XML structure. OperationBinding.useFlatFields can also be set to cause all dsRequests of a particular type to useFlatFields automatically. For DataBoundComponent','DataBoundComponents, DataBoundComponent.useFlatFields','component.useFlatFields can be set use "flattened" binding to fields of a WSDL message or XML Schema. Note that useFlatFields is not generally recommended for use with XML input messages where multiple simple type fields exist with the same name, however if used in this way, the first field to use a given name wins. "first" means the first field encountered in a depth first search. "wins" means only the first field will be populated in the generated XML message.
		 * Flags: IR, Group: flatFields */
		useFlatFields?: boolean /* Boolean */; // Flags=IR
		/** Cause the DSRequest.useFlatFields','useFlatFields XML serialization behavior to be used for all soap headers in the request. See also DSRequest.headerData.
		 * Flags: IRW, Group: flatFields */
		useFlatHeaderFields?: boolean; // Flags=IRW
		/** Should the HTTP response to this request be formatted using the strict JSON subset of the javascript language? If set to true, responses returned by the server should match the format described <a href='http://www.json.org/js.html' target='_blank'>here</a>. Only applies to requests sent a server with DataSource.dataFormat set to "json" or "iscServer".
		 * Flags: IR */
		useStrictJSON?: boolean; // Flags=IR
		/** Mode of validation for entered data.
		 * Flags: IR */
		validationMode?: ValidationMode; // Flags=IR
	} // DSRequestProps


	/**
	 * Request sent to the server to initiate a dataSourceOperations','DataSource operation. All properties which are legal on RPCRequest are legal, in addition to the properties listed here. 
	 */
	export interface DSRequest extends RPCRequest {
		/** For fetch, add or update operation, an optional comma separated list of fields to fetch from another, related DataSource. Fields should be specified in the format "localFieldName!relatedDataSourceID.relatedDataSourceFieldName". where relatedDataSourceID is the ID of the related dataSource, and relatedDataSourceFieldName is the field for which you want to fetch related values. The returned field values will be stored on the data returned to the client under the specified localFieldName. Note that this will be applied in addition to any specified DSRequest.outputs. Note that as with DataSourceField.includeFrom, the related dataSource must be linked to the primary datasource via a foreignKey relationship. Note additionalOutputs sent in request from the browser can be completely disabled in server_properties','server.properties by setting datasource.allowClientAdditionalOutputs: datasource.allowClientAdditionalOutputs: false In this case DSRequest.additionalOutputs sent from the browser will be cleared before executing request. Note that programatically configured additionalOutputs are always allowed, but you can't modify them from within a DMI method, so the only way to execute a request with additionalOutputs that differ from what was sent by the client is to create a new DSRequest
		 * Flags: IRA */
		additionalOutputs: string /* String */;

		/** A callback method that will be called with an instance of DSResponse, as sent by the server. Queuing does not affect callbacks in any way - your specified callback will be invoked for each DSRequest that contained a callback regardless of whether the request was sent as part of a queue or not. Note that if the request encounters an error (such as 500 server error), by default the callback will not be fired. Instead, RPCManager.handleError is called to invoke the default system-wide error handling. Set RPCRequest.willHandleError','willHandleError:true to have your callback invoked regardless of whether there are errors; however, make sure your callback properly handles malformed responses when RPCResponse.status is non-zero. See the errorHandling','error handling overview below for more details.
		 * Flags: IR, Group: errorHandling */
		callback: DSCallback;

		/** An object to be held onto for the duration of the DSRequest turnaround to track application-specific context. When a DataSource request completes, the clientContext is available in the DSCallback as dsResponse.clientContext. The clientContext is never sent to the server. The clientContext is useful for holding onto state that will be used when the DSCallback fires, such as the name of a component that will receive the returned data.
		 * Flags: IRW */
		clientContext: any /* Object */;

		/** For requests submitted by a DataBoundComponent, the Canvas.ID of the submitting component. This ID will be present for operations including automatic saves by a ListGrid editing','during editing, or calls to DynamicForm.saveData','form.saveData(). It will not be present for a direct call to a DataSource method such as DataSource.fetchData. Note this is the component's String ID - you can retrieve the component itself via Canvas.getById. This property should be used for debugging purposes only - do not use it to trigger differences in server-side behavior, instead, use DSRequest.operationId because only operationId is considered when assessing dsRequestEquivalence','request equivalence.
		 * Flags: IR */
		componentId: string /* String */;

		/** Data, such as search criteria or an updated record, to be acted upon. Contents differ by operationType, see dataSourceOperations','DataSource Operations for details. This field is generally filled in by passing the "data" argument to methods such as ListGrid.fetchData.
		 * Flags: IR */
		data: Array<any> /* Object or Array of Object */;

		/** DataSource.dataProtocol','DataProtocol for this particular request. Note: Typically developers should use DataSource.operationBindings','operation bindings to specify an explicit data protocol for a request. One exception: advanced developers may wish to have a custom DataSource.transformRequest','request transformer with entirely client-side handling for some requests. This may be achieved by setting the request's dataProtocol to DSProtocol','"clientCustom" within transformRequest, and also triggering application code which will fire DataSource.processResponse when complete. The DataSource.getDataProtocol method may be used to determine what data protocol will be used to handle a specific request based on this property (if set), otherwise the settings at the OperationBinding.dataProtocol','operationBinding or DataSource.dataProtocol','dataSource levels.
		 * Flags: IRW */
		dataProtocol: DSProtocol;

		/** DataSource this DSRequest will act on. This property is generally automatically populated, for example when calling DataSource.fetchData the dataSource property is set to the target DataSource.
		 * Flags: IR */
		dataSource: string /* String */;

		/** End row of requested results, used only with fetch operations. Note that startRow and endRow are zero-based, inclusive at the beginning and exclusive at the end (like substring), so startRow: 0, endRow: 1 is a request for the first record.
		 * Flags: IR, Group: paging */
		endRow: number;

		/** The format in which the data should be exported. See ExportFormat for more information.
		 * Flags: IR */
		exportAs: ExportFormat;

		/** When using RPCManager.exportContent to produce a .pdf from a SmartClient UI, this property allows dynamic CSS to be passed to the server. Since the exportContent() system already provides a way to specify a custom skin or additional stylesheet for export, exportCSS should only be used for small bits of CSS that are necessarily dynamic. For example, when printing a very wide page, such as a grid with many columns or a very wide chart, you could send the string "@page {size: A4 landscape; }" as exportCSS to cause the generated PDF to use landscape mode, so that all content fits without clipping.
		 * Flags: IR */
		exportCSS: string /* String */;

		/** Only applies to request properties passed to ListGrid.exportClientData. If specified this property contains an arbitrary set of data to be exported.
		 * Flags: IR */
		exportData: Array<any> /* Array of Record */;

		/** When exporting via ListGrid.exportClientData to an XLS or OOXML spreadsheet, forces dates to export as a string rather than a true date value. If a date value is provided to a spreadsheet as a string, Excel or other spreadsheet applications may not recognize them as being date values that are valid for use in date-specific functions in formulas, filters, etc. For this reason, the default behavior of exportClientData is to provide date values to the spreadsheet as true date values. If FormatString','Format Strings are provided via properties like DataSourceField.format','dataSourceField.format these will be translated to Excel / OpenOffice format strings and used when generating spreadsheets. Other formatting logic, such as ListGridField.formatCellValue','cell formatters, will not be used since they cannot be automatically translated to an Excel format string. If no translatable format string is available, date values will be provided to the spreadsheet with no formatter and the spreadsheet program's default formatting for date values will be used. If exportDatesAsFormattedString is set to true, date fields will appear as strings that exactly match the formatting shown in the DataBoundComponent. As noted above, this means the spreadsheet program will not recognize the value as a date.
		 * Flags: IR, Group: exportFormatting */
		exportDatesAsFormattedString: boolean;

		/** The character to use as a field-separator in CSV exports. The default delimiter is comma.
		 * Flags: IR */
		exportDelimiter: string /* String */;

		/** Specifies whether the exported data will be downloaded as an attachment or displayed in a new browser window. See ExportDisplay for more information.
		 * Flags: IR */
		exportDisplay: ExportDisplay;

		/** The list of field names to export. If provided, the field list in the exported output is limited and sorted as per the list. If exportFields is not provided: If we are exporting via DSRequest.exportData','exportData(), the field list in the exported output is every non-hidden field defined in the DataSource, in DataSource definition order If we are exporting via ListGrid.exportClientData','exportClientData() and we are not exporting to OOXML, or we are exporting to OOXML but we are not DSRequest.exportStreaming','streaming, the field list in the exported output is based on the client data sent up, taking every row into account (so if there is a value for field "foo" only in row 57, we will output a column "foo", the cells of which are empty except for row 57) If we are exporting via ListGrid.exportClientData','exportClientData() and we are exporting to OOXML and streaming is in force (the default for OOXML), the field list in the exported output is based on the client data sent up, taking just the first row into account (so if there is a value for field "foo" only in row 57, we will not output a column "foo" at all) 
		 * Flags: IR */
		exportFields: Array<string> /* Array of String */;

		/** The name of the file to save the exported data into. If DSRequest.exportToFilesystem','exportToFilesystem is set, this is the name of the file the server creates on its filesystem. If DSRequest.exportToClient','exportToClient is set, this is the filename that will appear to the browser. If the exportFilename that you specify does not include an extension, one will be added to it based on the ExportFormat specified by DSRequest.exportAs.
		 * Flags: IR */
		exportFilename: string /* String */;

		/** Optional text to appear at the end of the file.
		 * Flags: IR */
		exportFooter: string /* String */;

		/** Optional text to appear at the beginning of the file.
		 * Flags: IR */
		exportHeader: string /* String */;

		/** This property allows omitting column names from CSV and Excel exports (no effect on JSON or XML exports).
		 * Flags: IRW */
		exportHeaderless: boolean /* Boolean */;

		/** The image format in which the SVG graphic should be exported.
		 * Flags: IR */
		exportImageFormat: ExportImageFormat;

		/** If exporting in ExportImageFormat','JPEG format, the output JPEG quality level. This is a number from 0 to 1, with 1 representing the best quality and 0 representing the least quality but smallest file size.
		 * Flags: IR */
		exportImageQuality: number /* float */;

		/** If DSRequest.exportToFilesystem','exportToFilesystem is set, optionally specifies a path to use when saving the file. This path is relative to the default export path, which is set using the server_properties','server.properties setting export.location; this is the project webRoot by default. For example, with the default setting of export.location, an exportPath of "shared/ds" and an DSRequest.exportFilename','exportFilename of "exportedData.csv", SmartClient Server would export to file $webRoot/shared/ds/exportedData.csv. If you do not specify this property, SmartClient Server will export to the file indicated by exportFilename directly in the default export location. This property is only applicable when DSRequest.exportToFilesystem','exportToFilesystem is set.
		 * Flags: IR */
		exportPath: string /* String */;

		/** Determines the PropertyIdentifier to be used in the exported data. This essentially means, should we export internal field names like "countryCode" or "EMPLOYEE_NO", or localized descriptive field titles like "code du pays" or "Employee Number". This setting has a lot in common with DSRequest.exportRawValues; both are largely dependent on whether the exported data is intended for direct consumption by an end user (in which case it is appropriate to export formatted values and localized field titles), or for interface to some downstream computer system (in which case you probably want raw, unformatted values and internal field names). If this property is not set, the following defaults apply: If the export format is a native spreadsheet format (XLS or OOXML), localized field titles are used If the export format is CSV, XML or JSON and this is a client-driven export (ie it was initiated by a call to ListGrid.exportClientData','exportClientData()), localized field titles are used If the export format is CSV, XML or JSON and this is not a client-driven export, internal field names are used 
		 * Flags: IRW, Group: exportFormatting */
		exportPropertyIdentifier: PropertyIdentifier;

		/** Whether formatting settings should be applied to data being exported. Default behavior and the effect of setting of exportRawValues is described in the exportFormatting','Export Formatting overview.
		 * Flags: IRW, Group: exportFormatting */
		exportRawValues: boolean /* Boolean */;

		/** When set, causes the results of the DSRequest to be exported to a file, whose name and format are indicated by DSRequest.exportFilename and DSRequest.exportAs respectively. When no exportFilename is provided, the default is Results.csv and the default value of exportAs is csv. The export field-list can also be configured, see DSRequest.exportFields. Formats for exported date and numeric are controlled by several settings - see exportFormatting for an overview. Once the operation completes, DSRequest.exportDisplay specifies whether the exported data should be downloaded to the file-system or displayed in a new window. The default value of exportDisplay is "download" which displays the Save As dialog. See ExportDisplay for more information. You can configure the style of LineBreakStyle','line-breaks to use when generating the output, the DSRequest.exportDelimiter','delimiter to use when exporting to CSV and the DSRequest.exportTitleSeparatorChar','separator-character to use in field-titles when exporting to XML. Additionally, you can output arbitrary text before and after the exported data by setting DSRequest.exportHeader','exportHeader and DSRequest.exportFooter','exportFooter. Note that for security reasons, an export initiated using dsRequest properties does not provide support for JSON format (see <a href="http://forums.smartclient.com/showthread.php?t=235">this post</a> for more detail). However, you can use operationBinding.exportAs:"json" in a server-side .ds.xml file to force JSON export to be allowed. As well as setting dsRequest.exportResults and related properties, exports can be initiated in two other ways, via OperationBindings and via custom server code which sets export-related properties on the DSResponse. Both of those methods support exporting to JSON format. Format Examples XML format &lt;List&gt; &lt;Object&gt; &lt;id&gt;10101&lt;/id&gt; &lt;displayName&gt;Record 10101&lt;/displayName&gt; &lt;/Object&gt; &lt;/List&gt; JSON Format [ { id: 10101, displayName: "Record 10101" } ] CSV Format id,displayName 10101,"Record 10101" 
		 * Flags: IR */
		exportResults: boolean /* Boolean */;

		/** When you erxport a ListGrid that has ListGrid.headerSpans','headerSpans, should headerSpans also be exported. See DSRequest.exportSpanTitleSeparator for details of of what it means to export headerSpans to different export targets.
		 * Flags: IR */
		exportShowHeaderSpanTitles: boolean /* Boolean */;

		/** When you export a ListGrid that has ListGrid.headerSpans','headerSpans defined and DSRequest.exportShowHeaderSpanTitles is true, the behavior is dependent on the export type. Direct exports to Excel formats (both XLS and OOXML) place the headerSpans in merged cells in the spreadsheet, giving the same visual effect as the original ListGrid. This is not possible with exports to CSV format; instead, we alter the exported headers so that they contain the titles of the ancestor headerSpan(s). For example, if you had a field titled "Population" inside a headerSpan titled "National", nested inside another headerSpan titled "Demographics", that would result in the exported field being titled "Demographics - National - Population". The exportSpanTitleSeparator property allows you to override the separator string used when constructing these amalgamated headers.
		 * Flags: IR */
		exportSpanTitleSeparator: string /* String */;

		/** When exporting to OOXML format (this is the standard file format used by Excel 2007 and later), we default to using streaming mode, for memory efficiency. You can override this for individual exports by setting this flag false. You may wish to do this if you need to grab the spreadsheet object in a DMI and do something with it. The underlying object in use - POI's SXSSFWorkbook - is intended for write only and cannot usefully be read. You can switch off Excel streaming altogether by setting "excel.useStreaming" false in server.properties. Note, OOXML is the only native Excel format that supports streaming: when exporting to the older XLS format, we build the spreadsheet in its entirety in server-side memory before writing it to disk or returning it to the client. This is unlikely to change: streaming the XLS format is impractical bcause it is a self-referential binary format, and in any case the problem of huge exports overflowing JVM memory is less likely to arise with XLS, because it is innately limited to 65535 rows.
		 * Flags: IR */
		exportStreaming: boolean;

		/** The character with which to replace spaces in field-titles when exporting to XML. If not specified in the request, the server uses "".
		 * Flags: IR */
		exportTitleSeparatorChar: string /* String */;

		/** If set, SmartClient Server will export data back to the client, either as a file download or as content in a new browser window, depending on the setting of DSRequest.exportDisplay','exportDisplay. Note that it is perfectly valid to specify both this property and DSRequest.exportToFilesystem','exportToFilesystem; in this case the data is both exported to a file on the server filesystem, and downloaded to the client. If you specify <em>neither</em> property, the export no-ops.
		 * Flags: IR */
		exportToClient: boolean /* Boolean */;

		/** If set, SmartClient Server will export data to a file on the server filesystem. The file we export to is determined by the DSRequest.exportFilename','exportFilename and DSRequest.exportPath','exportPath. Note that filesystem exports are disabled by default, for security reasons. To enable them, set export.allow.filesystem to true in your server.properties file. If you enable filesystem exports, you should also consider setting a default export path, as described in the DSRequest.exportPath','exportPath documentation. Note that it is perfectly valid to specify both this property and DSRequest.exportToClient','exportToClient; in this case the data is both exported to a file on the server filesystem <em>and</em> downloaded to the client. If you specify <em>neither</em> property, the export no-ops. It is possible to redirect the filesystem export to make use of an OutputStream you provide. You use this when you want to make some use of the export document other than writing it to a disk file - for example, attaching it to an email or writing it to a database table. See the server-side Javadocs for DSRequest.setExportTo().
		 * Flags: IR */
		exportToFilesystem: boolean /* Boolean */;

		/** For server-side export with ExportFormat "xls" or "ooxml" only, timezone to use when saving values from FieldType "datetime" to the spreadsheet. This setting exists because MS Excel&trade; has no concept of providing a true datetime value that is timezone-independent and will display in the local timezone where the Excel program is launched. Instead, datetime values must be provided as a rendered string, which implies rendering in a particular timezone when the spreadsheet is generated. exportTZ can either be specified as a timezone offset in the same format expected by Time.setDefaultDisplayTimezone (for example, "+01:00" for one hour after GMT) or as the special constants "client" (meaning the current client display timezone) or "server" (meaning the timezone of the server). Default if unspecified is "server". This setting does not affect fields of type "date" or "time", which are timezone-independent values. See dateFormatAndStorage for more information on how SmartClient handles date, time and datetime values. All non-spreadsheet export formats always use UTC. This setting also does not affect client-driven exports (DataSource.exportClientData), which always use client-side time.
		 * Flags: IR, Group: exportFormatting */
		exportTZ: string /* String */;

		/** This flag has a different meaning depending on whether you are doing a client-driven or server-driven export. For ListGrid.exportClientData','exportClientData() calls (client-driven), ordinarily any fields that have a ListGridField.displayField','displayField defined have the value of that displayField exported, rather than the underlying value in the ListGridField.valueField','valueField. If you set the exportValueFields property, we export both the underlying value and the displayField value. Again for exportClientData() calls, any fields that have a ListGridField.valueMap','valueMap defined ordinarily have the mapped value of the field exported, rather than the underlying data value. If you set the exportValueFields property, we instead export the underlying data value. Note, there is only one field in this scenario, not a valueField and a separate displayField, so we export either the underlying data value or the mapped value, not both as in the displayField/valueField case described above. For DataBoundComponent.exportData','exportData() calls (server-driven), we ordinarily export the underlying data value of all fields. However, if you set the exportValueFields property explicitly to false, any fields that have a DataSource-defined DataSourceField.valueMap','valueMap will have the mapped value exported instead. This is similar to the client-side treatment of valueMaps, except that the defaults are reversed.
		 * Flags: IR */
		exportValueFields: boolean;

		/** A set of key:value pairs, mapping field names to expressions that will be evaluated server-side to derive a value for that field. This property allows for client-driven transactionChaining','Transaction Chaining, with some restrictions for security reasons: Normal OperationBinding.values','server-side Transaction Chaining settings for a field take precedence over this property, so server-defined rules cannot be overridden from the client Arbitrary Velocity expressions are not allowed in DSRequests sent from the client (fieldValueExpressions is also a valid property on a server-side DSRequest, and normal Velocity expressions <em>are</em> allowed in that case - see the server-side Javadoc for DSRequest.setFieldValueExpressions()). For client-originated requests, only the following bindings are allowed - see the velocitySupport','Velocity overview for details of what these values mean: $currentDate $transactionDate $userId $masterId - see DSRequestModifier.value for details References to specific fields in prior responses, via $responseData.first and $responseData.last, with or without parameters. For example, $responseData.first("myDataSource", "fetch")[0].myField. See the velocitySupport','Velocity overview for details of $responseData References to certain metadata properties of prior responses, via $responses.first and $responses.last, with or without parameters. For example, $responses.last("myDataSource", "fetch").totalRows. Note that the only properties allowed in a client-driven fieldValueExpression are: "startRow", "endRow", "totalRows" and "status"; this restriction does not apply to server-driven fieldValueExpressions. See the Velocity overview for details of $responses Normal DataSourceField.editRequiresRole','declarative security rules apply: if a field is not valid for writing, its fieldValueExpression will be ignored. Again, this only applies to client-originated requests. Note, it is possible to globally disable fieldValueExpression in client-originated requests by setting a flag in your server.properties file: dataSource.allowClientFieldValueExpressions: false
		 * Flags: IRW, Group: transactionChaining */
		fieldValueExpressions: any /* Object */;

		/** Specifies should related updates have to be generated. If not set (or set to null) then related updates will be generated only for "add" and "update" operations. This property has to be explicitly set to true to generate related updates for "remove" operation.<p/> This functionality loads related objects from database thus affecting operation performance. For "add" and "update" operations related objects are loaded anyway and performance impact is minimal. Simple "remove" operation does not need to load related objects. Depending on database structure performance impact can be significant if this property is set to true. Note this feature works only with Hibernate/JPA data sources, see jpaHibernateRelations','JPA & Hibernate Relations for instructions how to set up relations. Table below uses "country -&gt; cities" sample data model. <table border=1 class="normal"> <tr> <td width="20%">Relation and Operation type</td> <td width="40%">Loading complete related objects</td> <td width="40%">Loading related IDs</td> </tr> <tr> <td>Many-to-one (cities -&gt; country): ADD/UPDATE</td> <td>If operation affected country, for example new city added with existing countryId, then relatedUpdate is generated. Otherwise if city is added or updated without countryId set, relatedUpdate is not generated. Note that if provided countryId does not exist, it is created.</td> <td>Same as with complete related objects, except if provided countryId does not exist, then it is not created, but reset to NULL.</td> </tr> <tr> <td>Many-to-one (cities -&gt; country): REMOVE</td> <td colSpan=2>Removes record, depending on setting generates or not relatedUpdate for parent record. For example if city record is removed and countryId is sent to the server in remove request, then country record will be generated in relatedUpdates.</td> </tr> <tr> <td>One-to-many (country -&gt; cities): ADD/UPDATE</td> <td>If add or update operation provides value sets for cities as well as for country, then cities are created/updated if necessary and relatedUpdates are generated. Note that all fields in cities value sets can be sent to server. <td>Same as with complete related objects, except you can only sent primary key values for cities.</td> <tr> <td>One-to-many (country -&gt; cities): REMOVE</td> <td colSpan=2>Removes country, depending on setting returns or not relatedUpdates for the cities of removed country, which can be either REMOVE operations of all cities if cascade enabled, or UPDATE operations setting countryId=null to all cities if cascade is disabled</td> </tr> </table> Note that Many-to-Many works the same way as One-to-Many.
		 * Flags: IRW */
		generateRelatedUpdates: boolean;

		/** List of fields to group by when using serverSummaries','server-side summarization. Valid only for an operation of type "fetch". See the serverSummaries','Server Summaries overview for details and examples of usage.
		 * Flags: IR, Group: serverSummaries */
		groupBy: Array<string> /* Array of String */;

		/** For DataSources using SOAP messaging with a WSDL web service, data to be serialized to form SOAP headers, as a map from the header part name to the data. See WSRequest.headerData for more information. SOAP headers typically contain request metadata such as a session id for authentication, and so dsRequest.headerData is typically populated by DataSource.transformRequest, or, for data that applies to every request sent to the server, by WebService.getHeaderData. Note that this only applies to SOAP headers. General HTTP headers for requests may be modified using RPCRequest.httpHeaders.
		 * Flags: IRW */
		headerData: any /* Object */;

		/** This property is for advanced use in integrating trees that TreeGrid.loadDataOnDemand','load data on demand using data paging. When this flag is set, a server fetch operation is expected to return all of the tree nodes that either match the provided criteria or have one or more children that match the criteria. A ResultTree with ResultTree.fetchMode','fetchMode:"paged" and with ResultTree.keepParentsOnFilter','keepParentsOnFilter enabled will automatically set this property to true on all DSRequests that it sends to the server. Currently, no built-in server-side connectors (SQL, JPA, Hibernate) implement support for the keepParentsOnFilter flag.
		 * Flags: IRW, Group: treeDataBinding */
		keepParentsOnFilter: boolean /* Boolean */;

		/** The style of line-breaks to use in the exported output. See LineBreakStyle for more information.
		 * Flags: IR */
		lineBreakStyle: string /* String */;

		/** For an update or remove operation, the original values from the record that is being updated or removed. oldValues is automatically added to DSRequests submitted by DataBound Components. Available on the server via DSRequest.getOldValues(). The server can compare the oldValues to the most recent stored values in order to detect that the user was looking at stale values when the user submitted changes (NOTE: this means of detecting concurrent edit is sometimes called "optimistic concurrency" or "long transactions"). In applications where a policy of "last update wins" is not appropriate when updating certain fields, special UI can be shown for this case. For example, on detecting concurrent edit, the server may send back a special dsResponse.status code that the client application detects, offering the user a choice of proceeding with the operation, discarding edits, or reconciling new and old values in a special interface.
		 * Flags: IR */
		oldValues: any /* Record */;

		/** When a DataBoundComponent sends a DSRequest, the dsRequest.operationId will be automatically picked up from the fetchOperation, addOperation, etc properties of the DataBoundComponent. The operationId serves as an identifier that you can use to create variations on the 4 basic DataSource operations that are used by different components in different parts of your application. For example, you may be using a standard fetch operation in one part of your application, however on another screen you want to perform a fetch operation on the same DataSource but interpret search criteria differently (eg full text search). If you declare more than one OperationBinding for the same OperationBinding.operationType, you can specify an operationId OperationBinding.operationId','on the operationBinding which will cause that operationBinding to be used for dsRequests containing a matching operationId. This allows all the possible settings of an operationBinding, including OperationBinding.wsOperation','wsOperation or dmiOverview','DMI settings, to be switched on a per-component or per-request basis. For example, by setting the fetchOperation on a particular ListGrid, you could cause it to invoke a different server method via DMI, different OperationBinding.dataURL','dataURL or different OperationBinding.wsOperation','web service operation. The operationId can also be directly received by the server in order to affect behavior. When using the SmartClient Server, operationId can be accessed via dsRequest.getOperationId(). The RestDataSource will also send the operationId to the server as part of the RestDataSource.metaDataPrefix','request metadata. Note that if you DataSource.fetchData','manually invoke a DataSource operation, you can also specify operationId via the requestProperties parameter. Note that the operationId has special significance in terms of whether two DSRequests are considered equivalent for caching and synchronization purposes - see dsRequestEquivalence.
		 * Flags: IR, Group: operations */
		operationId: string /* String */;

		/** Type of operation being performed: "fetch", "add", "remove", "update" or "custom". This property is generally automatically populated, for example when calling fetchData() on a DataSource or DataBound component the operationType is automatically set to "fetch". Note that "custom" operations are never generated automatically, they are always fired by your code.
		 * Flags: IR */
		operationType: DSOperationType;

		/** The list of fields to return in the response, specified as a comma-separated string (eg, "foo, bar, baz"). You can use this property to indicate to the server that you are only interested in a subset of the fields that would normally be returned. Note that you cannot use this property to request a <em>superset</em> of the fields that would normally be returned, because that would be a security hole. It is possible to configure individual OperationBindings to return extra fields, but this must be done in the server's DataSource descriptor; it cannot be altered on the fly from the client side.
		 * Flags: IR */
		outputs: string /* String */;

		/** For advanced use in integrating trees that TreeGrid.loadDataOnDemand','load data on demand with web services, parentNode is automatically set in "fetch" DSRequests issued by a databound TreeGrid that is loading children for that parentNode. This is sometimes needed if a web service requires that additional properties beyond the ID of the parentNode must be passed in order to accomplished level-by-level loading. A custom implementation of DataSource.transformRequest can access dsRequest.parentNode and add any such properties to DSRequest.data. parentNode will also be automatically set by a TreeGrid performing databound reparenting of nodes, as implemented by TreeGrid.folderDrop. This property can only be read. There is no meaning to setting this property yourself.
		 * Flags: R */
		parentNode: TreeNode;

		/** Indicates that a validation request is being made for a record that will ultimately be saved with an "add" request, as opposed to an "update" request. This context is necessary for some validators because the nature of the validation depends on whether we are adding or updating a record. The system sets this flag when processing interim validations, such as those fired when DynamicForm.validateOnChange is in force.
		 * Flags: IR */
		pendingAdd: boolean;

		/** Sets DataSource.progressiveLoading','progressive loading mode for this specific request, overriding the OperationBinding- and DataSource-level settings. Note that this setting applies only to fetch requests - it has no effect if specified on any other kind of request.
		 * Flags: IRW, Group: progressiveLoading */
		progressiveLoading: boolean;

		/** Automatically generated unique ID for this request. This ID will be required by developers making use of the DSProtocol','"clientCustom" dataProtocol.
		 * Flags: RA */
		requestId: string /* String */;

		/** For advanced use in integrating dataset paging with web services, the ResultSet that issued this "fetch" DSRequest is automatically made available as the resultSet property. This property can only be read. There is no meaning to setting this property yourself.
		 * Flags: R */
		resultSet: ResultSet;

		/** For advanced use in integrating trees that ResultTree.loadDataOnDemand','load data on demand with web services, the ResultTree that issued this "fetch" DSRequest is automatically made available as the resultTree property. This property can only be read. There is no meaning to setting this property yourself.
		 * Flags: R */
		resultTree: ResultTree;

		/** This is a per-request flag for explicitly controlling whether the cache is used (bypassing it when not wanted, or using it when settings would indicate otherwise). See DataSource.cacheAllData, DataSource.cacheAllOperationId and DataSource.cacheAcrossOperationIds for caching management for all requests of a dataSource.
		 * Flags: IRW */
		shouldUseCache: boolean;

		/** Fieldname to sortBy, prefixed with optional "-" indicating descending sort. For example, to sort by the field "userName" in ascending order, set sortBy to just "userName". For descending sort on "userName", set sortBy to "-userName". To sort by multiple fields, an Array of Strings is also supported. For example, to sort by the field "department" in ascending order, followed by the field "userName" in descending order, set sortBy to: [ "department", "-userName" ] Additionally, this property supports an array of SortSpecifier objects. Setting sortBy to the following SortSpecifier array results in the same multi-level sort mentioned above: [ &nbsp;&nbsp;{ property: "department", direction: "ascending" }, &nbsp;&nbsp;{ property: "userName", direction: "descending" } ] 
		 * Flags: IR */
		sortBy: Array<SortSpecifier> /* String | Array of String or Array of SortSpecifiers */;

		/** Starting row of requested results, used only with fetch operations. If unset, 0 is assumed. Note that startRow and endRow are zero-based, inclusive at the beginning and exclusive at the end (like substring), so startRow: 0, endRow: 1 is a request for the first record.
		 * Flags: IR, Group: paging */
		startRow: number;

		/** If true, results will be streamed on the server, rather than all records being read into server memory at once; this approach is appropriate for retrieving or exporting large datasets without swamping the server. Although this property can be set without any particular concerns (small datasets can be streamed just as readily as large ones), bear in mind that although streaming enables the processing of very large datasets, processing and downloading very large datasets in a normal client/server flow will very rarely give an acceptable user experience. Streaming is of more practical use in a batch setting - for example, a disconnected DSRequest.exportToFilesystem','export. Note that streaming requires specific server support; of SmartClient's built-in DataSource types, only SQLDataSource is able to stream results. This property is ignored by other DataSource types. If you wish to implement the necessary server-side behavior to support streaming with a custom DataSource, see the the server-side Javadocs for DSResponse.hasNextRecord() and DSResponse.nextRecordAsObject(). See also the server-side documentation for DSResponse, SQLDataSource and StreamingResponseIterator. Note, that streaming results does not support fields with SummaryFunction','"concat" summary function on non-Oracle databases. Such fields will be skipped.
		 * Flags: IR */
		streamResults: boolean;

		/** A mapping from field names to SummaryFunction','summary functions to be applied to each field. Valid only for an operation of type "fetch". See the serverSummaries','Server Summaries overview for examples of usage.
		 * Flags: IR, Group: serverSummaries */
		summaryFunctions: any /* Object<String,SummaryFunction> */;

		/** For "fetch" operations, how search criteria should be interpreted for text fields: one of "exact" for exact match, "exactCase" for case-sensitive exact match, "startsWith" for matching at the beginning only, or "substring" for substring match. All textMatchStyle settings except "exactCase" are case-insensitive; use AdvancedCriteria for greater control over matching. This property defaults to the value of DataSource.defaultTextMatchStyle if it is not explicitly provided on the DSRequest. Note, however, that DSRequests issued by ListGrids and other DataBoundComponent','components will generally have a setting for textMatchStyle on the component itself (see ListGrid.autoFetchTextMatchStyle, for example). This setting is respected by the built-in server-side connectors for SQL, JPA and Hibernate. A custom server-side DataSource implementation should generally respect this flag as well, or server-side filtering will not match client-side filtering, which will require ResultSet.useClientFiltering','disabling client-side filtering, a huge performance loss.
		 * Flags: IR */
		textMatchStyle: TextMatchStyle;

		/** When useFlatFields is set for a request to be sent to a WSDL web service, when creating the input XML message to send to the web service, properties in DSRequest.data','request.data will be used as the values for XML elements of the same name, at any level of nesting. useFlatFields allows you to ignore gratuitous XML message structure, such as extra levels of nested elements, and provides some insulation against changes in the required structure of the input message. For example, given this input message: &lt;FindServices&gt; &lt;searchFor&gt;search text&lt;/searchFor&gt; &lt;Options&gt; &lt;caseSensitive&gt;false&lt;/caseSensitive&gt; &lt;/Options&gt; &lt;IncludeInSearch&gt; &lt;serviceName&gt;true&lt;/serviceName&gt; &lt;documentation&gt;true&lt;/documentation&gt; &lt;keywords&gt;true&lt;/keywords&gt; &lt;/IncludeInSearch&gt; &lt;/FindServices&gt; If useFlatFields were not set, in order to fill out this message correctly, request.data would need to be: { searchFor: "search text", Options : { caseSensitive: false, }, IncludeInSearch : { serviceName: true, documentation : true, keywords : true } } However if useFlatFields were set, request.data could be just: { searchFor: "search text", caseSensitive: false, serviceName: true, documentation : true, keywords : true } useFlatFields is often set when the input data comes from a DynamicForm to avoid the cumbersome and fragile process of mapping input fields to an XML structure. OperationBinding.useFlatFields can also be set to cause all dsRequests of a particular type to useFlatFields automatically. For DataBoundComponent','DataBoundComponents, DataBoundComponent.useFlatFields','component.useFlatFields can be set use "flattened" binding to fields of a WSDL message or XML Schema. Note that useFlatFields is not generally recommended for use with XML input messages where multiple simple type fields exist with the same name, however if used in this way, the first field to use a given name wins. "first" means the first field encountered in a depth first search. "wins" means only the first field will be populated in the generated XML message.
		 * Flags: IR, Group: flatFields */
		useFlatFields: boolean /* Boolean */;

		/** Cause the DSRequest.useFlatFields','useFlatFields XML serialization behavior to be used for all soap headers in the request. See also DSRequest.headerData.
		 * Flags: IRW, Group: flatFields */
		useFlatHeaderFields: boolean;

		/** Should the HTTP response to this request be formatted using the strict JSON subset of the javascript language? If set to true, responses returned by the server should match the format described <a href='http://www.json.org/js.html' target='_blank'>here</a>. Only applies to requests sent a server with DataSource.dataFormat set to "json" or "iscServer".
		 * Flags: IR */
		useStrictJSON: boolean;

		/** Mode of validation for entered data.
		 * Flags: IR */
		validationMode: ValidationMode;

	} // DSRequest

	export interface DSRequestStatic<T, P> extends RPCRequestStatic<T, P> {
	} // DSRequestStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a DynamicForm Props argument.
	 * This is derived from the methods in the DynamicForm class and it's parents and their properties marked with the I flag.
	 */
	export interface DynamicFormProps extends CanvasProps {
		/** The URL to which the form will submit its values. NOTE: this is used only in the very rare case that a form is used to submit data directly to a URL. Normal server contact is through RPCManager. See DynamicForm.canSubmit for more on this.
		 * Flags: IRW, Group: submitting */
		action?: string; // Flags=IRW
		/** For a form that produces filter criteria (see DynamicForm.getValuesAsCriteria','form.getValuesAsCriteria()), allows the user to enter simple expressions in any field in this form that takes text input. Also note that enabling allowExpressions for an entire form changes the DynamicForm.defaultSearchOperator to DataSource.translatePatternOperators','"iContainsPattern", so that simple search expressions similar to SQL "LIKE" patterns can be entered in most fields. See FormItem.allowExpressions for details.
		 * Flags: IRW, Group: advancedFilter */
		allowExpressions?: boolean; // Flags=IRW
		/** Should this form allow browser auto-completion of its items' values? Applies only to items based on native HTML form elements (TextItem, PasswordItem, etc), and will only have a user-visible impact for browsers where native autoComplete behavior is actually supported and enabled via user settings. This property may be explicitly specified per item via FormItem.autoComplete. Note that even with this value set to "none", native browser auto-completion may occur for log in forms (forms containing username and PasswordItem','password fields). This behavior varies by browser, and is a result of an <a href='https://www.google.com/search?q=password+ignores+autocomplete+off' target='_blank'>intentional change by some browser developers</a> to disregard the HTML setting autocomplete=off for password items or log-in forms.
		 * Flags: IRW, Group: autoComplete */
		autoComplete?: AutoComplete; // Flags=IRW
		/** If true, when this component is first drawn, automatically call this.fetchData(). Criteria for this fetch may be picked up from DynamicForm.initialCriteria, and textMatchStyle may be specified via ListGrid.autoFetchTextMatchStyle','autoFetchTextMatchStyle. <span style='color:red'>NOTE:</span> if autoFetchData is set, calling ListGrid.fetchData','fetchData() before draw will cause two requests to be issued, one from the manual call to fetchData() and one from the autoFetchData setting. The second request will use only DynamicForm.initialCriteria and not any other criteria or settings from the first request. Generally, turn off autoFetchData if you are going to manually call ListGrid.fetchData','fetchData() at any time.
		 * Flags: IR, Group: databinding */
		autoFetchData?: boolean; // Flags=IR
		/** If DynamicForm.autoFetchData is true, this attribute allows the developer to specify a textMatchStyle for the initial ListGrid.fetchData','fetchData() call.
		 * Flags: IR, Group: databinding */
		autoFetchTextMatchStyle?: TextMatchStyle; // Flags=IR
		/** If true, when the form is drawn, focus will automatically be put into the first focusable element in the form. Note that to put focus in a different item you can explicitly call dynamicForm.focusInItem(itemName)
		 * Flags: IRW, Group: focus */
		autoFocus?: boolean /* Boolean */; // Flags=IRW
		/** If true, when DynamicForm.validate','validation fails focus will automatically be put into the first focusable field which failed validation.
		 * Flags: IRW, Group: focus */
		autoFocusOnError?: boolean /* Boolean */; // Flags=IRW
		/** If this browser has a 'spellCheck' feature for text-based form item elements, should it be used for items in this form? Can be overridden at the item level via FormItem.browserSpellCheck Notes: - this property only applies to text based items such as TextItem and TextAreaItem. - this property is not supported on all browsers.
		 * Flags: IRW */
		browserSpellCheck?: boolean /* Boolean */; // Flags=IRW
		/** The name of the special field sent to the server as part of DynamicForm.cancel
		 * Flags: IRW */
		cancelParamName?: string /* String */; // Flags=IRW
		/** The value of the special field sent to the server as part of DynamicForm.cancel
		 * Flags: IRW */
		cancelParamValue?: string /* String */; // Flags=IRW
		/** If set to false, the form will be marked read-only. A widget on the form is editable if either (1) beginning with the widget and continuing up the containment hierarchy, including the form, the first widget to have a non-null canEdit attribute has canEdit:true, or (2) neither the widget nor any parent has a non-null canEdit attribute. This setting allows you to enable or disable the default editability of the form's items at one time. This setting differs from the enabled/disabled state in that most form items will allow copying of the contents while read-only but do not while disabled. Note that a form is considered editable if canEdit is null (default) or true. 
		 * Flags: IRWA, Group: readOnly */
		canEdit?: boolean /* Boolean */; // Flags=IRWA
		/** If this component is bound to a dataSource, this attribute may be specified to customize what fields from the dataSource may be edited by default. For example the SearchForm class has this attribute set to "canFilter" which allows search forms to edit dataSource fields marked as canEdit:false (but not those marked as canFilter:false). Note that if canEdit is explicitly specified on a field in the DataBoundComponent.fields array, that property will be respected in preference to the canEditAttribute value. (See FormItem.canEdit, ListGridField.canEdit). Also note that individual dataBoundComponents may have additional logic around whether a field can be edited - for example ListGrid.canEditCell may be overridden.
		 * Flags: IRA */
		canEditFieldAttribute?: string /* identifier */; // Flags=IRA
		/** DynamicForms are considered to have focus if any of their form items have focus. Note that setting dynamicForm.canFocus to false will have no effect on whether form items within the form may receive focus. This property will only govern whether the form may receive focus if the form contains no focusable items.
		 * Flags: IRWA, Group: focus */
		canFocus?: boolean /* Boolean */; // Flags=IRWA
		/** Governs whether this form will be used to perform a standard HTML form submission. Note that if true, DynamicForm.submit will perform a native HTML submission to the specified DynamicForm.action URL. Wherever possible we strongly recommend using the dataBoundComponentMethods','DataBound Component Methods to send data to the server as they provide a far more sophisticated interface, with built in options for server validation, required fields, etc.
		 * Flags: IRWA, Group: submitting */
		canSubmit?: boolean /* Boolean */; // Flags=IRWA
		/** Should users be able to tab into the FormItem.icons','icons and FormItem.showPickerIcon','picker icon for items within this form by default? May be overridden at the item level by FormItem.canTabToIcons. Developers may also suppress tabbing to individual icons by setting FormItemIcon.tabIndex to -1.
		 * Flags: IRWA, Group: formIcons */
		canTabToIcons?: boolean /* Boolean */; // Flags=IRWA
		/** If true, the headers for any SectionStackSection.items','SectionItems will be included in the page's tab order for accessibility. May also be set at the item level via SectionItem.canTabToHeader If unset, section headers will be focusable if isc.setScreenReaderMode has been called. See accessibility.
		 * Flags: IRA */
		canTabToSectionHeaders?: boolean; // Flags=IRA
		/** Width of border for the table that form is drawn in. This is primarily used for debugging form layout.
		 * Flags: IRW, Group: formLayout */
		cellBorder?: number; // Flags=IRW
		/** The amount of empty space, in pixels, surrounding each form item within its cell in the layout grid.
		 * Flags: IRW, Group: formLayout */
		cellPadding?: number; // Flags=IRW
		/** Should the titles for form items be clipped if they are too large for the available space? Can be overridden for individual items via FormItem.clipTitle.
		 * Flags: IRW */
		clipItemTitles?: boolean; // Flags=IRW
		/** Default FormItem.clipStaticValue setting for items in this form. When unset, this is equivalent to false.
		 * Flags: IR */
		clipStaticValue?: boolean /* Boolean */; // Flags=IR
		/** An array of widths for the columns of items in this form's layout grid. If specified, these widths should sum to the total width of the form (form.width). If not specified, we assume every other column will contain form item titles, and so should have form.titleWidth, and all other columns should share the remaining space. Acceptable values for each element in the array are: A number (e.g. 100) representing the number of pixel widths to allocate to a column. A percent (e.g. 20%) representing the percentage of the total form.width to allocate to a column. "*" (all) to allocate remaining width (form.width minus all specified column widths). Multiple columns can use "*", in which case remaining width is divided between all columns marked "*". 
		 * Flags: IRW, Group: formLayout */
		colWidths?: Array<any> /* Array */; // Flags=IRW
		/** How to fetch and manage records retrieve from the server. See FetchMode. This setting only applies to the ResultSet automatically created by calling ListGrid.fetchData','fetchData(). If a pre-existing ResultSet is passed to setData() instead, it's existing setting for ResultSet.fetchMode applies.
		 * Flags: IRW, Group: databinding */
		dataFetchMode?: FetchMode; // Flags=IRW
		/** The DataSource that this component should bind to for default fields and for performing DSRequest','DataSource requests. Can be specified as either a DataSource instance or the String ID of a DataSource.
		 * Flags: IRW, Group: databinding */
		dataSource?: DataSource | string /* DataSource or ID */; // Flags=IRW
		/** Default DateDisplayFormat for Date type values displayed in this form. If some field's value is set to a native Date object, how should it be displayed to the user? If specified this is the default display format to use, and will apply to all fields except those specified as FormItem.type','type:"time" (See DynamicForm.timeFormatter). May be overridden at the component level for fields of type datetime via DynamicForm.datetimeFormatter. Note that if specified, FormItem.dateFormatter and FormItem.timeFormatter take precedence over the format specified at the component level. If no explicit formatter is specified at the field or component level, dates will be formatted according to the system-wide DateUtil.setShortDisplayFormat','short date display format or DateUtil.setShortDatetimeDisplayFormat','short datetime display format depending on the specified field type.
		 * Flags: IRW */
		dateFormatter?: DateDisplayFormat; // Flags=IRW
		/** Default DateDisplayFormat for Date type values displayed in this form in fields of type datetime. For datetime fields, this attribute will be used instead of DynamicForm.dateFormatter when formatting Date values. Note that if specified, FormItem.dateFormatter and FormItem.timeFormatter take precedence over the format specified at the component level. If no explicit formatter is specified at the field or component level, datetime field values will be formatted according to the system-wide DateUtil.setShortDatetimeDisplayFormat','short datetime display format.
		 * Flags: IRW */
		datetimeFormatter?: DateDisplayFormat; // Flags=IRW
		/** Default OperatorId','search operator to use for fields in a form that produces AdvancedCriteria. Default is "iContains" unless DynamicForm.allowExpressions is enabled for the form as a whole, in which case the default is DataSource.translatePatternOperators','"iContainsPattern". Does not apply to special fields where exact match is obviously the right default setting, such as fields of type:"enum", or fields with a FormItem.valueMap','valueMap or FormItem.optionDataSource','optionDataSource. defaultSearchOperator also has no effect in a form that does not produce AdvancedCriteria - see DynamicForm.getValuesAsCriteria for settings that cause a form to produce AdvancedCriteria.
		 * Flags: IR */
		defaultSearchOperator?: OperatorId; // Flags=IR
		/** If set to true, client-side validators will not run on the form when validate() is called. Server-side validators (if any) will still run on attempted save.
		 * Flags: IRW, Group: validation */
		disableValidation?: boolean; // Flags=IRW
		/** Default class used to construct the EditProxy for this component when the component is Canvas.setEditMode','first placed into edit mode.
		 * Flags: IR */
		editProxyConstructor?: string /* SCClassName */; // Flags=IR
		/** encoding for the form, use MULTIPART_ENCODING for file upload forms
		 * Flags: IRWA, Group: submitting */
		encoding?: Encoding; // Flags=IRWA
		/** If DynamicForm.showInlineErrors is false we show all errors for the form item in a single item rendered at the top of the form. This attribute specifies the cellStyle to apply to this item.
		 * Flags: IR, Group: validation */
		errorItemCellStyle?: string; // Flags=IR
		/** If DynamicForm.showInlineErrors is false we show all errors for the form item in a single item rendered at the top of the form. This attribute contains a properties block for this item.
		 * Flags: IRA, Group: validation */
		errorItemProperties?: any /* object */; // Flags=IRA
		/** If DynamicForm.showInlineErrors is true, where should the error icon and text appear relative to form items? Valid options are "top", "bottom", "left" or "right". May be overridden at the item level via FormItem.errorOrientation.
		 * Flags: IRW, Group: validation */
		errorOrientation?: string /* align */; // Flags=IRW
		/** A property list of itemName:errorMessage pairs, specifying the set of error messages displayed with the corresponding form elements. Each errorMessage may be either a single string or an array of strings.
		 * Flags: IRW, Group: validation */
		errors?: Array<any> /* array */; // Flags=IRW
		/** If DynamicForm.showInlineErrors is false, all errors for the items in the form are rendered as a single item at the top of the form. This attribute specifies an introductory message rendered out before the individual error messages.
		 * Flags: IR, Group: validation */
		errorsPreamble?: string /* HTMLString */; // Flags=IR
		/** An array of field objects, specifying the order, layout, and types of each field in the DynamicForm. When both dynamicForm.fields and dynamicForm.dataSource are set, dynamicForm.fields acts as a set of overrides as explained in DataBoundComponent.fields. See formLayout','Form Layout for information about how flags specified on the FormItems control how the form is laid out.
		 * Flags: IRW, Group: items */
		fields?: Array<FormItemProps> /* Array of FormItem Properties */; // Flags=IRW
		/** If true, we ensure that column widths are at least as large as you specify them. This means that if any single column overflows (due to, eg, a long unbreakable title), the form as a whole overflows. If false, columns will have their specified sizes as long as no column overflows. If any column overflows, space will be taken from any other columns that aren't filling the available room, until there is no more free space, in which case the form as a whole overflows.
		 * Flags: IRW, Group: formLayout */
		fixedColWidths?: boolean /* Boolean */; // Flags=IRW
		/** Warning to display to the user if an attempt to DynamicForm.submitForm','natively submit a form is unable to submit to the server. The most common cause for this failure is that the user has typed an invalid file-path into an upload type field.
		 * Flags: IRWA, Group: i18nMessages */
		formSubmitFailedWarning?: string /* String */; // Flags=IRWA
		/** Indicates whether the titles of required items in this form should use the special prefix and suffix specified by the next two properties, instead of the standard prefix and suffix.
		 * Flags: IRW, Group: formTitles */
		hiliteRequiredFields?: boolean /* Boolean */; // Flags=IRW
		/** When true, indicates that changes to items in this form will be automatically saved on a DynamicForm.implicitSaveDelay','delay, as well as when the entire form is submitted. Unless DynamicForm.implicitSaveOnBlur','form.implicitSaveOnBlur is set to false, changes will also be automatically saved on editorExit for each item. This attribute can also be set directly on FormItems.
		 * Flags: IRW */
		implicitSave?: boolean /* Boolean */; // Flags=IRW
		/** When DynamicForm.implicitSave','implicitSave is true, this attribute dictates the millisecond delay after which form items are automatically saved during editing.
		 * Flags: IRW */
		implicitSaveDelay?: number; // Flags=IRW
		/** If true, form item values will be automatically saved when each item's "editorExit" handler is fired as well as on a delay and when the entire form is submitted. This attribute can also be set directly on FormItems.
		 * Flags: IRW */
		implicitSaveOnBlur?: boolean /* Boolean */; // Flags=IRW
		/** Criteria to be used when DynamicForm.autoFetchData is set. This property supports dynamicCriteria - use Criterion.valuePath to refer to values in the Canvas.ruleScope.
		 * Flags: IR, Group: searchCriteria */
		initialCriteria?: Criteria; // Flags=IR
		/** Text alignment for hovers shown for items
		 * Flags: IRW, Group: Hovers */
		itemHoverAlign?: Alignment; // Flags=IRW
		/** If the user rolls over an item, how long a delay before we fire any hover action / show a hover for that item?
		 * Flags: IRW, Group: Hovers */
		itemHoverDelay?: number; // Flags=IRW
		/** A default height for hovers shown for items
		 * Flags: IRW, Group: Hovers */
		itemHoverHeight?: any /* measure */; // Flags=IRW
		/** Opacity for hovers shown for items
		 * Flags: IRW, Group: Hovers */
		itemHoverOpacity?: number; // Flags=IRW
		/** CSS Style for hovers shown for items
		 * Flags: IRW, Group: Hovers */
		itemHoverStyle?: string /* CSSStyleName */; // Flags=IRW
		/** Vertical text alignment for hovers shown for items
		 * Flags: IRW, Group: Hovers */
		itemHoverVAlign?: any /* measure */; // Flags=IRW
		/** A default width for hovers shown for items
		 * Flags: IRW, Group: Hovers */
		itemHoverWidth?: any /* measure */; // Flags=IRW
		/** Layout style to use with this form. The default of "table" uses a tabular layout similar to HTML tables, but with much more powerful control over sizing, item visibility and reflow, overflow handling, etc. itemLayout:"absolute" allows absolute positioning of every form item. This provides maximum flexibility in placement, with the following limitations: titles, which normally take up an adjacent cell, are not shown. Use StaticTextItems to show titles no automatic reflow when showing or hiding items. FormItem.setLeft and FormItem.setTop can be used for manual reflow. only pixel and percent sizes are allowed, no "*". Percent widths mean percentage of the overall form size rather than the column size with different font styling or internationalized titles, items may overlap that did not overlap in the skin used at design time 
		 * Flags: IRWA, Group: formLayout */
		itemLayout?: string /* FormLayoutType */; // Flags=IRWA
		/** Synonym for DynamicForm.fields
		 * Flags: IRW, Group: items */
		items?: Array<FormItemProps> /* Array of FormItem Properties */; // Flags=IRW
		/** When creating form items for fields with text type data, if the specified length of the field exceeds this threshold we will create form item of type this.longTextEditorType (a TextAreaItem by default), rather than a simple text item. Overridden by explicitly specifying editorType for the field.
		 * Flags: IRW, Group: appearance */
		longTextEditorThreshold?: number; // Flags=IRW
		/** Name of the Form Item class to use for text fields which exceed the longTextEditorThreshold for this form.
		 * Flags: IRW, Group: appearance */
		longTextEditorType?: string; // Flags=IRW
		/** The mechanism by which form data is sent to the action URL. See FormMethod type for details. NOTE: this is used only in the very rare case that a form is used to submit data directly to a URL. Normal server contact is through dataBoundComponentMethods','DataBound Component Methods.
		 * Flags: IRW, Group: submitting */
		method?: FormMethod; // Flags=IRW
		/** Minimum width of a form column.
		 * Flags: IRW, Group: formLayout */
		minColWidth?: number; // Flags=IRW
		/** Minimum horizontal space made available for FormItem.hint text. Typically this reflects how much space the hint text takes up before it wraps. May be overridden at the item level via FormItem.minHintWidth. This setting does not apply to hints that are TextItem.showHintInField','shown in field.
		 * Flags: IR */
		minHintWidth?: number /* Integer */; // Flags=IR
		/** FormItem class to use for any singular (ie, non-list) complex fields on this DynamicForm.
		 * Flags: IRW */
		nestedEditorType?: string /* String */; // Flags=IRW
		/** FormItem class to use for any list-type complex fields on this DynamicForm. List-type fields are denoted by marking them multiple: true in the DataSource.
		 * Flags: IRW */
		nestedListEditorType?: string /* String */; // Flags=IRW
		/** A message to display to the user if server-side validation fails with an error but the server did not provide an error message
		 * Flags: IRW, Group: validation */
		noErrorDetailsMessage?: string /* String */; // Flags=IRW
		/** The number of columns of titles and items in this form's layout grid. A title and corresponding item each have their own column, so to display two form elements per row (each having a title and item), you would set this property to 4.
		 * Flags: IRW, Group: formLayout */
		numCols?: number; // Flags=IRW
		/** When FormItem.operator has been set for any FormItem in this form, what logical operator should be applied across the Criterion','criteria produced by the form items? Only applicable to forms that have a DataBoundComponent.dataSource','dataSource.
		 * Flags: IR */
		operator?: string /* OperationId */; // Flags=IR
		/** Default template HTML string when an item does not set its own FormItem.originalValueMessage. Variables in the template are substituted as follows: <table border="1"> <tr> <th>Variable</th> <th>Substitution</th> </tr> <tr> <td>$value</td> <td>The item's old value as stored in the object returned by DynamicForm.getOldValues.</td> </tr> <tr> <td>$newValue</td> <td>The item's new value.</td> </tr> </table> For $value and $newValue, any formatters or stored/display value mapping will be applied.
		 * Flags: IRWA, Group: i18nMessages */
		originalValueMessage?: string /* HTMLString */; // Flags=IRWA
		/** If DynamicForm.canEdit is set to false, how should the items in this form be displayed to the user? Can be overridden via FormItem.readOnlyDisplay on individual form items.
		 * Flags: IRW, Group: readOnly */
		readOnlyDisplay?: ReadOnlyDisplayAppearance; // Flags=IRW
		/** Default FormItem.readOnlyTextBoxStyle setting for items in this form.
		 * Flags: IRW */
		readOnlyTextBoxStyle?: string /* FormItemBaseStyle */; // Flags=IRW
		/** If validateOnChange is true, and validation fails for an item on change, with no suggested value, should we revert to the previous value, or continue to display the bad value entered by the user. May be set at the item or form level.
		 * Flags: IRWA */
		rejectInvalidValueOnChange?: boolean; // Flags=IRWA
		/** The required message for required field errors.
		 * Flags: IRW, Group: formTitles */
		requiredMessage?: string /* HTMLString */; // Flags=IRW
		/** The string pre-pended to the title of every required item in this form if DynamicForm.hiliteRequiredFields is true and the TitleOrientation property is set to "right".
		 * Flags: IRW, Group: formTitles */
		requiredRightTitlePrefix?: string /* HTMLString */; // Flags=IRW
		/** The string appended to the title of every required item in this form if DynamicForm.hiliteRequiredFields is true and the TitleOrientation property is set to "right".
		 * Flags: IRW, Group: formTitles */
		requiredRightTitleSuffix?: string /* HTMLString */; // Flags=IRW
		/** The string pre-pended to the title of every required item in this form if DynamicForm.hiliteRequiredFields is true.
		 * Flags: IRW, Group: formTitles */
		requiredTitlePrefix?: string /* HTMLString */; // Flags=IRW
		/** The string appended to the title of every required item in this form if DynamicForm.hiliteRequiredFields is true.
		 * Flags: IRW, Group: formTitles */
		requiredTitleSuffix?: string /* HTMLString */; // Flags=IRW
		/** Keyboard shortcut that causes the value of the currently focused form item to be reverted to whatever value would be shown if DynamicForm.resetValues were called.
		 * Flags: IR */
		revertValueKey?: string /* KeyIdentifier */; // Flags=IR
		/** The string pre-pended to the title of an item in this form if its titleOrientation property is set to "right".
		 * Flags: IRW, Group: formTitles */
		rightTitlePrefix?: string /* HTMLString */; // Flags=IRW
		/** The string appended to the title of an item in this form if its titleOrientation property is set to "right".
		 * Flags: IRW, Group: formTitles */
		rightTitleSuffix?: string /* HTMLString */; // Flags=IRW
		/** If true, when the user hits the Enter key while focused in a text-item in this form, we automatically submit the form to the server using the DynamicForm.submit method.
		 * Flags: IRW, Group: submitting */
		saveOnEnter?: boolean /* Boolean */; // Flags=IRW
		/** Default DSOperationType to be performed when DynamicForm.saveData is called. This property is automatically set on a call to DynamicForm.editRecord or DynamicForm.editNewRecord, or may be set directly via DynamicForm.setSaveOperationType. If saveOperationType is unset, the form will heuristically determine whether an "add" or "update" operation is intended based on whether the primaryKey field is present and editable.
		 * Flags: IRW */
		saveOperationType?: DSOperationType; // Flags=IRW
		/** If the form has sections, [implemented as SectionItems], this attribute controls whether multiple sections can be expanded at once.
		 * Flags: IRW, Group: formLayout */
		sectionVisibilityMode?: VisibilityMode; // Flags=IRW
		/** If this property is set to true, whenever a text-based field in this form (TextItem, TextAreaItem) is given focus - whether programmatically (see DynamicForm.focusInItem), or via a mouse click, all text within the item will be selected. If you only want the value to be selected when on programmatic focus or keyboard navigation (this is the native browser behavior), set DynamicForm.selectOnFocus','selectOnFocus instead. May be overridden at the form item level via FormItem.selectOnClick.
		 * Flags: IRW, Group: focus */
		selectOnClick?: boolean /* Boolean */; // Flags=IRW
		/** If this property is set to true, whenever a text-based field in this form (TextItem, TextAreaItem) is given focus programmatically (see DynamicForm.focusInItem), all text within the item will be selected. Note that this flag affects only programmatic focus. It's the normal behavior of text fields to select all text if the user navigates into them via keyboard, or if the user navigates via mouse, to place the text insertion point at the mouse click, and SmartClient preserves these behaviors. selectOnFocus is only needed for cases like a form within a pop-up dialog that should have the first field selected. If you also want the value to be selected when the user clicks on the field, set DynamicForm.selectOnClick','selectOnClick instead. If selectOnFocus is false, the selection is not modified on focus - any previous selection within the item will be maintained. May be overridden at the form item level via FormItem.selectOnFocus.
		 * Flags: IRW, Group: focus */
		selectOnFocus?: boolean /* Boolean */; // Flags=IRW
		/** If set, this DynamicForm will set both DataBoundComponent.showComplexFields','showComplexFields and showComplexFieldsRecursively on any nested component used for showing/editing a complex field. Thus any of this form's items that handle complex fields will themselves also show complex fields. This allows for handling of field structures of any complexity. If set, this value automatically sets DataBoundComponent.showComplexFields','showComplexFields as well.
		 * Flags: IR */
		showComplexFieldsRecursively?: boolean /* Boolean */; // Flags=IR
		/** Default FormItem.showDeletions setting for items in this form.
		 * Flags: IRA */
		showDeletions?: boolean /* Boolean */; // Flags=IRA
		/** For databound forms, whether to show fields marked as detail fields.
		 * Flags: IR */
		showDetailFields?: boolean /* Boolean */; // Flags=IR
		/** DynamicForm.showErrorIcons','showErrorIcons, DynamicForm.showErrorText','showErrorText, and DynamicForm.showErrorStyle','showErrorStyle control how validation errors are displayed when they are displayed inline in the form (next to the form item where there is a validation error). To instead display all errors at the top of the form, set DynamicForm.showInlineErrors','showInlineErrors:false. showErrorIcons, showErrorText and showErrorStyle are all boolean properties, and can be set on a DynamicForm to control the behavior form-wide, or set on individual FormItems. The HTML displayed next to a form item with errors is generated by FormItem.getErrorHTML. The default implementation of that method respects showErrorIcons and showErrorText as follows: showErrorIcons, or showErrorIcon at the FormItem level controls whether an error icon should appear next to fields which have validation errors. The icon's appearance is governed by FormItem.errorIconSrc, FormItem.errorIconWidth and FormItem.errorIconHeight showErrorText determines whether the text of the validation error should be displayed next to fields which have validation errors. The attribute DynamicForm.showTitlesWithErrorMessages may be set to prefix error messages with the form item's title + ":" (may be desired if the item has FormItem.showTitle set to false). DynamicForm.errorOrientation controls where the error HTML should appear relative to form items. Therefore the combination of DynamicForm.showErrorText:false and DynamicForm.errorOrientation:"left" creates a compact validation error display consisting of just an icon, to the left of the item with the error message available via a hover (similar appearance to ListGrid validation error display). In addition to this, showErrorStyle determines whether fields with validation errors should have special styling applied to them. Error styling is achieved by applying suffixes to existing styling applied to various parts of the form item. See FormItemBaseStyle for more on this.
		 * Flags: IRW, Group: validation */
		showErrorIcons?: boolean /* Boolean */; // Flags=IRW
		/** DynamicForm.showErrorIcons','showErrorIcons, DynamicForm.showErrorText','showErrorText, and DynamicForm.showErrorStyle','showErrorStyle control how validation errors are displayed when they are displayed inline in the form (next to the form item where there is a validation error). To instead display all errors at the top of the form, set DynamicForm.showInlineErrors','showInlineErrors:false. showErrorIcons, showErrorText and showErrorStyle are all boolean properties, and can be set on a DynamicForm to control the behavior form-wide, or set on individual FormItems. The HTML displayed next to a form item with errors is generated by FormItem.getErrorHTML. The default implementation of that method respects showErrorIcons and showErrorText as follows: showErrorIcons, or showErrorIcon at the FormItem level controls whether an error icon should appear next to fields which have validation errors. The icon's appearance is governed by FormItem.errorIconSrc, FormItem.errorIconWidth and FormItem.errorIconHeight showErrorText determines whether the text of the validation error should be displayed next to fields which have validation errors. The attribute DynamicForm.showTitlesWithErrorMessages may be set to prefix error messages with the form item's title + ":" (may be desired if the item has FormItem.showTitle set to false). DynamicForm.errorOrientation controls where the error HTML should appear relative to form items. Therefore the combination of DynamicForm.showErrorText:false and DynamicForm.errorOrientation:"left" creates a compact validation error display consisting of just an icon, to the left of the item with the error message available via a hover (similar appearance to ListGrid validation error display). In addition to this, showErrorStyle determines whether fields with validation errors should have special styling applied to them. Error styling is achieved by applying suffixes to existing styling applied to various parts of the form item. See FormItemBaseStyle for more on this.
		 * Flags: IRW, Group: validation */
		showErrorStyle?: boolean /* Boolean */; // Flags=IRW
		/** DynamicForm.showErrorIcons','showErrorIcons, DynamicForm.showErrorText','showErrorText, and DynamicForm.showErrorStyle','showErrorStyle control how validation errors are displayed when they are displayed inline in the form (next to the form item where there is a validation error). To instead display all errors at the top of the form, set DynamicForm.showInlineErrors','showInlineErrors:false. showErrorIcons, showErrorText and showErrorStyle are all boolean properties, and can be set on a DynamicForm to control the behavior form-wide, or set on individual FormItems. The HTML displayed next to a form item with errors is generated by FormItem.getErrorHTML. The default implementation of that method respects showErrorIcons and showErrorText as follows: showErrorIcons, or showErrorIcon at the FormItem level controls whether an error icon should appear next to fields which have validation errors. The icon's appearance is governed by FormItem.errorIconSrc, FormItem.errorIconWidth and FormItem.errorIconHeight showErrorText determines whether the text of the validation error should be displayed next to fields which have validation errors. The attribute DynamicForm.showTitlesWithErrorMessages may be set to prefix error messages with the form item's title + ":" (may be desired if the item has FormItem.showTitle set to false). DynamicForm.errorOrientation controls where the error HTML should appear relative to form items. Therefore the combination of DynamicForm.showErrorText:false and DynamicForm.errorOrientation:"left" creates a compact validation error display consisting of just an icon, to the left of the item with the error message available via a hover (similar appearance to ListGrid validation error display). In addition to this, showErrorStyle determines whether fields with validation errors should have special styling applied to them. Error styling is achieved by applying suffixes to existing styling applied to various parts of the form item. See FormItemBaseStyle for more on this.
		 * Flags: IRW, Group: validation */
		showErrorText?: boolean /* Boolean */; // Flags=IRW
		/** If true, field errors are written into the form next to the item(s) where the errors occurred. Errors may appear as text or just an icon (via DynamicForm.showErrorText:false). If false, errors are written at the top of the form. To do some other kind of error display, override DynamicForm.showErrors.
		 * Flags: IRW, Group: validation */
		showInlineErrors?: boolean /* Boolean */; // Flags=IRW
		/** Default setting for the form items' FormItem.showOldValueInHover setting.
		 * Flags: IRWA */
		showOldValueInHover?: boolean /* Boolean */; // Flags=IRWA
		/** This property applies to all of the items that a form has, and works according to FormItem.showPending. Also, in a form with showPending:true, an individual FormItem can set showPending:false and vice versa.
		 * Flags: IRA */
		showPending?: boolean /* Boolean */; // Flags=IRA
		/** Indicates whether on validation failure, the error message displayed to the user should be pre-pended with the title for the item.
		 * Flags: IRW, Group: validation */
		showTitlesWithErrorMessages?: boolean /* Boolean */; // Flags=IRW
		/** Indicates that if validation fails, the user should not be allowed to exit the field - focus will be forced back into the field until the error is corrected. Enabling this property also implies FormItem.validateOnExit is automatically enabled. If there are server-based validators on this item, setting this property also implies that FormItem.synchronousValidation is forced on.
		 * Flags: IR */
		stopOnError?: boolean; // Flags=IR
		/** When calling DynamicForm.saveData on a form or valuesManager, by default if the server returns an error code, any callback passed into saveData() will not be fired. If the error code returned by the server indicates a validation error, it will be displayed to the user by updating the form items to show the error messages, and firing any specified hiddenValidationErrors handler, otherwise the standard RPCManager error handling logic would be invoked. Developers who want to handle errors themselves can override this default by specifying RPCRequest.willHandleError','dsRequest.willHandleError on the DSRequest. In this case the callback passed in will be fired even if the server returns an error status code. If suppressValidationErrorCallback is set to true, if a save attempt returns a validation error code, the user-specified callback will not be fired even if willHandleError:true was specified on the dsRequest - though for other error codes, the callback would be fired if willHandleError is specified on the request. Note that this is the historical behavior for SmartClient builds 8.0 and earlier 
		 * Flags: IRWA */
		suppressValidationErrorCallback?: boolean /* Boolean */; // Flags=IRWA
		/** If enabled, whenever validation is triggered and a request to the server is required, user interactivity will be blocked until the request returns. Can be set for the entire form or individual FormItems. If false, the form will try to avoid blocking user interaction until it is strictly required. That is until the user attempts to use a FormItem whose state could be affected by a server request that has not yet returned.
		 * Flags: IR */
		synchronousValidation?: boolean /* Boolean */; // Flags=IR
		/** The name of a window or frame that will receive the results returned by the form's action. The default null indicates to use the current frame. NOTE: this is used only in the very rare case that a form is used to submit data directly to a URL. Normal server contact is through dataBoundComponentMethods','DataBound Component Methods.
		 * Flags: IRWA, Group: submitting */
		target?: string; // Flags=IRWA
		/** Default TimeDisplayFormat for FormItem.type','type:"time" field values displayed in this form. Note that if specified, FormItem.dateFormatter and FormItem.timeFormatter take precedence over the format specified at the component level. If no explicit formatter is specified at the field or component level, time values will be formatted according to the system-wide Time.setNormalDisplayFormat','normal time display format. specified field type.
		 * Flags: IRW */
		timeFormatter?: TimeDisplayFormat; // Flags=IRW
		/** Default alignment for item titles. If unset default alignment will be derived from Page.isRTL','text direction as described in DynamicForm.getTitleAlign
		 * Flags: IRW */
		titleAlign?: Alignment; // Flags=IRW
		/** Default orientation for titles for items in this form. TitleOrientation lists valid options. Note that titles on the left or right take up a cell in tabular formLayout','form layouts, but titles on top do not.
		 * Flags: IRW, Group: formTitles */
		titleOrientation?: TitleOrientation; // Flags=IRW
		/** The string pre-pended to the title of every item in this form. See also +{requiredTitlePrefix} for fields that are required.
		 * Flags: IRW, Group: formTitles */
		titlePrefix?: string /* HTMLString */; // Flags=IRW
		/** The string appended to the title of every item in this form. See also +{requiredTitleSuffix} for fields that are required.
		 * Flags: IRW, Group: formTitles */
		titleSuffix?: string /* HTMLString */; // Flags=IRW
		/** The width in pixels allocated to the title of every item in this form. If you don't specify explicit DynamicForm.colWidths, you can set this value to the string "*" to divide the usable space evenly between titles and fields.
		 * Flags: IRW, Group: formTitles */
		titleWidth?: number | "*" /* number or "*" */; // Flags=IRW
		/** The error message for a failed validator that does not specify its own errorMessage.
		 * Flags: IRW, Group: validation */
		unknownErrorMessage?: string /* HTMLString */; // Flags=IRW
		/** Associated userTask if current dynamic form used along with workflow. See UserTask','userTask for more details.
		 * Flags: IR */
		userTask?: UserTask; // Flags=IR
		/** If true, form fields will be validated when each item's "change" handler is fired as well as when the entire form is submitted or validated. Note that this property can also be set at the item level or on each validator to enable finer granularity validation in response to user interaction. If true at the form or field level, validators not explicitly set with validateOnChange:false will be fired on change - displaying errors and rejecting the change on validation failure.
		 * Flags: IRW, Group: validation */
		validateOnChange?: boolean /* Boolean */; // Flags=IRW
		/** If true, form items will be validated when each item's "editorExit" handler is fired as well as when the entire form is submitted or validated. Note that this property can also be set at the item level to enable finer granularity validation in response to user interaction - if true at either level, validation will occur on editorExit.
		 * Flags: IRW */
		validateOnExit?: boolean /* Boolean */; // Flags=IRW
		/** validationURL can be set to do server-side validation against a different URL from where the form will ultimately save, as part of an incremental upgrade strategy for Struts and Struts-like applications. If set, calling DynamicForm.submit causes an RPC to be sent to this URL to perform server-side validation of the form values. If the validation fails, the validation errors returned by the server are rendered in the form. If the validation succeeds, the form is submitted to the URL specified by DynamicForm.action. The form values are available on the server as request parameters (just like a normal form submit) and also as the values of a DSRequest sent as an RPC alongside the normal submit. The expected response to this request is a DSResponse sent via the RPC mechanism. If validation is successful, an empty response with the STATUS_SUCCESS status code is sufficient. If there are validation errors, the DSResponse should have the status set to STATUS_VALIDATION_ERROR and the errors should be set on the response via the addError()/setErrorReport() API on DSResponse. See the javadoc for DSResponse for details. See the Struts examples in [webroot]/examples/struts for usage examples.
		 * Flags: IRW, Group: validation */
		validationURL?: string /* URL */; // Flags=IRW
		/** An Object containing the initial values of the form as properties, where each propertyName is the name of a Items','form item in the form, and each property value is the value held by that form item. The form's values may contain values that are not managed by any FormItem, and these values will be preserved and available when the form values are subsequently retrieved via DynamicForm.getValues. Providing values on initialization is equivalent to calling DynamicForm.setValues. As the user manipulates form items to change values, change events fire FormItem.change','on the items and DynamicForm.itemChange','on the form as a whole. Note that form values are logical values, for example, the value of a DateItem is a JavaScript Date object, not a String, even if the user enters the date via a text input. Likewise the value of a TextItem or CheckboxItem that started out null remains null until the user changes it; the value will not be automatically converted to the null string ("") or false respectively, as happens with native HTML elements.
		 * Flags: IRW, Group: formValues */
		values?: any /* Object */; // Flags=IRW
		/** Should items within this form that are showing a FormItem.hint have the hint text wrap? May be overridden at the item level via FormItem.wrapHintText. If wrapHintText is unset on both the form and item, then the default behavior is not wrapping the hint. This setting does not apply to hints that are TextItem.showHintInField','shown in field.
		 * Flags: IR */
		wrapHintText?: boolean /* Boolean */; // Flags=IR
		/** Whether titles for form items should wrap. If not specified, titles will wrap by default. Can be overridden for individual items via FormItem.wrapTitle
		 * Flags: IRW, Group: formTitles */
		wrapItemTitles?: boolean; // Flags=IRW

		/* Method Overrides */

		/** 
		 * Retrieve data that matches the provided criteria, and edit the first record returned 
		 * @param {Criteria} criteria - search criteria
		 * @param {DSCallback} callback - callback to invoke on completion
		 * @param {DSRequest} requestProperties - additional properties to set on the DSRequest that will be issued
		 */
		fetchData?(criteria?:Criteria, callback?:DSCallback, requestProperties?:DSRequest): void; 

		/** 
		 * Synonym for dynamicForm.getItem()
		 * @param {string} itemName - name of the item you're looking for
		 */
		getField?(itemName:string): FormItem; 

		/** 
		 * Retrieve a FormItem in this form by it's FormItem.name','name, FormItem.dataPath','dataPath, or index within the DynamicForm.items','items array. FormItems that also have a FormItem.ID may be accessed directly as a global variable window[itemID] or just itemID
		 * @param {string} itemName - name of the item you're looking for
		 */
		getItem?(itemName:string | number /* string or int */): FormItem; 

		/** 
		 * Returns the value stored in the form for some field. Shorthand for dynamicForm.getValues()[fieldName];
		 * @param {string} fieldName - name of the field for which you're retrieving a value. Nested values may be retrieved by passing in a DataPath
		 */
		getValue?(fieldName:string): any; 

	} // DynamicFormProps


	/**
	 * The DynamicForm manages a collection of FormItems which represent user input controls. The DynamicForm provides formLayout','layout, value management, validation and databinding for the controls it manages. To create a DynamicForm, set DynamicForm.fields to an Array of Objects describing the FormItems you want to use. For example: isc.DynamicForm.create({ fields:[ {name:"userName", type:"text"}, // creates a TextItem {name:"usState", type:"select"} // creates a SelectItem ] }) The item name is an identifier for the item that must be unique just within this form. It is used: as the name under which the item's value is stored in the form (the form's current values are accessible as DynamicForm.getValues','form.getValues() when retrieving the FormItem's current value (via DynamicForm.getValue','form.getValue()) to retrieve the item itself via DynamicForm.getItem','form.getItem() FormItems can also be created by binding the form to a DataSource via setDataSource(). In this case, FormItems are chosen based on the data type of the field - see FormItemType. You can override the automatically chosen FormItem via DataSourceField.editorType. When using DataSource binding, you can also add additional FormItems not specified in the DataSource, or override any properties on the automatically generated FormItems, without having to re-declare any information that comes from the DataSource. See the QuickStart Guide chapter on Data Binding for an overview. All FormItems share a common set of properties for controlling formLayout','form\n layout. Other properties common to all FormItems are documented on the FormItem class, and properties specific to particular FormItems are documented on the respective FormItems. NOTE: For very simple forms consisting of exactly one item, you still use a DynamicForm. See the "fontSelector" form in the toolstrip', 'Toolstrip example. 
	 */
	export interface DynamicForm extends Canvas {
		/** The URL to which the form will submit its values. NOTE: this is used only in the very rare case that a form is used to submit data directly to a URL. Normal server contact is through RPCManager. See DynamicForm.canSubmit for more on this.
		 * Flags: IRW, Group: submitting */
		action: string;

		/** For a form that produces filter criteria (see DynamicForm.getValuesAsCriteria','form.getValuesAsCriteria()), allows the user to enter simple expressions in any field in this form that takes text input. Also note that enabling allowExpressions for an entire form changes the DynamicForm.defaultSearchOperator to DataSource.translatePatternOperators','"iContainsPattern", so that simple search expressions similar to SQL "LIKE" patterns can be entered in most fields. See FormItem.allowExpressions for details.
		 * Flags: IRW, Group: advancedFilter */
		allowExpressions: boolean;

		/** Should this form allow browser auto-completion of its items' values? Applies only to items based on native HTML form elements (TextItem, PasswordItem, etc), and will only have a user-visible impact for browsers where native autoComplete behavior is actually supported and enabled via user settings. This property may be explicitly specified per item via FormItem.autoComplete. Note that even with this value set to "none", native browser auto-completion may occur for log in forms (forms containing username and PasswordItem','password fields). This behavior varies by browser, and is a result of an <a href='https://www.google.com/search?q=password+ignores+autocomplete+off' target='_blank'>intentional change by some browser developers</a> to disregard the HTML setting autocomplete=off for password items or log-in forms.
		 * Flags: IRW, Group: autoComplete */
		autoComplete: AutoComplete;

		/** If true, when this component is first drawn, automatically call this.fetchData(). Criteria for this fetch may be picked up from DynamicForm.initialCriteria, and textMatchStyle may be specified via ListGrid.autoFetchTextMatchStyle','autoFetchTextMatchStyle. <span style='color:red'>NOTE:</span> if autoFetchData is set, calling ListGrid.fetchData','fetchData() before draw will cause two requests to be issued, one from the manual call to fetchData() and one from the autoFetchData setting. The second request will use only DynamicForm.initialCriteria and not any other criteria or settings from the first request. Generally, turn off autoFetchData if you are going to manually call ListGrid.fetchData','fetchData() at any time.
		 * Flags: IR, Group: databinding */
		autoFetchData: boolean;

		/** If DynamicForm.autoFetchData is true, this attribute allows the developer to specify a textMatchStyle for the initial ListGrid.fetchData','fetchData() call.
		 * Flags: IR, Group: databinding */
		autoFetchTextMatchStyle: TextMatchStyle;

		/** If true, when the form is drawn, focus will automatically be put into the first focusable element in the form. Note that to put focus in a different item you can explicitly call dynamicForm.focusInItem(itemName)
		 * Flags: IRW, Group: focus */
		autoFocus: boolean /* Boolean */;

		/** If true, when DynamicForm.validate','validation fails focus will automatically be put into the first focusable field which failed validation.
		 * Flags: IRW, Group: focus */
		autoFocusOnError: boolean /* Boolean */;

		/** If this browser has a 'spellCheck' feature for text-based form item elements, should it be used for items in this form? Can be overridden at the item level via FormItem.browserSpellCheck Notes: - this property only applies to text based items such as TextItem and TextAreaItem. - this property is not supported on all browsers.
		 * Flags: IRW */
		browserSpellCheck: boolean /* Boolean */;

		/** The name of the special field sent to the server as part of DynamicForm.cancel
		 * Flags: IRW */
		cancelParamName: string /* String */;

		/** The value of the special field sent to the server as part of DynamicForm.cancel
		 * Flags: IRW */
		cancelParamValue: string /* String */;

		/** If set to false, the form will be marked read-only. A widget on the form is editable if either (1) beginning with the widget and continuing up the containment hierarchy, including the form, the first widget to have a non-null canEdit attribute has canEdit:true, or (2) neither the widget nor any parent has a non-null canEdit attribute. This setting allows you to enable or disable the default editability of the form's items at one time. This setting differs from the enabled/disabled state in that most form items will allow copying of the contents while read-only but do not while disabled. Note that a form is considered editable if canEdit is null (default) or true. 
		 * Flags: IRWA, Group: readOnly */
		canEdit: boolean /* Boolean */;

		/** If this component is bound to a dataSource, this attribute may be specified to customize what fields from the dataSource may be edited by default. For example the SearchForm class has this attribute set to "canFilter" which allows search forms to edit dataSource fields marked as canEdit:false (but not those marked as canFilter:false). Note that if canEdit is explicitly specified on a field in the DataBoundComponent.fields array, that property will be respected in preference to the canEditAttribute value. (See FormItem.canEdit, ListGridField.canEdit). Also note that individual dataBoundComponents may have additional logic around whether a field can be edited - for example ListGrid.canEditCell may be overridden.
		 * Flags: IRA */
		canEditFieldAttribute: string /* identifier */;

		/** DynamicForms are considered to have focus if any of their form items have focus. Note that setting dynamicForm.canFocus to false will have no effect on whether form items within the form may receive focus. This property will only govern whether the form may receive focus if the form contains no focusable items.
		 * Flags: IRWA, Group: focus */
		canFocus: boolean /* Boolean */;

		/** Governs whether this form will be used to perform a standard HTML form submission. Note that if true, DynamicForm.submit will perform a native HTML submission to the specified DynamicForm.action URL. Wherever possible we strongly recommend using the dataBoundComponentMethods','DataBound Component Methods to send data to the server as they provide a far more sophisticated interface, with built in options for server validation, required fields, etc.
		 * Flags: IRWA, Group: submitting */
		canSubmit: boolean /* Boolean */;

		/** Should users be able to tab into the FormItem.icons','icons and FormItem.showPickerIcon','picker icon for items within this form by default? May be overridden at the item level by FormItem.canTabToIcons. Developers may also suppress tabbing to individual icons by setting FormItemIcon.tabIndex to -1.
		 * Flags: IRWA, Group: formIcons */
		canTabToIcons: boolean /* Boolean */;

		/** If true, the headers for any SectionStackSection.items','SectionItems will be included in the page's tab order for accessibility. May also be set at the item level via SectionItem.canTabToHeader If unset, section headers will be focusable if isc.setScreenReaderMode has been called. See accessibility.
		 * Flags: IRA */
		canTabToSectionHeaders: boolean;

		/** Width of border for the table that form is drawn in. This is primarily used for debugging form layout.
		 * Flags: IRW, Group: formLayout */
		cellBorder: number;

		/** The amount of empty space, in pixels, surrounding each form item within its cell in the layout grid.
		 * Flags: IRW, Group: formLayout */
		cellPadding: number;

		/** Should the titles for form items be clipped if they are too large for the available space? Can be overridden for individual items via FormItem.clipTitle.
		 * Flags: IRW */
		clipItemTitles: boolean;

		/** Default FormItem.clipStaticValue setting for items in this form. When unset, this is equivalent to false.
		 * Flags: IR */
		clipStaticValue: boolean /* Boolean */;

		/** An array of widths for the columns of items in this form's layout grid. If specified, these widths should sum to the total width of the form (form.width). If not specified, we assume every other column will contain form item titles, and so should have form.titleWidth, and all other columns should share the remaining space. Acceptable values for each element in the array are: A number (e.g. 100) representing the number of pixel widths to allocate to a column. A percent (e.g. 20%) representing the percentage of the total form.width to allocate to a column. "*" (all) to allocate remaining width (form.width minus all specified column widths). Multiple columns can use "*", in which case remaining width is divided between all columns marked "*". 
		 * Flags: IRW, Group: formLayout */
		colWidths: Array<any> /* Array */;

		/** How to fetch and manage records retrieve from the server. See FetchMode. This setting only applies to the ResultSet automatically created by calling ListGrid.fetchData','fetchData(). If a pre-existing ResultSet is passed to setData() instead, it's existing setting for ResultSet.fetchMode applies.
		 * Flags: IRW, Group: databinding */
		dataFetchMode: FetchMode;

		/** The DataSource that this component should bind to for default fields and for performing DSRequest','DataSource requests. Can be specified as either a DataSource instance or the String ID of a DataSource.
		 * Flags: IRW, Group: databinding */
		dataSource: DataSource | string /* DataSource or ID */;

		/** Default DateDisplayFormat for Date type values displayed in this form. If some field's value is set to a native Date object, how should it be displayed to the user? If specified this is the default display format to use, and will apply to all fields except those specified as FormItem.type','type:"time" (See DynamicForm.timeFormatter). May be overridden at the component level for fields of type datetime via DynamicForm.datetimeFormatter. Note that if specified, FormItem.dateFormatter and FormItem.timeFormatter take precedence over the format specified at the component level. If no explicit formatter is specified at the field or component level, dates will be formatted according to the system-wide DateUtil.setShortDisplayFormat','short date display format or DateUtil.setShortDatetimeDisplayFormat','short datetime display format depending on the specified field type.
		 * Flags: IRW */
		dateFormatter: DateDisplayFormat;

		/** Default DateDisplayFormat for Date type values displayed in this form in fields of type datetime. For datetime fields, this attribute will be used instead of DynamicForm.dateFormatter when formatting Date values. Note that if specified, FormItem.dateFormatter and FormItem.timeFormatter take precedence over the format specified at the component level. If no explicit formatter is specified at the field or component level, datetime field values will be formatted according to the system-wide DateUtil.setShortDatetimeDisplayFormat','short datetime display format.
		 * Flags: IRW */
		datetimeFormatter: DateDisplayFormat;

		/** Default OperatorId','search operator to use for fields in a form that produces AdvancedCriteria. Default is "iContains" unless DynamicForm.allowExpressions is enabled for the form as a whole, in which case the default is DataSource.translatePatternOperators','"iContainsPattern". Does not apply to special fields where exact match is obviously the right default setting, such as fields of type:"enum", or fields with a FormItem.valueMap','valueMap or FormItem.optionDataSource','optionDataSource. defaultSearchOperator also has no effect in a form that does not produce AdvancedCriteria - see DynamicForm.getValuesAsCriteria for settings that cause a form to produce AdvancedCriteria.
		 * Flags: IR */
		defaultSearchOperator: OperatorId;

		/** If set to true, client-side validators will not run on the form when validate() is called. Server-side validators (if any) will still run on attempted save.
		 * Flags: IRW, Group: validation */
		disableValidation: boolean;

		/** Default class used to construct the EditProxy for this component when the component is Canvas.setEditMode','first placed into edit mode.
		 * Flags: IR */
		editProxyConstructor: string /* SCClassName */;

		/** encoding for the form, use MULTIPART_ENCODING for file upload forms
		 * Flags: IRWA, Group: submitting */
		encoding: Encoding;

		/** If DynamicForm.showInlineErrors is false we show all errors for the form item in a single item rendered at the top of the form. This attribute specifies the cellStyle to apply to this item.
		 * Flags: IR, Group: validation */
		errorItemCellStyle: string;

		/** If DynamicForm.showInlineErrors is false we show all errors for the form item in a single item rendered at the top of the form. This attribute contains a properties block for this item.
		 * Flags: IRA, Group: validation */
		errorItemProperties: any /* object */;

		/** If DynamicForm.showInlineErrors is true, where should the error icon and text appear relative to form items? Valid options are "top", "bottom", "left" or "right". May be overridden at the item level via FormItem.errorOrientation.
		 * Flags: IRW, Group: validation */
		errorOrientation: string /* align */;

		/** A property list of itemName:errorMessage pairs, specifying the set of error messages displayed with the corresponding form elements. Each errorMessage may be either a single string or an array of strings.
		 * Flags: IRW, Group: validation */
		errors: Array<any> /* array */;

		/** If DynamicForm.showInlineErrors is false, all errors for the items in the form are rendered as a single item at the top of the form. This attribute specifies an introductory message rendered out before the individual error messages.
		 * Flags: IR, Group: validation */
		errorsPreamble: string /* HTMLString */;

		/** An array of field objects, specifying the order, layout, and types of each field in the DynamicForm. When both dynamicForm.fields and dynamicForm.dataSource are set, dynamicForm.fields acts as a set of overrides as explained in DataBoundComponent.fields. See formLayout','Form Layout for information about how flags specified on the FormItems control how the form is laid out.
		 * Flags: IRW, Group: items */
		fields: Array<FormItemProps> /* Array of FormItem Properties */;

		/** If true, we ensure that column widths are at least as large as you specify them. This means that if any single column overflows (due to, eg, a long unbreakable title), the form as a whole overflows. If false, columns will have their specified sizes as long as no column overflows. If any column overflows, space will be taken from any other columns that aren't filling the available room, until there is no more free space, in which case the form as a whole overflows.
		 * Flags: IRW, Group: formLayout */
		fixedColWidths: boolean /* Boolean */;

		/** Warning to display to the user if an attempt to DynamicForm.submitForm','natively submit a form is unable to submit to the server. The most common cause for this failure is that the user has typed an invalid file-path into an upload type field.
		 * Flags: IRWA, Group: i18nMessages */
		formSubmitFailedWarning: string /* String */;

		/** Indicates whether the titles of required items in this form should use the special prefix and suffix specified by the next two properties, instead of the standard prefix and suffix.
		 * Flags: IRW, Group: formTitles */
		hiliteRequiredFields: boolean /* Boolean */;

		/** When true, indicates that changes to items in this form will be automatically saved on a DynamicForm.implicitSaveDelay','delay, as well as when the entire form is submitted. Unless DynamicForm.implicitSaveOnBlur','form.implicitSaveOnBlur is set to false, changes will also be automatically saved on editorExit for each item. This attribute can also be set directly on FormItems.
		 * Flags: IRW */
		implicitSave: boolean /* Boolean */;

		/** When DynamicForm.implicitSave','implicitSave is true, this attribute dictates the millisecond delay after which form items are automatically saved during editing.
		 * Flags: IRW */
		implicitSaveDelay: number;

		/** If true, form item values will be automatically saved when each item's "editorExit" handler is fired as well as on a delay and when the entire form is submitted. This attribute can also be set directly on FormItems.
		 * Flags: IRW */
		implicitSaveOnBlur: boolean /* Boolean */;

		/** Criteria to be used when DynamicForm.autoFetchData is set. This property supports dynamicCriteria - use Criterion.valuePath to refer to values in the Canvas.ruleScope.
		 * Flags: IR, Group: searchCriteria */
		initialCriteria: Criteria;

		/** Text alignment for hovers shown for items
		 * Flags: IRW, Group: Hovers */
		itemHoverAlign: Alignment;

		/** If the user rolls over an item, how long a delay before we fire any hover action / show a hover for that item?
		 * Flags: IRW, Group: Hovers */
		itemHoverDelay: number;

		/** A default height for hovers shown for items
		 * Flags: IRW, Group: Hovers */
		itemHoverHeight: any /* measure */;

		/** Opacity for hovers shown for items
		 * Flags: IRW, Group: Hovers */
		itemHoverOpacity: number;

		/** CSS Style for hovers shown for items
		 * Flags: IRW, Group: Hovers */
		itemHoverStyle: string /* CSSStyleName */;

		/** Vertical text alignment for hovers shown for items
		 * Flags: IRW, Group: Hovers */
		itemHoverVAlign: any /* measure */;

		/** A default width for hovers shown for items
		 * Flags: IRW, Group: Hovers */
		itemHoverWidth: any /* measure */;

		/** Layout style to use with this form. The default of "table" uses a tabular layout similar to HTML tables, but with much more powerful control over sizing, item visibility and reflow, overflow handling, etc. itemLayout:"absolute" allows absolute positioning of every form item. This provides maximum flexibility in placement, with the following limitations: titles, which normally take up an adjacent cell, are not shown. Use StaticTextItems to show titles no automatic reflow when showing or hiding items. FormItem.setLeft and FormItem.setTop can be used for manual reflow. only pixel and percent sizes are allowed, no "*". Percent widths mean percentage of the overall form size rather than the column size with different font styling or internationalized titles, items may overlap that did not overlap in the skin used at design time 
		 * Flags: IRWA, Group: formLayout */
		itemLayout: string /* FormLayoutType */;

		/** Synonym for DynamicForm.fields
		 * Flags: IRW, Group: items */
		items: Array<FormItemProps> /* Array of FormItem Properties */;

		/** When creating form items for fields with text type data, if the specified length of the field exceeds this threshold we will create form item of type this.longTextEditorType (a TextAreaItem by default), rather than a simple text item. Overridden by explicitly specifying editorType for the field.
		 * Flags: IRW, Group: appearance */
		longTextEditorThreshold: number;

		/** Name of the Form Item class to use for text fields which exceed the longTextEditorThreshold for this form.
		 * Flags: IRW, Group: appearance */
		longTextEditorType: string;

		/** The mechanism by which form data is sent to the action URL. See FormMethod type for details. NOTE: this is used only in the very rare case that a form is used to submit data directly to a URL. Normal server contact is through dataBoundComponentMethods','DataBound Component Methods.
		 * Flags: IRW, Group: submitting */
		method: FormMethod;

		/** Minimum width of a form column.
		 * Flags: IRW, Group: formLayout */
		minColWidth: number;

		/** Minimum horizontal space made available for FormItem.hint text. Typically this reflects how much space the hint text takes up before it wraps. May be overridden at the item level via FormItem.minHintWidth. This setting does not apply to hints that are TextItem.showHintInField','shown in field.
		 * Flags: IR */
		minHintWidth: number /* Integer */;

		/** FormItem class to use for any singular (ie, non-list) complex fields on this DynamicForm.
		 * Flags: IRW */
		nestedEditorType: string /* String */;

		/** FormItem class to use for any list-type complex fields on this DynamicForm. List-type fields are denoted by marking them multiple: true in the DataSource.
		 * Flags: IRW */
		nestedListEditorType: string /* String */;

		/** A message to display to the user if server-side validation fails with an error but the server did not provide an error message
		 * Flags: IRW, Group: validation */
		noErrorDetailsMessage: string /* String */;

		/** The number of columns of titles and items in this form's layout grid. A title and corresponding item each have their own column, so to display two form elements per row (each having a title and item), you would set this property to 4.
		 * Flags: IRW, Group: formLayout */
		numCols: number;

		/** When FormItem.operator has been set for any FormItem in this form, what logical operator should be applied across the Criterion','criteria produced by the form items? Only applicable to forms that have a DataBoundComponent.dataSource','dataSource.
		 * Flags: IR */
		operator: string /* OperationId */;

		/** Default template HTML string when an item does not set its own FormItem.originalValueMessage. Variables in the template are substituted as follows: <table border="1"> <tr> <th>Variable</th> <th>Substitution</th> </tr> <tr> <td>$value</td> <td>The item's old value as stored in the object returned by DynamicForm.getOldValues.</td> </tr> <tr> <td>$newValue</td> <td>The item's new value.</td> </tr> </table> For $value and $newValue, any formatters or stored/display value mapping will be applied.
		 * Flags: IRWA, Group: i18nMessages */
		originalValueMessage: string /* HTMLString */;

		/** If DynamicForm.canEdit is set to false, how should the items in this form be displayed to the user? Can be overridden via FormItem.readOnlyDisplay on individual form items.
		 * Flags: IRW, Group: readOnly */
		readOnlyDisplay: ReadOnlyDisplayAppearance;

		/** Default FormItem.readOnlyTextBoxStyle setting for items in this form.
		 * Flags: IRW */
		readOnlyTextBoxStyle: string /* FormItemBaseStyle */;

		/** If validateOnChange is true, and validation fails for an item on change, with no suggested value, should we revert to the previous value, or continue to display the bad value entered by the user. May be set at the item or form level.
		 * Flags: IRWA */
		rejectInvalidValueOnChange: boolean;

		/** The required message for required field errors.
		 * Flags: IRW, Group: formTitles */
		requiredMessage: string /* HTMLString */;

		/** The string pre-pended to the title of every required item in this form if DynamicForm.hiliteRequiredFields is true and the TitleOrientation property is set to "right".
		 * Flags: IRW, Group: formTitles */
		requiredRightTitlePrefix: string /* HTMLString */;

		/** The string appended to the title of every required item in this form if DynamicForm.hiliteRequiredFields is true and the TitleOrientation property is set to "right".
		 * Flags: IRW, Group: formTitles */
		requiredRightTitleSuffix: string /* HTMLString */;

		/** The string pre-pended to the title of every required item in this form if DynamicForm.hiliteRequiredFields is true.
		 * Flags: IRW, Group: formTitles */
		requiredTitlePrefix: string /* HTMLString */;

		/** The string appended to the title of every required item in this form if DynamicForm.hiliteRequiredFields is true.
		 * Flags: IRW, Group: formTitles */
		requiredTitleSuffix: string /* HTMLString */;

		/** Keyboard shortcut that causes the value of the currently focused form item to be reverted to whatever value would be shown if DynamicForm.resetValues were called.
		 * Flags: IR */
		revertValueKey: string /* KeyIdentifier */;

		/** The string pre-pended to the title of an item in this form if its titleOrientation property is set to "right".
		 * Flags: IRW, Group: formTitles */
		rightTitlePrefix: string /* HTMLString */;

		/** The string appended to the title of an item in this form if its titleOrientation property is set to "right".
		 * Flags: IRW, Group: formTitles */
		rightTitleSuffix: string /* HTMLString */;

		/** If true, when the user hits the Enter key while focused in a text-item in this form, we automatically submit the form to the server using the DynamicForm.submit method.
		 * Flags: IRW, Group: submitting */
		saveOnEnter: boolean /* Boolean */;

		/** Default DSOperationType to be performed when DynamicForm.saveData is called. This property is automatically set on a call to DynamicForm.editRecord or DynamicForm.editNewRecord, or may be set directly via DynamicForm.setSaveOperationType. If saveOperationType is unset, the form will heuristically determine whether an "add" or "update" operation is intended based on whether the primaryKey field is present and editable.
		 * Flags: IRW */
		saveOperationType: DSOperationType;

		/** If the form has sections, [implemented as SectionItems], this attribute controls whether multiple sections can be expanded at once.
		 * Flags: IRW, Group: formLayout */
		sectionVisibilityMode: VisibilityMode;

		/** If this property is set to true, whenever a text-based field in this form (TextItem, TextAreaItem) is given focus - whether programmatically (see DynamicForm.focusInItem), or via a mouse click, all text within the item will be selected. If you only want the value to be selected when on programmatic focus or keyboard navigation (this is the native browser behavior), set DynamicForm.selectOnFocus','selectOnFocus instead. May be overridden at the form item level via FormItem.selectOnClick.
		 * Flags: IRW, Group: focus */
		selectOnClick: boolean /* Boolean */;

		/** If this property is set to true, whenever a text-based field in this form (TextItem, TextAreaItem) is given focus programmatically (see DynamicForm.focusInItem), all text within the item will be selected. Note that this flag affects only programmatic focus. It's the normal behavior of text fields to select all text if the user navigates into them via keyboard, or if the user navigates via mouse, to place the text insertion point at the mouse click, and SmartClient preserves these behaviors. selectOnFocus is only needed for cases like a form within a pop-up dialog that should have the first field selected. If you also want the value to be selected when the user clicks on the field, set DynamicForm.selectOnClick','selectOnClick instead. If selectOnFocus is false, the selection is not modified on focus - any previous selection within the item will be maintained. May be overridden at the form item level via FormItem.selectOnFocus.
		 * Flags: IRW, Group: focus */
		selectOnFocus: boolean /* Boolean */;

		/** If set, this DynamicForm will set both DataBoundComponent.showComplexFields','showComplexFields and showComplexFieldsRecursively on any nested component used for showing/editing a complex field. Thus any of this form's items that handle complex fields will themselves also show complex fields. This allows for handling of field structures of any complexity. If set, this value automatically sets DataBoundComponent.showComplexFields','showComplexFields as well.
		 * Flags: IR */
		showComplexFieldsRecursively: boolean /* Boolean */;

		/** Default FormItem.showDeletions setting for items in this form.
		 * Flags: IRA */
		showDeletions: boolean /* Boolean */;

		/** For databound forms, whether to show fields marked as detail fields.
		 * Flags: IR */
		showDetailFields: boolean /* Boolean */;

		/** DynamicForm.showErrorIcons','showErrorIcons, DynamicForm.showErrorText','showErrorText, and DynamicForm.showErrorStyle','showErrorStyle control how validation errors are displayed when they are displayed inline in the form (next to the form item where there is a validation error). To instead display all errors at the top of the form, set DynamicForm.showInlineErrors','showInlineErrors:false. showErrorIcons, showErrorText and showErrorStyle are all boolean properties, and can be set on a DynamicForm to control the behavior form-wide, or set on individual FormItems. The HTML displayed next to a form item with errors is generated by FormItem.getErrorHTML. The default implementation of that method respects showErrorIcons and showErrorText as follows: showErrorIcons, or showErrorIcon at the FormItem level controls whether an error icon should appear next to fields which have validation errors. The icon's appearance is governed by FormItem.errorIconSrc, FormItem.errorIconWidth and FormItem.errorIconHeight showErrorText determines whether the text of the validation error should be displayed next to fields which have validation errors. The attribute DynamicForm.showTitlesWithErrorMessages may be set to prefix error messages with the form item's title + ":" (may be desired if the item has FormItem.showTitle set to false). DynamicForm.errorOrientation controls where the error HTML should appear relative to form items. Therefore the combination of DynamicForm.showErrorText:false and DynamicForm.errorOrientation:"left" creates a compact validation error display consisting of just an icon, to the left of the item with the error message available via a hover (similar appearance to ListGrid validation error display). In addition to this, showErrorStyle determines whether fields with validation errors should have special styling applied to them. Error styling is achieved by applying suffixes to existing styling applied to various parts of the form item. See FormItemBaseStyle for more on this.
		 * Flags: IRW, Group: validation */
		showErrorIcons: boolean /* Boolean */;

		/** DynamicForm.showErrorIcons','showErrorIcons, DynamicForm.showErrorText','showErrorText, and DynamicForm.showErrorStyle','showErrorStyle control how validation errors are displayed when they are displayed inline in the form (next to the form item where there is a validation error). To instead display all errors at the top of the form, set DynamicForm.showInlineErrors','showInlineErrors:false. showErrorIcons, showErrorText and showErrorStyle are all boolean properties, and can be set on a DynamicForm to control the behavior form-wide, or set on individual FormItems. The HTML displayed next to a form item with errors is generated by FormItem.getErrorHTML. The default implementation of that method respects showErrorIcons and showErrorText as follows: showErrorIcons, or showErrorIcon at the FormItem level controls whether an error icon should appear next to fields which have validation errors. The icon's appearance is governed by FormItem.errorIconSrc, FormItem.errorIconWidth and FormItem.errorIconHeight showErrorText determines whether the text of the validation error should be displayed next to fields which have validation errors. The attribute DynamicForm.showTitlesWithErrorMessages may be set to prefix error messages with the form item's title + ":" (may be desired if the item has FormItem.showTitle set to false). DynamicForm.errorOrientation controls where the error HTML should appear relative to form items. Therefore the combination of DynamicForm.showErrorText:false and DynamicForm.errorOrientation:"left" creates a compact validation error display consisting of just an icon, to the left of the item with the error message available via a hover (similar appearance to ListGrid validation error display). In addition to this, showErrorStyle determines whether fields with validation errors should have special styling applied to them. Error styling is achieved by applying suffixes to existing styling applied to various parts of the form item. See FormItemBaseStyle for more on this.
		 * Flags: IRW, Group: validation */
		showErrorStyle: boolean /* Boolean */;

		/** DynamicForm.showErrorIcons','showErrorIcons, DynamicForm.showErrorText','showErrorText, and DynamicForm.showErrorStyle','showErrorStyle control how validation errors are displayed when they are displayed inline in the form (next to the form item where there is a validation error). To instead display all errors at the top of the form, set DynamicForm.showInlineErrors','showInlineErrors:false. showErrorIcons, showErrorText and showErrorStyle are all boolean properties, and can be set on a DynamicForm to control the behavior form-wide, or set on individual FormItems. The HTML displayed next to a form item with errors is generated by FormItem.getErrorHTML. The default implementation of that method respects showErrorIcons and showErrorText as follows: showErrorIcons, or showErrorIcon at the FormItem level controls whether an error icon should appear next to fields which have validation errors. The icon's appearance is governed by FormItem.errorIconSrc, FormItem.errorIconWidth and FormItem.errorIconHeight showErrorText determines whether the text of the validation error should be displayed next to fields which have validation errors. The attribute DynamicForm.showTitlesWithErrorMessages may be set to prefix error messages with the form item's title + ":" (may be desired if the item has FormItem.showTitle set to false). DynamicForm.errorOrientation controls where the error HTML should appear relative to form items. Therefore the combination of DynamicForm.showErrorText:false and DynamicForm.errorOrientation:"left" creates a compact validation error display consisting of just an icon, to the left of the item with the error message available via a hover (similar appearance to ListGrid validation error display). In addition to this, showErrorStyle determines whether fields with validation errors should have special styling applied to them. Error styling is achieved by applying suffixes to existing styling applied to various parts of the form item. See FormItemBaseStyle for more on this.
		 * Flags: IRW, Group: validation */
		showErrorText: boolean /* Boolean */;

		/** If true, field errors are written into the form next to the item(s) where the errors occurred. Errors may appear as text or just an icon (via DynamicForm.showErrorText:false). If false, errors are written at the top of the form. To do some other kind of error display, override DynamicForm.showErrors.
		 * Flags: IRW, Group: validation */
		showInlineErrors: boolean /* Boolean */;

		/** Default setting for the form items' FormItem.showOldValueInHover setting.
		 * Flags: IRWA */
		showOldValueInHover: boolean /* Boolean */;

		/** This property applies to all of the items that a form has, and works according to FormItem.showPending. Also, in a form with showPending:true, an individual FormItem can set showPending:false and vice versa.
		 * Flags: IRA */
		showPending: boolean /* Boolean */;

		/** Indicates whether on validation failure, the error message displayed to the user should be pre-pended with the title for the item.
		 * Flags: IRW, Group: validation */
		showTitlesWithErrorMessages: boolean /* Boolean */;

		/** Indicates that if validation fails, the user should not be allowed to exit the field - focus will be forced back into the field until the error is corrected. Enabling this property also implies FormItem.validateOnExit is automatically enabled. If there are server-based validators on this item, setting this property also implies that FormItem.synchronousValidation is forced on.
		 * Flags: IR */
		stopOnError: boolean;

		/** When calling DynamicForm.saveData on a form or valuesManager, by default if the server returns an error code, any callback passed into saveData() will not be fired. If the error code returned by the server indicates a validation error, it will be displayed to the user by updating the form items to show the error messages, and firing any specified hiddenValidationErrors handler, otherwise the standard RPCManager error handling logic would be invoked. Developers who want to handle errors themselves can override this default by specifying RPCRequest.willHandleError','dsRequest.willHandleError on the DSRequest. In this case the callback passed in will be fired even if the server returns an error status code. If suppressValidationErrorCallback is set to true, if a save attempt returns a validation error code, the user-specified callback will not be fired even if willHandleError:true was specified on the dsRequest - though for other error codes, the callback would be fired if willHandleError is specified on the request. Note that this is the historical behavior for SmartClient builds 8.0 and earlier 
		 * Flags: IRWA */
		suppressValidationErrorCallback: boolean /* Boolean */;

		/** If enabled, whenever validation is triggered and a request to the server is required, user interactivity will be blocked until the request returns. Can be set for the entire form or individual FormItems. If false, the form will try to avoid blocking user interaction until it is strictly required. That is until the user attempts to use a FormItem whose state could be affected by a server request that has not yet returned.
		 * Flags: IR */
		synchronousValidation: boolean /* Boolean */;

		/** The name of a window or frame that will receive the results returned by the form's action. The default null indicates to use the current frame. NOTE: this is used only in the very rare case that a form is used to submit data directly to a URL. Normal server contact is through dataBoundComponentMethods','DataBound Component Methods.
		 * Flags: IRWA, Group: submitting */
		target: string;

		/** Default TimeDisplayFormat for FormItem.type','type:"time" field values displayed in this form. Note that if specified, FormItem.dateFormatter and FormItem.timeFormatter take precedence over the format specified at the component level. If no explicit formatter is specified at the field or component level, time values will be formatted according to the system-wide Time.setNormalDisplayFormat','normal time display format. specified field type.
		 * Flags: IRW */
		timeFormatter: TimeDisplayFormat;

		/** Default alignment for item titles. If unset default alignment will be derived from Page.isRTL','text direction as described in DynamicForm.getTitleAlign
		 * Flags: IRW */
		titleAlign: Alignment;

		/** Default orientation for titles for items in this form. TitleOrientation lists valid options. Note that titles on the left or right take up a cell in tabular formLayout','form layouts, but titles on top do not.
		 * Flags: IRW, Group: formTitles */
		titleOrientation: TitleOrientation;

		/** The string pre-pended to the title of every item in this form. See also +{requiredTitlePrefix} for fields that are required.
		 * Flags: IRW, Group: formTitles */
		titlePrefix: string /* HTMLString */;

		/** The string appended to the title of every item in this form. See also +{requiredTitleSuffix} for fields that are required.
		 * Flags: IRW, Group: formTitles */
		titleSuffix: string /* HTMLString */;

		/** The width in pixels allocated to the title of every item in this form. If you don't specify explicit DynamicForm.colWidths, you can set this value to the string "*" to divide the usable space evenly between titles and fields.
		 * Flags: IRW, Group: formTitles */
		titleWidth: number | "*" /* number or "*" */;

		/** The error message for a failed validator that does not specify its own errorMessage.
		 * Flags: IRW, Group: validation */
		unknownErrorMessage: string /* HTMLString */;

		/** Associated userTask if current dynamic form used along with workflow. See UserTask','userTask for more details.
		 * Flags: IR */
		userTask: UserTask;

		/** If true, form fields will be validated when each item's "change" handler is fired as well as when the entire form is submitted or validated. Note that this property can also be set at the item level or on each validator to enable finer granularity validation in response to user interaction. If true at the form or field level, validators not explicitly set with validateOnChange:false will be fired on change - displaying errors and rejecting the change on validation failure.
		 * Flags: IRW, Group: validation */
		validateOnChange: boolean /* Boolean */;

		/** If true, form items will be validated when each item's "editorExit" handler is fired as well as when the entire form is submitted or validated. Note that this property can also be set at the item level to enable finer granularity validation in response to user interaction - if true at either level, validation will occur on editorExit.
		 * Flags: IRW */
		validateOnExit: boolean /* Boolean */;

		/** validationURL can be set to do server-side validation against a different URL from where the form will ultimately save, as part of an incremental upgrade strategy for Struts and Struts-like applications. If set, calling DynamicForm.submit causes an RPC to be sent to this URL to perform server-side validation of the form values. If the validation fails, the validation errors returned by the server are rendered in the form. If the validation succeeds, the form is submitted to the URL specified by DynamicForm.action. The form values are available on the server as request parameters (just like a normal form submit) and also as the values of a DSRequest sent as an RPC alongside the normal submit. The expected response to this request is a DSResponse sent via the RPC mechanism. If validation is successful, an empty response with the STATUS_SUCCESS status code is sufficient. If there are validation errors, the DSResponse should have the status set to STATUS_VALIDATION_ERROR and the errors should be set on the response via the addError()/setErrorReport() API on DSResponse. See the javadoc for DSResponse for details. See the Struts examples in [webroot]/examples/struts for usage examples.
		 * Flags: IRW, Group: validation */
		validationURL: string /* URL */;

		/** An Object containing the initial values of the form as properties, where each propertyName is the name of a Items','form item in the form, and each property value is the value held by that form item. The form's values may contain values that are not managed by any FormItem, and these values will be preserved and available when the form values are subsequently retrieved via DynamicForm.getValues. Providing values on initialization is equivalent to calling DynamicForm.setValues. As the user manipulates form items to change values, change events fire FormItem.change','on the items and DynamicForm.itemChange','on the form as a whole. Note that form values are logical values, for example, the value of a DateItem is a JavaScript Date object, not a String, even if the user enters the date via a text input. Likewise the value of a TextItem or CheckboxItem that started out null remains null until the user changes it; the value will not be automatically converted to the null string ("") or false respectively, as happens with native HTML elements.
		 * Flags: IRW, Group: formValues */
		values: any /* Object */;

		/** Should items within this form that are showing a FormItem.hint have the hint text wrap? May be overridden at the item level via FormItem.wrapHintText. If wrapHintText is unset on both the form and item, then the default behavior is not wrapping the hint. This setting does not apply to hints that are TextItem.showHintInField','shown in field.
		 * Flags: IR */
		wrapHintText: boolean /* Boolean */;

		/** Whether titles for form items should wrap. If not specified, titles will wrap by default. Can be overridden for individual items via FormItem.wrapTitle
		 * Flags: IRW, Group: formTitles */
		wrapItemTitles: boolean;


		/* Instance Method Overrides */

		/** 
		 * Retrieve data that matches the provided criteria, and edit the first record returned 
		 * @param {Criteria} criteria - search criteria
		 * @param {DSCallback} callback - callback to invoke on completion
		 * @param {DSRequest} requestProperties - additional properties to set on the DSRequest that will be issued
		 */
		fetchData?(criteria?:Criteria, callback?:DSCallback, requestProperties?:DSRequest): void; 

		/** 
		 * Synonym for dynamicForm.getItem()
		 * @param {string} itemName - name of the item you're looking for
		 */
		getField?(itemName:string): FormItem; 

		/** 
		 * Retrieve a FormItem in this form by it's FormItem.name','name, FormItem.dataPath','dataPath, or index within the DynamicForm.items','items array. FormItems that also have a FormItem.ID may be accessed directly as a global variable window[itemID] or just itemID
		 * @param {string} itemName - name of the item you're looking for
		 */
		getItem?(itemName:string | number /* string or int */): FormItem; 

		/** 
		 * Returns the value stored in the form for some field. Shorthand for dynamicForm.getValues()[fieldName];
		 * @param {string} fieldName - name of the field for which you're retrieving a value. Nested values may be retrieved by passing in a DataPath
		 */
		getValue?(fieldName:string): any; 

	} // DynamicForm

	export interface DynamicFormStatic<T, P> extends CanvasStatic<T, P> {
	} // DynamicFormStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a EditProxy Props argument.
	 * This is derived from the methods in the EditProxy class and it's parents and their properties marked with the I flag.
	 */
	export interface EditProxyProps  {
		/** This property acts as a component-specific override for the EditContext.allowNestedDrops property. Unless explicitly set to false, the EditContext.allowNestedDrops controls whether a drop can be made into this component.
		 * Flags: IR */
		allowNestedDrops?: boolean /* Boolean */; // Flags=IR
		/** When child nodes are added to an EditContext, should they be masked by setting EditProxy.useEditMask true if not explicitly set?
		 * Flags: IR */
		autoMaskChildren?: boolean /* Boolean */; // Flags=IR
		/** Should component be brought to front when selected? Applies when EditProxy.useEditMask:true.
		 * Flags: IR */
		bringToFrontOnSelect?: boolean /* Boolean */; // Flags=IR
		/** Can this component be selected? Selection is allowed unless this property is set to false.
		 * Flags: IR */
		canSelect?: boolean /* Boolean */; // Flags=IR
		/** Whether to allow selection of the children of this EditNode. The appearance and behavior of selected components is controlled by SelectedAppearance, or centrally across an EditContext via EditContext.selectedAppearance. Individual children can be marked non-selectable via setting EditProxy.canSelect to false. Use the EditContext to access and manipulate the currently selected set of EditNodes, via APIs such as EditContext.getSelectedEditNode, EditContext.selectSingleEditNode and EditContext.selectedEditNodesUpdated.
		 * Flags: IRW */
		canSelectChildren?: boolean /* Boolean */; // Flags=IRW
		/** If not null the Canvas.childrenSnapResizeToGrid on the component represented by this EditProxy is set to this value only while in edit mode. This allows snapResizeToGrid functionality to be enforced during edit mode but not when live.
		 * Flags: IRW */
		childrenSnapResizeToGrid?: boolean /* Boolean */; // Flags=IRW
		/** If not null the Canvas.childrenSnapToGrid on the component represented by this EditProxy is set to this value only while in edit mode. This allows snapToGrid functionality to be enforced during edit mode but not when live.
		 * Flags: IRW */
		childrenSnapToGrid?: boolean /* Boolean */; // Flags=IRW
		/** An editMask is created for any component placed into editMode with EditProxy.useEditMask:true. Common customization properties can be provided by EditContext.editMaskProperties.
		 * Flags: IR */
		editMask?:  Canvas /* AutoChild Canvas */; // Flags=IR
		/** Hoop selector canvas used for selecting multiple components. Common customization properties can be provided by EditContext.hoopSelectorProperties.
		 * Flags: IR */
		hoopSelector?:  Canvas /* AutoChild Canvas */; // Flags=IR
		/** Event that triggers inline editing, showing the EditProxy.inlineEditForm, which consists of a single text input (single or multi-line according to EditProxy.inlineEditMultiline) shown in the EditProxy.inlineEditForm AutoChild. The initial value in the form comes from EditProxy.getInlineEditText and is applied via EditProxy.setInlineEditText. Many EditProxy subclasses have built-in modes for inline editing.
		 * Flags: IR */
		inlineEditEvent?: InlineEditEvent; // Flags=IR
		/** See EditProxy.inlineEditEvent.
		 * Flags: IR */
		inlineEditForm?:  DynamicForm /* MultiAutoChild DynamicForm */; // Flags=IR
		/** Label AutoChild used to display EditProxy.inlineEditInstructions below the text entry area if provided. Defaults to the same styling as the system Hover.
		 * Flags: IR */
		inlineEditInstructionLabel?:  Label /* AutoChild Label */; // Flags=IR
		/** Instructions that appear below the text entry area if inline editing is enabled. See EditProxy.inlineEditEvent and EditProxy.inlineEditInstructionLabel.
		 * Flags: IR */
		inlineEditInstructions?: string /* HTMLString */; // Flags=IR
		/** Whether inline editing should be single or multi-line. Single-line input appears at the control's top-left corner, multiline covers the control.
		 * Flags: IR */
		inlineEditMultiline?: boolean /* Boolean */; // Flags=IR
		/** Should the inline editor be shown when new component is first dropped?
		 * Flags: IR */
		inlineEditOnDrop?: boolean /* Boolean */; // Flags=IR
		/** Changes to all child EditNode.liveObject','liveObject's position and size can be persisted to their EditNode','EditNodes based on this attribute setting and EditContext.persistCoordinates. This applies to both programmatic calls and user interaction (drag reposition or drag resize). The default value of null allows EditContext.persistCoordinates to control all coordinate persistence. An explicit value of false overrides the EditContext setting so that no children of the component save coordinates. All coordinate persisting can be disabled with EditContext.persistCoordinates. Additionally, all control of persistence can be deferred to each EditProxy by setting EditContext.persistCoordinates to null.
		 * Flags: IRW */
		persistCoordinates?: boolean /* Boolean */; // Flags=IRW
		/** Appearance that is applied to selected component. Default value is determined from EditContext.selectedAppearance. When value is null the appearance is determined by: If multiple selection is enabled, "tintMask" is used Otherwise, "outlineMask" is used 
		 * Flags: IR */
		selectedAppearance?: SelectedAppearance; // Flags=IR
		/** Set the CSS border to be applied to the selection outline of the selected components. Default value is determined from EditContext.selectedBorder. This property is used when EditProxy.selectedAppearance is outlineMask or outlineEdges.
		 * Flags: IR */
		selectedBorder?: string /* String */; // Flags=IR
		/** The background color for the selection outline label. The default is defined on SelectionOutline or EditContext.selectedLabelBackgroundColor. NOTE: A selected component label is only supported when EditProxy.selectedAppearance','selectedAppearance is "outlineEdges".
		 * Flags: IR */
		selectedLabelBackgroundColor?: string /* String */; // Flags=IR
		/** Mask color applied to EditProxy.editMask','editMask of selected component when EditProxy.selectedAppearance','selectedAppearance is "tintMask". Default value is determined from EditContext.selectedTintColor.
		 * Flags: IR */
		selectedTintColor?: string /* CSSColor */; // Flags=IR
		/** Opacity applied to EditProxy.editMask','editMask of selected component when EditProxy.selectedAppearance','selectedAppearance is "tintMask".
		 * Flags: IR */
		selectedTintOpacity?: number /* Number */; // Flags=IR
		/** Whether this EditProxy has an inline edit behavior, which allows an end user to configure a component by editing a simple text representation of its configuration. For example, when inline edit is enabled, a SelectItem allows SelectItemEditProxy.getInlineEditText','editing its valueMap as a comma-separated string, and a ListGrid's columns and data can be edited as several lines of comma-separated headings and data values. See EditProxy.inlineEditEvent for more details and configuration options.
		 * Flags: IR */
		supportsInlineEdit?: boolean /* Boolean */; // Flags=IR
		/** Whether to enable keyboard shortcuts to EditContext.copyEditNodes','copy and EditContext.pasteEditNodes','paste editNodes. Enabled by default if EditProxy.canSelectChildren','selection of children is also enabled. For pasting, if EditContext.allowNestedDrops is enabled, only one editNode is selected and it is a valid container for the contents of the clipboard, editNodes will be pasted as new children of the selected container. Otherwise, they will be pasted at the root level of the EditContext.getEditNodeTree','editNodeTree. useCopyPasteShortcuts may only be set on the root editNode within any one EditContext.getEditNodeTree','editNodeTree.
		 * Flags: IR */
		useCopyPasteShortcuts?: boolean /* Boolean */; // Flags=IR
		/** When true an EditProxy.editMask will be auto-generated and placed over the component to allow selection, positioning and resizing. If this property is not set it will enabled when added to an EditContext if its parent component has an editProxy and EditProxy.autoMaskChildren is true.
		 * Flags: IR */
		useEditMask?: boolean /* Boolean */; // Flags=IR

		/* Method Overrides */

	} // EditProxyProps


	/**
	 * An EditProxy is attached to an editable component when editMode is enabled. This proxy has methods and properties which affect the component during editing. 
	 */
	export interface EditProxy  {
		/** This property acts as a component-specific override for the EditContext.allowNestedDrops property. Unless explicitly set to false, the EditContext.allowNestedDrops controls whether a drop can be made into this component.
		 * Flags: IR */
		allowNestedDrops: boolean /* Boolean */;

		/** When child nodes are added to an EditContext, should they be masked by setting EditProxy.useEditMask true if not explicitly set?
		 * Flags: IR */
		autoMaskChildren: boolean /* Boolean */;

		/** Should component be brought to front when selected? Applies when EditProxy.useEditMask:true.
		 * Flags: IR */
		bringToFrontOnSelect: boolean /* Boolean */;

		/** Can this component be selected? Selection is allowed unless this property is set to false.
		 * Flags: IR */
		canSelect: boolean /* Boolean */;

		/** Whether to allow selection of the children of this EditNode. The appearance and behavior of selected components is controlled by SelectedAppearance, or centrally across an EditContext via EditContext.selectedAppearance. Individual children can be marked non-selectable via setting EditProxy.canSelect to false. Use the EditContext to access and manipulate the currently selected set of EditNodes, via APIs such as EditContext.getSelectedEditNode, EditContext.selectSingleEditNode and EditContext.selectedEditNodesUpdated.
		 * Flags: IRW */
		canSelectChildren: boolean /* Boolean */;

		/** If not null the Canvas.childrenSnapResizeToGrid on the component represented by this EditProxy is set to this value only while in edit mode. This allows snapResizeToGrid functionality to be enforced during edit mode but not when live.
		 * Flags: IRW */
		childrenSnapResizeToGrid: boolean /* Boolean */;

		/** If not null the Canvas.childrenSnapToGrid on the component represented by this EditProxy is set to this value only while in edit mode. This allows snapToGrid functionality to be enforced during edit mode but not when live.
		 * Flags: IRW */
		childrenSnapToGrid: boolean /* Boolean */;

		/** An editMask is created for any component placed into editMode with EditProxy.useEditMask:true. Common customization properties can be provided by EditContext.editMaskProperties.
		 * Flags: IR */
		editMask:  Canvas /* AutoChild Canvas */;

		/** Hoop selector canvas used for selecting multiple components. Common customization properties can be provided by EditContext.hoopSelectorProperties.
		 * Flags: IR */
		hoopSelector:  Canvas /* AutoChild Canvas */;

		/** Event that triggers inline editing, showing the EditProxy.inlineEditForm, which consists of a single text input (single or multi-line according to EditProxy.inlineEditMultiline) shown in the EditProxy.inlineEditForm AutoChild. The initial value in the form comes from EditProxy.getInlineEditText and is applied via EditProxy.setInlineEditText. Many EditProxy subclasses have built-in modes for inline editing.
		 * Flags: IR */
		inlineEditEvent: InlineEditEvent;

		/** See EditProxy.inlineEditEvent.
		 * Flags: IR */
		inlineEditForm:  DynamicForm /* MultiAutoChild DynamicForm */;

		/** Label AutoChild used to display EditProxy.inlineEditInstructions below the text entry area if provided. Defaults to the same styling as the system Hover.
		 * Flags: IR */
		inlineEditInstructionLabel:  Label /* AutoChild Label */;

		/** Instructions that appear below the text entry area if inline editing is enabled. See EditProxy.inlineEditEvent and EditProxy.inlineEditInstructionLabel.
		 * Flags: IR */
		inlineEditInstructions: string /* HTMLString */;

		/** Whether inline editing should be single or multi-line. Single-line input appears at the control's top-left corner, multiline covers the control.
		 * Flags: IR */
		inlineEditMultiline: boolean /* Boolean */;

		/** Should the inline editor be shown when new component is first dropped?
		 * Flags: IR */
		inlineEditOnDrop: boolean /* Boolean */;

		/** Changes to all child EditNode.liveObject','liveObject's position and size can be persisted to their EditNode','EditNodes based on this attribute setting and EditContext.persistCoordinates. This applies to both programmatic calls and user interaction (drag reposition or drag resize). The default value of null allows EditContext.persistCoordinates to control all coordinate persistence. An explicit value of false overrides the EditContext setting so that no children of the component save coordinates. All coordinate persisting can be disabled with EditContext.persistCoordinates. Additionally, all control of persistence can be deferred to each EditProxy by setting EditContext.persistCoordinates to null.
		 * Flags: IRW */
		persistCoordinates: boolean /* Boolean */;

		/** Appearance that is applied to selected component. Default value is determined from EditContext.selectedAppearance. When value is null the appearance is determined by: If multiple selection is enabled, "tintMask" is used Otherwise, "outlineMask" is used 
		 * Flags: IR */
		selectedAppearance: SelectedAppearance;

		/** Set the CSS border to be applied to the selection outline of the selected components. Default value is determined from EditContext.selectedBorder. This property is used when EditProxy.selectedAppearance is outlineMask or outlineEdges.
		 * Flags: IR */
		selectedBorder: string /* String */;

		/** The background color for the selection outline label. The default is defined on SelectionOutline or EditContext.selectedLabelBackgroundColor. NOTE: A selected component label is only supported when EditProxy.selectedAppearance','selectedAppearance is "outlineEdges".
		 * Flags: IR */
		selectedLabelBackgroundColor: string /* String */;

		/** Mask color applied to EditProxy.editMask','editMask of selected component when EditProxy.selectedAppearance','selectedAppearance is "tintMask". Default value is determined from EditContext.selectedTintColor.
		 * Flags: IR */
		selectedTintColor: string /* CSSColor */;

		/** Opacity applied to EditProxy.editMask','editMask of selected component when EditProxy.selectedAppearance','selectedAppearance is "tintMask".
		 * Flags: IR */
		selectedTintOpacity: number /* Number */;

		/** Whether this EditProxy has an inline edit behavior, which allows an end user to configure a component by editing a simple text representation of its configuration. For example, when inline edit is enabled, a SelectItem allows SelectItemEditProxy.getInlineEditText','editing its valueMap as a comma-separated string, and a ListGrid's columns and data can be edited as several lines of comma-separated headings and data values. See EditProxy.inlineEditEvent for more details and configuration options.
		 * Flags: IR */
		supportsInlineEdit: boolean /* Boolean */;

		/** Whether to enable keyboard shortcuts to EditContext.copyEditNodes','copy and EditContext.pasteEditNodes','paste editNodes. Enabled by default if EditProxy.canSelectChildren','selection of children is also enabled. For pasting, if EditContext.allowNestedDrops is enabled, only one editNode is selected and it is a valid container for the contents of the clipboard, editNodes will be pasted as new children of the selected container. Otherwise, they will be pasted at the root level of the EditContext.getEditNodeTree','editNodeTree. useCopyPasteShortcuts may only be set on the root editNode within any one EditContext.getEditNodeTree','editNodeTree.
		 * Flags: IR */
		useCopyPasteShortcuts: boolean /* Boolean */;

		/** When true an EditProxy.editMask will be auto-generated and placed over the component to allow selection, positioning and resizing. If this property is not set it will enabled when added to an EditContext if its parent component has an editProxy and EditProxy.autoMaskChildren is true.
		 * Flags: IR */
		useEditMask: boolean /* Boolean */;


		/* Instance Method Overrides */

	} // EditProxy

	export interface EditProxyStatic<T, P> extends ClassStatic<T, P> {
	} // EditProxyStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a FieldPicker Props argument.
	 * This is derived from the methods in the FieldPicker class and it's parents and their properties marked with the I flag.
	 */
	export interface FieldPickerProps  {
		/** The title displayed for the Add Custom Fields Button
		 * Flags: IR, Group: i18nMessages */
		addCustomFieldsButtonTitle?: string /* String */; // Flags=IR
		/** A ListGrid','ListGrid showing the list of available fields.
		 * Flags: IR */
		availableFieldsGrid?:  ListGrid /* AutoChild ListGrid */; // Flags=IR
		/** Provides a set of controls to appear as SectionHeader.controls','section header controls above the available fields grid.
		 * Flags: IR */
		availableFieldsHeaderControls?: Array<Canvas> /* Array of Canvas */; // Flags=IR
		availableFieldsTitle?: string /* String */; // Flags=IR
		/** The title displayed for the title property of the available fields
		 * Flags: IR, Group: i18nMessages */
		availableTitleTitle?: string /* String */; // Flags=IR
		/** A HLayout','horizontal layout used to show the FieldPicker.saveAndExitButton','Save and FieldPicker.cancelChangesButton','Cancel buttons.
		 * Flags: IR */
		buttonLayout?:  HLayout /* AutoChild HLayout */; // Flags=IR
		/** The title shown on the Cancel button
		 * Flags: IR, Group: i18nMessages */
		cancelButtonTitle?: string /* String */; // Flags=IR
		/** An AutoChild IButton','button that saves the current field-set and exits the Field Picker.
		 * Flags: IR */
		cancelChangesButton?:  IButton /* AutoChild IButton */; // Flags=IR
		confirmText?: string /* String */; // Flags=IR
		/** A ListGrid','ListGrid showing the list of currently selected fields.
		 * Flags: IR */
		currentFieldsGrid?:  ListGrid /* AutoChild ListGrid */; // Flags=IR
		currentFieldsTitle?: string /* String */; // Flags=IR
		/** The title displayed for the title property of the current fields
		 * Flags: IR, Group: i18nMessages */
		currentTitleTitle?: string /* String */; // Flags=IR
		/** The component whose fields should be edited. Note that if DataBoundComponent.useAllDataSourceFields is set on the component, it will be cleared when the FieldPicker applies the requested ordering since that setting imposes a fixed ordering on the fields.
		 * Flags: IR */
		dataBoundComponent?: Canvas; // Flags=IR
		/** An optional DataSource that is used to create a disposable FieldPicker.dataBoundComponent if none is provided. Has no effect if a FieldPicker.dataBoundComponent is specified.
		 * Flags: IR */
		dataSource?: DataSource; // Flags=IR
		/** The hint shown when editing a field with no title defined.
		 * Flags: IR, Group: i18nMessages */
		emptyTitleHint?: string /* String */; // Flags=IR
		hilitesText?: string /* String */; // Flags=IR
		/** A Label','label displaying the text assigned as the FieldPicker's FieldPicker.instructions','instructions. Shown across the top of the widget.
		 * Flags: IR */
		instructionLabel?:  Label /* AutoChild Label */; // Flags=IR
		instructions?: string /* HTMLString */; // Flags=IR
		/** The title shown on the 'Visible Fields' grid's context menu item, whose click handler puts the selected item back in the 'Available Fields' collection.
		 * Flags: IR, Group: i18nMessages */
		removeItemTitle?: string /* String */; // Flags=IR
		removeText?: string /* String */; // Flags=IR
		/** If a sampleRecord is provided, the FieldPicker will show a second column in the Current Fields dialog showing the cell value that will appear for that field given the provided sample record. A value of "first" means the first record. If the underlying FieldPicker.dataBoundComponent is a TreeGrid, you can specify "firstOpenLeaf" to use the first open leaf as the sampleRecord (this is often desirable in trees where the first record may be a folder that's used for organizational purposes only and hence would have no actual data for columns other than the tree column).
		 * Flags: IR */
		sampleRecord?: any | DefaultSampleRecord /* Record | DefaultSampleRecord */; // Flags=IR
		/** The title displayed for the sample value property of the current fields
		 * Flags: IR, Group: i18nMessages */
		sampleValueTitle?: string /* String */; // Flags=IR
		/** An AutoChild IButton','button that saves the current field-set and exits the Field Picker.
		 * Flags: IR */
		saveAndExitButton?:  IButton /* AutoChild IButton */; // Flags=IR
		/** The title shown on the Save and Exit button
		 * Flags: IR, Group: i18nMessages */
		saveAndExitButtonTitle?: string /* String */; // Flags=IR
		/** When set to false, hides the right-most set of buttons, used for re-ordering fields in the Visible Fields list.
		 * Flags: IR */
		showFieldOrderButtons?: boolean; // Flags=IR
		/** Shows a "Highlights..." button that shows an interface for editing hilites in the attached DataBoundComponent.
		 * Flags: IR */
		showHilitesButton?: boolean; // Flags=IR

		/* Method Overrides */

	} // FieldPickerProps


	/**
	 * FieldPicker provides a configuration dialog that displays, side-by-side, the available and currently-displayed fields of a DataBoundComponent. It allows for easy customization of the order in which the fields of a DataBoundComponent are displayed, and of which are visible. If so configured, it also allows for convenient launching of the HiliteEditor, FormulaBuilder, and SummaryBuilder. A FieldPicker instance runs in its own window, a FieldPickerWindow 
	 */
	export interface FieldPicker  {
		/** The title displayed for the Add Custom Fields Button
		 * Flags: IR, Group: i18nMessages */
		addCustomFieldsButtonTitle: string /* String */;

		/** A ListGrid','ListGrid showing the list of available fields.
		 * Flags: IR */
		availableFieldsGrid:  ListGrid /* AutoChild ListGrid */;

		/** Provides a set of controls to appear as SectionHeader.controls','section header controls above the available fields grid.
		 * Flags: IR */
		availableFieldsHeaderControls: Array<Canvas> /* Array of Canvas */;

		availableFieldsTitle: string /* String */;

		/** The title displayed for the title property of the available fields
		 * Flags: IR, Group: i18nMessages */
		availableTitleTitle: string /* String */;

		/** A HLayout','horizontal layout used to show the FieldPicker.saveAndExitButton','Save and FieldPicker.cancelChangesButton','Cancel buttons.
		 * Flags: IR */
		buttonLayout:  HLayout /* AutoChild HLayout */;

		/** The title shown on the Cancel button
		 * Flags: IR, Group: i18nMessages */
		cancelButtonTitle: string /* String */;

		/** An AutoChild IButton','button that saves the current field-set and exits the Field Picker.
		 * Flags: IR */
		cancelChangesButton:  IButton /* AutoChild IButton */;

		confirmText: string /* String */;

		/** A ListGrid','ListGrid showing the list of currently selected fields.
		 * Flags: IR */
		currentFieldsGrid:  ListGrid /* AutoChild ListGrid */;

		currentFieldsTitle: string /* String */;

		/** The title displayed for the title property of the current fields
		 * Flags: IR, Group: i18nMessages */
		currentTitleTitle: string /* String */;

		/** The component whose fields should be edited. Note that if DataBoundComponent.useAllDataSourceFields is set on the component, it will be cleared when the FieldPicker applies the requested ordering since that setting imposes a fixed ordering on the fields.
		 * Flags: IR */
		dataBoundComponent: Canvas;

		/** An optional DataSource that is used to create a disposable FieldPicker.dataBoundComponent if none is provided. Has no effect if a FieldPicker.dataBoundComponent is specified.
		 * Flags: IR */
		dataSource: DataSource;

		/** The hint shown when editing a field with no title defined.
		 * Flags: IR, Group: i18nMessages */
		emptyTitleHint: string /* String */;

		hilitesText: string /* String */;

		/** A Label','label displaying the text assigned as the FieldPicker's FieldPicker.instructions','instructions. Shown across the top of the widget.
		 * Flags: IR */
		instructionLabel:  Label /* AutoChild Label */;

		instructions: string /* HTMLString */;

		/** The title shown on the 'Visible Fields' grid's context menu item, whose click handler puts the selected item back in the 'Available Fields' collection.
		 * Flags: IR, Group: i18nMessages */
		removeItemTitle: string /* String */;

		removeText: string /* String */;

		/** If a sampleRecord is provided, the FieldPicker will show a second column in the Current Fields dialog showing the cell value that will appear for that field given the provided sample record. A value of "first" means the first record. If the underlying FieldPicker.dataBoundComponent is a TreeGrid, you can specify "firstOpenLeaf" to use the first open leaf as the sampleRecord (this is often desirable in trees where the first record may be a folder that's used for organizational purposes only and hence would have no actual data for columns other than the tree column).
		 * Flags: IR */
		sampleRecord: any | DefaultSampleRecord /* Record | DefaultSampleRecord */;

		/** The title displayed for the sample value property of the current fields
		 * Flags: IR, Group: i18nMessages */
		sampleValueTitle: string /* String */;

		/** An AutoChild IButton','button that saves the current field-set and exits the Field Picker.
		 * Flags: IR */
		saveAndExitButton:  IButton /* AutoChild IButton */;

		/** The title shown on the Save and Exit button
		 * Flags: IR, Group: i18nMessages */
		saveAndExitButtonTitle: string /* String */;

		/** When set to false, hides the right-most set of buttons, used for re-ordering fields in the Visible Fields list.
		 * Flags: IR */
		showFieldOrderButtons: boolean;

		/** Shows a "Highlights..." button that shows an interface for editing hilites in the attached DataBoundComponent.
		 * Flags: IR */
		showHilitesButton: boolean;


		/* Instance Method Overrides */

	} // FieldPicker

	export interface FieldPickerStatic<T, P> extends ClassStatic<T, P> {
	} // FieldPickerStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a FieldPickerWindow Props argument.
	 * This is derived from the methods in the FieldPickerWindow class and it's parents and their properties marked with the I flag.
	 */
	export interface FieldPickerWindowProps  {
		/** By default, a FieldPickerWindow will close automatically if the mouse is clicked outside of it. To have the window shown with true modality, set this attribute to false.
		 * Flags: IR */
		autoDismiss?: boolean /* Boolean */; // Flags=IR
		/** A FieldPicker','FieldPicker for altering the working field-set in a DataBoundComponent','Data-bound component.
		 * Flags: IR */
		fieldPicker?:  FieldPicker /* AutoChild FieldPicker */; // Flags=IR
		title?: string /* String */; // Flags=IR
	} // FieldPickerWindowProps


	/**
	 * A dialog for picking fields to display from among the available fields. This is typically useful in scenarios where there are many more fields than can reasonably fit on screen. The application can start off displaying a few of the fields by default (such as the most commonly-needed fields), and show a FieldPickerWindow to allow the user to customize which fields to display as well as the order in which to display them. 
	 */
	export interface FieldPickerWindow  {
		/** By default, a FieldPickerWindow will close automatically if the mouse is clicked outside of it. To have the window shown with true modality, set this attribute to false.
		 * Flags: IR */
		autoDismiss: boolean /* Boolean */;

		/** A FieldPicker','FieldPicker for altering the working field-set in a DataBoundComponent','Data-bound component.
		 * Flags: IR */
		fieldPicker:  FieldPicker /* AutoChild FieldPicker */;

		title: string /* String */;

	} // FieldPickerWindow

	export interface FieldPickerWindowStatic<T, P> extends ClassStatic<T, P> {
	} // FieldPickerWindowStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a FilterClause Props argument.
	 * This is derived from the methods in the FilterClause class and it's parents and their properties marked with the I flag.
	 */
	export interface FilterClauseProps  {
		/** AutoChild containing the UI for the filter-properties in this FilterClause.
		 * Flags: IR */
		clause?:  SearchForm /* AutoChild SearchForm */; // Flags=IR
		/** Initial criterion for this FilterClause. When initialized with a criterion, the clause will be automatically set up for editing the supplied criterion. Note that an empty or partial criterion is allowed, for example, it may specify Criterion.fieldName only and will generate an expression with the operator not chosen.
		 * Flags: IRW */
		criterion?: Criteria; // Flags=IRW
		/** AutoChild for the FormItem that allows a user to pick a DataSource field when creating filter clauses. This will be a SelectItem by default, or a ComboBoxItem if FilterBuilder.fieldDataSource has been specified.
		 * Flags: IR */
		fieldPicker?:  PickList /* AutoChild PickList */; // Flags=IR
		/** Properties to combine with the FieldPicker autoChild FormItem.
		 * Flags: IR */
		fieldPickerProperties?: FormItemProps /* FormItem Properties */; // Flags=IR
		/** The title for the FieldPicker','field-picker select-item.
		 * Flags: IR, Group: i18nMessages */
		fieldPickerTitle?: string /* String */; // Flags=IR
		/** AutoChild for the FormItem that allows a user to select the operator when creating filter clauses. Each clause will create an operatorPicker automatically. To customize this item, use FilterClause.operatorPickerProperties
		 * Flags: IR */
		operatorPicker?:  SelectItem /* AutoChild SelectItem */; // Flags=IR
		/** Properties to combine with the FilterClause.operatorPicker autoChild FormItem.
		 * Flags: IR */
		operatorPickerProperties?: FormItemProps /* FormItem Properties */; // Flags=IR
		/** The title for the operator-picker select-item.
		 * Flags: IR, Group: i18nMessages */
		operatorPickerTitle?: string /* String */; // Flags=IR
		/** The clause removal ImgButton that appears before this clause if FilterClause.showRemoveButton is set.
		 * Flags: IR */
		removeButton?:  ImgButton /* AutoChild ImgButton */; // Flags=IR
		/** The hover prompt text for the remove button.
		 * Flags: IR, Group: i18nMessages */
		removeButtonPrompt?: string; // Flags=IR
		/** If true (the default), show field titles in the drop-down box used to select a field for querying. If false, show actual field names instead.
		 * Flags: IR */
		showFieldTitles?: boolean /* Boolean */; // Flags=IR
		/** If set, show a button for this clause allowing it to be removed.
		 * Flags: IR */
		showRemoveButton?: boolean /* Boolean */; // Flags=IR
		/** If true (the default), validates the entered value when it changes, to make sure it is a a valid value of its type (valid string, number, and so on). No other validation is carried out. If you switch this property off, it is still possible to validate the FilterClause by calling FilterClause.validate from your own code.
		 * Flags: IR */
		validateOnChange?: boolean /* Boolean */; // Flags=IR
		/** A hint to show in the value-item when using an operator that allows users to select field-names from a list.
		 * Flags: IR, Group: i18nMessages */
		valueItemFieldHint?: string /* String */; // Flags=IR
		/** A hint to show in the value-item when using an operator that allows users to select values from a list.
		 * Flags: IR, Group: i18nMessages */
		valueItemListHint?: string /* String */; // Flags=IR
		/** A hint to show in the value-item when using an operator that takes user-entered values.
		 * Flags: IR, Group: i18nMessages */
		valueItemTextHint?: string /* String */; // Flags=IR
		/** The title for the value-item.
		 * Flags: IR, Group: i18nMessages */
		valueItemTitle?: string /* String */; // Flags=IR
		/** A hint to show in the value-item when using an operator that takes an array of values.
		 * Flags: IR, Group: i18nMessages */
		valueSetHint?: string /* String */; // Flags=IR

		/* Method Overrides */

	} // FilterClauseProps


	/**
	 * A horizontal, Layout-based widget that allows a user to input a single criterion based on one field and one operator. Note that FilterClauses must be used in conjunction with a FilterBuilder. By default the FilterBuilder will auto-generate its clauses based on specified criteria, but for advanced usage a FilterClause may be instantiated directly and passed to a filterBuilder via FilterBuilder.addClause. 
	 */
	export interface FilterClause  {
		/** AutoChild containing the UI for the filter-properties in this FilterClause.
		 * Flags: IR */
		clause:  SearchForm /* AutoChild SearchForm */;

		/** Initial criterion for this FilterClause. When initialized with a criterion, the clause will be automatically set up for editing the supplied criterion. Note that an empty or partial criterion is allowed, for example, it may specify Criterion.fieldName only and will generate an expression with the operator not chosen.
		 * Flags: IRW */
		criterion: Criteria;

		/** AutoChild for the FormItem that allows a user to pick a DataSource field when creating filter clauses. This will be a SelectItem by default, or a ComboBoxItem if FilterBuilder.fieldDataSource has been specified.
		 * Flags: IR */
		fieldPicker:  PickList /* AutoChild PickList */;

		/** Properties to combine with the FieldPicker autoChild FormItem.
		 * Flags: IR */
		fieldPickerProperties: FormItemProps /* FormItem Properties */;

		/** The title for the FieldPicker','field-picker select-item.
		 * Flags: IR, Group: i18nMessages */
		fieldPickerTitle: string /* String */;

		/** AutoChild for the FormItem that allows a user to select the operator when creating filter clauses. Each clause will create an operatorPicker automatically. To customize this item, use FilterClause.operatorPickerProperties
		 * Flags: IR */
		operatorPicker:  SelectItem /* AutoChild SelectItem */;

		/** Properties to combine with the FilterClause.operatorPicker autoChild FormItem.
		 * Flags: IR */
		operatorPickerProperties: FormItemProps /* FormItem Properties */;

		/** The title for the operator-picker select-item.
		 * Flags: IR, Group: i18nMessages */
		operatorPickerTitle: string /* String */;

		/** The clause removal ImgButton that appears before this clause if FilterClause.showRemoveButton is set.
		 * Flags: IR */
		removeButton:  ImgButton /* AutoChild ImgButton */;

		/** The hover prompt text for the remove button.
		 * Flags: IR, Group: i18nMessages */
		removeButtonPrompt: string;

		/** If true (the default), show field titles in the drop-down box used to select a field for querying. If false, show actual field names instead.
		 * Flags: IR */
		showFieldTitles: boolean /* Boolean */;

		/** If set, show a button for this clause allowing it to be removed.
		 * Flags: IR */
		showRemoveButton: boolean /* Boolean */;

		/** If true (the default), validates the entered value when it changes, to make sure it is a a valid value of its type (valid string, number, and so on). No other validation is carried out. If you switch this property off, it is still possible to validate the FilterClause by calling FilterClause.validate from your own code.
		 * Flags: IR */
		validateOnChange: boolean /* Boolean */;

		/** A hint to show in the value-item when using an operator that allows users to select field-names from a list.
		 * Flags: IR, Group: i18nMessages */
		valueItemFieldHint: string /* String */;

		/** A hint to show in the value-item when using an operator that allows users to select values from a list.
		 * Flags: IR, Group: i18nMessages */
		valueItemListHint: string /* String */;

		/** A hint to show in the value-item when using an operator that takes user-entered values.
		 * Flags: IR, Group: i18nMessages */
		valueItemTextHint: string /* String */;

		/** The title for the value-item.
		 * Flags: IR, Group: i18nMessages */
		valueItemTitle: string /* String */;

		/** A hint to show in the value-item when using an operator that takes an array of values.
		 * Flags: IR, Group: i18nMessages */
		valueSetHint: string /* String */;


		/* Instance Method Overrides */

	} // FilterClause

	export interface FilterClauseStatic<T, P> extends ClassStatic<T, P> {
	} // FilterClauseStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a FormItem Props argument.
	 * This is derived from the methods in the FormItem class and it's parents and their properties marked with the I flag.
	 */
	export interface FormItemProps  {
		/** If specified this governs the HTML accessKey for the item. This should be set to a character - when a user hits the html accessKey modifier for the browser, plus this character, focus will be given to the item. The accessKey modifier can vary by browser and platform. The following list of default behavior is for reference only, developers should also consult browser documentation for additional information. Internet Explorer (all platforms): Alt + accessKey Mozilla Firefox (Windows, Unix): Alt+Shift + accessKey Mozilla Firefox (Mac): Ctrl+Opt + accessKey Chrome and Safari (Windows, Unix): Alt + accessKey Chrome and Safari (Mac): Ctrl+Opt + accessKey 
		 * Flags: IRW, Group: focus */
		accessKey?: string /* keyChar */; // Flags=IRW
		/** Alignment of this item in its cell. Note that the alignment of text / content within this item is controlled separately via FormItem.textAlign (typically textAlign applies to items showing a "textBox", such as a TextItem or SelectItem, as well as text-only form item types such as StaticTextItem and HeaderItem). If FormItem.applyAlignToText','applyAlignToText is true, then the textAlign setting, if unset, will default to the align setting if set.
		 * Flags: IRW, Group: appearance */
		align?: Alignment; // Flags=IRW
		/** For a form that produces filter criteria (see DynamicForm.getValuesAsCriteria','form.getValuesAsCriteria()), allows the user to type in simple expressions to cause filtering with that operator. For example, entering "&gt;5" means values greater than 5, and "&gt;0 and &lt;5" means values between 0 and 5. The following table lists character sequences that can be entered as a prefix to a value, and the corresponding OperatorId','operator that will be used. <table style='font-size:14;'> <tr><td>Prefix</td><td>Operator</td></tr> <tr><td>&lt;</td><td>lessThan</td></tr> <tr><td>&gt;</td><td>greaterThan</td></tr> <tr><td>&lt;=</td><td>lessThanOrEqual</td></tr> <tr><td>&gt;=</td><td>greaterThanOrEqual</td></tr> <tr><td>someValue...someValue</td><td>betweenInclusive</td></tr> <tr><td>!</td><td>notEqual</td></tr> <tr><td>^</td><td>startsWith</td></tr> <tr><td>|</td><td>endsWith</td></tr> <tr><td>!^</td><td>notStartsWith plus logical not</td></tr> <tr><td>!@</td><td>notEndsWith plus logical not</td></tr> <tr><td>~</td><td>contains</td></tr> <tr><td>!~</td><td>notContains</td></tr> <tr><td>$</td><td>isBlank</td></tr> <tr><td>!$</td><td>notBlank</td></tr> <tr><td>#</td><td>isNull</td></tr> <tr><td>!#</td><td>isNotNull</td></tr> <tr><td>==</td><td>exact match (for fields where 'contains' is the default)</td></tr> </table> Two further special notations are allowed: /regex/ means the value is taken as a regular expression and applied via the "regexp" operator =.fieldName means the value should match the value of another field. Either the user-visible title of the field (field.title) or the field's name (field.name) may be used. In all cases, if an operator is disallowed for the field (via DataSourceField.validOperators','field.validOperators at either the dataSource or field level), the operator character is ignored (treated as part of a literal value). By default, the case-insensitive version of the operator is used (eg, startsWith will actually use "iStartsWith"). To avoid this, explicitly set item.operator (the default operator) to any case sensitive operator (eg "equals" or "contains") and case sensitive operators will be used for user-entered expressions. Compound expressions (including "and" and "or") are allowed only for numeric or date/time types. Note that if the user does not type a prefix or use other special notation as described above, the operator specified via FormItem.operator is used, or if formItem.operator is unspecified, a default operator chosen as described under FormItem.operator. Also note that whatever you enter will be used literally, including any whitespace characters. For example if you input '== China ' then ' China ' will be the value. The allowExpression behavior can be enabled for every field in a form via DynamicForm.allowExpressions. Finally, note that, like FormItem.operator, enabling allowExpressions:true causes DynamicForm.getValuesAsCriteria','form.getValuesAsCriteria()) to return AdvancedCriteria.
		 * Flags: IRW, Group: advancedFilter */
		allowExpressions?: boolean; // Flags=IRW
		/** If this form item has a specified FormItem.optionDataSource and FormItem.fetchMissingValues is true, when the item value changes, a fetch will be performed against the optionDataSource to retrieve the related record if FormItem.displayField is specified and the new item value is not present in any valueMap explicitly specified on the item. Setting this property to true means that a fetch will occur against the optionDataSource to retrieve the related record even if FormItem.displayField is unset, or the item has a valueMap which explicitly contains this field's value. An example of a use case where this might be set would be if FormItem.formatValue or FormItem.formatEditorValue were written to display properties from the FormItem.getSelectedRecord','selected record. Note - for efficiency we cache the associated record once a fetch has been performed, meaning if the value changes, then reverts to a previously seen value, we do not kick off an additional fetch even if this property is true. If necessary this cache may be explicitly invalidated via a call to FormItem.invalidateDisplayValueCache
		 * Flags: IRWA, Group: display_values */
		alwaysFetchMissingValues?: boolean /* Boolean */; // Flags=IRWA
		/** A formItem showing a FormItem.showPickerIcon','pickerIcon will always write out a "control box" around the text box and picker icon. This is an HTML element styled using the specified FormItem.controlStyle. This attribute controls whether the control box should be written out even if the picker icon is not being shown. If unset, default behavior will write out a control table if FormItem.showPickerIcon is true and the icon is not suppressed via FormItemIcon.showIf. This means the control table can be written out with no visible picker if FormItem.showPickerIconOnFocus is true and the item does not have focus. This attribute is useful for developers who wish to rely on styling specified via the FormItem.controlStyle even while the picker icon is not visible. See the formItemStyling','form item styling overview for details of the control table and other styling options.
		 * Flags: IRA */
		alwaysShowControlBox?: boolean /* Boolean */; // Flags=IRA
		/** If the FormItem.textAlign','textAlign is unset, should the FormItem.align','align setting, if set, be used for this item's textAlign? applyAlignToText defaults to false for most form item types. It defaults to true for StaticTextItem and HeaderItem, which are text-based form item types that do not have a natural distinction between the item and its cell.
		 * Flags: IRA, Group: appearance */
		applyAlignToText?: boolean; // Flags=IRA
		/** If FormItem.height is specified, should it be applied to the item's text box element? If unset, behavior is determined as described in FormItem.shouldApplyHeightToTextBox
		 * Flags: IRA */
		applyHeightToTextBox?: boolean /* Boolean */; // Flags=IRA
		/** ARIA role of this formItem. Usually does not need to be manually set - see accessibility.
		 * Flags: IRWA, Group: accessibility */
		ariaRole?: string /* String */; // Flags=IRWA
		/** ARIA state mappings for this formItem. Usually this does not need to be manually set - see accessibility. This attribute should be set to a mapping of aria state-names to values - for example to have the "aria-multiline" property be present with a value "true", you'd specify: { multiline : true } 
		 * Flags: IRWA, Group: accessibility */
		ariaState?: any /* Object */; // Flags=IRWA
		/** Should this item allow browser auto-completion of its value? Applies only to items based on native HTML form elements (TextItem, PasswordItem, etc), and will only have a user-visible impact for browsers where native autoComplete behavior is actually supported and enabled via user settings. If unset, defaults to DynamicForm.autoComplete. Note that even with this value set to "none", native browser auto-completion may occur for log in forms (forms containing username and PasswordItem','password fields). This behavior varies by browser, and is a result of an <a href='https://www.google.com/search?q=password+ignores+autocomplete+off' target='_blank'>intentional change by some browser developers</a> to disregard the HTML setting autocomplete=off for password items or log-in forms. In some browsers any form redraw (including a redraw from a call to DynamicForm.setValues) will re-populate the form with the natively remembered login credentials. This can make it very difficult to control the values displayed to the user, as a call to 'setValues()' may appear to be ignored. While behavior varies by browser we have specifically observed this behavior in Safari. Moreover in this browser, if the user asks the browser to remember login credentials for a URL, any form with a password item and a text item may be auto-filled with the remembered login credentials, even if the form's configuration and field names differ from those on the login form. If an application has both an initial log in form, and a separate form within the application which makes contains a Password item (a use case might be an interface for a user with manager privileges for modifying other users' passwords), this will cause the second form to autofill with unexpected values. Should this arise, developers can avoid this by making the initial log in interface into a separate log in page from the main application page. This is often good practice in any case for reasons outlined in the "Authentication" section of the Quick Start guide.
		 * Flags: IRW, Group: autoComplete */
		autoComplete?: AutoComplete; // Flags=IRW
		/** Form item input type - governs which keyboard should be displayed for mobile devices (supported on iPhone / iPad)
		 * Flags: IRA */
		browserInputType?: string /* String */; // Flags=IRA
		/** If this browser supports spell-checking of text editing elements, do we want this enabled for this item? If unset the property will be inherited from the containing form. Notes: - this property only applies to text based items such as TextItem and TextAreaItem. - this property is not supported on all browsers.
		 * Flags: IRWA */
		browserSpellCheck?: boolean; // Flags=IRWA
		/** Is this form item editable (canEdit:true) or read-only (canEdit:false)? Setting the form item to non-editable causes it to render as read-only. Can be updated at runtime via the FormItem.setCanEdit','setCanEdit() method. Read-only appearance may be specified via FormItem.readOnlyDisplay. The default setting for this value ("readOnly") differs from the disabled state in that the form item is not rendered with disabled styling and most form items will allow copying of the contents while read-only but do not while disabled. Note that for forms bound to a DataSource, if this property is not explicitly set at the item level, its default value will match the DynamicForm.canEditFieldAttribute on the associated dataSource field. Developers should also be aware that the FormItem.readOnlyDisplay attribute is unrelated to the DataSourceField.readOnlyEditorType attribute. When a DynamicForm is first bound to a dataSource, for DataSourceField.canEdit','canEdit:false DataSourceFields, DataSourceField.readOnlyEditorType will determine what FormItemType should be created for the field. Once created, a FormItem's type can not be changed. Setting FormItem.canEdit at runtime will simply change the appearance of the item to allow or disallow editing of the item. 
		 * Flags: IRW, Group: readOnly */
		canEdit?: boolean; // Flags=IRW
		/** If true, indicates that this FormItem is capable of editing "opaque" values, ie, objects that are more complex than simple primitive types like numbers, strings and dates. Ordinarily, you use the SimpleType','SimpleType system to convert these opaque values into "atomic" values that can be edited by the built-in editors like TextItem. However, sometimes you to create a custom editor that knows how to edit a particular opaque type in a domain-specific way - for example, a composite custom FormItem that allows the user to edit both a number and a currency code, both of which are needed to make a proper monetary amount (for that particular application). When this value is set, the FormItem will manage the opaque value directly, rather than it being filtered through calls to SimpleType.getAtomicValue','getAtomicValue() and SimpleType.updateAtomicValue','updateAtomicValue(). Note, if you set this flag on a FormItem that does not have the ability to edit an opaque value (which is something that must be custom-coded) then you will get garbage in your editor, if not an outright crash.
		 * Flags: IRA */
		canEditOpaqueValues?: boolean /* Boolean */; // Flags=IRA
		/** Is this form item focusable? Setting this property to true on an otherwise non-focusable element such as a StaticTextItem will cause the item to be included in the page's tab order and respond to keyboard events.
		 * Flags: IRA, Group: focus */
		canFocus?: boolean; // Flags=IRA
		/** For items showing a text value, should the user be able to select the text in this item?
		 * Flags: IRW */
		canSelectText?: boolean; // Flags=IRW
		/** Should this item's FormItem.icons','icons and FormItem.showPickerIcon','picker icon be included in the page's tab order by default? If not explicitly set, this property will be derived from DynamicForm.canTabToIcons. Developers may also suppress tabbing to individual icons by setting FormItemIcon.tabIndex to -1. Note that if this form item has tabIndex -1, neither the form item nor the icons will be included in the page's tab order.
		 * Flags: IRWA, Group: formIcons */
		canTabToIcons?: boolean /* Boolean */; // Flags=IRWA
		/** If specified, this property will govern the height of the cell in which this form item is rendered. Will not apply when the containing DynamicForm sets itemLayout:"absolute".
		 * Flags: IRW */
		cellHeight?: number; // Flags=IRW
		/** CSS style applied to the form item as a whole, including the text element, any icons, and any hint text for the item. Applied to the cell containing the form item. See formItemStyling for an overview of formItem styling, and the CompoundFormItem_skinning discussion for special skinning considerations.
		 * Flags: IRW, Group: formItemStyling */
		cellStyle?: string /* FormItemBaseStyle */; // Flags=IRW
		/** Should this form item fire its FormItem.change','change handler (and store its value in the form) on every keypress? Set to false to suppress the 'change' handler firing (and the value stored) on every keypress. Note: If false, the value returned by FormItem.getValue','getValue will not reflect the value displayed in the form item element as long as focus is in the form item element.
		 * Flags: IRW, Group: eventHandling */
		changeOnKeypress?: boolean /* Boolean */; // Flags=IRW
		/** If this item is FormItem.getCanEdit','read-only and is using FormItem.readOnlyDisplay','readOnlyDisplay "static", should the item value be clipped if it overflows the specified size of the item? If set, overrides the form-level DynamicForm.clipStaticValue default.
		 * Flags: IR */
		clipStaticValue?: boolean /* Boolean */; // Flags=IR
		/** If the title for this form item is showing, and is too large for the available space should the title be clipped? Null by default - if set to true or false, overrides DynamicForm.clipItemTitles.
		 * Flags: IRW, Group: title */
		clipTitle?: boolean; // Flags=IRW
		/** Number of columns that this item spans. The colSpan setting does not include the title shown for items with FormItem.showTitle:true, so the effective colSpan is one higher than this setting for items that are showing a title and whose TitleOrientation is either "left" or "right".
		 * Flags: IRW, Group: formLayout */
		colSpan?: number; // Flags=IRW
		/** Base CSS class name for a form item's "control box". This is an HTML element which contains the text box and picker icon for the item. See FormItem.alwaysShowControlBox for details on when the control box is written out. See formItemStyling for an overview of formItem styling, and the CompoundFormItem_skinning discussion for special skinning considerations.
		 * Flags: IRW, Group: formItemStyling */
		controlStyle?: string /* FormItemBaseStyle */; // Flags=IRW
		/** When using FormItem.operator, the name of the DataSource field for the Criterion this FormItem generates. If not specified, defaults to FormItem.name. Generally, because criteriaField defaults to item.name, you don't need to specify it. However, if more than one FormItem specifies criteria for the same DataSource field, they will need unique values for FormItem.name but should set FormItem.criteriaField to the name of DataSource field they both target. For example, if two DateItems are used to provide a min and max date for a single field called "joinDate", set FormItem.criteriaField to "joinDate" on both fields but give the fields distinct names (eg "minDate" and "maxDate") and use those names for any programmatic access, such as DynamicForm.setValue.
		 * Flags: IR */
		criteriaField?: string /* identifier */; // Flags=IR
		/** dataPath for this item. Allows the user to edit details nested data structures in a flat set of form fields Note that an item must have a valid dataPath or FormItem.name','name in order for its value to be validated and/or saved.
		 * Flags: IR */
		dataPath?: string /* DataPath */; // Flags=IR
		/** Display format to use for date type values within this formItem. Note that Fields of type "date", "datetime" or "time" will be edited using a DateItem or TimeItem by default, but this can be overridden - for canEdit:false fields, a StaticTextItem is used by default, and the developer can always specify a custom FormItem.editorType as well as FormItem.type','data type. The FormItem.timeFormatter may also be used to format underlying Date values as times (ommitting the date part entirely). If both dateFormatter and timeFormatter are specified on an item, for fields specified as FormItem.type','type "time" the timeFormatter will be used, otherwise the dateFormatter If item.dateFormatter and item.timeFormatter is unspecified, date display format may be defined at the component level via DynamicForm.dateFormatter, or for fields of type "datetime" DynamicForm.datetimeFormatter. Otherwise the default is to use the system-wide default short date format, configured via DateUtil.setShortDisplayFormat. Specify any valid DateDisplayFormat to change the format used by this item. Note that if this is a freeform editable field, such a TextItem, with type specified as "date" or "datetime" the system will automatically attempt to parse user entered values back to a Date value, assuming the entered string matches the date format for the field. Developers may further customize this via an explicit FormItem.inputFormat or via entirely custom FormItem.formatEditorValue and FormItem.parseEditorValue methods. 
		 * Flags: IRWA, Group: appearance */
		dateFormatter?: DateDisplayFormat; // Flags=IRWA
		/** Applies only to fields of type "float" and enforces a minimum number of digits shown after the decimal point. For example, a field value of 343.1, 343.104 and 343.09872677 would all be shown as 343.10 if decimalPad is 2. The original unpadded value is always shown when the value is edited.
		 * Flags: IRW, Group: appearance */
		decimalPad?: number; // Flags=IRW
		/** Applies only to fields of type "float" and affects how many significant digits are shown. For example, with decimalPrecision 3, if the field value is 343.672677, 343.673 is shown. If the value is 125.2, 125.2 is shown - decimalPrecision will not cause extra zeros to be added. Use DataSourceField.decimalPad for this. A number is always shown with its original precision when edited.
		 * Flags: IRW, Group: appearance */
		decimalPrecision?: number; // Flags=IRW
		/** Default icon image source. Specify as the partial URL to an image, relative to the imgDir of this component. To specify image source for a specific icon use the icon.src property. If this item is drawn in the disabled state, the url will be modified by adding "_Disabled" to get a disabled state image for the icon. If icon.showOver is true, this url will be modified by adding "_Over" to get an over state image for the icon.
		 * Flags: IRWA, Group: formIcons */
		defaultIconSrc?: string /* SCImgURL */; // Flags=IRWA
		/** Value used when no value is provided for this item. Note that whenever this item's value is cleared programmatically (for example via item.clearValue() or item.setValue(null)), it will be reverted to the defaultValue. Developers should use the DynamicForm.values object if their intention is to provide an initial value for a field in a form rather than a value to use in place of null. Developers looking to provide a 'hint' or placeholder value for an empty item may wish to use FormItem.hint (possibly in conjunction with TextItem.showHintInField), or FormItem.prompt. Note: Some items provide a user interface allowing the user to explicitly clear them - for example a standard TextItem. If such an item has a defaultValue specified, and the user explicitly clears that value, the value of the item will be (correctly) reported as null, and will remain null over form item redraw()s. However any programmatic call to set the value to null (including, but not limited to item.clearValue(), item.setValue(null), dynamicForm.setValues(...) with a null value for this field, etc) will reset the item value to its default.
		 * Flags: IRW, Group: basics */
		defaultValue?: any; // Flags=IRW
		/** Whether this item is disabled. Can be updated at runtime via the setDisabled() method. Note that if the widget containing this formItem is disabled, the formItem will behave in a disabled manner regardless of the setting of the item.disabled property. Note that not all items can be disabled, and not all browsers show an obvious disabled style for native form elements.
		 * Flags: IRW, Group: appearance */
		disabled?: boolean /* Boolean */; // Flags=IRW
		/** If FormItem.canEdit is set to false, should FormItem.icons','icons be disabled by default? This may also be specified at the icon level. See FormItemIcon.disableOnReadOnly.
		 * Flags: IRW, Group: formIcons */
		disableIconsOnReadOnly?: boolean /* Boolean */; // Flags=IRW
		/** If set, this item will display a value from another field to the user instead of showing the underlying data value for the FormItem.name','field name. The display value can be derived in two ways: The item will display the displayField value from the DynamicForm.getValues','record currently being edited if FormItem.useLocalDisplayFieldValue is true, (or if unset and the conditions outlined in the documentation for that property are met). Note that DataSourceField.useLocalDisplayFieldValue will default to true if not explicitly set in some cases, as described in the documentation for that property. Otherwise this item will perform a fetch against the FormItem.optionDataSource to find a record where the FormItem.getValueFieldName','value field matches this item's value, and use the displayField, or FormItem.foreignDisplayField value from that record. Note that the specified displayField must be explicitly defined in the optionDataSource to be used - see FormItem.getDisplayFieldName for more on this behavior. This essentially allows the specified optionDataSource to be used as a server based valueMap. Note that if optionDataSource is set and no valid display field is specified, FormItem.getDisplayFieldName will return the dataSource title field by default. If a displayField is specified for a freeform text based item (such as a ComboBoxItem), any user-entered value will be treated as a display value. In this scenario, items will derive the data value for the item from the first record where the displayField value matches the user-entered value. To avoid ambiguity, developers may wish to avoid this usage if display values are not unique.
		 * Flags: IR, Group: databinding */
		displayField?: string; // Flags=IR
		/** Name of the FormItem to use for editing, eg "TextItem" or "SelectItem". The type of FormItem to use for editing is normally derived automatically from FormItem.type','field.type, which is the data type of the field, by the rules explained FormItemType','here.
		 * Flags: IR, Group: appearance */
		editorType?: string /* FormItem class */; // Flags=IR
		/** Custom CSS text to be applied to cells with pending edits that have not yet been submitted.
		 * Flags: IRWA, Group: appearance */
		editPendingCSSText?: string /* CSSText */; // Flags=IRWA
		/** Default class used to construct the EditProxy for this component when the component is Canvas.setEditMode','first placed into edit mode.
		 * Flags: IR */
		editProxyConstructor?: string /* SCClassName */; // Flags=IR
		/** Text to display when this form item has a null or undefined value. If the formItem has a databound pickList, and its FormItem.displayField or FormItem.valueField (if the former isn't set) has an undefined ListGridField.emptyCellValue','emptyCellValue setting, that field's emptyCellValue will automatically be set to the emptyDisplayValue.
		 * Flags: IRW, Group: display_values */
		emptyDisplayValue?: string; // Flags=IRW
		/** This property allows the developer to specify an icon to display when this item has no value. It is configured in the same way as any other valueIcon (see FormItem.valueIcons)
		 * Flags: IRW, Group: valueIcons */
		emptyValueIcon?: string; // Flags=IRW
		/** Whether this item should end the row it's in in the form layout
		 * Flags: IRW, Group: formLayout */
		endRow?: boolean /* Boolean */; // Flags=IRW
		/** Height of the error icon, if we're showing icons when validation errors occur.
		 * Flags: IRW, Group: errorIcon */
		errorIconHeight?: number; // Flags=IRW
		/** URL of the image to show as an error icon, if we're showing icons when validation errors occur.
		 * Flags: IRW, Group: errorIcon */
		errorIconSrc?: string /* SCImgURL */; // Flags=IRW
		/** Height of the error icon, if we're showing icons when validation errors occur.
		 * Flags: IRW, Group: errorIcon */
		errorIconWidth?: number; // Flags=IRW
		/** When DynamicForm.showInlineErrors and FormItem.showErrorText are both true and FormItem.errorOrientation is "left" or "right", errorMessageWidth is the amount to reduce the width of the editor to accommodate the error message and icon.
		 * Flags: IRW, Group: validation */
		errorMessageWidth?: number /* int */; // Flags=IRW
		/** If DynamicForm.showInlineErrors is true, where should the error icon and text appear relative to the form item itself. Valid options are "top", "bottom", "left" or "right". If unset the orientation will be derived from DynamicForm.errorOrientation.
		 * Flags: IRW, Group: validation */
		errorOrientation?: string /* align */; // Flags=IRW
		/** FormatString used during exports for numeric or date formatting. See DataSourceField.exportFormat.
		 * Flags: IR, Group: exportFormatting */
		exportFormat?: string /* FormatString */; // Flags=IR
		/** If this form item has a specified FormItem.optionDataSource, should the item ever perform a fetch against this dataSource to retrieve the related record. The fetch occurs if the item value is non null on initial draw of the form or whenever setValue() is called. Once the fetch completes, the returned record is available via the FormItem.getSelectedRecord api. By default, a fetch will only occur if FormItem.displayField is specified, and the item does not have an explicit FormItem.valueMap containing the data value as a key. However you can also set FormItem.alwaysFetchMissingValues to have a fetch occur even if no displayField is specified. This ensures FormItem.getSelectedRecord will return a record if possible - useful for custom formatter functions, etc. Note - for efficiency we cache the associated record once a fetch has been performed, meaning if the value changes, then reverts to a previously seen value, we do not kick off an additional fetch to pick up the display value for the previously seen data value. If necessary this cache may be explicitly invalidated via a call to FormItem.invalidateDisplayValueCache
		 * Flags: IRWA, Group: display_values */
		fetchMissingValues?: boolean /* Boolean */; // Flags=IRWA
		/** If this form item is mapping data values to a display value by fetching records from a dataSource (see FormItem.optionDataSource, FormItem.displayField and FormItem.fetchMissingValues), setting this property to true ensures that when the form item value is set, entire data-set from the dataSource is loaded at once and used as a valueMap, rather than just loading the display value for the current value. This avoids the need to perform fetches each time setValue() is called with a new value. See also PickList.filterLocally for behavior on form items such as SelectItems that show pick-lists.
		 * Flags: IRA, Group: display_values */
		filterLocally?: boolean; // Flags=IRA
		/** For items with an FormItem.optionDataSource, this property specifies an alternative field from which display values should be retrieved for this item. If present this item will attempt to map its underlying value to a display value by retrieving a record from the FormItem.optionDataSource where the FormItem.valueField matches this item's value, and displaying the foreignDisplayField value from that record. This essentially enables the specified optionDataSource to be used as a server based valueMap. If unset, FormItem.displayField may be used. The foreignDisplayField attribute is particularly useful to allow developers to handle the case where one field name is used as a displayField within the form's dataSource (for static display of a value within the current record), and a different field name is to be used to get the display value for records in the FormItem.optionDataSource.
		 * Flags: IR */
		foreignDisplayField?: string; // Flags=IR
		/** FormatString for numeric or date formatting. See DataSourceField.format.
		 * Flags: IR, Group: exportFormatting */
		format?: string /* FormatString */; // Flags=IR
		/** Formula to be used to calculate the numeric value of this FormItem. For a field of type "text" (or subtypes) FormItem.textFormula is used instead. Available fields for use in the formula are the current Canvas.ruleScope','rule context. The formula is re-evaluated every time the rule context changes. Values calculated by the formula will always replace the current value of a non-editable field. For an editable field, the current value will be replaced if the end user has not changed the value since the last time it was computed by the formula, or if the value of the field is invalid according to declared FormItem.validators','validators. Note: A FormItem using a formula must have a FormItem.name defined. FormItem.shouldSaveValue can be set to false to prevent the formula field from storing the calculated value into the form's values.
		 * Flags: IR, Group: formulaFields */
		formula?: UserFormula; // Flags=IR
		/** TabIndex for the form item within the page. Takes precedence over any local tab index specified as FormItem.tabIndex','item.tabIndex. Use of this API is extremely advanced and essentially implies taking over management of tab index assignment for all components on the page.
		 * Flags: IRWA, Group: focus */
		globalTabIndex?: number /* integer */; // Flags=IRWA
		/** Height of the FormItem. Can be either a number indicating a fixed height in pixels, a percentage indicating a percentage of the overall form's height, or "*" indicating take whatever remaining space is available. See the formLayout overview for details. For form items having a FormItem.showPickerIcon','picker icon (e.g. SelectItem, ComboBoxItem) and SpinnerItems, if skinning','spriting is enabled, it is not recommended to change the height of the form item from the default because the image sprites are set up assuming a specific, fixed height of the item. If the item height must be changed, then the FormItem.pickerIconStyle','pickerIconStyle should be changed to a custom CSS style name. Or, in the case of SpinnerItems, the FormItemIcon.baseStyle','baseStyle and FormItemIcon.src','src of the SpinnerItem.increaseIcon and SpinnerItem.decreaseIcon AutoChildren should be customized. Note that when FormItem is rendered as read-only with readOnlyDisplay as "static" the property FormItem.staticHeight is used instead.
		 * Flags: IRW, Group: formLayout */
		height?: number | string /* int | String */; // Flags=IRW
		/** Should this form item be hidden? Setting this property to true on an item configuration will have the same effect as having a FormItem.showIf implementation which returns false. Note this differs slightly from DataSourceField.hidden. That property will cause the field in question to be omitted entirely from databound components by default. A dataSourceField with hidden set to true can still be displayed in a DynamicForm either by being explicitly included in the specified DynamicForm.items','items array, or by having DataBoundComponent.showHiddenFields set to true. In this case, this property will not be inherited onto the FormItem instance, meaning the item will be visible in the form even though the hidden property was set to true on the dataSourceField configuration object.
		 * Flags: IR */
		hidden?: boolean /* Boolean */; // Flags=IR
		/** Specifies "hint" string to show next to the form item to indicate something to the user. This string generally appears to the right of the form item.
		 * Flags: IRW, Group: appearance */
		hint?: string /* HTMLString */; // Flags=IRW
		/** CSS class for the "hint" string. For items that support TextItem.showHintInField, this only applies when showHintInField is false.
		 * Flags: IRW, Group: formItemStyling */
		hintStyle?: string /* CSSStyleName */; // Flags=IRW
		/** Text alignment for text displayed in this item's hover canvas, if shown.
		 * Flags: IRW, Group: Hovers */
		hoverAlign?: Alignment; // Flags=IRW
		/** If specified, this is the number of milliseconds to wait between the user rolling over this form item, and triggering any hover action for it. If not specified this.form.itemHoverDelay will be used instead.
		 * Flags: IRWA, Group: Hovers */
		hoverDelay?: number; // Flags=IRWA
		/** Option to specify a height for any hover shown for this item.
		 * Flags: IRW, Group: Hovers */
		hoverHeight?: any /* measure */; // Flags=IRW
		/** Opacity for any hover shown for this item
		 * Flags: IRW, Group: Hovers */
		hoverOpacity?: number; // Flags=IRW
		/** Explicit CSS Style for any hover shown for this item.
		 * Flags: IRW, Group: Hovers */
		hoverStyle?: string /* CSSStyleName */; // Flags=IRW
		/** Vertical text alignment for text displayed in this item's hover canvas, if shown.
		 * Flags: IRW, Group: Hovers */
		hoverVAlign?: VerticalAlignment; // Flags=IRW
		/** Option to specify a width for any hover shown for this item.
		 * Flags: IRW, Group: Hovers */
		hoverWidth?: any /* measure */; // Flags=IRW
		/** Default height for form item icons. May be overridden at the icon level by FormItemIcon.height.
		 * Flags: IRA, Group: formIcons */
		iconHeight?: number /* int */; // Flags=IRA
		/** Horizontal space (in px) to leave between form item icons. The space appears either on the left or right of each icon. May be overridden at the icon level via FormItemIcon.hspace. Must be non-negative.
		 * Flags: IR, Group: formIcons */
		iconHSpace?: number /* int */; // Flags=IR
		/** Default prompt (and tooltip-text) for icons.
		 * Flags: IRWA, Group: formIcons */
		iconPrompt?: string /* HTMLString */; // Flags=IRWA
		/** An array of descriptor objects for icons to display in a line after this form item. These icons are clickable images, often used to display some kind of helper for populating a form item.
		 * Flags: IRW, Group: formIcons */
		icons?: Array<FormItemIcon> /* Array of FormItemIcon Properties */; // Flags=IRW
		/** How should icons be aligned vertically for this form item.
		 * Flags: IRWA, Group: formIcons */
		iconVAlign?: VerticalAlignment; // Flags=IRWA
		/** Default width for form item icons. May be overridden at the icon level by FormItemIcon.width.
		 * Flags: IRA, Group: formIcons */
		iconWidth?: number /* int */; // Flags=IRA
		/** Global identifier for referring to the formItem in JavaScript. The ID property is optional if you do not need to refer to the widget from JavaScript, or can refer to it indirectly (for example, via form.getItem("itemName")). An internal, unique ID will automatically be created upon instantiation for any formItem where one is not provided.
		 * Flags: IRW, Group: basics */
		ID?: string /* identifier */; // Flags=IRW
		/** Prefix to apply to the beginning of any FormItem.valueIcons when determining the URL for the image. Will not be applied if the valueIcon URL is absolute.
		 * Flags: IRWA, Group: valueIcons */
		imageURLPrefix?: string; // Flags=IRWA
		/** Suffix to apply to the end of any FormItem.valueIcons when determining the URL for the image. A common usage would be to specify a suffix of ".gif" in which case the valueIcons property would map values to the names of images without the ".gif" extension.
		 * Flags: IRWA, Group: valueIcons */
		imageURLSuffix?: string; // Flags=IRWA
		/** When true, indicates that changes to this item will cause an automatic save on a DynamicForm.implicitSaveDelay','delay, as well as when the entire form is submitted. If implicitSaveOnBlur is set to true on either this FormItem.implicitSaveOnBlur','formItem or it's DynamicForm.implicitSaveOnBlur','form, changes will also be automatically saved immediately on editorExit.
		 * Flags: IRW */
		implicitSave?: boolean /* Boolean */; // Flags=IRW
		/** If set to true, this item's value will be saved immediately when its "editorExit" handler is fired. This attribute works separately from FormItem.implicitSave','implicitSave, which causes saves during editing, after a DynamicForm.implicitSaveDelay','short delay, and when the entire form is submitted.
		 * Flags: IRW */
		implicitSaveOnBlur?: boolean /* Boolean */; // Flags=IRW
		/** For fields of type "date", if this is an editable field such as a TextItem, this property allows you to specify the DateItem.inputFormat','inputFormat applied to the item.
		 * Flags: IRWA */
		inputFormat?: string /* DateInputFormat */; // Flags=IRWA
		/** Left coordinate of this item in pixels. Applies only when the containing DynamicForm sets itemLayout:"absolute".
		 * Flags: IRWA */
		left?: number /* int */; // Flags=IRWA
		/** Value shown in field when FormItem.fetchMissingValues','fetchMissingValues is active and a fetch is pending. The field is read-only while a fetch is pending. Set to null to show actual value until display value is loaded.
		 * Flags: IRW, Group: display_values */
		loadingDisplayValue?: string /* String */; // Flags=IRW
		/** When AutoTest.getElement is used to parse locator strings generated by AutoTest.getLocator for this form item, should the item be identified? By default if the item has a name this will always be used, however for items with no name, the following options are available: "title" use the title as an identifier within this form "value" use the value of the item to identify it (often used for items with a static defaultValue such as HeaderItems "index" use the index within the form's items array. If unset, and the item has no specified name, default behavior is to identify by title (if available), otherwise by index.
		 * Flags: IRWA, Group: autoTest */
		locateItemBy?: string; // Flags=IRWA
		/** If this item is showing a FormItem.hint, this setting specifies how much horizontal space is made available for rendering the hint text by default. Typically this reflects how much space the hint text takes up before it wraps. Note that the presence of a hint may cause a form item to expand horizontally past its specified FormItem.width. This property value acts as a minimum - if the hint text can not wrap within this width (either due to FormItem.wrapHintText being set to false, or due to it containing long, un-wrappable content), it will further expand to take up the space it needs. If unset this property will be picked up from the DynamicForm.minHintWidth setting. This setting does not apply to hints that are TextItem.showHintInField','shown in field.
		 * Flags: IR */
		minHintWidth?: number /* Integer */; // Flags=IR
		/** If this item is displaying multiple values, this property will be the string that separates those values for display purposes.
		 * Flags: IR, Group: display_values */
		multipleValueSeparator?: string; // Flags=IR
		/** Name for this form field. The FormItem's name determines the name of the property it edits within the form. Must be unique within the form as well as a valid JavaScript identifier, as specified by ECMA-262 Section 7.6 (the String.isValidID function can be used to test whether a name is a valid JavaScript identifier). Note that an item must have a valid name or FormItem.dataPath','dataPath in order for its value to be validated and/or saved.
		 * Flags: IR, Group: basics */
		name?: string /* identifier */; // Flags=IR
		/** OperatorId to be used when DynamicForm.getValuesAsCriteria is called. item.operator can be used to create a form that offers search functions such as numeric range filtering, without the more advanced user interface of the FilterBuilder. For example, two SpinnerItems could be created with formItem.operator set to "greaterThan" and "lessThan" respectively to enable filtering by a numeric range. When item.operator is set for any FormItem in a form, form.getValuesAsCriteria() will return an AdvancedCriteria object instead of a normal Criteria object. Each FormItem will produce one Criterion affecting the DataSource field specified by FormItem.criteriaField. The criteria produced by the FormItems will be grouped under the logical operator provided by DynamicForm.operator. If operator is set for some fields but not others, the default operator is "equals" for fields with a valueMap or an optionDataSource, and for fields of type "enum" (or of a type that inherits from "enum"). The default operator for all other fields is controlled by DynamicForm.defaultSearchOperator. Note: formItem.operator is only supported for a form that has a DataBoundComponent.dataSource','dataSource. In a form with no DataSource, setting formItem.operator will have no effect.
		 * Flags: IR, Group: criteriaEditing */
		operator?: OperatorId; // Flags=IR
		/** If this item has a specified optionDataSource, and this property may be used to specify criteria to pass to the datasource when performing the fetch operation on the dataSource to obtain a data-value to display-value mapping. This property supports dynamicCriteria - use Criterion.valuePath to refer to values in the Canvas.ruleScope. Criteria are re-evaluated when the Canvas.getRuleContext','rule context changes.
		 * Flags: IR, Group: databinding */
		optionCriteria?: Criteria /* criteria */; // Flags=IR
		/** If set, this FormItem will map stored values to display values as though a ValueMap were specified, by fetching records from the specified optionDataSource and extracting the FormItem.valueField','valueField and FormItem.displayField','displayField in loaded records, to derive one valueMap entry per record loaded from the optionDataSource. With the default setting of FormItem.fetchMissingValues','fetchMissingValues, fetches will be initiated against the optionDataSource any time the FormItem has a non-null value and no corresponding display value is available. This includes when the form is first initialized, as well as any subsequent calls to FormItem.setValue, such as may happen when DynamicForm.editRecord is called. Retrieved values are automatically cached by the FormItem. Note that if a normal, static FormItem.valueMap','valueMap is also specified for the field (either directly in the form item or as part of the field definition in the dataSource), it will be preferred to the data derived from the optionDataSource for whatever mappings are present. In a databound form, if FormItem.displayField is specified for a FormItem and optionDataSource is unset, optionDataSource will default to the form's current DataSource
		 * Flags: IR, Group: display_values */
		optionDataSource?: DataSource | string /* DataSource | String */; // Flags=IR
		/** If this item has a specified optionDataSource, and this property is not null, this will be passed to the datasource as RPCRequest properties when performing the fetch operation on the dataSource to obtain a data-value to display-value mapping
		 * Flags: IRA */
		optionFilterContext?: RPCRequestProps /* RPCRequest Properties */; // Flags=IRA
		/** If this item has a specified optionDataSource, this attribute may be set to specify an explicit DSRequest.operationId when performing a fetch against the option dataSource to pick up display value mapping.
		 * Flags: IRA */
		optionOperationId?: string; // Flags=IRA
		/** Message shown when FormItem.showOldValueInHover','showOldValueInHover is enabled and the value has been modified. If unset, defaults to the form's DynamicForm.originalValueMessage. Otherwise, overrides the form-default originalValueMessage for this item.
		 * Flags: IRWA */
		originalValueMessage?: string /* HTMLString */; // Flags=IRWA
		/** The component that will be displayed when FormItem.showPicker is called due to a click on the FormItem.showPickerIcon','picker icon. Can be specified directly as a Canvas, or created automatically via the AutoChild pattern. Note that the picker is not automatically destroyed with the FormItem that uses it, in order to allow recycling of picker components. To destroy a single-use picker, override Canvas.destroy.
		 * Flags: IRW */
		picker?:  Canvas /* AutoChild Canvas */; // Flags=IRW
		/** Class name of the picker to be created.
		 * Flags: IRW */
		pickerConstructor?: string /* SCClassName */; // Flags=IRW
		/** Block of default properties to apply to the pickerIcon for this widget. Intended for class-level customization: To modify this value we recommend using Class.changeDefaults rather than directly assigning a value to the property.
		 * Flags: IRWA, Group: pickerIcon */
		pickerIconDefaults?: FormItemIcon /* FormItemIcon Properties */; // Flags=IRWA
		/** If FormItem.showPickerIcon','showPickerIcon is true for this item, this property governs the size of the picker icon. If unset, the picker icon will be sized as a square to fit in the available height for the icon. It is not recommended to change the pickerIconHeight from the default value if skinning','spriting is enabled because the image sprites are set up assuming specific, fixed dimensions of the picker icon. If the pickerIconHeight must be changed, then the FormItem.pickerIconStyle','pickerIconStyle should be changed to a custom CSS style name.
		 * Flags: IRWA, Group: pickerIcon */
		pickerIconHeight?: number /* int */; // Flags=IRWA
		/** If FormItem.showPickerIcon','showPickerIcon is true, this attribute specifies the FormItemIcon.name applied to the picker icon
		 * Flags: IRA, Group: pickerIcon */
		pickerIconName?: string /* identifier */; // Flags=IRA
		/** Prompt to show when the user hovers the mouse over the picker icon.
		 * Flags: IR, Group: pickerIcon */
		pickerIconPrompt?: string /* HTMLString */; // Flags=IR
		/** If FormItem.showPickerIcon','showPickerIcon is true for this item, this block of properties will be applied to the pickerIcon. Allows for advanced customization of this icon.
		 * Flags: IRWA, Group: pickerIcon */
		pickerIconProperties?: FormItemIcon /* FormItemIcon Properties */; // Flags=IRWA
		/** If FormItem.showPickerIcon','showPickerIcon is true for this item, this property governs the FormItemIcon.src','src of the picker icon image to be displayed.
		 * Flags: IRWA, Group: pickerIcon */
		pickerIconSrc?: string /* SCImgURL */; // Flags=IRWA
		/** Base CSS class name for a form item's picker icon cell. If unset, inherits from this item's FormItem.controlStyle','controlStyle.
		 * Flags: IRW, Group: pickerIcon */
		pickerIconStyle?: string /* FormItemBaseStyle */; // Flags=IRW
		/** If FormItem.showPickerIcon','showPickerIcon is true for this item, this property governs the size of the picker icon. If unset, the picker icon will be sized as a square to fit in the available height for the icon. It is not recommended to change the pickerIconWidth from the default value if skinning','spriting is enabled because the image sprites are set up assuming specific, fixed dimensions of the picker icon. If the pickerIconWidth must be changed, then the FormItem.pickerIconStyle','pickerIconStyle should be changed to a custom CSS style name.
		 * Flags: IRWA, Group: pickerIcon */
		pickerIconWidth?: number /* int */; // Flags=IRWA
		/** Default properties for the picker.
		 * Flags: IRW */
		pickerProperties?: CanvasProps /* Canvas Properties */; // Flags=IRW
		/** Base CSS class name for a form item's text box element when getting printable HTML for the form. If unset FormItem.textBoxStyle will be used instead. Note that focused styling will never be displayed while printing, though error and disabled styling will.
		 * Flags: IRW, Group: printing */
		printTextBoxStyle?: string /* FormItemBaseStyle */; // Flags=IRW
		/** Base CSS stylename for a form item's title when generating print HTML for the item. If unset FormItem.titleStyle will be used instead.
		 * Flags: IRW, Group: printing */
		printTitleStyle?: string /* FormItemBaseStyle */; // Flags=IRW
		/** This text is shown as a tooltip prompt when the cursor hovers over this item. When item is FormItem.setCanEdit','read-only a different hover can be shown with FormItem.readOnlyHover.
		 * Flags: IRW, Group: basics */
		prompt?: string /* HTMLString */; // Flags=IRW
		/** If this item is FormItem.getCanEdit','read-only, how should this item be displayed to the user? If set, overrides the form-level DynamicForm.readOnlyDisplay default.
		 * Flags: IRW */
		readOnlyDisplay?: ReadOnlyDisplayAppearance; // Flags=IRW
		/** This text is shown as a tooltip prompt when the cursor hovers over this item and the item is FormItem.setCanEdit','read-only.
		 * Flags: IRW */
		readOnlyHover?: string /* HTMLString */; // Flags=IRW
		/** Base text box style to apply when this item is FormItem.getCanEdit','read-only and is using FormItem.readOnlyDisplay','readOnlyDisplay "static". If set, overrides the form-level DynamicForm.readOnlyTextBoxStyle default.
		 * Flags: IRW */
		readOnlyTextBoxStyle?: string /* FormItemBaseStyle */; // Flags=IRW
		/** Criteria to be evaluated to determine whether this FormItem should be made FormItem.setCanEdit','read-only. Appearance when read-only is determined by FormItem.readOnlyDisplay. Criteria are evaluated against the DynamicForm.getValues','form\'s current values as well as the current Canvas.ruleScope','rule context. Criteria are re-evaluated every time form values or the rule context changes, whether by end user action or by programmatic calls. A basic criteria uses textMatchStyle:"exact". When specified in componentXML','Component XML this property allows xmlCriteriaShorthand','shorthand formats for defining criteria. Note: A FormItem using readOnlyWhen must have a FormItem.name defined. FormItem.shouldSaveValue can be set to false to prevent the field from storing its value into the form's values.
		 * Flags: IR, Group: ruleCriteria */
		readOnlyWhen?: AdvancedCriteria; // Flags=IR
		/** If true, this item will cause the entire form to be redrawn when the item's "elementChanged" event is done firing
		 * Flags: IRW, Group: changeHandling */
		redrawOnChange?: boolean /* Boolean */; // Flags=IRW
		/** If validateOnChange is true, and validation fails for this item on change, with no suggested value, should we revert to the previous value, or continue to display the bad value entered by the user. May be set at the item or form level.
		 * Flags: IRWA */
		rejectInvalidValueOnChange?: boolean /* Boolean */; // Flags=IRWA
		/** Whether a non-empty value is required for this field to pass validation. If the user does not fill in the required field, the error message to be shown will be taken from these properties in the following order: FormItem.requiredMessage, DynamicForm.requiredMessage, DataSource.requiredMessage, Validator.requiredField. Note: if specified on a FormItem, required is only enforced on the client. required should generally be specified on a DataSourceField.
		 * Flags: IR, Group: validation */
		required?: boolean /* Boolean */; // Flags=IR
		/** The required message for required field errors.
		 * Flags: IRW, Group: validation */
		requiredMessage?: string /* HTMLString */; // Flags=IRW
		/** Criteria to be evaluated to determine whether this FormItem should be FormItem.required','required. Criteria are evaluated against the DynamicForm.getValues','form\'s current values as well as the current Canvas.ruleScope','rule context. Criteria are re-evaluated every time form values or the rule context changes, whether by end user action or by programmatic calls. A basic criteria uses textMatchStyle:"exact". When specified in componentXML','Component XML this property allows xmlCriteriaShorthand','shorthand formats for defining criteria. Note: A FormItem using requiredWhen must have a FormItem.name defined.
		 * Flags: IR, Group: ruleCriteria */
		requiredWhen?: Criteria; // Flags=IR
		/** Number of rows that this item spans
		 * Flags: IRW, Group: formLayout */
		rowSpan?: number; // Flags=IRW
		/** Set this to true to allow the parent form to save it's data when 'Enter' is pressed on this formItem and DynamicForm.saveOnEnter','saveOnEnter is true on the parent form.
		 * Flags: IRW */
		saveOnEnter?: boolean /* Boolean */; // Flags=IRW
		/** Allows the DynamicForm.selectOnClick','selectOnClick behavior to be configured on a per-FormItem basis. Normally all items in a form default to the value of DynamicForm.selectOnClick.
		 * Flags: IRW, Group: focus */
		selectOnClick?: boolean; // Flags=IRW
		/** Allows the DynamicForm.selectOnFocus','selectOnFocus behavior to be configured on a per-FormItem basis. Normally all items in a form default to the value of DynamicForm.selectOnFocus.
		 * Flags: IRW, Group: focus */
		selectOnFocus?: boolean; // Flags=IRW
		/** Should this item's value be saved in the form's values and hence returned from DynamicForm.getValues','form.getValues()? shouldSaveValue:false is used to mark formItems which do not correspond to the underlying data model and should not save a value into the form's DynamicForm.values','values. Example includes visual separators, password re-type fields, or checkboxes used to show/hide other form items. A shouldSaveValue:false item should be given a value either via FormItem.defaultValue or by calling DynamicForm.setValue','form.setValue(item, value) or FormItem.setValue','formItem.setValue(value). Providing a value via DynamicForm.values','form.values or DynamicForm.setValues','form.setValues() will automatically switch the item to shouldSaveValue:true. Note that if an item is shouldSaveValue true, but has no name, a warning is logged, and shouldSaveValue will be set to false. 
		 * Flags: IR, Group: formValues */
		shouldSaveValue?: boolean /* Boolean */; // Flags=IR
		/** If true and the title is clipped, then a hover containing the full title of this item is enabled. The FormItem.titleHover method is called before the hover is displayed, allowing the hover to be canceled if desired. The HTML shown in the hover can be customized by overriding FormItem.titleHoverHTML. 
		 * Flags: IRW, Group: Hovers */
		showClippedTitleOnHover?: boolean; // Flags=IRW
		/** If true and the value is clipped, then a hover containing the full value of this item is enabled. The FormItem.valueHover method is called before the hover is displayed, allowing the hover to be canceled if desired. The HTML shown in the hover can be customized by overriding FormItem.valueHoverHTML. 
		 * Flags: IRW, Group: Hovers */
		showClippedValueOnHover?: boolean /* Boolean */; // Flags=IRW
		/** For items that support SelectItem.multiple','multiple values, this causes distinct CSS styling to be applied to values that the user has unselected. Only allowed when FormItem.showPending','showPending is true. Defaults to the form-level DynamicForm.showDeletions setting if set; otherwise, to the value of showPending. Only supported for MultiComboBoxItem and for SelectItem when SelectItem.multiple','multiple:true is set. The specific default behaviors are: For MultiComboBoxItem, buttons corresponding to deleted values (also called "deselected buttons") will be disabled and have their Button.baseStyle set to MultiComboBoxItem.deselectedButtonStyle. For a multiple SelectItem, FormItem.valueDeselectedCSSText is applied to any deleted value in the text box. In addition, "Deselected" is appended to the cells' ListGrid.baseStyle for cells in the pickList menu corresponding to deleted values. <strong>NOTE:</strong> When a value is shown as deleted, this is not reflected to screen readers, and screen readers are instructed to ignore the deleted value. Therefore, it is not advisable to design a UI where it is necessary for the user to know whether a value is shown as deleted in order to work with the form.
		 * Flags: IRA */
		showDeletions?: boolean /* Boolean */; // Flags=IRA
		/** When this item is disabled, should it be re-styled to indicate its disabled state? See formItemStyling for more details on formItem styling.
		 * Flags: IRWA, Group: formItemStyling */
		showDisabled?: boolean /* Boolean */; // Flags=IRWA
		/** If FormItem.showIconsOnFocus is true, should icons marked as disabled be shown on focus? Default setting is false - it is not commonly desirable to present a user with a disabled icon on focus. Can be overridden at the icon level by FormItemIcon.showDisabledOnFocus
		 * Flags: IRWA, Group: formIcons */
		showDisabledIconsOnFocus?: boolean /* Boolean */; // Flags=IRWA
		/** If FormItem.showPickerIconOnFocus is true, should the picker icon be shown on focus if it is disabled (as in a read-only item, for example?) Default setting is false - it is not commonly desirable to present a user with a disabled icon on focus. Can be overridden at the icon level by FormItemIcon.showDisabledOnFocus
		 * Flags: IRWA, Group: formIcons */
		showDisabledPickerIconOnFocus?: boolean /* Boolean */; // Flags=IRWA
		/** DynamicForm.showErrorIcons','showErrorIcons, DynamicForm.showErrorText','showErrorText, and DynamicForm.showErrorStyle','showErrorStyle control how validation errors are displayed when they are displayed inline in the form (next to the form item where there is a validation error). To instead display all errors at the top of the form, set DynamicForm.showInlineErrors','showInlineErrors:false. showErrorIcons, showErrorText and showErrorStyle are all boolean properties, and can be set on a DynamicForm to control the behavior form-wide, or set on individual FormItems. The HTML displayed next to a form item with errors is generated by FormItem.getErrorHTML. The default implementation of that method respects showErrorIcons and showErrorText as follows: showErrorIcons, or showErrorIcon at the FormItem level controls whether an error icon should appear next to fields which have validation errors. The icon's appearance is governed by FormItem.errorIconSrc, FormItem.errorIconWidth and FormItem.errorIconHeight showErrorText determines whether the text of the validation error should be displayed next to fields which have validation errors. The attribute DynamicForm.showTitlesWithErrorMessages may be set to prefix error messages with the form item's title + ":" (may be desired if the item has FormItem.showTitle set to false). DynamicForm.errorOrientation controls where the error HTML should appear relative to form items. Therefore the combination of FormItem.showErrorText:false and FormItem.errorOrientation:"left" creates a compact validation error display consisting of just an icon, to the left of the item with the error message available via a hover (similar appearance to ListGrid validation error display). In addition to this, showErrorStyle determines whether fields with validation errors should have special styling applied to them. Error styling is achieved by applying suffixes to existing styling applied to various parts of the form item. See FormItemBaseStyle for more on this.
		 * Flags: IRW, Group: errorIcon */
		showErrorIcon?: boolean; // Flags=IRW
		/** DynamicForm.showErrorIcons','showErrorIcons, DynamicForm.showErrorText','showErrorText, and DynamicForm.showErrorStyle','showErrorStyle control how validation errors are displayed when they are displayed inline in the form (next to the form item where there is a validation error). To instead display all errors at the top of the form, set DynamicForm.showInlineErrors','showInlineErrors:false. showErrorIcons, showErrorText and showErrorStyle are all boolean properties, and can be set on a DynamicForm to control the behavior form-wide, or set on individual FormItems. The HTML displayed next to a form item with errors is generated by FormItem.getErrorHTML. The default implementation of that method respects showErrorIcons and showErrorText as follows: showErrorIcons, or showErrorIcon at the FormItem level controls whether an error icon should appear next to fields which have validation errors. The icon's appearance is governed by FormItem.errorIconSrc, FormItem.errorIconWidth and FormItem.errorIconHeight showErrorText determines whether the text of the validation error should be displayed next to fields which have validation errors. The attribute DynamicForm.showTitlesWithErrorMessages may be set to prefix error messages with the form item's title + ":" (may be desired if the item has FormItem.showTitle set to false). DynamicForm.errorOrientation controls where the error HTML should appear relative to form items. Therefore the combination of FormItem.showErrorText:false and FormItem.errorOrientation:"left" creates a compact validation error display consisting of just an icon, to the left of the item with the error message available via a hover (similar appearance to ListGrid validation error display). In addition to this, showErrorStyle determines whether fields with validation errors should have special styling applied to them. Error styling is achieved by applying suffixes to existing styling applied to various parts of the form item. See FormItemBaseStyle for more on this.
		 * Flags: IRW, Group: validation */
		showErrorStyle?: boolean; // Flags=IRW
		/** DynamicForm.showErrorIcons','showErrorIcons, DynamicForm.showErrorText','showErrorText, and DynamicForm.showErrorStyle','showErrorStyle control how validation errors are displayed when they are displayed inline in the form (next to the form item where there is a validation error). To instead display all errors at the top of the form, set DynamicForm.showInlineErrors','showInlineErrors:false. showErrorIcons, showErrorText and showErrorStyle are all boolean properties, and can be set on a DynamicForm to control the behavior form-wide, or set on individual FormItems. The HTML displayed next to a form item with errors is generated by FormItem.getErrorHTML. The default implementation of that method respects showErrorIcons and showErrorText as follows: showErrorIcons, or showErrorIcon at the FormItem level controls whether an error icon should appear next to fields which have validation errors. The icon's appearance is governed by FormItem.errorIconSrc, FormItem.errorIconWidth and FormItem.errorIconHeight showErrorText determines whether the text of the validation error should be displayed next to fields which have validation errors. The attribute DynamicForm.showTitlesWithErrorMessages may be set to prefix error messages with the form item's title + ":" (may be desired if the item has FormItem.showTitle set to false). DynamicForm.errorOrientation controls where the error HTML should appear relative to form items. Therefore the combination of FormItem.showErrorText:false and FormItem.errorOrientation:"left" creates a compact validation error display consisting of just an icon, to the left of the item with the error message available via a hover (similar appearance to ListGrid validation error display). In addition to this, showErrorStyle determines whether fields with validation errors should have special styling applied to them. Error styling is achieved by applying suffixes to existing styling applied to various parts of the form item. See FormItemBaseStyle for more on this.
		 * Flags: IRW, Group: validation */
		showErrorText?: boolean; // Flags=IRW
		/** When this item receives focus, should it be re-styled to indicate it has focus? See formItemStyling for more details on formItem styling.
		 * Flags: IRWA, Group: formItemStyling */
		showFocused?: boolean /* Boolean */; // Flags=IRWA
		/** If set to true, when an item has errors and is focused, an "ErrorFocused" suffix will appear on the stylename.
		 * Flags: IRWA, Group: appearance */
		showFocusedErrorState?: boolean /* Boolean */; // Flags=IRWA
		/** If we're showing icons, should we change their image source to the appropriate focused source when this item has focus? Can be overridden on a per icon basis by the formItemIcon showFocused property.
		 * Flags: IRWA, Group: formIcons */
		showFocusedIcons?: boolean; // Flags=IRWA
		/** If FormItem.showPickerIcon is true for this item, should the picker icon show a focused image when the form item has focus?
		 * Flags: IRW, Group: pickerIcon */
		showFocusedPickerIcon?: boolean /* Boolean */; // Flags=IRW
		/** If a hint is defined for this form item, should it be shown?
		 * Flags: IRWA, Group: appearance */
		showHint?: boolean /* Boolean */; // Flags=IRWA
		/** Set to false to suppress writing out any FormItem.icons for this item.
		 * Flags: IRWA, Group: formIcons */
		showIcons?: boolean /* Boolean */; // Flags=IRWA
		/** Show the FormItem.icons when the item gets focus, and hide them when it loses focus. Can be overridden at the icon level by FormItemIcon.showOnFocus. Note that icons marked as disabled will not be shown on focus even if this flag is true by default. This may be overridden by FormItem.showDisabledIconsOnFocus.
		 * Flags: IRWA, Group: formIcons */
		showIconsOnFocus?: boolean /* Boolean */; // Flags=IRWA
		/** Causes the original value to be shown to the end user when the user hovers over the FormItem as such (when the FormItem.itemHover event would fire). When FormItem.showOldValueInHover and the form's DynamicForm.showOldValueInHover are both unset, defaults to the value of FormItem.showPending. The message shown is controlled by FormItem.originalValueMessage.
		 * Flags: IRWA */
		showOldValueInHover?: boolean /* Boolean */; // Flags=IRWA
		/** When the user rolls over this item, should it be re-styled to indicate it has focus? When enabled, the "Over" styling is applied to the text box, control table (if present), and pickerIcon (if present), and any icons where FormItemIcon.showOver is true and FormItemIcon.showOverWhen is set to "textBox". These behaviors can be disabled piecemeal via FormItem.updateTextBoxOnOver, FormItem.updateControlOnOver and FormItem.updatePickerIconOnOver properties. Developers may also show rollover styling for other icons (see FormItem.showOverIcons and FormItemIcon.showOverWhen). See formItemStyling for more details on formItem styling.
		 * Flags: IRWA, Group: formItemStyling */
		showOver?: boolean; // Flags=IRWA
		/** If we're showing icons, should we change their image source to the appropriate over source when the user rolls over (or puts focus onto) them? Can be overridden on a per icon basis by the formItemIcon showOver property.
		 * Flags: IRWA, Group: formIcons */
		showOverIcons?: boolean; // Flags=IRWA
		/** When true, causes the "Pending" optional suffix to be added if the item's current value differs from the value that would be restored by a call to DynamicForm.resetValues. FormItem.shouldSaveValue','shouldSaveValue must be true for this setting to have an effect. Styling of the value is updated only after the FormItem.change event is processed, so depending on the value of FormItem.changeOnKeypress','changeOnKeypress, styling may be updated immediately on keystroke or only when the user leaves the field. Default styling is provided for the Enterprise, EnterpriseBlue, and Graphite skins only. showPending should not be enabled for an item when using a skin without default styling unless the default FormItem.pendingStatusChanged behavior is canceled and a custom pending visual state is implemented by the item. <strong>NOTE:</strong> Whether an item is shown as pending is not reflected to screen readers. Therefore, it is not advisable to design a UI where it is necessary for the user to know whether an item is shown as pending in order to work with the form.
		 * Flags: IRA */
		showPending?: boolean /* Boolean */; // Flags=IRA
		/** Should we show a special 'picker' FormItemIcon','icon for this form item? Picker icons are customizable via FormItem.pickerIconProperties','pickerIconProperties. By default they will be rendered inside the form item's FormItem.controlStyle','"control box" area, and will call FormItem.showPicker when clicked.
		 * Flags: IRW, Group: pickerIcon */
		showPickerIcon?: boolean /* Boolean */; // Flags=IRW
		/** Show the picker icon when the item gets focus, and hide it when it loses focus. Can be overridden at the icon level by FormItemIcon.showOnFocus. Note that a pickerIcon marked as disabled will not be shown on focus even if this flag is true by default. This may be overridden by FormItem.showDisabledIconsOnFocus.
		 * Flags: IRWA, Group: formIcons */
		showPickerIconOnFocus?: boolean /* Boolean */; // Flags=IRWA
		/** When this item is in RTL mode, should its style name include an "RTL" suffix?
		 * Flags: IRA, Group: RTL */
		showRTL?: boolean; // Flags=IRA
		/** Should we show a title cell for this formItem? Note: the default value of this attribute is overridden by some subclasses.
		 * Flags: IRW, Group: title */
		showTitle?: boolean /* Boolean */; // Flags=IRW
		/** If FormItem.valueIcons is set, this property may be set to show the valueIcon only and prevent the standard form item element or text from displaying
		 * Flags: IRWA, Group: valueIcons */
		showValueIconOnly?: boolean; // Flags=IRWA
		/** Whether this item should always start a new row in the form layout.
		 * Flags: IRW, Group: formLayout */
		startRow?: boolean /* Boolean */; // Flags=IRW
		/** Height of the FormItem when canEdit is false and readOnlyDisplay is "static". The normal FormItem.height is used if this property is not set.
		 * Flags: IR, Group: formLayout */
		staticHeight?: number /* Integer */; // Flags=IR
		/** Indicates that if validation fails, the user should not be allowed to exit the field - focus will be forced back into the field until the error is corrected. This property defaults to DynamicForm.stopOnError if unset. Enabling this property also implies FormItem.validateOnExit is automatically enabled. If there are server-based validators on this item, setting this property also implies that FormItem.synchronousValidation is forced on.
		 * Flags: IR */
		stopOnError?: boolean; // Flags=IR
		/** Does the current formItem support native cut and paste events? This attribute only applies to freeform text entry fields such as TextItem and TextAreaItem, and only if FormItem.changeOnKeypress is true. If true, developers can detect the user editing the value via cut or paste interactions (triggered from keyboard shortcuts or the native browser menu options) using the FormItem.isCutEvent and FormItem.isPasteEvent methods. This allows custom cut/paste handling to be added to the various change notification flow methods including FormItem.change, FormItem.handleChange and FormItem.transformInput.
		 * Flags: IR */
		supportsCutPasteEvents?: boolean; // Flags=IR
		/** If FormItem.valueIcons is set, this property may be set to prevent the value icons from showing up next to the form items value
		 * Flags: IRWA, Group: valueIcons */
		suppressValueIcon?: boolean; // Flags=IRWA
		/** If enabled, whenever validation is triggered and a request to the server is required, user interactivity will be blocked until the request returns. Can be set for the entire form or individual FormItems. If false, the form will try to avoid blocking user interaction until it is strictly required. That is until the user attempts to use a FormItem whose state could be affected by a server request that has not yet returned.
		 * Flags: IR */
		synchronousValidation?: boolean; // Flags=IR
		/** TabIndex for the form item within the form, which controls the order in which controls are visited when the user hits the tab or shift-tab keys to navigate between items. tabIndex is automatically assigned as the order that items appear in the DynamicForm.items list. To specify the tabindex of an item within the page as a whole (not just this form), use FormItem.globalTabIndex instead.
		 * Flags: IRW, Group: focus */
		tabIndex?: number /* integer */; // Flags=IRW
		/** Alignment of the text / content within this form item. Note that FormItem.align may be used to control alignment of the entire form item within its cell. textAlign does not apply to all form item types; typically it applies only to items showing a "textBox", such as a TextItem or SelectItem, as well as text-only form item types such as StaticTextItem and HeaderItem. If FormItem.applyAlignToText','applyAlignToText is true, then textAlign will default to the align setting if set. Otherwise, if this item has FormItem.icons','icons, then textAlign will default to "left" ("right" in Page.isRTL','RTL mode).
		 * Flags: IRW, Group: appearance */
		textAlign?: Alignment; // Flags=IRW
		/** Base CSS class name for a form item's text box element. See formItemStyling for an overview of formItem styling, and the CompoundFormItem_skinning discussion for special skinning considerations. If the textBoxStyle is changed at runtime, FormItem.updateState','updateState() must be called to update the visual state of this item.
		 * Flags: IRW, Group: formItemStyling */
		textBoxStyle?: string /* FormItemBaseStyle */; // Flags=IRW
		/** Formula to be used to calculate the text value of this FormItem. For a numeric field FormItem.formula is used instead. Available fields for use in the formula are the current Canvas.ruleScope','rule context. The formula is re-evaluated every time the rule context changes. See FormItem.formula for details on available fields for the formula and when the formula is calculated. Note: A FormItem using a textFormula must have a FormItem.name defined. FormItem.shouldSaveValue can be set to false to prevent the formula field from storing the calculated value into the form's values.
		 * Flags: IR, Group: formulaFields */
		textFormula?: UserSummary; // Flags=IR
		/** Time-format to apply to date type values within this formItem. If specified, any dates displayed in this item will be formatted as times using the appropriate format. This is most commonly only applied to fields specified as type "time" though if no explicit FormItem.dateFormatter is specified it will be respected for other fields as well. If unspecified, a timeFormatter may be defined DynamicForm.timeFormatter','at the component level and will be respected by fields of type "time".
		 * Flags: IRWA, Group: appearance */
		timeFormatter?: TimeDisplayFormat; // Flags=IRWA
		/** User visible title for this form item.
		 * Flags: IRW, Group: basics */
		title?: string /* String */; // Flags=IRW
		/** Alignment of this item's title in its cell. If null, dynamically set according to text direction.
		 * Flags: IRW, Group: title */
		titleAlign?: Alignment; // Flags=IRW
		/** Number of columns that this item's title spans. This setting only applies for items that are showing a title and whose TitleOrientation is either "left" or "right".
		 * Flags: IRW, Group: formLayout */
		titleColSpan?: number; // Flags=IRW
		/** On which side of this item should the title be placed. TitleOrientation lists valid options. Note that titles on the left or right take up a cell in tabular formLayout','form layouts, but titles on top do not.
		 * Flags: IRW, Group: title */
		titleOrientation?: TitleOrientation; // Flags=IRW
		/** Base CSS class name for a form item's title. Note that this is a FormItemBaseStyle so will pick up stateful suffixes on focus, disabled state change etc. by default. Note the appearance of the title is also affected by DynamicForm.titlePrefix/DynamicForm.titleSuffix','titleSuffix and DynamicForm.requiredTitlePrefix/DynamicForm.requiredTitleSuffix','requiredTitleSuffix.
		 * Flags: IRW */
		titleStyle?: string /* FormItemBaseStyle */; // Flags=IRW
		/** Vertical alignment of this item's title in its cell. Only applies when FormItem.titleOrientation is "left" or "right".
		 * Flags: IRW, Group: title */
		titleVAlign?: VerticalAlignment; // Flags=IRW
		/** Top coordinate of this item in pixels. Applies only when the containing DynamicForm sets itemLayout:"absolute".
		 * Flags: IRWA */
		top?: number /* int */; // Flags=IRWA
		/** The DynamicForm picks a field renderer based on the type of the field (and sometimes other attributes of the field).
		 * Flags: IR, Group: appearance */
		type?: FormItemType; // Flags=IR
		/** If FormItem.showOver is true, setting this property to false will explicitly disable showing the "Over" state for the control table element of this item (if present).
		 * Flags: IRWA, Group: formItemStyling */
		updateControlOnOver?: boolean /* Boolean */; // Flags=IRWA
		/** If FormItem.showOver is true, setting this property to false will explicitly disable showing the "Over" state for the PickerIcon of this item (if present)
		 * Flags: IRWA, Group: formItemStyling */
		updatePickerIconOnOver?: boolean /* Boolean */; // Flags=IRWA
		/** If FormItem.showOver is true, setting this property to false will explicitly disable showing the "Over" state for the TextBox element of this item.
		 * Flags: IRWA, Group: formItemStyling */
		updateTextBoxOnOver?: boolean /* Boolean */; // Flags=IRWA
		/** By default, FormItem.canEdit','read-only fields use the same style name as editable fields for in-field hints, unless they are FormItem.isDisabled','disabled or configured to use a disabled ReadOnlyDisplayAppearance. This is described under TextItem.showHintInField If useDisabledHintStyleForReadOnly is set, the "HintDisabled" style will be used for read-only fields regardless of their ReadOnlyDisplayAppearance. This allows you to use a different in-field hint style for read-only fields without having to use a general disabled appearance for those fields
		 * Flags: IRW, Group: appearance */
		useDisabledHintStyleForReadOnly?: boolean; // Flags=IRW
		/** If FormItem.displayField is specified for a field, should the display value for the field be picked up from the DynamicForm.getValues','record currently being edited? If unset the local display value will be used in the following cases: The formItem has no explicit FormItem.optionDataSource (though a dataSource may be derived from a foreignKey relationship as described in FormItem.getOptionDataSource The FormItem.name matches the FormItem.getValueFieldName','valueField for the item Note that if not explicitly set, this property may defaulted to true for certain fields at the DataSourceField.useLocalDisplayFieldValue','dataSource level.
		 * Flags: IR */
		useLocalDisplayFieldValue?: boolean /* Boolean */; // Flags=IR
		/** If true, form items will be validated when each item's "change" handler is fired as well as when the entire form is submitted or validated. Note that this property can also be set at the form level or on each validator; If true at the form or field level, validators not explicitly set with validateOnChange:false will be fired on change - displaying errors and rejecting the change on validation failure.
		 * Flags: IRW, Group: changeHandling */
		validateOnChange?: boolean /* Boolean */; // Flags=IRW
		/** If true, form items will be validated when each item's "editorExit" handler is fired as well as when the entire form is submitted or validated. Note that this property can also be set at the form level. If true at either level the validator will be fired on editorExit.
		 * Flags: IRW */
		validateOnExit?: boolean /* Boolean */; // Flags=IRW
		/** Validators for this form item. Note: these validators will only be run on the client; to do real client-server validation, validators must be specified via DataSourceField.validators.
		 * Flags: IR */
		validators?: Array<Validator> /* Array of Validator */; // Flags=IR
		/** Array of valid filtering operators (eg "greaterThan") that are legal for this FormItem. Applies only to form/formItem when FormItem.allowExpressions is true, allowing the user to input expressions.
		 * Flags: IR, Group: advancedFilter */
		validOperators?: Array<OperatorId> /* Array of OperatorId */; // Flags=IR
		/** Vertical alignment of this item within its cell. This property governs the position of the item's text box within the cell (not the content within the text box). If FormItem.shouldApplyHeightToTextBox is true, for this to have a visible effect, the cell height must exceed the specified height of the item, either due to an explicit FormItem.cellHeight specification, or due to the row being expanded by another taller item. Has no effect if DynamicForm.itemLayout is set to "absolute" for the form.
		 * Flags: IRW, Group: title */
		vAlign?: VerticalAlignment; // Flags=IRW
		/** Value for this form item. This value may be set directly on the form item initialization block but is not updated on live items and should not be directly accessed. Once a form item has been created by the dynamicForm use FormItem.setValue and FormItem.getValue directly.
		 * Flags: IR, Group: basics */
		value?: any; // Flags=IR
		/** Custom CSS text to be applied to values that have been deleted, when FormItem.showDeletions','showDeletions is enabled.
		 * Flags: IRA */
		valueDeselectedCSSText?: string /* CSSText */; // Flags=IRA
		/** If this form item maps data values to display values by retrieving the FormItem.displayField values from an FormItem.optionDataSource','optionDataSource, this property denotes the the field to use as the underlying data value in records from the optionDataSource. If not explicitly supplied, the valueField name will be derived as described in FormItem.getValueFieldName.
		 * Flags: IR, Group: databinding */
		valueField?: string; // Flags=IR
		/** If FormItem.valueIcons is specified, use this property to specify a height for the value icon written out.
		 * Flags: IRW, Group: valueIcons */
		valueIconHeight?: number; // Flags=IRW
		/** If we're showing a value icon, this attribute governs the amount of space between the icon and the start edge of the form item cell. NOTE: In RTL mode, the valueIconLeftPadding is applied to the <em>right</em> of the value icon.
		 * Flags: IRW, Group: valueIcons */
		valueIconLeftPadding?: number; // Flags=IRW
		/** If we're showing a value icon, this attribute governs the amount of space between the icon and the value text. NOTE: In RTL mode, the valueIconRightPadding is applied to the <em>left</em> of the value icon.
		 * Flags: IRW, Group: valueIcons */
		valueIconRightPadding?: number; // Flags=IRW
		/** A mapping of logical form item values to SCImgURLs or the special value "blank", which means that no image will be displayed. If specified, when the form item is set to the value in question, an icon will be displayed with the appropriate source URL.
		 * Flags: IRW, Group: valueIcons */
		valueIcons?: any /* Object */; // Flags=IRW
		/** If FormItem.valueIcons is specified, this property may be used to specify both the width and height of the icon written out. Note that FormItem.valueIconWidth and FormItem.valueIconHeight take precedence over this value, if specified.
		 * Flags: IRW, Group: valueIcons */
		valueIconSize?: number; // Flags=IRW
		/** If FormItem.valueIcons is specified, use this property to specify a width for the value icon written out.
		 * Flags: IRW, Group: valueIcons */
		valueIconWidth?: number; // Flags=IRW
		/** In a form, valueMaps are used for FormItem types that allow the user to pick from a limited set of values, such as a SelectItem. The valueMap can be either an Array of legal values or an Object where each property maps a stored value to a user-displayable value. To set the initial selection for a form item with a valueMap, use FormItem.defaultValue. See also DataSourceField.valueMap.
		 * Flags: IRW, Group: valueMap */
		valueMap?: Array<any> | any /* Array or Object */; // Flags=IRW
		/** Whether this item is currently visible. visible can only be set on creation. After creation, use FormItem.show and FormItem.hide to manipulate visibility.
		 * Flags: IRW, Group: appearance */
		visible?: boolean /* Boolean */; // Flags=IRW
		/** Criteria to be evaluated to determine whether this FormItem should be visible. Criteria are evaluated against the DynamicForm.getValues','form\'s current values as well as the current Canvas.ruleScope','rule context. Criteria are re-evaluated every time form values or the rule context changes, whether by end user action or by programmatic calls. If both FormItem.showIf and visibleWhen are specified, visibleWhen is ignored. A basic criteria uses textMatchStyle:"exact". When specified in componentXML','Component XML this property allows xmlCriteriaShorthand','shorthand formats for defining criteria. Note: A FormItem using visibleWhen must have a FormItem.name defined. FormItem.shouldSaveValue can be set to false to prevent the field from storing its value into the form's values.
		 * Flags: IR, Group: ruleCriteria */
		visibleWhen?: AdvancedCriteria; // Flags=IR
		/** Width of the FormItem. Can be either a number indicating a fixed width in pixels, or "*" indicating the FormItem fills the space allocated to it's column (or columns, for a FormItem.colSpan','column spanning item). See the formLayout overview for details.
		 * Flags: IRW, Group: formLayout */
		width?: number | string /* int | String */; // Flags=IRW
		/** If this item is showing a FormItem.hint, should the hint text be allowed to wrap? Setting this property to false will render the hint on a single line without wrapping, expanding the width required to render the item if necessary. If unset this property will be picked up from the DynamicForm.wrapHintText setting. This setting does not apply to hints that are TextItem.showHintInField','shown in field.
		 * Flags: IR */
		wrapHintText?: boolean /* Boolean */; // Flags=IR
		/** If specified determines whether this items title should wrap. Overrides DynamicForm.wrapItemTitles','wrapItemTitles at the DynamicForm level.
		 * Flags: IRW, Group: title */
		wrapTitle?: boolean; // Flags=IRW

		/* Method Overrides */

		/** 
		 * Called when this FormItem is clicked on. Note: click() is available on StaticTextItem, BlurbItems, ButtonItem, and derivatives. Other form items (such as HiddenItem) do not support click().
		 * @param {DynamicForm} form - the managing DynamicForm instance
		 * @param {FormItem} item - the form item itself (also available as "this")
		 */
		click?(form:DynamicForm, item:FormItem): boolean; 

		/** 
		 * Return the name for the this formItem.
		 */
		getFieldName?(): string; 

		/** 
		 * Return the value tracked by this form item. Note that for FormItems that have a ValueMap or where a FormItem.formatValue','formatter has been defined, getValue() returns the underlying value of the FormItem, not the displayed value.
		 */
		getValue?(): any; 

		/** 
		 * Hide this form item. This will cause the form to redraw. If this item had an item.showIf expression, it will be destroyed.
		 */
		hide?(): void; 

		/** 
		 * Show this form item. This will cause the form to redraw. If this item had an item.showIf expression, it will be destroyed.
		 */
		show?(): void; 

	} // FormItemProps


	/**
	 * A UI component that can participate in a DynamicForm, allowing editing or display of one of the DynamicForm.values','values tracked by the form. FormItems are never created via the Class.create','create() method, instead, an Array of plain Object','JavaScript objects are passed as DynamicForm.items when the form is created. See the DynamicForm documentation for details and sample code. 
	 */
	export interface FormItem  {
		/** If specified this governs the HTML accessKey for the item. This should be set to a character - when a user hits the html accessKey modifier for the browser, plus this character, focus will be given to the item. The accessKey modifier can vary by browser and platform. The following list of default behavior is for reference only, developers should also consult browser documentation for additional information. Internet Explorer (all platforms): Alt + accessKey Mozilla Firefox (Windows, Unix): Alt+Shift + accessKey Mozilla Firefox (Mac): Ctrl+Opt + accessKey Chrome and Safari (Windows, Unix): Alt + accessKey Chrome and Safari (Mac): Ctrl+Opt + accessKey 
		 * Flags: IRW, Group: focus */
		accessKey: string /* keyChar */;

		/** Alignment of this item in its cell. Note that the alignment of text / content within this item is controlled separately via FormItem.textAlign (typically textAlign applies to items showing a "textBox", such as a TextItem or SelectItem, as well as text-only form item types such as StaticTextItem and HeaderItem). If FormItem.applyAlignToText','applyAlignToText is true, then the textAlign setting, if unset, will default to the align setting if set.
		 * Flags: IRW, Group: appearance */
		align: Alignment;

		/** For a form that produces filter criteria (see DynamicForm.getValuesAsCriteria','form.getValuesAsCriteria()), allows the user to type in simple expressions to cause filtering with that operator. For example, entering "&gt;5" means values greater than 5, and "&gt;0 and &lt;5" means values between 0 and 5. The following table lists character sequences that can be entered as a prefix to a value, and the corresponding OperatorId','operator that will be used. <table style='font-size:14;'> <tr><td>Prefix</td><td>Operator</td></tr> <tr><td>&lt;</td><td>lessThan</td></tr> <tr><td>&gt;</td><td>greaterThan</td></tr> <tr><td>&lt;=</td><td>lessThanOrEqual</td></tr> <tr><td>&gt;=</td><td>greaterThanOrEqual</td></tr> <tr><td>someValue...someValue</td><td>betweenInclusive</td></tr> <tr><td>!</td><td>notEqual</td></tr> <tr><td>^</td><td>startsWith</td></tr> <tr><td>|</td><td>endsWith</td></tr> <tr><td>!^</td><td>notStartsWith plus logical not</td></tr> <tr><td>!@</td><td>notEndsWith plus logical not</td></tr> <tr><td>~</td><td>contains</td></tr> <tr><td>!~</td><td>notContains</td></tr> <tr><td>$</td><td>isBlank</td></tr> <tr><td>!$</td><td>notBlank</td></tr> <tr><td>#</td><td>isNull</td></tr> <tr><td>!#</td><td>isNotNull</td></tr> <tr><td>==</td><td>exact match (for fields where 'contains' is the default)</td></tr> </table> Two further special notations are allowed: /regex/ means the value is taken as a regular expression and applied via the "regexp" operator =.fieldName means the value should match the value of another field. Either the user-visible title of the field (field.title) or the field's name (field.name) may be used. In all cases, if an operator is disallowed for the field (via DataSourceField.validOperators','field.validOperators at either the dataSource or field level), the operator character is ignored (treated as part of a literal value). By default, the case-insensitive version of the operator is used (eg, startsWith will actually use "iStartsWith"). To avoid this, explicitly set item.operator (the default operator) to any case sensitive operator (eg "equals" or "contains") and case sensitive operators will be used for user-entered expressions. Compound expressions (including "and" and "or") are allowed only for numeric or date/time types. Note that if the user does not type a prefix or use other special notation as described above, the operator specified via FormItem.operator is used, or if formItem.operator is unspecified, a default operator chosen as described under FormItem.operator. Also note that whatever you enter will be used literally, including any whitespace characters. For example if you input '== China ' then ' China ' will be the value. The allowExpression behavior can be enabled for every field in a form via DynamicForm.allowExpressions. Finally, note that, like FormItem.operator, enabling allowExpressions:true causes DynamicForm.getValuesAsCriteria','form.getValuesAsCriteria()) to return AdvancedCriteria.
		 * Flags: IRW, Group: advancedFilter */
		allowExpressions: boolean;

		/** If this form item has a specified FormItem.optionDataSource and FormItem.fetchMissingValues is true, when the item value changes, a fetch will be performed against the optionDataSource to retrieve the related record if FormItem.displayField is specified and the new item value is not present in any valueMap explicitly specified on the item. Setting this property to true means that a fetch will occur against the optionDataSource to retrieve the related record even if FormItem.displayField is unset, or the item has a valueMap which explicitly contains this field's value. An example of a use case where this might be set would be if FormItem.formatValue or FormItem.formatEditorValue were written to display properties from the FormItem.getSelectedRecord','selected record. Note - for efficiency we cache the associated record once a fetch has been performed, meaning if the value changes, then reverts to a previously seen value, we do not kick off an additional fetch even if this property is true. If necessary this cache may be explicitly invalidated via a call to FormItem.invalidateDisplayValueCache
		 * Flags: IRWA, Group: display_values */
		alwaysFetchMissingValues: boolean /* Boolean */;

		/** A formItem showing a FormItem.showPickerIcon','pickerIcon will always write out a "control box" around the text box and picker icon. This is an HTML element styled using the specified FormItem.controlStyle. This attribute controls whether the control box should be written out even if the picker icon is not being shown. If unset, default behavior will write out a control table if FormItem.showPickerIcon is true and the icon is not suppressed via FormItemIcon.showIf. This means the control table can be written out with no visible picker if FormItem.showPickerIconOnFocus is true and the item does not have focus. This attribute is useful for developers who wish to rely on styling specified via the FormItem.controlStyle even while the picker icon is not visible. See the formItemStyling','form item styling overview for details of the control table and other styling options.
		 * Flags: IRA */
		alwaysShowControlBox: boolean /* Boolean */;

		/** If the FormItem.textAlign','textAlign is unset, should the FormItem.align','align setting, if set, be used for this item's textAlign? applyAlignToText defaults to false for most form item types. It defaults to true for StaticTextItem and HeaderItem, which are text-based form item types that do not have a natural distinction between the item and its cell.
		 * Flags: IRA, Group: appearance */
		applyAlignToText: boolean;

		/** If FormItem.height is specified, should it be applied to the item's text box element? If unset, behavior is determined as described in FormItem.shouldApplyHeightToTextBox
		 * Flags: IRA */
		applyHeightToTextBox: boolean /* Boolean */;

		/** ARIA role of this formItem. Usually does not need to be manually set - see accessibility.
		 * Flags: IRWA, Group: accessibility */
		ariaRole: string /* String */;

		/** ARIA state mappings for this formItem. Usually this does not need to be manually set - see accessibility. This attribute should be set to a mapping of aria state-names to values - for example to have the "aria-multiline" property be present with a value "true", you'd specify: { multiline : true } 
		 * Flags: IRWA, Group: accessibility */
		ariaState: any /* Object */;

		/** Should this item allow browser auto-completion of its value? Applies only to items based on native HTML form elements (TextItem, PasswordItem, etc), and will only have a user-visible impact for browsers where native autoComplete behavior is actually supported and enabled via user settings. If unset, defaults to DynamicForm.autoComplete. Note that even with this value set to "none", native browser auto-completion may occur for log in forms (forms containing username and PasswordItem','password fields). This behavior varies by browser, and is a result of an <a href='https://www.google.com/search?q=password+ignores+autocomplete+off' target='_blank'>intentional change by some browser developers</a> to disregard the HTML setting autocomplete=off for password items or log-in forms. In some browsers any form redraw (including a redraw from a call to DynamicForm.setValues) will re-populate the form with the natively remembered login credentials. This can make it very difficult to control the values displayed to the user, as a call to 'setValues()' may appear to be ignored. While behavior varies by browser we have specifically observed this behavior in Safari. Moreover in this browser, if the user asks the browser to remember login credentials for a URL, any form with a password item and a text item may be auto-filled with the remembered login credentials, even if the form's configuration and field names differ from those on the login form. If an application has both an initial log in form, and a separate form within the application which makes contains a Password item (a use case might be an interface for a user with manager privileges for modifying other users' passwords), this will cause the second form to autofill with unexpected values. Should this arise, developers can avoid this by making the initial log in interface into a separate log in page from the main application page. This is often good practice in any case for reasons outlined in the "Authentication" section of the Quick Start guide.
		 * Flags: IRW, Group: autoComplete */
		autoComplete: AutoComplete;

		/** Form item input type - governs which keyboard should be displayed for mobile devices (supported on iPhone / iPad)
		 * Flags: IRA */
		browserInputType: string /* String */;

		/** If this browser supports spell-checking of text editing elements, do we want this enabled for this item? If unset the property will be inherited from the containing form. Notes: - this property only applies to text based items such as TextItem and TextAreaItem. - this property is not supported on all browsers.
		 * Flags: IRWA */
		browserSpellCheck: boolean;

		/** Is this form item editable (canEdit:true) or read-only (canEdit:false)? Setting the form item to non-editable causes it to render as read-only. Can be updated at runtime via the FormItem.setCanEdit','setCanEdit() method. Read-only appearance may be specified via FormItem.readOnlyDisplay. The default setting for this value ("readOnly") differs from the disabled state in that the form item is not rendered with disabled styling and most form items will allow copying of the contents while read-only but do not while disabled. Note that for forms bound to a DataSource, if this property is not explicitly set at the item level, its default value will match the DynamicForm.canEditFieldAttribute on the associated dataSource field. Developers should also be aware that the FormItem.readOnlyDisplay attribute is unrelated to the DataSourceField.readOnlyEditorType attribute. When a DynamicForm is first bound to a dataSource, for DataSourceField.canEdit','canEdit:false DataSourceFields, DataSourceField.readOnlyEditorType will determine what FormItemType should be created for the field. Once created, a FormItem's type can not be changed. Setting FormItem.canEdit at runtime will simply change the appearance of the item to allow or disallow editing of the item. 
		 * Flags: IRW, Group: readOnly */
		canEdit: boolean;

		/** If true, indicates that this FormItem is capable of editing "opaque" values, ie, objects that are more complex than simple primitive types like numbers, strings and dates. Ordinarily, you use the SimpleType','SimpleType system to convert these opaque values into "atomic" values that can be edited by the built-in editors like TextItem. However, sometimes you to create a custom editor that knows how to edit a particular opaque type in a domain-specific way - for example, a composite custom FormItem that allows the user to edit both a number and a currency code, both of which are needed to make a proper monetary amount (for that particular application). When this value is set, the FormItem will manage the opaque value directly, rather than it being filtered through calls to SimpleType.getAtomicValue','getAtomicValue() and SimpleType.updateAtomicValue','updateAtomicValue(). Note, if you set this flag on a FormItem that does not have the ability to edit an opaque value (which is something that must be custom-coded) then you will get garbage in your editor, if not an outright crash.
		 * Flags: IRA */
		canEditOpaqueValues: boolean /* Boolean */;

		/** Is this form item focusable? Setting this property to true on an otherwise non-focusable element such as a StaticTextItem will cause the item to be included in the page's tab order and respond to keyboard events.
		 * Flags: IRA, Group: focus */
		canFocus: boolean;

		/** For items showing a text value, should the user be able to select the text in this item?
		 * Flags: IRW */
		canSelectText: boolean;

		/** Should this item's FormItem.icons','icons and FormItem.showPickerIcon','picker icon be included in the page's tab order by default? If not explicitly set, this property will be derived from DynamicForm.canTabToIcons. Developers may also suppress tabbing to individual icons by setting FormItemIcon.tabIndex to -1. Note that if this form item has tabIndex -1, neither the form item nor the icons will be included in the page's tab order.
		 * Flags: IRWA, Group: formIcons */
		canTabToIcons: boolean /* Boolean */;

		/** If specified, this property will govern the height of the cell in which this form item is rendered. Will not apply when the containing DynamicForm sets itemLayout:"absolute".
		 * Flags: IRW */
		cellHeight: number;

		/** CSS style applied to the form item as a whole, including the text element, any icons, and any hint text for the item. Applied to the cell containing the form item. See formItemStyling for an overview of formItem styling, and the CompoundFormItem_skinning discussion for special skinning considerations.
		 * Flags: IRW, Group: formItemStyling */
		cellStyle: string /* FormItemBaseStyle */;

		/** Should this form item fire its FormItem.change','change handler (and store its value in the form) on every keypress? Set to false to suppress the 'change' handler firing (and the value stored) on every keypress. Note: If false, the value returned by FormItem.getValue','getValue will not reflect the value displayed in the form item element as long as focus is in the form item element.
		 * Flags: IRW, Group: eventHandling */
		changeOnKeypress: boolean /* Boolean */;

		/** If this item is FormItem.getCanEdit','read-only and is using FormItem.readOnlyDisplay','readOnlyDisplay "static", should the item value be clipped if it overflows the specified size of the item? If set, overrides the form-level DynamicForm.clipStaticValue default.
		 * Flags: IR */
		clipStaticValue: boolean /* Boolean */;

		/** If the title for this form item is showing, and is too large for the available space should the title be clipped? Null by default - if set to true or false, overrides DynamicForm.clipItemTitles.
		 * Flags: IRW, Group: title */
		clipTitle: boolean;

		/** Number of columns that this item spans. The colSpan setting does not include the title shown for items with FormItem.showTitle:true, so the effective colSpan is one higher than this setting for items that are showing a title and whose TitleOrientation is either "left" or "right".
		 * Flags: IRW, Group: formLayout */
		colSpan: number;

		/** A Read-Only pointer to the SmartClient canvas that holds this form item. In most cases this will be the FormItem.form','DynamicForm containing the item but in some cases editable components handle writing out form items directly. An example of this is editing','Grid Editing - when a listGrid shows per-field editors, the containerWidget for each item will be the listGrid body. Note that even if the containerWidget is not a DynamicForm, a DynamicForm will still exist for the item (available as FormItem.form), allowing access to standard APIs such as DynamicForm.getValues
		 * Flags: RA */
		containerWidget: Canvas;

		/** Base CSS class name for a form item's "control box". This is an HTML element which contains the text box and picker icon for the item. See FormItem.alwaysShowControlBox for details on when the control box is written out. See formItemStyling for an overview of formItem styling, and the CompoundFormItem_skinning discussion for special skinning considerations.
		 * Flags: IRW, Group: formItemStyling */
		controlStyle: string /* FormItemBaseStyle */;

		/** When using FormItem.operator, the name of the DataSource field for the Criterion this FormItem generates. If not specified, defaults to FormItem.name. Generally, because criteriaField defaults to item.name, you don't need to specify it. However, if more than one FormItem specifies criteria for the same DataSource field, they will need unique values for FormItem.name but should set FormItem.criteriaField to the name of DataSource field they both target. For example, if two DateItems are used to provide a min and max date for a single field called "joinDate", set FormItem.criteriaField to "joinDate" on both fields but give the fields distinct names (eg "minDate" and "maxDate") and use those names for any programmatic access, such as DynamicForm.setValue.
		 * Flags: IR */
		criteriaField: string /* identifier */;

		/** dataPath for this item. Allows the user to edit details nested data structures in a flat set of form fields Note that an item must have a valid dataPath or FormItem.name','name in order for its value to be validated and/or saved.
		 * Flags: IR */
		dataPath: string /* DataPath */;

		/** Display format to use for date type values within this formItem. Note that Fields of type "date", "datetime" or "time" will be edited using a DateItem or TimeItem by default, but this can be overridden - for canEdit:false fields, a StaticTextItem is used by default, and the developer can always specify a custom FormItem.editorType as well as FormItem.type','data type. The FormItem.timeFormatter may also be used to format underlying Date values as times (ommitting the date part entirely). If both dateFormatter and timeFormatter are specified on an item, for fields specified as FormItem.type','type "time" the timeFormatter will be used, otherwise the dateFormatter If item.dateFormatter and item.timeFormatter is unspecified, date display format may be defined at the component level via DynamicForm.dateFormatter, or for fields of type "datetime" DynamicForm.datetimeFormatter. Otherwise the default is to use the system-wide default short date format, configured via DateUtil.setShortDisplayFormat. Specify any valid DateDisplayFormat to change the format used by this item. Note that if this is a freeform editable field, such a TextItem, with type specified as "date" or "datetime" the system will automatically attempt to parse user entered values back to a Date value, assuming the entered string matches the date format for the field. Developers may further customize this via an explicit FormItem.inputFormat or via entirely custom FormItem.formatEditorValue and FormItem.parseEditorValue methods. 
		 * Flags: IRWA, Group: appearance */
		dateFormatter: DateDisplayFormat;

		/** Applies only to fields of type "float" and enforces a minimum number of digits shown after the decimal point. For example, a field value of 343.1, 343.104 and 343.09872677 would all be shown as 343.10 if decimalPad is 2. The original unpadded value is always shown when the value is edited.
		 * Flags: IRW, Group: appearance */
		decimalPad: number;

		/** Applies only to fields of type "float" and affects how many significant digits are shown. For example, with decimalPrecision 3, if the field value is 343.672677, 343.673 is shown. If the value is 125.2, 125.2 is shown - decimalPrecision will not cause extra zeros to be added. Use DataSourceField.decimalPad for this. A number is always shown with its original precision when edited.
		 * Flags: IRW, Group: appearance */
		decimalPrecision: number;

		/** Default icon image source. Specify as the partial URL to an image, relative to the imgDir of this component. To specify image source for a specific icon use the icon.src property. If this item is drawn in the disabled state, the url will be modified by adding "_Disabled" to get a disabled state image for the icon. If icon.showOver is true, this url will be modified by adding "_Over" to get an over state image for the icon.
		 * Flags: IRWA, Group: formIcons */
		defaultIconSrc: string /* SCImgURL */;

		/** Value used when no value is provided for this item. Note that whenever this item's value is cleared programmatically (for example via item.clearValue() or item.setValue(null)), it will be reverted to the defaultValue. Developers should use the DynamicForm.values object if their intention is to provide an initial value for a field in a form rather than a value to use in place of null. Developers looking to provide a 'hint' or placeholder value for an empty item may wish to use FormItem.hint (possibly in conjunction with TextItem.showHintInField), or FormItem.prompt. Note: Some items provide a user interface allowing the user to explicitly clear them - for example a standard TextItem. If such an item has a defaultValue specified, and the user explicitly clears that value, the value of the item will be (correctly) reported as null, and will remain null over form item redraw()s. However any programmatic call to set the value to null (including, but not limited to item.clearValue(), item.setValue(null), dynamicForm.setValues(...) with a null value for this field, etc) will reset the item value to its default.
		 * Flags: IRW, Group: basics */
		defaultValue: any;

		/** Whether this item is disabled. Can be updated at runtime via the setDisabled() method. Note that if the widget containing this formItem is disabled, the formItem will behave in a disabled manner regardless of the setting of the item.disabled property. Note that not all items can be disabled, and not all browsers show an obvious disabled style for native form elements.
		 * Flags: IRW, Group: appearance */
		disabled: boolean /* Boolean */;

		/** If FormItem.canEdit is set to false, should FormItem.icons','icons be disabled by default? This may also be specified at the icon level. See FormItemIcon.disableOnReadOnly.
		 * Flags: IRW, Group: formIcons */
		disableIconsOnReadOnly: boolean /* Boolean */;

		/** If set, this item will display a value from another field to the user instead of showing the underlying data value for the FormItem.name','field name. The display value can be derived in two ways: The item will display the displayField value from the DynamicForm.getValues','record currently being edited if FormItem.useLocalDisplayFieldValue is true, (or if unset and the conditions outlined in the documentation for that property are met). Note that DataSourceField.useLocalDisplayFieldValue will default to true if not explicitly set in some cases, as described in the documentation for that property. Otherwise this item will perform a fetch against the FormItem.optionDataSource to find a record where the FormItem.getValueFieldName','value field matches this item's value, and use the displayField, or FormItem.foreignDisplayField value from that record. Note that the specified displayField must be explicitly defined in the optionDataSource to be used - see FormItem.getDisplayFieldName for more on this behavior. This essentially allows the specified optionDataSource to be used as a server based valueMap. Note that if optionDataSource is set and no valid display field is specified, FormItem.getDisplayFieldName will return the dataSource title field by default. If a displayField is specified for a freeform text based item (such as a ComboBoxItem), any user-entered value will be treated as a display value. In this scenario, items will derive the data value for the item from the first record where the displayField value matches the user-entered value. To avoid ambiguity, developers may wish to avoid this usage if display values are not unique.
		 * Flags: IR, Group: databinding */
		displayField: string;

		/** Name of the FormItem to use for editing, eg "TextItem" or "SelectItem". The type of FormItem to use for editing is normally derived automatically from FormItem.type','field.type, which is the data type of the field, by the rules explained FormItemType','here.
		 * Flags: IR, Group: appearance */
		editorType: string /* FormItem class */;

		/** Custom CSS text to be applied to cells with pending edits that have not yet been submitted.
		 * Flags: IRWA, Group: appearance */
		editPendingCSSText: string /* CSSText */;

		/** Default class used to construct the EditProxy for this component when the component is Canvas.setEditMode','first placed into edit mode.
		 * Flags: IR */
		editProxyConstructor: string /* SCClassName */;

		/** Text to display when this form item has a null or undefined value. If the formItem has a databound pickList, and its FormItem.displayField or FormItem.valueField (if the former isn't set) has an undefined ListGridField.emptyCellValue','emptyCellValue setting, that field's emptyCellValue will automatically be set to the emptyDisplayValue.
		 * Flags: IRW, Group: display_values */
		emptyDisplayValue: string;

		/** This property allows the developer to specify an icon to display when this item has no value. It is configured in the same way as any other valueIcon (see FormItem.valueIcons)
		 * Flags: IRW, Group: valueIcons */
		emptyValueIcon: string;

		/** Whether this item should end the row it's in in the form layout
		 * Flags: IRW, Group: formLayout */
		endRow: boolean /* Boolean */;

		/** Height of the error icon, if we're showing icons when validation errors occur.
		 * Flags: IRW, Group: errorIcon */
		errorIconHeight: number;

		/** URL of the image to show as an error icon, if we're showing icons when validation errors occur.
		 * Flags: IRW, Group: errorIcon */
		errorIconSrc: string /* SCImgURL */;

		/** Height of the error icon, if we're showing icons when validation errors occur.
		 * Flags: IRW, Group: errorIcon */
		errorIconWidth: number;

		/** When DynamicForm.showInlineErrors and FormItem.showErrorText are both true and FormItem.errorOrientation is "left" or "right", errorMessageWidth is the amount to reduce the width of the editor to accommodate the error message and icon.
		 * Flags: IRW, Group: validation */
		errorMessageWidth: number /* int */;

		/** If DynamicForm.showInlineErrors is true, where should the error icon and text appear relative to the form item itself. Valid options are "top", "bottom", "left" or "right". If unset the orientation will be derived from DynamicForm.errorOrientation.
		 * Flags: IRW, Group: validation */
		errorOrientation: string /* align */;

		/** FormatString used during exports for numeric or date formatting. See DataSourceField.exportFormat.
		 * Flags: IR, Group: exportFormatting */
		exportFormat: string /* FormatString */;

		/** If this form item has a specified FormItem.optionDataSource, should the item ever perform a fetch against this dataSource to retrieve the related record. The fetch occurs if the item value is non null on initial draw of the form or whenever setValue() is called. Once the fetch completes, the returned record is available via the FormItem.getSelectedRecord api. By default, a fetch will only occur if FormItem.displayField is specified, and the item does not have an explicit FormItem.valueMap containing the data value as a key. However you can also set FormItem.alwaysFetchMissingValues to have a fetch occur even if no displayField is specified. This ensures FormItem.getSelectedRecord will return a record if possible - useful for custom formatter functions, etc. Note - for efficiency we cache the associated record once a fetch has been performed, meaning if the value changes, then reverts to a previously seen value, we do not kick off an additional fetch to pick up the display value for the previously seen data value. If necessary this cache may be explicitly invalidated via a call to FormItem.invalidateDisplayValueCache
		 * Flags: IRWA, Group: display_values */
		fetchMissingValues: boolean /* Boolean */;

		/** If this form item is mapping data values to a display value by fetching records from a dataSource (see FormItem.optionDataSource, FormItem.displayField and FormItem.fetchMissingValues), setting this property to true ensures that when the form item value is set, entire data-set from the dataSource is loaded at once and used as a valueMap, rather than just loading the display value for the current value. This avoids the need to perform fetches each time setValue() is called with a new value. See also PickList.filterLocally for behavior on form items such as SelectItems that show pick-lists.
		 * Flags: IRA, Group: display_values */
		filterLocally: boolean;

		/** For items with an FormItem.optionDataSource, this property specifies an alternative field from which display values should be retrieved for this item. If present this item will attempt to map its underlying value to a display value by retrieving a record from the FormItem.optionDataSource where the FormItem.valueField matches this item's value, and displaying the foreignDisplayField value from that record. This essentially enables the specified optionDataSource to be used as a server based valueMap. If unset, FormItem.displayField may be used. The foreignDisplayField attribute is particularly useful to allow developers to handle the case where one field name is used as a displayField within the form's dataSource (for static display of a value within the current record), and a different field name is to be used to get the display value for records in the FormItem.optionDataSource.
		 * Flags: IR */
		foreignDisplayField: string;

		/** A Read-Only pointer to this formItem's DynamicForm widget.
		 * Flags: R */
		form: DynamicForm;

		/** FormatString for numeric or date formatting. See DataSourceField.format.
		 * Flags: IR, Group: exportFormatting */
		format: string /* FormatString */;

		/** Formula to be used to calculate the numeric value of this FormItem. For a field of type "text" (or subtypes) FormItem.textFormula is used instead. Available fields for use in the formula are the current Canvas.ruleScope','rule context. The formula is re-evaluated every time the rule context changes. Values calculated by the formula will always replace the current value of a non-editable field. For an editable field, the current value will be replaced if the end user has not changed the value since the last time it was computed by the formula, or if the value of the field is invalid according to declared FormItem.validators','validators. Note: A FormItem using a formula must have a FormItem.name defined. FormItem.shouldSaveValue can be set to false to prevent the formula field from storing the calculated value into the form's values.
		 * Flags: IR, Group: formulaFields */
		formula: UserFormula;

		/** TabIndex for the form item within the page. Takes precedence over any local tab index specified as FormItem.tabIndex','item.tabIndex. Use of this API is extremely advanced and essentially implies taking over management of tab index assignment for all components on the page.
		 * Flags: IRWA, Group: focus */
		globalTabIndex: number /* integer */;

		/** Height of the FormItem. Can be either a number indicating a fixed height in pixels, a percentage indicating a percentage of the overall form's height, or "*" indicating take whatever remaining space is available. See the formLayout overview for details. For form items having a FormItem.showPickerIcon','picker icon (e.g. SelectItem, ComboBoxItem) and SpinnerItems, if skinning','spriting is enabled, it is not recommended to change the height of the form item from the default because the image sprites are set up assuming a specific, fixed height of the item. If the item height must be changed, then the FormItem.pickerIconStyle','pickerIconStyle should be changed to a custom CSS style name. Or, in the case of SpinnerItems, the FormItemIcon.baseStyle','baseStyle and FormItemIcon.src','src of the SpinnerItem.increaseIcon and SpinnerItem.decreaseIcon AutoChildren should be customized. Note that when FormItem is rendered as read-only with readOnlyDisplay as "static" the property FormItem.staticHeight is used instead.
		 * Flags: IRW, Group: formLayout */
		height: number | string /* int | String */;

		/** Should this form item be hidden? Setting this property to true on an item configuration will have the same effect as having a FormItem.showIf implementation which returns false. Note this differs slightly from DataSourceField.hidden. That property will cause the field in question to be omitted entirely from databound components by default. A dataSourceField with hidden set to true can still be displayed in a DynamicForm either by being explicitly included in the specified DynamicForm.items','items array, or by having DataBoundComponent.showHiddenFields set to true. In this case, this property will not be inherited onto the FormItem instance, meaning the item will be visible in the form even though the hidden property was set to true on the dataSourceField configuration object.
		 * Flags: IR */
		hidden: boolean /* Boolean */;

		/** Specifies "hint" string to show next to the form item to indicate something to the user. This string generally appears to the right of the form item.
		 * Flags: IRW, Group: appearance */
		hint: string /* HTMLString */;

		/** CSS class for the "hint" string. For items that support TextItem.showHintInField, this only applies when showHintInField is false.
		 * Flags: IRW, Group: formItemStyling */
		hintStyle: string /* CSSStyleName */;

		/** Text alignment for text displayed in this item's hover canvas, if shown.
		 * Flags: IRW, Group: Hovers */
		hoverAlign: Alignment;

		/** If specified, this is the number of milliseconds to wait between the user rolling over this form item, and triggering any hover action for it. If not specified this.form.itemHoverDelay will be used instead.
		 * Flags: IRWA, Group: Hovers */
		hoverDelay: number;

		/** Option to specify a height for any hover shown for this item.
		 * Flags: IRW, Group: Hovers */
		hoverHeight: any /* measure */;

		/** Opacity for any hover shown for this item
		 * Flags: IRW, Group: Hovers */
		hoverOpacity: number;

		/** Explicit CSS Style for any hover shown for this item.
		 * Flags: IRW, Group: Hovers */
		hoverStyle: string /* CSSStyleName */;

		/** Vertical text alignment for text displayed in this item's hover canvas, if shown.
		 * Flags: IRW, Group: Hovers */
		hoverVAlign: VerticalAlignment;

		/** Option to specify a width for any hover shown for this item.
		 * Flags: IRW, Group: Hovers */
		hoverWidth: any /* measure */;

		/** Default height for form item icons. May be overridden at the icon level by FormItemIcon.height.
		 * Flags: IRA, Group: formIcons */
		iconHeight: number /* int */;

		/** Horizontal space (in px) to leave between form item icons. The space appears either on the left or right of each icon. May be overridden at the icon level via FormItemIcon.hspace. Must be non-negative.
		 * Flags: IR, Group: formIcons */
		iconHSpace: number /* int */;

		/** Default prompt (and tooltip-text) for icons.
		 * Flags: IRWA, Group: formIcons */
		iconPrompt: string /* HTMLString */;

		/** An array of descriptor objects for icons to display in a line after this form item. These icons are clickable images, often used to display some kind of helper for populating a form item.
		 * Flags: IRW, Group: formIcons */
		icons: Array<FormItemIcon> /* Array of FormItemIcon Properties */;

		/** How should icons be aligned vertically for this form item.
		 * Flags: IRWA, Group: formIcons */
		iconVAlign: VerticalAlignment;

		/** Default width for form item icons. May be overridden at the icon level by FormItemIcon.width.
		 * Flags: IRA, Group: formIcons */
		iconWidth: number /* int */;

		/** Global identifier for referring to the formItem in JavaScript. The ID property is optional if you do not need to refer to the widget from JavaScript, or can refer to it indirectly (for example, via form.getItem("itemName")). An internal, unique ID will automatically be created upon instantiation for any formItem where one is not provided.
		 * Flags: IRW, Group: basics */
		ID: string /* identifier */;

		/** Prefix to apply to the beginning of any FormItem.valueIcons when determining the URL for the image. Will not be applied if the valueIcon URL is absolute.
		 * Flags: IRWA, Group: valueIcons */
		imageURLPrefix: string;

		/** Suffix to apply to the end of any FormItem.valueIcons when determining the URL for the image. A common usage would be to specify a suffix of ".gif" in which case the valueIcons property would map values to the names of images without the ".gif" extension.
		 * Flags: IRWA, Group: valueIcons */
		imageURLSuffix: string;

		/** When true, indicates that changes to this item will cause an automatic save on a DynamicForm.implicitSaveDelay','delay, as well as when the entire form is submitted. If implicitSaveOnBlur is set to true on either this FormItem.implicitSaveOnBlur','formItem or it's DynamicForm.implicitSaveOnBlur','form, changes will also be automatically saved immediately on editorExit.
		 * Flags: IRW */
		implicitSave: boolean /* Boolean */;

		/** If set to true, this item's value will be saved immediately when its "editorExit" handler is fired. This attribute works separately from FormItem.implicitSave','implicitSave, which causes saves during editing, after a DynamicForm.implicitSaveDelay','short delay, and when the entire form is submitted.
		 * Flags: IRW */
		implicitSaveOnBlur: boolean /* Boolean */;

		/** For fields of type "date", if this is an editable field such as a TextItem, this property allows you to specify the DateItem.inputFormat','inputFormat applied to the item.
		 * Flags: IRWA */
		inputFormat: string /* DateInputFormat */;

		/** Left coordinate of this item in pixels. Applies only when the containing DynamicForm sets itemLayout:"absolute".
		 * Flags: IRWA */
		left: number /* int */;

		/** Value shown in field when FormItem.fetchMissingValues','fetchMissingValues is active and a fetch is pending. The field is read-only while a fetch is pending. Set to null to show actual value until display value is loaded.
		 * Flags: IRW, Group: display_values */
		loadingDisplayValue: string /* String */;

		/** When AutoTest.getElement is used to parse locator strings generated by AutoTest.getLocator for this form item, should the item be identified? By default if the item has a name this will always be used, however for items with no name, the following options are available: "title" use the title as an identifier within this form "value" use the value of the item to identify it (often used for items with a static defaultValue such as HeaderItems "index" use the index within the form's items array. If unset, and the item has no specified name, default behavior is to identify by title (if available), otherwise by index.
		 * Flags: IRWA, Group: autoTest */
		locateItemBy: string;

		/** If this item is showing a FormItem.hint, this setting specifies how much horizontal space is made available for rendering the hint text by default. Typically this reflects how much space the hint text takes up before it wraps. Note that the presence of a hint may cause a form item to expand horizontally past its specified FormItem.width. This property value acts as a minimum - if the hint text can not wrap within this width (either due to FormItem.wrapHintText being set to false, or due to it containing long, un-wrappable content), it will further expand to take up the space it needs. If unset this property will be picked up from the DynamicForm.minHintWidth setting. This setting does not apply to hints that are TextItem.showHintInField','shown in field.
		 * Flags: IR */
		minHintWidth: number /* Integer */;

		/** If this item is displaying multiple values, this property will be the string that separates those values for display purposes.
		 * Flags: IR, Group: display_values */
		multipleValueSeparator: string;

		/** Name for this form field. The FormItem's name determines the name of the property it edits within the form. Must be unique within the form as well as a valid JavaScript identifier, as specified by ECMA-262 Section 7.6 (the String.isValidID function can be used to test whether a name is a valid JavaScript identifier). Note that an item must have a valid name or FormItem.dataPath','dataPath in order for its value to be validated and/or saved.
		 * Flags: IR, Group: basics */
		name: string /* identifier */;

		/** OperatorId to be used when DynamicForm.getValuesAsCriteria is called. item.operator can be used to create a form that offers search functions such as numeric range filtering, without the more advanced user interface of the FilterBuilder. For example, two SpinnerItems could be created with formItem.operator set to "greaterThan" and "lessThan" respectively to enable filtering by a numeric range. When item.operator is set for any FormItem in a form, form.getValuesAsCriteria() will return an AdvancedCriteria object instead of a normal Criteria object. Each FormItem will produce one Criterion affecting the DataSource field specified by FormItem.criteriaField. The criteria produced by the FormItems will be grouped under the logical operator provided by DynamicForm.operator. If operator is set for some fields but not others, the default operator is "equals" for fields with a valueMap or an optionDataSource, and for fields of type "enum" (or of a type that inherits from "enum"). The default operator for all other fields is controlled by DynamicForm.defaultSearchOperator. Note: formItem.operator is only supported for a form that has a DataBoundComponent.dataSource','dataSource. In a form with no DataSource, setting formItem.operator will have no effect.
		 * Flags: IR, Group: criteriaEditing */
		operator: OperatorId;

		/** If this item has a specified optionDataSource, and this property may be used to specify criteria to pass to the datasource when performing the fetch operation on the dataSource to obtain a data-value to display-value mapping. This property supports dynamicCriteria - use Criterion.valuePath to refer to values in the Canvas.ruleScope. Criteria are re-evaluated when the Canvas.getRuleContext','rule context changes.
		 * Flags: IR, Group: databinding */
		optionCriteria: Criteria /* criteria */;

		/** If set, this FormItem will map stored values to display values as though a ValueMap were specified, by fetching records from the specified optionDataSource and extracting the FormItem.valueField','valueField and FormItem.displayField','displayField in loaded records, to derive one valueMap entry per record loaded from the optionDataSource. With the default setting of FormItem.fetchMissingValues','fetchMissingValues, fetches will be initiated against the optionDataSource any time the FormItem has a non-null value and no corresponding display value is available. This includes when the form is first initialized, as well as any subsequent calls to FormItem.setValue, such as may happen when DynamicForm.editRecord is called. Retrieved values are automatically cached by the FormItem. Note that if a normal, static FormItem.valueMap','valueMap is also specified for the field (either directly in the form item or as part of the field definition in the dataSource), it will be preferred to the data derived from the optionDataSource for whatever mappings are present. In a databound form, if FormItem.displayField is specified for a FormItem and optionDataSource is unset, optionDataSource will default to the form's current DataSource
		 * Flags: IR, Group: display_values */
		optionDataSource: DataSource | string /* DataSource | String */;

		/** If this item has a specified optionDataSource, and this property is not null, this will be passed to the datasource as RPCRequest properties when performing the fetch operation on the dataSource to obtain a data-value to display-value mapping
		 * Flags: IRA */
		optionFilterContext: RPCRequestProps /* RPCRequest Properties */;

		/** If this item has a specified optionDataSource, this attribute may be set to specify an explicit DSRequest.operationId when performing a fetch against the option dataSource to pick up display value mapping.
		 * Flags: IRA */
		optionOperationId: string;

		/** Message shown when FormItem.showOldValueInHover','showOldValueInHover is enabled and the value has been modified. If unset, defaults to the form's DynamicForm.originalValueMessage. Otherwise, overrides the form-default originalValueMessage for this item.
		 * Flags: IRWA */
		originalValueMessage: string /* HTMLString */;

		/** The component that will be displayed when FormItem.showPicker is called due to a click on the FormItem.showPickerIcon','picker icon. Can be specified directly as a Canvas, or created automatically via the AutoChild pattern. Note that the picker is not automatically destroyed with the FormItem that uses it, in order to allow recycling of picker components. To destroy a single-use picker, override Canvas.destroy.
		 * Flags: IRW */
		picker:  Canvas /* AutoChild Canvas */;

		/** Class name of the picker to be created.
		 * Flags: IRW */
		pickerConstructor: string /* SCClassName */;

		/** Block of default properties to apply to the pickerIcon for this widget. Intended for class-level customization: To modify this value we recommend using Class.changeDefaults rather than directly assigning a value to the property.
		 * Flags: IRWA, Group: pickerIcon */
		pickerIconDefaults: FormItemIcon /* FormItemIcon Properties */;

		/** If FormItem.showPickerIcon','showPickerIcon is true for this item, this property governs the size of the picker icon. If unset, the picker icon will be sized as a square to fit in the available height for the icon. It is not recommended to change the pickerIconHeight from the default value if skinning','spriting is enabled because the image sprites are set up assuming specific, fixed dimensions of the picker icon. If the pickerIconHeight must be changed, then the FormItem.pickerIconStyle','pickerIconStyle should be changed to a custom CSS style name.
		 * Flags: IRWA, Group: pickerIcon */
		pickerIconHeight: number /* int */;

		/** If FormItem.showPickerIcon','showPickerIcon is true, this attribute specifies the FormItemIcon.name applied to the picker icon
		 * Flags: IRA, Group: pickerIcon */
		pickerIconName: string /* identifier */;

		/** Prompt to show when the user hovers the mouse over the picker icon.
		 * Flags: IR, Group: pickerIcon */
		pickerIconPrompt: string /* HTMLString */;

		/** If FormItem.showPickerIcon','showPickerIcon is true for this item, this block of properties will be applied to the pickerIcon. Allows for advanced customization of this icon.
		 * Flags: IRWA, Group: pickerIcon */
		pickerIconProperties: FormItemIcon /* FormItemIcon Properties */;

		/** If FormItem.showPickerIcon','showPickerIcon is true for this item, this property governs the FormItemIcon.src','src of the picker icon image to be displayed.
		 * Flags: IRWA, Group: pickerIcon */
		pickerIconSrc: string /* SCImgURL */;

		/** Base CSS class name for a form item's picker icon cell. If unset, inherits from this item's FormItem.controlStyle','controlStyle.
		 * Flags: IRW, Group: pickerIcon */
		pickerIconStyle: string /* FormItemBaseStyle */;

		/** If FormItem.showPickerIcon','showPickerIcon is true for this item, this property governs the size of the picker icon. If unset, the picker icon will be sized as a square to fit in the available height for the icon. It is not recommended to change the pickerIconWidth from the default value if skinning','spriting is enabled because the image sprites are set up assuming specific, fixed dimensions of the picker icon. If the pickerIconWidth must be changed, then the FormItem.pickerIconStyle','pickerIconStyle should be changed to a custom CSS style name.
		 * Flags: IRWA, Group: pickerIcon */
		pickerIconWidth: number /* int */;

		/** Default properties for the picker.
		 * Flags: IRW */
		pickerProperties: CanvasProps /* Canvas Properties */;

		/** Base CSS class name for a form item's text box element when getting printable HTML for the form. If unset FormItem.textBoxStyle will be used instead. Note that focused styling will never be displayed while printing, though error and disabled styling will.
		 * Flags: IRW, Group: printing */
		printTextBoxStyle: string /* FormItemBaseStyle */;

		/** Base CSS stylename for a form item's title when generating print HTML for the item. If unset FormItem.titleStyle will be used instead.
		 * Flags: IRW, Group: printing */
		printTitleStyle: string /* FormItemBaseStyle */;

		/** This text is shown as a tooltip prompt when the cursor hovers over this item. When item is FormItem.setCanEdit','read-only a different hover can be shown with FormItem.readOnlyHover.
		 * Flags: IRW, Group: basics */
		prompt: string /* HTMLString */;

		/** If this item is FormItem.getCanEdit','read-only, how should this item be displayed to the user? If set, overrides the form-level DynamicForm.readOnlyDisplay default.
		 * Flags: IRW */
		readOnlyDisplay: ReadOnlyDisplayAppearance;

		/** This text is shown as a tooltip prompt when the cursor hovers over this item and the item is FormItem.setCanEdit','read-only.
		 * Flags: IRW */
		readOnlyHover: string /* HTMLString */;

		/** Base text box style to apply when this item is FormItem.getCanEdit','read-only and is using FormItem.readOnlyDisplay','readOnlyDisplay "static". If set, overrides the form-level DynamicForm.readOnlyTextBoxStyle default.
		 * Flags: IRW */
		readOnlyTextBoxStyle: string /* FormItemBaseStyle */;

		/** Criteria to be evaluated to determine whether this FormItem should be made FormItem.setCanEdit','read-only. Appearance when read-only is determined by FormItem.readOnlyDisplay. Criteria are evaluated against the DynamicForm.getValues','form\'s current values as well as the current Canvas.ruleScope','rule context. Criteria are re-evaluated every time form values or the rule context changes, whether by end user action or by programmatic calls. A basic criteria uses textMatchStyle:"exact". When specified in componentXML','Component XML this property allows xmlCriteriaShorthand','shorthand formats for defining criteria. Note: A FormItem using readOnlyWhen must have a FormItem.name defined. FormItem.shouldSaveValue can be set to false to prevent the field from storing its value into the form's values.
		 * Flags: IR, Group: ruleCriteria */
		readOnlyWhen: AdvancedCriteria;

		/** If true, this item will cause the entire form to be redrawn when the item's "elementChanged" event is done firing
		 * Flags: IRW, Group: changeHandling */
		redrawOnChange: boolean /* Boolean */;

		/** If validateOnChange is true, and validation fails for this item on change, with no suggested value, should we revert to the previous value, or continue to display the bad value entered by the user. May be set at the item or form level.
		 * Flags: IRWA */
		rejectInvalidValueOnChange: boolean /* Boolean */;

		/** Whether a non-empty value is required for this field to pass validation. If the user does not fill in the required field, the error message to be shown will be taken from these properties in the following order: FormItem.requiredMessage, DynamicForm.requiredMessage, DataSource.requiredMessage, Validator.requiredField. Note: if specified on a FormItem, required is only enforced on the client. required should generally be specified on a DataSourceField.
		 * Flags: IR, Group: validation */
		required: boolean /* Boolean */;

		/** The required message for required field errors.
		 * Flags: IRW, Group: validation */
		requiredMessage: string /* HTMLString */;

		/** Criteria to be evaluated to determine whether this FormItem should be FormItem.required','required. Criteria are evaluated against the DynamicForm.getValues','form\'s current values as well as the current Canvas.ruleScope','rule context. Criteria are re-evaluated every time form values or the rule context changes, whether by end user action or by programmatic calls. A basic criteria uses textMatchStyle:"exact". When specified in componentXML','Component XML this property allows xmlCriteriaShorthand','shorthand formats for defining criteria. Note: A FormItem using requiredWhen must have a FormItem.name defined.
		 * Flags: IR, Group: ruleCriteria */
		requiredWhen: Criteria;

		/** Number of rows that this item spans
		 * Flags: IRW, Group: formLayout */
		rowSpan: number;

		/** Set this to true to allow the parent form to save it's data when 'Enter' is pressed on this formItem and DynamicForm.saveOnEnter','saveOnEnter is true on the parent form.
		 * Flags: IRW */
		saveOnEnter: boolean /* Boolean */;

		/** Allows the DynamicForm.selectOnClick','selectOnClick behavior to be configured on a per-FormItem basis. Normally all items in a form default to the value of DynamicForm.selectOnClick.
		 * Flags: IRW, Group: focus */
		selectOnClick: boolean;

		/** Allows the DynamicForm.selectOnFocus','selectOnFocus behavior to be configured on a per-FormItem basis. Normally all items in a form default to the value of DynamicForm.selectOnFocus.
		 * Flags: IRW, Group: focus */
		selectOnFocus: boolean;

		/** Should this item's value be saved in the form's values and hence returned from DynamicForm.getValues','form.getValues()? shouldSaveValue:false is used to mark formItems which do not correspond to the underlying data model and should not save a value into the form's DynamicForm.values','values. Example includes visual separators, password re-type fields, or checkboxes used to show/hide other form items. A shouldSaveValue:false item should be given a value either via FormItem.defaultValue or by calling DynamicForm.setValue','form.setValue(item, value) or FormItem.setValue','formItem.setValue(value). Providing a value via DynamicForm.values','form.values or DynamicForm.setValues','form.setValues() will automatically switch the item to shouldSaveValue:true. Note that if an item is shouldSaveValue true, but has no name, a warning is logged, and shouldSaveValue will be set to false. 
		 * Flags: IR, Group: formValues */
		shouldSaveValue: boolean /* Boolean */;

		/** If true and the title is clipped, then a hover containing the full title of this item is enabled. The FormItem.titleHover method is called before the hover is displayed, allowing the hover to be canceled if desired. The HTML shown in the hover can be customized by overriding FormItem.titleHoverHTML. 
		 * Flags: IRW, Group: Hovers */
		showClippedTitleOnHover: boolean;

		/** If true and the value is clipped, then a hover containing the full value of this item is enabled. The FormItem.valueHover method is called before the hover is displayed, allowing the hover to be canceled if desired. The HTML shown in the hover can be customized by overriding FormItem.valueHoverHTML. 
		 * Flags: IRW, Group: Hovers */
		showClippedValueOnHover: boolean /* Boolean */;

		/** For items that support SelectItem.multiple','multiple values, this causes distinct CSS styling to be applied to values that the user has unselected. Only allowed when FormItem.showPending','showPending is true. Defaults to the form-level DynamicForm.showDeletions setting if set; otherwise, to the value of showPending. Only supported for MultiComboBoxItem and for SelectItem when SelectItem.multiple','multiple:true is set. The specific default behaviors are: For MultiComboBoxItem, buttons corresponding to deleted values (also called "deselected buttons") will be disabled and have their Button.baseStyle set to MultiComboBoxItem.deselectedButtonStyle. For a multiple SelectItem, FormItem.valueDeselectedCSSText is applied to any deleted value in the text box. In addition, "Deselected" is appended to the cells' ListGrid.baseStyle for cells in the pickList menu corresponding to deleted values. <strong>NOTE:</strong> When a value is shown as deleted, this is not reflected to screen readers, and screen readers are instructed to ignore the deleted value. Therefore, it is not advisable to design a UI where it is necessary for the user to know whether a value is shown as deleted in order to work with the form.
		 * Flags: IRA */
		showDeletions: boolean /* Boolean */;

		/** When this item is disabled, should it be re-styled to indicate its disabled state? See formItemStyling for more details on formItem styling.
		 * Flags: IRWA, Group: formItemStyling */
		showDisabled: boolean /* Boolean */;

		/** If FormItem.showIconsOnFocus is true, should icons marked as disabled be shown on focus? Default setting is false - it is not commonly desirable to present a user with a disabled icon on focus. Can be overridden at the icon level by FormItemIcon.showDisabledOnFocus
		 * Flags: IRWA, Group: formIcons */
		showDisabledIconsOnFocus: boolean /* Boolean */;

		/** If FormItem.showPickerIconOnFocus is true, should the picker icon be shown on focus if it is disabled (as in a read-only item, for example?) Default setting is false - it is not commonly desirable to present a user with a disabled icon on focus. Can be overridden at the icon level by FormItemIcon.showDisabledOnFocus
		 * Flags: IRWA, Group: formIcons */
		showDisabledPickerIconOnFocus: boolean /* Boolean */;

		/** DynamicForm.showErrorIcons','showErrorIcons, DynamicForm.showErrorText','showErrorText, and DynamicForm.showErrorStyle','showErrorStyle control how validation errors are displayed when they are displayed inline in the form (next to the form item where there is a validation error). To instead display all errors at the top of the form, set DynamicForm.showInlineErrors','showInlineErrors:false. showErrorIcons, showErrorText and showErrorStyle are all boolean properties, and can be set on a DynamicForm to control the behavior form-wide, or set on individual FormItems. The HTML displayed next to a form item with errors is generated by FormItem.getErrorHTML. The default implementation of that method respects showErrorIcons and showErrorText as follows: showErrorIcons, or showErrorIcon at the FormItem level controls whether an error icon should appear next to fields which have validation errors. The icon's appearance is governed by FormItem.errorIconSrc, FormItem.errorIconWidth and FormItem.errorIconHeight showErrorText determines whether the text of the validation error should be displayed next to fields which have validation errors. The attribute DynamicForm.showTitlesWithErrorMessages may be set to prefix error messages with the form item's title + ":" (may be desired if the item has FormItem.showTitle set to false). DynamicForm.errorOrientation controls where the error HTML should appear relative to form items. Therefore the combination of FormItem.showErrorText:false and FormItem.errorOrientation:"left" creates a compact validation error display consisting of just an icon, to the left of the item with the error message available via a hover (similar appearance to ListGrid validation error display). In addition to this, showErrorStyle determines whether fields with validation errors should have special styling applied to them. Error styling is achieved by applying suffixes to existing styling applied to various parts of the form item. See FormItemBaseStyle for more on this.
		 * Flags: IRW, Group: errorIcon */
		showErrorIcon: boolean;

		/** DynamicForm.showErrorIcons','showErrorIcons, DynamicForm.showErrorText','showErrorText, and DynamicForm.showErrorStyle','showErrorStyle control how validation errors are displayed when they are displayed inline in the form (next to the form item where there is a validation error). To instead display all errors at the top of the form, set DynamicForm.showInlineErrors','showInlineErrors:false. showErrorIcons, showErrorText and showErrorStyle are all boolean properties, and can be set on a DynamicForm to control the behavior form-wide, or set on individual FormItems. The HTML displayed next to a form item with errors is generated by FormItem.getErrorHTML. The default implementation of that method respects showErrorIcons and showErrorText as follows: showErrorIcons, or showErrorIcon at the FormItem level controls whether an error icon should appear next to fields which have validation errors. The icon's appearance is governed by FormItem.errorIconSrc, FormItem.errorIconWidth and FormItem.errorIconHeight showErrorText determines whether the text of the validation error should be displayed next to fields which have validation errors. The attribute DynamicForm.showTitlesWithErrorMessages may be set to prefix error messages with the form item's title + ":" (may be desired if the item has FormItem.showTitle set to false). DynamicForm.errorOrientation controls where the error HTML should appear relative to form items. Therefore the combination of FormItem.showErrorText:false and FormItem.errorOrientation:"left" creates a compact validation error display consisting of just an icon, to the left of the item with the error message available via a hover (similar appearance to ListGrid validation error display). In addition to this, showErrorStyle determines whether fields with validation errors should have special styling applied to them. Error styling is achieved by applying suffixes to existing styling applied to various parts of the form item. See FormItemBaseStyle for more on this.
		 * Flags: IRW, Group: validation */
		showErrorStyle: boolean;

		/** DynamicForm.showErrorIcons','showErrorIcons, DynamicForm.showErrorText','showErrorText, and DynamicForm.showErrorStyle','showErrorStyle control how validation errors are displayed when they are displayed inline in the form (next to the form item where there is a validation error). To instead display all errors at the top of the form, set DynamicForm.showInlineErrors','showInlineErrors:false. showErrorIcons, showErrorText and showErrorStyle are all boolean properties, and can be set on a DynamicForm to control the behavior form-wide, or set on individual FormItems. The HTML displayed next to a form item with errors is generated by FormItem.getErrorHTML. The default implementation of that method respects showErrorIcons and showErrorText as follows: showErrorIcons, or showErrorIcon at the FormItem level controls whether an error icon should appear next to fields which have validation errors. The icon's appearance is governed by FormItem.errorIconSrc, FormItem.errorIconWidth and FormItem.errorIconHeight showErrorText determines whether the text of the validation error should be displayed next to fields which have validation errors. The attribute DynamicForm.showTitlesWithErrorMessages may be set to prefix error messages with the form item's title + ":" (may be desired if the item has FormItem.showTitle set to false). DynamicForm.errorOrientation controls where the error HTML should appear relative to form items. Therefore the combination of FormItem.showErrorText:false and FormItem.errorOrientation:"left" creates a compact validation error display consisting of just an icon, to the left of the item with the error message available via a hover (similar appearance to ListGrid validation error display). In addition to this, showErrorStyle determines whether fields with validation errors should have special styling applied to them. Error styling is achieved by applying suffixes to existing styling applied to various parts of the form item. See FormItemBaseStyle for more on this.
		 * Flags: IRW, Group: validation */
		showErrorText: boolean;

		/** When this item receives focus, should it be re-styled to indicate it has focus? See formItemStyling for more details on formItem styling.
		 * Flags: IRWA, Group: formItemStyling */
		showFocused: boolean /* Boolean */;

		/** If set to true, when an item has errors and is focused, an "ErrorFocused" suffix will appear on the stylename.
		 * Flags: IRWA, Group: appearance */
		showFocusedErrorState: boolean /* Boolean */;

		/** If we're showing icons, should we change their image source to the appropriate focused source when this item has focus? Can be overridden on a per icon basis by the formItemIcon showFocused property.
		 * Flags: IRWA, Group: formIcons */
		showFocusedIcons: boolean;

		/** If FormItem.showPickerIcon is true for this item, should the picker icon show a focused image when the form item has focus?
		 * Flags: IRW, Group: pickerIcon */
		showFocusedPickerIcon: boolean /* Boolean */;

		/** If a hint is defined for this form item, should it be shown?
		 * Flags: IRWA, Group: appearance */
		showHint: boolean /* Boolean */;

		/** Set to false to suppress writing out any FormItem.icons for this item.
		 * Flags: IRWA, Group: formIcons */
		showIcons: boolean /* Boolean */;

		/** Show the FormItem.icons when the item gets focus, and hide them when it loses focus. Can be overridden at the icon level by FormItemIcon.showOnFocus. Note that icons marked as disabled will not be shown on focus even if this flag is true by default. This may be overridden by FormItem.showDisabledIconsOnFocus.
		 * Flags: IRWA, Group: formIcons */
		showIconsOnFocus: boolean /* Boolean */;

		/** Causes the original value to be shown to the end user when the user hovers over the FormItem as such (when the FormItem.itemHover event would fire). When FormItem.showOldValueInHover and the form's DynamicForm.showOldValueInHover are both unset, defaults to the value of FormItem.showPending. The message shown is controlled by FormItem.originalValueMessage.
		 * Flags: IRWA */
		showOldValueInHover: boolean /* Boolean */;

		/** When the user rolls over this item, should it be re-styled to indicate it has focus? When enabled, the "Over" styling is applied to the text box, control table (if present), and pickerIcon (if present), and any icons where FormItemIcon.showOver is true and FormItemIcon.showOverWhen is set to "textBox". These behaviors can be disabled piecemeal via FormItem.updateTextBoxOnOver, FormItem.updateControlOnOver and FormItem.updatePickerIconOnOver properties. Developers may also show rollover styling for other icons (see FormItem.showOverIcons and FormItemIcon.showOverWhen). See formItemStyling for more details on formItem styling.
		 * Flags: IRWA, Group: formItemStyling */
		showOver: boolean;

		/** If we're showing icons, should we change their image source to the appropriate over source when the user rolls over (or puts focus onto) them? Can be overridden on a per icon basis by the formItemIcon showOver property.
		 * Flags: IRWA, Group: formIcons */
		showOverIcons: boolean;

		/** When true, causes the "Pending" optional suffix to be added if the item's current value differs from the value that would be restored by a call to DynamicForm.resetValues. FormItem.shouldSaveValue','shouldSaveValue must be true for this setting to have an effect. Styling of the value is updated only after the FormItem.change event is processed, so depending on the value of FormItem.changeOnKeypress','changeOnKeypress, styling may be updated immediately on keystroke or only when the user leaves the field. Default styling is provided for the Enterprise, EnterpriseBlue, and Graphite skins only. showPending should not be enabled for an item when using a skin without default styling unless the default FormItem.pendingStatusChanged behavior is canceled and a custom pending visual state is implemented by the item. <strong>NOTE:</strong> Whether an item is shown as pending is not reflected to screen readers. Therefore, it is not advisable to design a UI where it is necessary for the user to know whether an item is shown as pending in order to work with the form.
		 * Flags: IRA */
		showPending: boolean /* Boolean */;

		/** Should we show a special 'picker' FormItemIcon','icon for this form item? Picker icons are customizable via FormItem.pickerIconProperties','pickerIconProperties. By default they will be rendered inside the form item's FormItem.controlStyle','"control box" area, and will call FormItem.showPicker when clicked.
		 * Flags: IRW, Group: pickerIcon */
		showPickerIcon: boolean /* Boolean */;

		/** Show the picker icon when the item gets focus, and hide it when it loses focus. Can be overridden at the icon level by FormItemIcon.showOnFocus. Note that a pickerIcon marked as disabled will not be shown on focus even if this flag is true by default. This may be overridden by FormItem.showDisabledIconsOnFocus.
		 * Flags: IRWA, Group: formIcons */
		showPickerIconOnFocus: boolean /* Boolean */;

		/** When this item is in RTL mode, should its style name include an "RTL" suffix?
		 * Flags: IRA, Group: RTL */
		showRTL: boolean;

		/** Should we show a title cell for this formItem? Note: the default value of this attribute is overridden by some subclasses.
		 * Flags: IRW, Group: title */
		showTitle: boolean /* Boolean */;

		/** If FormItem.valueIcons is set, this property may be set to show the valueIcon only and prevent the standard form item element or text from displaying
		 * Flags: IRWA, Group: valueIcons */
		showValueIconOnly: boolean;

		/** Whether this item should always start a new row in the form layout.
		 * Flags: IRW, Group: formLayout */
		startRow: boolean /* Boolean */;

		/** Height of the FormItem when canEdit is false and readOnlyDisplay is "static". The normal FormItem.height is used if this property is not set.
		 * Flags: IR, Group: formLayout */
		staticHeight: number /* Integer */;

		/** Indicates that if validation fails, the user should not be allowed to exit the field - focus will be forced back into the field until the error is corrected. This property defaults to DynamicForm.stopOnError if unset. Enabling this property also implies FormItem.validateOnExit is automatically enabled. If there are server-based validators on this item, setting this property also implies that FormItem.synchronousValidation is forced on.
		 * Flags: IR */
		stopOnError: boolean;

		/** Does the current formItem support native cut and paste events? This attribute only applies to freeform text entry fields such as TextItem and TextAreaItem, and only if FormItem.changeOnKeypress is true. If true, developers can detect the user editing the value via cut or paste interactions (triggered from keyboard shortcuts or the native browser menu options) using the FormItem.isCutEvent and FormItem.isPasteEvent methods. This allows custom cut/paste handling to be added to the various change notification flow methods including FormItem.change, FormItem.handleChange and FormItem.transformInput.
		 * Flags: IR */
		supportsCutPasteEvents: boolean;

		/** If FormItem.valueIcons is set, this property may be set to prevent the value icons from showing up next to the form items value
		 * Flags: IRWA, Group: valueIcons */
		suppressValueIcon: boolean;

		/** If enabled, whenever validation is triggered and a request to the server is required, user interactivity will be blocked until the request returns. Can be set for the entire form or individual FormItems. If false, the form will try to avoid blocking user interaction until it is strictly required. That is until the user attempts to use a FormItem whose state could be affected by a server request that has not yet returned.
		 * Flags: IR */
		synchronousValidation: boolean;

		/** TabIndex for the form item within the form, which controls the order in which controls are visited when the user hits the tab or shift-tab keys to navigate between items. tabIndex is automatically assigned as the order that items appear in the DynamicForm.items list. To specify the tabindex of an item within the page as a whole (not just this form), use FormItem.globalTabIndex instead.
		 * Flags: IRW, Group: focus */
		tabIndex: number /* integer */;

		/** Alignment of the text / content within this form item. Note that FormItem.align may be used to control alignment of the entire form item within its cell. textAlign does not apply to all form item types; typically it applies only to items showing a "textBox", such as a TextItem or SelectItem, as well as text-only form item types such as StaticTextItem and HeaderItem. If FormItem.applyAlignToText','applyAlignToText is true, then textAlign will default to the align setting if set. Otherwise, if this item has FormItem.icons','icons, then textAlign will default to "left" ("right" in Page.isRTL','RTL mode).
		 * Flags: IRW, Group: appearance */
		textAlign: Alignment;

		/** Base CSS class name for a form item's text box element. See formItemStyling for an overview of formItem styling, and the CompoundFormItem_skinning discussion for special skinning considerations. If the textBoxStyle is changed at runtime, FormItem.updateState','updateState() must be called to update the visual state of this item.
		 * Flags: IRW, Group: formItemStyling */
		textBoxStyle: string /* FormItemBaseStyle */;

		/** Formula to be used to calculate the text value of this FormItem. For a numeric field FormItem.formula is used instead. Available fields for use in the formula are the current Canvas.ruleScope','rule context. The formula is re-evaluated every time the rule context changes. See FormItem.formula for details on available fields for the formula and when the formula is calculated. Note: A FormItem using a textFormula must have a FormItem.name defined. FormItem.shouldSaveValue can be set to false to prevent the formula field from storing the calculated value into the form's values.
		 * Flags: IR, Group: formulaFields */
		textFormula: UserSummary;

		/** Time-format to apply to date type values within this formItem. If specified, any dates displayed in this item will be formatted as times using the appropriate format. This is most commonly only applied to fields specified as type "time" though if no explicit FormItem.dateFormatter is specified it will be respected for other fields as well. If unspecified, a timeFormatter may be defined DynamicForm.timeFormatter','at the component level and will be respected by fields of type "time".
		 * Flags: IRWA, Group: appearance */
		timeFormatter: TimeDisplayFormat;

		/** User visible title for this form item.
		 * Flags: IRW, Group: basics */
		title: string /* String */;

		/** Alignment of this item's title in its cell. If null, dynamically set according to text direction.
		 * Flags: IRW, Group: title */
		titleAlign: Alignment;

		/** Number of columns that this item's title spans. This setting only applies for items that are showing a title and whose TitleOrientation is either "left" or "right".
		 * Flags: IRW, Group: formLayout */
		titleColSpan: number;

		/** On which side of this item should the title be placed. TitleOrientation lists valid options. Note that titles on the left or right take up a cell in tabular formLayout','form layouts, but titles on top do not.
		 * Flags: IRW, Group: title */
		titleOrientation: TitleOrientation;

		/** Base CSS class name for a form item's title. Note that this is a FormItemBaseStyle so will pick up stateful suffixes on focus, disabled state change etc. by default. Note the appearance of the title is also affected by DynamicForm.titlePrefix/DynamicForm.titleSuffix','titleSuffix and DynamicForm.requiredTitlePrefix/DynamicForm.requiredTitleSuffix','requiredTitleSuffix.
		 * Flags: IRW */
		titleStyle: string /* FormItemBaseStyle */;

		/** Vertical alignment of this item's title in its cell. Only applies when FormItem.titleOrientation is "left" or "right".
		 * Flags: IRW, Group: title */
		titleVAlign: VerticalAlignment;

		/** Top coordinate of this item in pixels. Applies only when the containing DynamicForm sets itemLayout:"absolute".
		 * Flags: IRWA */
		top: number /* int */;

		/** The DynamicForm picks a field renderer based on the type of the field (and sometimes other attributes of the field).
		 * Flags: IR, Group: appearance */
		type: FormItemType;

		/** If FormItem.showOver is true, setting this property to false will explicitly disable showing the "Over" state for the control table element of this item (if present).
		 * Flags: IRWA, Group: formItemStyling */
		updateControlOnOver: boolean /* Boolean */;

		/** If FormItem.showOver is true, setting this property to false will explicitly disable showing the "Over" state for the PickerIcon of this item (if present)
		 * Flags: IRWA, Group: formItemStyling */
		updatePickerIconOnOver: boolean /* Boolean */;

		/** If FormItem.showOver is true, setting this property to false will explicitly disable showing the "Over" state for the TextBox element of this item.
		 * Flags: IRWA, Group: formItemStyling */
		updateTextBoxOnOver: boolean /* Boolean */;

		/** By default, FormItem.canEdit','read-only fields use the same style name as editable fields for in-field hints, unless they are FormItem.isDisabled','disabled or configured to use a disabled ReadOnlyDisplayAppearance. This is described under TextItem.showHintInField If useDisabledHintStyleForReadOnly is set, the "HintDisabled" style will be used for read-only fields regardless of their ReadOnlyDisplayAppearance. This allows you to use a different in-field hint style for read-only fields without having to use a general disabled appearance for those fields
		 * Flags: IRW, Group: appearance */
		useDisabledHintStyleForReadOnly: boolean;

		/** If FormItem.displayField is specified for a field, should the display value for the field be picked up from the DynamicForm.getValues','record currently being edited? If unset the local display value will be used in the following cases: The formItem has no explicit FormItem.optionDataSource (though a dataSource may be derived from a foreignKey relationship as described in FormItem.getOptionDataSource The FormItem.name matches the FormItem.getValueFieldName','valueField for the item Note that if not explicitly set, this property may defaulted to true for certain fields at the DataSourceField.useLocalDisplayFieldValue','dataSource level.
		 * Flags: IR */
		useLocalDisplayFieldValue: boolean /* Boolean */;

		/** If true, form items will be validated when each item's "change" handler is fired as well as when the entire form is submitted or validated. Note that this property can also be set at the form level or on each validator; If true at the form or field level, validators not explicitly set with validateOnChange:false will be fired on change - displaying errors and rejecting the change on validation failure.
		 * Flags: IRW, Group: changeHandling */
		validateOnChange: boolean /* Boolean */;

		/** If true, form items will be validated when each item's "editorExit" handler is fired as well as when the entire form is submitted or validated. Note that this property can also be set at the form level. If true at either level the validator will be fired on editorExit.
		 * Flags: IRW */
		validateOnExit: boolean /* Boolean */;

		/** Validators for this form item. Note: these validators will only be run on the client; to do real client-server validation, validators must be specified via DataSourceField.validators.
		 * Flags: IR */
		validators: Array<Validator> /* Array of Validator */;

		/** Array of valid filtering operators (eg "greaterThan") that are legal for this FormItem. Applies only to form/formItem when FormItem.allowExpressions is true, allowing the user to input expressions.
		 * Flags: IR, Group: advancedFilter */
		validOperators: Array<OperatorId> /* Array of OperatorId */;

		/** Vertical alignment of this item within its cell. This property governs the position of the item's text box within the cell (not the content within the text box). If FormItem.shouldApplyHeightToTextBox is true, for this to have a visible effect, the cell height must exceed the specified height of the item, either due to an explicit FormItem.cellHeight specification, or due to the row being expanded by another taller item. Has no effect if DynamicForm.itemLayout is set to "absolute" for the form.
		 * Flags: IRW, Group: title */
		vAlign: VerticalAlignment;

		/** Value for this form item. This value may be set directly on the form item initialization block but is not updated on live items and should not be directly accessed. Once a form item has been created by the dynamicForm use FormItem.setValue and FormItem.getValue directly.
		 * Flags: IR, Group: basics */
		value: any;

		/** Custom CSS text to be applied to values that have been deleted, when FormItem.showDeletions','showDeletions is enabled.
		 * Flags: IRA */
		valueDeselectedCSSText: string /* CSSText */;

		/** If this form item maps data values to display values by retrieving the FormItem.displayField values from an FormItem.optionDataSource','optionDataSource, this property denotes the the field to use as the underlying data value in records from the optionDataSource. If not explicitly supplied, the valueField name will be derived as described in FormItem.getValueFieldName.
		 * Flags: IR, Group: databinding */
		valueField: string;

		/** If FormItem.valueIcons is specified, use this property to specify a height for the value icon written out.
		 * Flags: IRW, Group: valueIcons */
		valueIconHeight: number;

		/** If we're showing a value icon, this attribute governs the amount of space between the icon and the start edge of the form item cell. NOTE: In RTL mode, the valueIconLeftPadding is applied to the <em>right</em> of the value icon.
		 * Flags: IRW, Group: valueIcons */
		valueIconLeftPadding: number;

		/** If we're showing a value icon, this attribute governs the amount of space between the icon and the value text. NOTE: In RTL mode, the valueIconRightPadding is applied to the <em>left</em> of the value icon.
		 * Flags: IRW, Group: valueIcons */
		valueIconRightPadding: number;

		/** A mapping of logical form item values to SCImgURLs or the special value "blank", which means that no image will be displayed. If specified, when the form item is set to the value in question, an icon will be displayed with the appropriate source URL.
		 * Flags: IRW, Group: valueIcons */
		valueIcons: any /* Object */;

		/** If FormItem.valueIcons is specified, this property may be used to specify both the width and height of the icon written out. Note that FormItem.valueIconWidth and FormItem.valueIconHeight take precedence over this value, if specified.
		 * Flags: IRW, Group: valueIcons */
		valueIconSize: number;

		/** If FormItem.valueIcons is specified, use this property to specify a width for the value icon written out.
		 * Flags: IRW, Group: valueIcons */
		valueIconWidth: number;

		/** In a form, valueMaps are used for FormItem types that allow the user to pick from a limited set of values, such as a SelectItem. The valueMap can be either an Array of legal values or an Object where each property maps a stored value to a user-displayable value. To set the initial selection for a form item with a valueMap, use FormItem.defaultValue. See also DataSourceField.valueMap.
		 * Flags: IRW, Group: valueMap */
		valueMap: Array<any> | any /* Array or Object */;

		/** Whether this item is currently visible. visible can only be set on creation. After creation, use FormItem.show and FormItem.hide to manipulate visibility.
		 * Flags: IRW, Group: appearance */
		visible: boolean /* Boolean */;

		/** Criteria to be evaluated to determine whether this FormItem should be visible. Criteria are evaluated against the DynamicForm.getValues','form\'s current values as well as the current Canvas.ruleScope','rule context. Criteria are re-evaluated every time form values or the rule context changes, whether by end user action or by programmatic calls. If both FormItem.showIf and visibleWhen are specified, visibleWhen is ignored. A basic criteria uses textMatchStyle:"exact". When specified in componentXML','Component XML this property allows xmlCriteriaShorthand','shorthand formats for defining criteria. Note: A FormItem using visibleWhen must have a FormItem.name defined. FormItem.shouldSaveValue can be set to false to prevent the field from storing its value into the form's values.
		 * Flags: IR, Group: ruleCriteria */
		visibleWhen: AdvancedCriteria;

		/** Width of the FormItem. Can be either a number indicating a fixed width in pixels, or "*" indicating the FormItem fills the space allocated to it's column (or columns, for a FormItem.colSpan','column spanning item). See the formLayout overview for details.
		 * Flags: IRW, Group: formLayout */
		width: number | string /* int | String */;

		/** If this item is showing a FormItem.hint, should the hint text be allowed to wrap? Setting this property to false will render the hint on a single line without wrapping, expanding the width required to render the item if necessary. If unset this property will be picked up from the DynamicForm.wrapHintText setting. This setting does not apply to hints that are TextItem.showHintInField','shown in field.
		 * Flags: IR */
		wrapHintText: boolean /* Boolean */;

		/** If specified determines whether this items title should wrap. Overrides DynamicForm.wrapItemTitles','wrapItemTitles at the DynamicForm level.
		 * Flags: IRW, Group: title */
		wrapTitle: boolean;


		/* Instance Method Overrides */

		/** 
		 * Called when this FormItem is clicked on. Note: click() is available on StaticTextItem, BlurbItems, ButtonItem, and derivatives. Other form items (such as HiddenItem) do not support click().
		 * @param {DynamicForm} form - the managing DynamicForm instance
		 * @param {FormItem} item - the form item itself (also available as "this")
		 */
		click?(form:DynamicForm, item:FormItem): boolean; 

		/** 
		 * Return the name for the this formItem.
		 */
		getFieldName?(): string; 

		/** 
		 * Return the value tracked by this form item. Note that for FormItems that have a ValueMap or where a FormItem.formatValue','formatter has been defined, getValue() returns the underlying value of the FormItem, not the displayed value.
		 */
		getValue?(): any; 

		/** 
		 * Hide this form item. This will cause the form to redraw. If this item had an item.showIf expression, it will be destroyed.
		 */
		hide?(): void; 

		/** 
		 * Show this form item. This will cause the form to redraw. If this item had an item.showIf expression, it will be destroyed.
		 */
		show?(): void; 

	} // FormItem

	export interface FormItemStatic<T, P> extends ClassStatic<T, P> {

	/* Methods */

/* Not - because it conflicts with Class.create()
		/** 
		 * FormItem.create() should never be called directly, instead, create a DynamicForm and specify form items via DynamicForm.items','form.items.
		 * /
		create(): void; 

 */ 

	} // FormItemStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a GridRenderer Props argument.
	 * This is derived from the methods in the GridRenderer class and it's parents and their properties marked with the I flag.
	 */
	export interface GridRendererProps  {
		/** The number of consecutive columns to draw in the same style before alternating, when GridRenderer.alternateColumnStyles','alternateColumnStyles is true.
		 * Flags: IRW, Group: cellStyling */
		alternateColumnFrequency?: number; // Flags=IRW
		/** Whether alternating columns (or blocks of columns, depending on GridRenderer.alternateColumnFrequency) should be drawn in alternating styles, in order to create a vertical "ledger" effect for easier reading. If enabled, the cell style for alternate rows will have the GridRenderer.alternateColumnSuffix appended to it. See also GridRenderer.alternateRowStyles.
		 * Flags: IRW, Group: cellStyling */
		alternateColumnStyles?: boolean; // Flags=IRW
		/** Suffix to append to GridRenderer.alternateColumnStyles','alternate columns. Note that if GridRenderer.alternateRowStyles is enabled, cells which fall into both an alternate row and column will have both suffixes appended - for example "cellDarkAltCol".
		 * Flags: IRW, Group: cellStyling */
		alternateColumnSuffix?: string /* String */; // Flags=IRW
		/** The number of consecutive rows to draw in the same style before alternating, when GridRenderer.alternateRowStyles','alternateRowStyles is true.
		 * Flags: IRW, Group: cellStyling */
		alternateRowFrequency?: number; // Flags=IRW
		/** Whether alternating rows (or blocks of rows, depending on GridRenderer.alternateRowFrequency) should be drawn in alternating styles, in order to create a "ledger" effect for easier reading. If enabled, the cell style for alternate rows will have the GridRenderer.alternateRowSuffix appended to it. See also GridRenderer.alternateColumnStyles.
		 * Flags: IRW, Group: cellStyling */
		alternateRowStyles?: boolean; // Flags=IRW
		/** Suffix to append to GridRenderer.alternateRowStyles','alternate rows. Note that if GridRenderer.alternateColumnStyles is enabled, cells which fall into both an alternate row and column will have both suffixes appended - for example "cellDarkAltCol".
		 * Flags: IRW, Group: cellStyling */
		alternateRowSuffix?: string /* String */; // Flags=IRW
		/** If true, make columns only wide enough to fit content, ignoring any widths specified. Overrides fixedFieldWidths.
		 * Flags: IRWA, Group: sizing */
		autoFit?: boolean; // Flags=IRWA
		/** The base name for the CSS class applied to cells. This style will have "Dark", "Over", "Selected", or "Disabled" appended to it according to the state of the cell.
		 * Flags: IR, Group: cellStyling */
		baseStyle?: string /* CSSStyleName */; // Flags=IR
		/** The default height of each row in pixels.
		 * Flags: IRW, Group: cellStyling */
		cellHeight?: number; // Flags=IRW
		/** The amount of empty space, in pixels, surrounding each value in its cell.
		 * Flags: IRW, Group: cellStyling */
		cellPadding?: number; // Flags=IRW
		/** How far should we render rows ahead of the currently visible area? This is expressed as a ratio from viewport size to rendered area size. Tweaking drawAheadRatio allows you to make tradeoffs between continuous scrolling speed vs initial render time and render time when scrolling by large amounts. NOTE: Only applies when showAllRows is false.
		 * Flags: IRWA, Group: performance */
		drawAheadRatio?: number /* float */; // Flags=IRWA
		/** If drawing all rows would cause less than drawAllMaxCells cells to be rendered, the full dataset will instead be drawn even if ListGrid.showAllRecords','showAllRecords is false and the viewport size and GridRenderer.drawAheadRatio setting would normally have caused incremental rendering to be used. The drawAllMaxCells setting prevents incremental rendering from being used in situations where it's really unnecessary, such as a 40 row, 5 column dataset (only 200 cells) which happens to be in a grid with a viewport showing only 20 or so rows. Incremental rendering causes a brief "flash" during scrolling as the visible portion of the dataset is redrawn, and a better scrolling experience can be obtained in this situation by drawing the entire dataset up front, which in this example would have negligible effect on initial draw time. drawAllMaxCells:0 disables this features. You may want to disable this feature if performance is an issue and: you are very frequently redraw a grid you do a lot of computation when rendering each cell (eg formulas) you are showing many grids on one screen and the user won't scroll most of them 
		 * Flags: IRWA, Group: performance */
		drawAllMaxCells?: number /* integer */; // Flags=IRWA
		/** Value to show in empty cells (when getCellValue returns null).
		 * Flags: IRW, Group: cellStyling */
		emptyCellValue?: string; // Flags=IRW
		/** The string to display in the body of a listGrid with an empty data array, if showEmptyMessage is true.
		 * Flags: IRW, Group: emptyMessage */
		emptyMessage?: string; // Flags=IRW
		/** The CSS style name applied to the emptyMessage string if displayed.
		 * Flags: IRW, Group: emptyMessage */
		emptyMessageStyle?: string /* CSSStyleName */; // Flags=IRW
		/** CSS styleName for the table as a whole if we're showing the empty message
		 * Flags: IRW, Group: emptyMessage */
		emptyMessageTableStyle?: string /* CSSStyleName */; // Flags=IRW
		/** Note: This property only has an effect in Internet Explorer Advanced property to improve performance for dynamic styling of gridRenderer cells in Internet Explorer, at the expense of slightly slower initial drawing, and some limitations on supported styling options. fastCellUpdates speeds up the dynamic styling system used by rollovers, selections, and custom styling that calls GridRenderer.refreshCellStyle, at the cost of slightly slower draw() and redraw() times. Notes: When this property is set, ListGrid cells may be styled using the ListGrid.tallBaseStyle. See ListGrid.getBaseStyle for more information. If any cell styles specify a a background image URL, the URL will be resolved relative to the page location rather than the location of the CSS stylesheet. This means cell styles with a background URL should either supply a fully qualified path, or the background image media should be made available at a second location for IE. fastCellUpdates will not work if the styles involved are in an external stylesheet loaded from a remote host. Either the stylesheet containing cell styles needs to be loaded from the same host as the main page, or the cell styles need to be inlined in the html of the bootstrap page. fastCellUpdates will not work if the css styles for cells are defined in a .css file loaded via @import. Instead the .css file should be loaded via a &lt;link ...&gt; tag. 
		 * Flags: IRWA */
		fastCellUpdates?: boolean; // Flags=IRWA
		/** Should we horizontally clip cell contents, or allow columns to expand horizontally to show all contents? If we allow columns to expand, the column width is treated as a minimum.
		 * Flags: IRWA, Group: sizing */
		fixedColumnWidths?: boolean; // Flags=IRWA
		/** Should we vertically clip cell contents, or allow rows to expand vertically to show all contents? If we allow rows to expand, the row height as derived from GridRenderer.getRowHeight','getRowHeight() or the default GridRenderer.cellHeight is treated as a minimum.
		 * Flags: IRWA, Group: cellStyling */
		fixedRowHeights?: boolean; // Flags=IRWA
		/** If true, if the user clicks on the scroll buttons at the end of the track or clicks once on the scroll track, there will be an instant redraw of the grid content so that the user doesn't see any blank space. For drag scrolling or other types of scrolling, the GridRenderer.scrollRedrawDelay applies.
		 * Flags: IRW, Group: performance */
		instantScrollTrackRedraw?: boolean; // Flags=IRW
		/** The string to display in the body of a listGrid with an empty data array, if showOfflineMessage is true and the data array is empty because we are offline and there is no suitable cached response
		 * Flags: IRW, Group: offlineGroup */
		offlineMessage?: string; // Flags=IRW
		/** The CSS style name applied to the offlineMessage string if displayed.
		 * Flags: IRW, Group: emptyMessage */
		offlineMessageStyle?: string /* CSSStyleName */; // Flags=IRW
		/** Alternative to GridRenderer.drawAheadRatio, to be used when the user is rapidly changing the grids viewport (for example drag scrolling through the grid). If unspecified GridRenderer.drawAheadRatio will be used in all cases
		 * Flags: IRWA, Group: performance */
		quickDrawAheadRatio?: number /* float */; // Flags=IRWA
		/** Denotes the name of a property that can be set on records to display a custom style. For example if this property is set to "customStyle", setting record.customStyle to a css styleName will cause the record in question to render out with that styling applied to it. Note that this will be a static style - it will not be modified as the state of the record (selected / over etc) changes.
		 * Flags: IRW */
		recordCustomStyleProperty?: "customStyle"; // Flags=IRW
		/** While drag scrolling in an incrementally rendered grid, time in milliseconds to wait before redrawing, after the last mouse movement by the user. This delay may be separately customized for mouse-wheel scrolling via GridRenderer.scrollWheelRedrawDelay. See also GridRenderer.instantScrollTrackRedraw for cases where this delay is skipped. <strong>NOTE:</strong> In Browser.isTouch','touch browsers, GridRenderer.touchScrollRedrawDelay','touchScrollRedrawDelay is used instead.
		 * Flags: IRW, Group: performance */
		scrollRedrawDelay?: number /* int */; // Flags=IRW
		/** While scrolling an incrementally rendered grid, using the mouseWheel, time in milliseconds to wait before redrawing, after the last mouseWheel movement by the user. If not specified GridRenderer.scrollRedrawDelay will be used as a default for both drag scrolling and mouseWheel scrolling. See also GridRenderer.instantScrollTrackRedraw for cases where this delay is skipped.
		 * Flags: IRW, Group: performance */
		scrollWheelRedrawDelay?: number /* Integer */; // Flags=IRW
		/** Whether all columns should be drawn all at once, or only columns visible in the viewport. Drawing all columns causes longer initial rendering time, but allows smoother horizontal scrolling. With a very large number of columns, showAllColumns will become too slow.
		 * Flags: IRA, Group: performance */
		showAllColumns?: boolean; // Flags=IRA
		/** Whether all rows should be drawn all at once, or only rows visible in the viewport. Drawing all rows causes longer initial rendering time, but allows smoother vertical scrolling. With a very large number of rows, showAllRows will become too slow. See also GridRenderer.drawAheadRatio and GridRenderer.drawAllMaxCells.
		 * Flags: IRA, Group: performance */
		showAllRows?: boolean; // Flags=IRA
		/** If true and a cell's value is clipped, then a hover containing the full cell value is enabled. Note that standard cell hovers override clipped value hovers. Thus, to enable clipped value hovers, GridRenderer.canHover','canHover must be unset or null and the corresponding field must have ListGridField.showHover','showHover unset or null as well.
		 * Flags: IRWA, Group: events */
		showClippedValuesOnHover?: boolean /* Boolean */; // Flags=IRWA
		/** Indicates whether the text of the emptyMessage property should be displayed if no data is available.
		 * Flags: IRW, Group: emptyMessage */
		showEmptyMessage?: boolean; // Flags=IRW
		/** Indicates whether the text of the offlineMessage property should be displayed if no data is available because we are offline and there is no suitable cached response
		 * Flags: IRW, Group: emptyMessage */
		showOfflineMessage?: boolean; // Flags=IRW
		/** Should the "Selected" style be applied to selected records?
		 * Flags: IRW */
		showSelectedStyle?: boolean; // Flags=IRW
		/** If true, snap-to-cell drops will snap the dropped object inside the selected cell's border. If false, snap-to-cell drops will snap the dropped object to the edge of the selected cell, regardless of borders
		 * Flags: IRW, Group: dragdrop */
		snapInsideBorder?: boolean; // Flags=IRW
		/** Should drag-and-drop operations snap the dragged object into line with the nearest cell?
		 * Flags: IRW, Group: dragdrop */
		snapToCells?: boolean; // Flags=IRW
		/** Total number of rows in the grid. NOTE: in order to create a valid grid, you must either provide a totalRows value or implement getTotalRows()
		 * Flags: IRW */
		totalRows?: number; // Flags=IRW
		/** In Browser.isTouch','touch browsers, the time in milliseconds to wait after a scroll before redrawing. In non-touch browsers, the GridRenderer.scrollRedrawDelay','scrollRedrawDelay or GridRenderer.scrollWheelRedrawDelay','scrollWheelRedrawDelay is used instead.
		 * Flags: IRW, Group: performance */
		touchScrollRedrawDelay?: number /* int */; // Flags=IRW
		/** When incremental rendering is switched on and there are variable record heights, the virtual scrolling mechanism manages the differences in scroll height calculations due to the unknown sizes of unrendered rows to make the scrollbar and viewport appear correctly. virtualScrolling is switched on automatically when fixedRowHeights is false but you should switch it on any time there are variable record heights.
		 * Flags: IRA */
		virtualScrolling?: boolean; // Flags=IRA
		/** Should content within cells be allowed to wrap?
		 * Flags: IRWA, Group: cellStyling */
		wrapCells?: boolean; // Flags=IRWA

		/* Method Overrides */

		/** 
		 * Called when a cell receives a contextclick event.
		 * @param {ListGridRecord} record - cell record as returned by getCellRecord
		 * @param {number} rowNum - row number for the cell
		 * @param {number} colNum - column number of the cell
		 */
		cellContextClick?(record:ListGridRecord, rowNum:number, colNum:number): boolean; 

		/** 
		 * Return CSS text for styling this cell, which will be applied in addition to the CSS class for the cell, as overrides. "CSS text" means semicolon-separated style settings, suitable for inclusion in a CSS stylesheet or in a STYLE attribute of an HTML element. 
		 * @param {ListGridRecord} record - cell record as returned by getCellRecord
		 * @param {number} rowNum - row number for the cell
		 * @param {number} colNum - column number of the cell
		 */
		getCellCSSText?(record:ListGridRecord, rowNum:number, colNum:number): string; 

	} // GridRendererProps


	/**
	 * A flexible, high-speed table that offers consistent cross-platform sizing, clipping, and events. 
	 */
	export interface GridRenderer  {
		/** The number of consecutive columns to draw in the same style before alternating, when GridRenderer.alternateColumnStyles','alternateColumnStyles is true.
		 * Flags: IRW, Group: cellStyling */
		alternateColumnFrequency: number;

		/** Whether alternating columns (or blocks of columns, depending on GridRenderer.alternateColumnFrequency) should be drawn in alternating styles, in order to create a vertical "ledger" effect for easier reading. If enabled, the cell style for alternate rows will have the GridRenderer.alternateColumnSuffix appended to it. See also GridRenderer.alternateRowStyles.
		 * Flags: IRW, Group: cellStyling */
		alternateColumnStyles: boolean;

		/** Suffix to append to GridRenderer.alternateColumnStyles','alternate columns. Note that if GridRenderer.alternateRowStyles is enabled, cells which fall into both an alternate row and column will have both suffixes appended - for example "cellDarkAltCol".
		 * Flags: IRW, Group: cellStyling */
		alternateColumnSuffix: string /* String */;

		/** The number of consecutive rows to draw in the same style before alternating, when GridRenderer.alternateRowStyles','alternateRowStyles is true.
		 * Flags: IRW, Group: cellStyling */
		alternateRowFrequency: number;

		/** Whether alternating rows (or blocks of rows, depending on GridRenderer.alternateRowFrequency) should be drawn in alternating styles, in order to create a "ledger" effect for easier reading. If enabled, the cell style for alternate rows will have the GridRenderer.alternateRowSuffix appended to it. See also GridRenderer.alternateColumnStyles.
		 * Flags: IRW, Group: cellStyling */
		alternateRowStyles: boolean;

		/** Suffix to append to GridRenderer.alternateRowStyles','alternate rows. Note that if GridRenderer.alternateColumnStyles is enabled, cells which fall into both an alternate row and column will have both suffixes appended - for example "cellDarkAltCol".
		 * Flags: IRW, Group: cellStyling */
		alternateRowSuffix: string /* String */;

		/** If true, make columns only wide enough to fit content, ignoring any widths specified. Overrides fixedFieldWidths.
		 * Flags: IRWA, Group: sizing */
		autoFit: boolean;

		/** The base name for the CSS class applied to cells. This style will have "Dark", "Over", "Selected", or "Disabled" appended to it according to the state of the cell.
		 * Flags: IR, Group: cellStyling */
		baseStyle: string /* CSSStyleName */;

		/** If true, cellHover and rowHover events will fire and then a hover will be shown (if not canceled) when the user leaves the mouse over a row / cell unless the corresponding field has ListGridField.showHover','showHover set to false. If unset or null, the hover will be shown if the corresponding field has showHover:true. If false, then hovers are disabled. Note that standard hovers override GridRenderer.showClippedValuesOnHover','clipped value hovers. Thus, to enable clipped value hovers, canHover must be unset or null and the corresponding field must have showHover unset or null as well.
		 * Flags: RW, Group: events */
		canHover: boolean;

		/** If true, rightMouseDown events will fire 'selectOnRightMouseDown()' for the appropriate cells.
		 * Flags: RW, Group: events */
		canSelectOnRightMouse: boolean;

		/** The default height of each row in pixels.
		 * Flags: IRW, Group: cellStyling */
		cellHeight: number;

		/** The amount of empty space, in pixels, surrounding each value in its cell.
		 * Flags: IRW, Group: cellStyling */
		cellPadding: number;

		/** How far should we render rows ahead of the currently visible area? This is expressed as a ratio from viewport size to rendered area size. Tweaking drawAheadRatio allows you to make tradeoffs between continuous scrolling speed vs initial render time and render time when scrolling by large amounts. NOTE: Only applies when showAllRows is false.
		 * Flags: IRWA, Group: performance */
		drawAheadRatio: number /* float */;

		/** If drawing all rows would cause less than drawAllMaxCells cells to be rendered, the full dataset will instead be drawn even if ListGrid.showAllRecords','showAllRecords is false and the viewport size and GridRenderer.drawAheadRatio setting would normally have caused incremental rendering to be used. The drawAllMaxCells setting prevents incremental rendering from being used in situations where it's really unnecessary, such as a 40 row, 5 column dataset (only 200 cells) which happens to be in a grid with a viewport showing only 20 or so rows. Incremental rendering causes a brief "flash" during scrolling as the visible portion of the dataset is redrawn, and a better scrolling experience can be obtained in this situation by drawing the entire dataset up front, which in this example would have negligible effect on initial draw time. drawAllMaxCells:0 disables this features. You may want to disable this feature if performance is an issue and: you are very frequently redraw a grid you do a lot of computation when rendering each cell (eg formulas) you are showing many grids on one screen and the user won't scroll most of them 
		 * Flags: IRWA, Group: performance */
		drawAllMaxCells: number /* integer */;

		/** Value to show in empty cells (when getCellValue returns null).
		 * Flags: IRW, Group: cellStyling */
		emptyCellValue: string;

		/** The string to display in the body of a listGrid with an empty data array, if showEmptyMessage is true.
		 * Flags: IRW, Group: emptyMessage */
		emptyMessage: string;

		/** The CSS style name applied to the emptyMessage string if displayed.
		 * Flags: IRW, Group: emptyMessage */
		emptyMessageStyle: string /* CSSStyleName */;

		/** CSS styleName for the table as a whole if we're showing the empty message
		 * Flags: IRW, Group: emptyMessage */
		emptyMessageTableStyle: string /* CSSStyleName */;

		/** Note: This property only has an effect in Internet Explorer Advanced property to improve performance for dynamic styling of gridRenderer cells in Internet Explorer, at the expense of slightly slower initial drawing, and some limitations on supported styling options. fastCellUpdates speeds up the dynamic styling system used by rollovers, selections, and custom styling that calls GridRenderer.refreshCellStyle, at the cost of slightly slower draw() and redraw() times. Notes: When this property is set, ListGrid cells may be styled using the ListGrid.tallBaseStyle. See ListGrid.getBaseStyle for more information. If any cell styles specify a a background image URL, the URL will be resolved relative to the page location rather than the location of the CSS stylesheet. This means cell styles with a background URL should either supply a fully qualified path, or the background image media should be made available at a second location for IE. fastCellUpdates will not work if the styles involved are in an external stylesheet loaded from a remote host. Either the stylesheet containing cell styles needs to be loaded from the same host as the main page, or the cell styles need to be inlined in the html of the bootstrap page. fastCellUpdates will not work if the css styles for cells are defined in a .css file loaded via @import. Instead the .css file should be loaded via a &lt;link ...&gt; tag. 
		 * Flags: IRWA */
		fastCellUpdates: boolean;

		/** Should we horizontally clip cell contents, or allow columns to expand horizontally to show all contents? If we allow columns to expand, the column width is treated as a minimum.
		 * Flags: IRWA, Group: sizing */
		fixedColumnWidths: boolean;

		/** Should we vertically clip cell contents, or allow rows to expand vertically to show all contents? If we allow rows to expand, the row height as derived from GridRenderer.getRowHeight','getRowHeight() or the default GridRenderer.cellHeight is treated as a minimum.
		 * Flags: IRWA, Group: cellStyling */
		fixedRowHeights: boolean;

		/** If true, if the user clicks on the scroll buttons at the end of the track or clicks once on the scroll track, there will be an instant redraw of the grid content so that the user doesn't see any blank space. For drag scrolling or other types of scrolling, the GridRenderer.scrollRedrawDelay applies.
		 * Flags: IRW, Group: performance */
		instantScrollTrackRedraw: boolean;

		/** The string to display in the body of a listGrid with an empty data array, if showOfflineMessage is true and the data array is empty because we are offline and there is no suitable cached response
		 * Flags: IRW, Group: offlineGroup */
		offlineMessage: string;

		/** The CSS style name applied to the offlineMessage string if displayed.
		 * Flags: IRW, Group: emptyMessage */
		offlineMessageStyle: string /* CSSStyleName */;

		/** Alternative to GridRenderer.drawAheadRatio, to be used when the user is rapidly changing the grids viewport (for example drag scrolling through the grid). If unspecified GridRenderer.drawAheadRatio will be used in all cases
		 * Flags: IRWA, Group: performance */
		quickDrawAheadRatio: number /* float */;

		/** Denotes the name of a property that can be set on records to display a custom style. For example if this property is set to "customStyle", setting record.customStyle to a css styleName will cause the record in question to render out with that styling applied to it. Note that this will be a static style - it will not be modified as the state of the record (selected / over etc) changes.
		 * Flags: IRW */
		recordCustomStyleProperty: "customStyle";

		/** While drag scrolling in an incrementally rendered grid, time in milliseconds to wait before redrawing, after the last mouse movement by the user. This delay may be separately customized for mouse-wheel scrolling via GridRenderer.scrollWheelRedrawDelay. See also GridRenderer.instantScrollTrackRedraw for cases where this delay is skipped. <strong>NOTE:</strong> In Browser.isTouch','touch browsers, GridRenderer.touchScrollRedrawDelay','touchScrollRedrawDelay is used instead.
		 * Flags: IRW, Group: performance */
		scrollRedrawDelay: number /* int */;

		/** While scrolling an incrementally rendered grid, using the mouseWheel, time in milliseconds to wait before redrawing, after the last mouseWheel movement by the user. If not specified GridRenderer.scrollRedrawDelay will be used as a default for both drag scrolling and mouseWheel scrolling. See also GridRenderer.instantScrollTrackRedraw for cases where this delay is skipped.
		 * Flags: IRW, Group: performance */
		scrollWheelRedrawDelay: number /* Integer */;

		/** Whether all columns should be drawn all at once, or only columns visible in the viewport. Drawing all columns causes longer initial rendering time, but allows smoother horizontal scrolling. With a very large number of columns, showAllColumns will become too slow.
		 * Flags: IRA, Group: performance */
		showAllColumns: boolean;

		/** Whether all rows should be drawn all at once, or only rows visible in the viewport. Drawing all rows causes longer initial rendering time, but allows smoother vertical scrolling. With a very large number of rows, showAllRows will become too slow. See also GridRenderer.drawAheadRatio and GridRenderer.drawAllMaxCells.
		 * Flags: IRA, Group: performance */
		showAllRows: boolean;

		/** If true and a cell's value is clipped, then a hover containing the full cell value is enabled. Note that standard cell hovers override clipped value hovers. Thus, to enable clipped value hovers, GridRenderer.canHover','canHover must be unset or null and the corresponding field must have ListGridField.showHover','showHover unset or null as well.
		 * Flags: IRWA, Group: events */
		showClippedValuesOnHover: boolean /* Boolean */;

		/** Indicates whether the text of the emptyMessage property should be displayed if no data is available.
		 * Flags: IRW, Group: emptyMessage */
		showEmptyMessage: boolean;

		/** If true, and canHover is also true, when the user hovers over a cell, hover text will pop up next to the mouse. The contents of the hover is determined by GridRenderer.cellHoverHTML.
		 * Flags: RW, Group: events */
		showHover: boolean;

		/** Indicates whether the text of the offlineMessage property should be displayed if no data is available because we are offline and there is no suitable cached response
		 * Flags: IRW, Group: emptyMessage */
		showOfflineMessage: boolean;

		/** Should the "Selected" style be applied to selected records?
		 * Flags: IRW */
		showSelectedStyle: boolean;

		/** If true, snap-to-cell drops will snap the dropped object inside the selected cell's border. If false, snap-to-cell drops will snap the dropped object to the edge of the selected cell, regardless of borders
		 * Flags: IRW, Group: dragdrop */
		snapInsideBorder: boolean;

		/** Should drag-and-drop operations snap the dragged object into line with the nearest cell?
		 * Flags: IRW, Group: dragdrop */
		snapToCells: boolean;

		/** Total number of rows in the grid. NOTE: in order to create a valid grid, you must either provide a totalRows value or implement getTotalRows()
		 * Flags: IRW */
		totalRows: number;

		/** In Browser.isTouch','touch browsers, the time in milliseconds to wait after a scroll before redrawing. In non-touch browsers, the GridRenderer.scrollRedrawDelay','scrollRedrawDelay or GridRenderer.scrollWheelRedrawDelay','scrollWheelRedrawDelay is used instead.
		 * Flags: IRW, Group: performance */
		touchScrollRedrawDelay: number /* int */;

		/** When incremental rendering is switched on and there are variable record heights, the virtual scrolling mechanism manages the differences in scroll height calculations due to the unknown sizes of unrendered rows to make the scrollbar and viewport appear correctly. virtualScrolling is switched on automatically when fixedRowHeights is false but you should switch it on any time there are variable record heights.
		 * Flags: IRA */
		virtualScrolling: boolean;

		/** Should content within cells be allowed to wrap?
		 * Flags: IRWA, Group: cellStyling */
		wrapCells: boolean;


		/* Instance Method Overrides */

		/** 
		 * Called when a cell receives a contextclick event.
		 * @param {ListGridRecord} record - cell record as returned by getCellRecord
		 * @param {number} rowNum - row number for the cell
		 * @param {number} colNum - column number of the cell
		 */
		cellContextClick?(record:ListGridRecord, rowNum:number, colNum:number): boolean; 

		/** 
		 * Return CSS text for styling this cell, which will be applied in addition to the CSS class for the cell, as overrides. "CSS text" means semicolon-separated style settings, suitable for inclusion in a CSS stylesheet or in a STYLE attribute of an HTML element. 
		 * @param {ListGridRecord} record - cell record as returned by getCellRecord
		 * @param {number} rowNum - row number for the cell
		 * @param {number} colNum - column number of the cell
		 */
		getCellCSSText?(record:ListGridRecord, rowNum:number, colNum:number): string; 

	} // GridRenderer

	export interface GridRendererStatic<T, P> extends ClassStatic<T, P> {
	} // GridRendererStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a HiliteEditor Props argument.
	 * This is derived from the methods in the HiliteEditor class and it's parents and their properties marked with the I flag.
	 */
	export interface HiliteEditorProps extends VLayoutProps {
		/** AutoChild IButton that opens an AdvancedHiliteEditor to create a new advanced rule. This component is an AutoChild and as such may be customized via hiliteEditor.addAdvancedRuleButtonProperties.
		 * Flags: IR */
		addAdvancedRuleButton?:  StatefulCanvas /* AutoChild StatefulCanvas */; // Flags=IR
		/** The title text for the HiliteEditor.addAdvancedRuleButton','add advanced rule button.
		 * Flags: IR, Group: i18nMessages */
		addAdvancedRuleButtonTitle?: string; // Flags=IR
		/** The title for the 'Available Fields' column in the HiliteEditor.fieldList','fieldList.
		 * Flags: IR, Group: i18nMessages */
		availableFieldsColumnTitle?: string; // Flags=IR
		/** The callback to fire when HiliteEditor.saveHilites is called.
		 * Flags: IR */
		callback?: Callback; // Flags=IR
		/** AutoChild ImgButton that cancels this editor without saving any changes, firing the HiliteEditor.callback','callback with a null parameter. This component is an AutoChild and as such may be customized via hiliteEditor.cancelButtonProperties.
		 * Flags: IR */
		cancelButton?:  StatefulCanvas /* AutoChild StatefulCanvas */; // Flags=IR
		/** The title text for the HiliteEditor.cancelButton','cancel button.
		 * Flags: IR, Group: i18nMessages */
		cancelButtonTitle?: string; // Flags=IR
		/** AutoChild ListGrid showing the list of fields to create hilites for. This component is an AutoChild and as such may be customized via hiliteEditor.fieldListProperties.
		 * Flags: IR */
		fieldList?:  ListGrid /* AutoChild ListGrid */; // Flags=IR
		/** Specifies a list of icons that can be used in Hilite','hilites. hiliteIcons should be specified as an Array of SCImgURL. When present, HiliteRules will offer the user a drop down for picking one of these icons. If the user picks an icon, the created hiliting rule will have Hilite.icon set to the chosen icon. ListGridField.hiliteIconPosition controls where the icon will appear for that field -- the default is that it appears in front of the normal cell content.
		 * Flags: IRW */
		hiliteIcons?: Array<string> /* Array of SCImgURL */; // Flags=IRW
		/** AutoChild HiliteRule used to create new simple hilites. This component is an AutoChild and as such may be customized via hiliteEditor.hiliteRuleProperties.
		 * Flags: IR */
		hiliteRule?:  HiliteRule /* AutoChild HiliteRule */; // Flags=IR
		/** AutoChild ImgButton that saves the hilites in this editor and fires the HiliteEditor.callback','callback. This component is an AutoChild and as such may be customized via hiliteEditor.saveButtonProperties.
		 * Flags: IR */
		saveButton?:  StatefulCanvas /* AutoChild StatefulCanvas */; // Flags=IR
		/** The title text for the HiliteEditor.saveButton','saveButton.
		 * Flags: IR, Group: i18nMessages */
		saveButtonTitle?: string; // Flags=IR

		/* Method Overrides */

	} // HiliteEditorProps


	/**
	 * A widget for defining and editing a set of HiliteRule','hilite rules for use by DataBoundComponent','dataBoundComponents. Presents a list of available fields and allows editing of simple hilites directly and more complex hilites via AdvancedHiliteEditors. Important Note: this class should not be used directly - it is exposed purely for i18nMessages','i18n reasons. 
	 */
	export interface HiliteEditor extends VLayout {
		/** AutoChild IButton that opens an AdvancedHiliteEditor to create a new advanced rule. This component is an AutoChild and as such may be customized via hiliteEditor.addAdvancedRuleButtonProperties.
		 * Flags: IR */
		addAdvancedRuleButton:  StatefulCanvas /* AutoChild StatefulCanvas */;

		/** The title text for the HiliteEditor.addAdvancedRuleButton','add advanced rule button.
		 * Flags: IR, Group: i18nMessages */
		addAdvancedRuleButtonTitle: string;

		/** The title for the 'Available Fields' column in the HiliteEditor.fieldList','fieldList.
		 * Flags: IR, Group: i18nMessages */
		availableFieldsColumnTitle: string;

		/** The callback to fire when HiliteEditor.saveHilites is called.
		 * Flags: IR */
		callback: Callback;

		/** AutoChild ImgButton that cancels this editor without saving any changes, firing the HiliteEditor.callback','callback with a null parameter. This component is an AutoChild and as such may be customized via hiliteEditor.cancelButtonProperties.
		 * Flags: IR */
		cancelButton:  StatefulCanvas /* AutoChild StatefulCanvas */;

		/** The title text for the HiliteEditor.cancelButton','cancel button.
		 * Flags: IR, Group: i18nMessages */
		cancelButtonTitle: string;

		/** AutoChild ListGrid showing the list of fields to create hilites for. This component is an AutoChild and as such may be customized via hiliteEditor.fieldListProperties.
		 * Flags: IR */
		fieldList:  ListGrid /* AutoChild ListGrid */;

		/** Specifies a list of icons that can be used in Hilite','hilites. hiliteIcons should be specified as an Array of SCImgURL. When present, HiliteRules will offer the user a drop down for picking one of these icons. If the user picks an icon, the created hiliting rule will have Hilite.icon set to the chosen icon. ListGridField.hiliteIconPosition controls where the icon will appear for that field -- the default is that it appears in front of the normal cell content.
		 * Flags: IRW */
		hiliteIcons: Array<string> /* Array of SCImgURL */;

		/** AutoChild HiliteRule used to create new simple hilites. This component is an AutoChild and as such may be customized via hiliteEditor.hiliteRuleProperties.
		 * Flags: IR */
		hiliteRule:  HiliteRule /* AutoChild HiliteRule */;

		/** AutoChild ImgButton that saves the hilites in this editor and fires the HiliteEditor.callback','callback. This component is an AutoChild and as such may be customized via hiliteEditor.saveButtonProperties.
		 * Flags: IR */
		saveButton:  StatefulCanvas /* AutoChild StatefulCanvas */;

		/** The title text for the HiliteEditor.saveButton','saveButton.
		 * Flags: IR, Group: i18nMessages */
		saveButtonTitle: string;


		/* Instance Method Overrides */

	} // HiliteEditor

	export interface HiliteEditorStatic<T, P> extends VLayoutStatic<T, P> {
	} // HiliteEditorStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a HiliteRule Props argument.
	 * This is derived from the methods in the HiliteRule class and it's parents and their properties marked with the I flag.
	 */
	export interface HiliteRuleProps  {
		/** AutoChild ImgButton displayed by an advanced hilite-rule and used to open it for editing in an AdvancedHiliteEditor','advanced hilite editor. This component is an AutoChild and as such may be customized via hiliteRule.advancedClauseEditButtonProperties.
		 * Flags: IR */
		advancedClauseEditButton?:  ImgButton /* AutoChild ImgButton */; // Flags=IR
		/** AutoChild Label displaying the human-readable description of an advanced hilite-rule. This component is an AutoChild and as such may be customized via hiliteRule.advancedClauseLabelProperties.
		 * Flags: IR */
		advancedClauseLabel?:  Label /* AutoChild Label */; // Flags=IR
		/** The FormItem.title','title of the 'Background' color picker.
		 * Flags: IR, Group: i18nMessages */
		backgroundColorTitle?: string; // Flags=IR
		/** AutoChild FilterClause displaying the FormItem','formItems used to specify the criteria for this HiliteRule. This component is an AutoChild and as such may be customized via hiliteRule.clauseProperties.
		 * Flags: IR */
		clause?:  FilterClause /* AutoChild FilterClause */; // Flags=IR
		/** The title for the Color picker field.
		 * Flags: IR, Group: i18nMessages */
		colorFieldTitle?: string; // Flags=IR
		/** The FormItem.title','title of the 'Text' color picker.
		 * Flags: IR, Group: i18nMessages */
		foregroundColorTitle?: string; // Flags=IR
		/** AutoChild DynamicForm displaying the FormItem','formItems used to specify the hiliting properties of this rule. This component is an AutoChild and as such may be customized via hiliteRule.hiliteFormProperties.
		 * Flags: IR */
		hiliteForm?:  DynamicForm /* AutoChild DynamicForm */; // Flags=IR
		/** The FormItem.title','title of the 'Icon' picker.
		 * Flags: IR, Group: i18nMessages */
		iconFieldTitle?: string; // Flags=IR
		/** The Hilite removal ImgButton that appears before this Hilite if HiliteRule.showRemoveButton is set. This component is an AutoChild and as such may be customized via hiliteRule.removeButtonProperties.
		 * Flags: IR */
		removeButton?:  ImgButton /* AutoChild ImgButton */; // Flags=IR
		/** The hover prompt text for the HiliteRule.removeButton','remove button.
		 * Flags: IR, Group: i18nMessages */
		removeButtonPrompt?: string; // Flags=IR
		/** If true, show a HiliteRule.removeButton','button for this HiliteRule, allowing it to be removed.
		 * Flags: IR */
		showRemoveButton?: boolean; // Flags=IR

		/* Method Overrides */

	} // HiliteRuleProps


	/**
	 * A widget for editing the criteria of a single DataBoundComponent hilite. The default implementation presents a series of FormItem','formItems for selecting the various elements of a simple criterion and a foreground or background color. To specify more complex criteria, specify both foreground and background colors or to apply the hilite to multiple fields, you can create an AdvancedHiliteEditor','advanced hilite rule. Important Note: this class should not be used directly - it is exposed purely for i18nMessages','i18n reasons. 
	 */
	export interface HiliteRule  {
		/** AutoChild ImgButton displayed by an advanced hilite-rule and used to open it for editing in an AdvancedHiliteEditor','advanced hilite editor. This component is an AutoChild and as such may be customized via hiliteRule.advancedClauseEditButtonProperties.
		 * Flags: IR */
		advancedClauseEditButton:  ImgButton /* AutoChild ImgButton */;

		/** AutoChild Label displaying the human-readable description of an advanced hilite-rule. This component is an AutoChild and as such may be customized via hiliteRule.advancedClauseLabelProperties.
		 * Flags: IR */
		advancedClauseLabel:  Label /* AutoChild Label */;

		/** The FormItem.title','title of the 'Background' color picker.
		 * Flags: IR, Group: i18nMessages */
		backgroundColorTitle: string;

		/** AutoChild FilterClause displaying the FormItem','formItems used to specify the criteria for this HiliteRule. This component is an AutoChild and as such may be customized via hiliteRule.clauseProperties.
		 * Flags: IR */
		clause:  FilterClause /* AutoChild FilterClause */;

		/** The title for the Color picker field.
		 * Flags: IR, Group: i18nMessages */
		colorFieldTitle: string;

		/** The FormItem.title','title of the 'Text' color picker.
		 * Flags: IR, Group: i18nMessages */
		foregroundColorTitle: string;

		/** AutoChild DynamicForm displaying the FormItem','formItems used to specify the hiliting properties of this rule. This component is an AutoChild and as such may be customized via hiliteRule.hiliteFormProperties.
		 * Flags: IR */
		hiliteForm:  DynamicForm /* AutoChild DynamicForm */;

		/** The FormItem.title','title of the 'Icon' picker.
		 * Flags: IR, Group: i18nMessages */
		iconFieldTitle: string;

		/** The Hilite removal ImgButton that appears before this Hilite if HiliteRule.showRemoveButton is set. This component is an AutoChild and as such may be customized via hiliteRule.removeButtonProperties.
		 * Flags: IR */
		removeButton:  ImgButton /* AutoChild ImgButton */;

		/** The hover prompt text for the HiliteRule.removeButton','remove button.
		 * Flags: IR, Group: i18nMessages */
		removeButtonPrompt: string;

		/** If true, show a HiliteRule.removeButton','button for this HiliteRule, allowing it to be removed.
		 * Flags: IR */
		showRemoveButton: boolean;


		/* Instance Method Overrides */

	} // HiliteRule

	export interface HiliteRuleStatic<T, P> extends ClassStatic<T, P> {
	} // HiliteRuleStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a HLayout Props argument.
	 * This is derived from the methods in the HLayout class and it's parents and their properties marked with the I flag.
	 */
	export interface HLayoutProps extends LayoutProps {
	} // HLayoutProps


	/**
	 * A subclass of Layout that applies a sizing policy along the horizontal axis, interpreting percent and "*" sizes as proportions of the width of the layout. HLayouts will set any members that do not have explicit heights to match the layout. 
	 */
	export interface HLayout extends Layout {
	} // HLayout

	export interface HLayoutStatic<T, P> extends LayoutStatic<T, P> {
	} // HLayoutStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a HTMLFlow Props argument.
	 * This is derived from the methods in the HTMLFlow class and it's parents and their properties marked with the I flag.
	 */
	export interface HTMLFlowProps extends CanvasProps {
		/** By default an HTMLFlow will explicitly prevent browser caching. Set to true to allow browser caching if the browser would normally do so, in other words, if the HTTP headers returned with the response indicate that the response can be cached.
		 * Flags: IR */
		allowCaching?: boolean /* Boolean */; // Flags=IR
		/** If true, SmartClient components created while executing the loaded HTML are captured for rendering inside the HTMLFlow. Only applies when contentsType is not "page".
		 * Flags: IR, Group: contentLoading */
		captureSCComponents?: boolean /* Boolean */; // Flags=IR
		/** The contents of a canvas or label widget. Any HTML string is acceptable.
		 * Flags: IRW, Group: contents */
		contents?: string /* HTMLString */; // Flags=IRW
		/** The default setting of null or 'fragment' indicates that HTML loaded from HTMLFlow.contentsURL is assumed to be an HTML fragment rather than a complete page. Set to "page" to load HTML as a standalone page, via an IFRAME. contentsType:"page" should only be used for controlled HTML content, and only when such content cannot be delivered as an HTML fragment instead (the default). To dynamically load SmartClient components, use ViewLoader, never this mechanism (click noFrames','here for why). Loading HTML content as a fragment is less resource intensive and avoids visual artifacts such as translucent media becoming opaque or disappearing when placed over an IFRAME. Loading third-party, uncontrolled content could lead to the surrounding page disappearing if a user clicks on an HTML link with target=_top. With contentsType:"page", HTMLFlow.loadingMessage is not supported, and only "GET" is supported for HTMLFlow.httpMethod','httpMethod. Note that a native bug has been observed in Internet Explorer version 10 whereby if an HTMLFlow with contentsType set to "page" loads a page containing an HTML &lt;frameset&gt;, when the HTMLFlow is Canvas.hide','hidden, it can interfere with the rendering of other elements on the page. Setting Canvas.shrinkElementOnHide to true will work around this behavior.
		 * Flags: IR, Group: contentLoading */
		contentsType?: ContentsType; // Flags=IR
		/** URL to load content from. If specified, this component will load HTML content from the specified URL when it is first drawn. This feature relies on the XMLHttpRequest object which can be disabled by end-users in some supported browsers. See platformDependencies for more information.
		 * Flags: IRW, Group: contentLoading */
		contentsURL?: string /* URL */; // Flags=IRW
		/** Parameters to be sent to the contentsURL when fetching content.
		 * Flags: IRW, Group: contentLoading */
		contentsURLParams?: any /* Object */; // Flags=IRW
		/** Dynamic contents allows the contents string to be treated as a simple, but powerful template. When this attribute is set to true, expressions of the form &#36;{arbitrary JS here} are replaced by the result of the evaluation of the JS code inside the curly brackets. This evaluation happens at draw time. If you want to trigger a re-evaluation of the expressions in the contents string you can call markForRedraw() on the canvas. You can use this feature to build some simple custom components. For example, let's say you want to show the value of a Slider in a Canvas somewhere on the screen. You can do this by observing the valueChanged() method on the slider and calling setContents() on your canvas with the new string or you can set the contents of the canvas to something like: "The slider value is &#36;{sliderInstance.getValue()}." Next you set dynamicContents: true on the canvas, observe valueChanged() on the slider and call canvas.markForRedraw() in that observation. This approach is cleaner than setContents() when the Canvas is aggregating several values or dynamic expressions. Like so: Slider.create({ ID: "mySlider" }); Canvas.create({ ID: "myCanvas", dynamicContents: true, contents: "The slider value is &#36;{mySlider.getValue()}." }); myCanvas.observe(mySlider, "valueChanged", "observer.markForRedraw()"); You can embed an arbitrary number of dynamic expressions in the contents string. The search and replace is optimized for speed. If an error occurs during the evaluation of one of the expressions, a warning is logged to the ISC Developer Console and the error string is embedded in place of the expected value in the Canvas. The value of a function is its return value. The value of any variable is the same as that returned by its toString() representation. Inside the evaluation contentext, this points to the canvas instance that has the dynamicContents string as its contents - in other words the canvas instance on which the template is declared.
		 * Flags: IRWA, Group: contents */
		dynamicContents?: boolean /* Boolean */; // Flags=IRWA
		/** If evalScriptBlocks is true, HTMLFlow will pre-process the loaded HTML in order to mimic how the HTML would execute if it were loaded as an independent page or loaded via an IFRAME. This feature is intended to assist with migrating existing applications to SmartClient. evalScriptBlocks is enabled by default when loading remote content (via HTMLFlow.contentsURL) and disabled by default for content supplied via HTMLFlow.setContents. Note that, if evalScriptBlocks is false, &lt;SCRIPT&gt; blocks will still be detected and disabled to avoid the inconsistent results across different browsers. Only applies when contentsType is not "page".
		 * Flags: IR, Group: contentLoading */
		evalScriptBlocks?: boolean; // Flags=IR
		/** Selects the HTTP method that will be used when fetching content. Valid values are "POST" and "GET".
		 * Flags: IRW, Group: contentLoading */
		httpMethod?: SendMethod; // Flags=IRW
		/** When using HTMLFlow.contentsType','contentsType "page", sets the &lt;iframe&gt; sandbox attribute to the provided value. Use the value "*ALL*" to cause the "sandbox" attribute to be output with no value (which causes full sandboxing). See any HTML reference for other legal values of the "sandbox" attribute, which allow you to remove individual restrictions on the loaded content. Note that SmartClient simply applies the provided value to the generated &lt;iframe&gt; element and cannot fix bugs or differences in sandbox behavior across different browsers.
		 * Flags: IR */
		iframeSandbox?: string /* String */; // Flags=IR
		/** HTML to show while content is being fetched, active only if the contentsURL property has been set. Use "&#36;{loadingImage}" to include Canvas.loadingImageSrc','a loading image. The loading message will show both during the initial load of content, and during reload if the contents are reloaded or the contentsURL changed. For a first-time only loading message, initialize the contents property instead. Note: the loadingMessage is never displayed when loading complete web pages rather than HTML fragments (see HTMLFlow.contentsType).
		 * Flags: IRW, Group: contentLoading */
		loadingMessage?: string /* HTMLString */; // Flags=IRW
		/** When this HTMLFlow is focused, causes Ctrl-A / Command-A keypresses to select just the content, as opposed to all content on the screen becoming selected. This HTMLFlow must be Canvas.canFocus','focusable in order for this setting to have an effect. Not valid with HTMLFlow.contentsType','contentsType "page". 
		 * Flags: IRW */
		selectContentOnSelectAll?: boolean /* Boolean */; // Flags=IRW

		/* Method Overrides */

		/** 
		 * StringMethod fired when content is completely loaded in this htmlFlow. Has no default implementation. May be observed or overridden as a notification type method to fire custom logic when loading completes. Notes: A call to Canvas.setContents','this.setContents() will cause this notification to be fired when the contents have been set. If HTMLFlow.evalScriptBlocks is true, and the HTML passed into setContents() contains any &lt;script src=... &gt; tags, this callback will be fired asynchronously once the scripts have been loaded from the server and executed, as well as having the widget content updated When using HTMLFlow.contentsURL, this does not apply to htmlFlows with HTMLFlow.contentsType','contentsType set to "page"
		 */
		contentLoaded?(): void; 

		/** 
		 * Changes the contents of a widget to newContents, an HTML string.
		 * @param {string} newContents - an HTML string to be set as the contents of this widget
		 */
		setContents?(newContents?:string): void; 

	} // HTMLFlowProps


	/**
	 * Use the HTMLFlow component to display HTML content that should expand to its natural size without scrolling. HTML content can be loaded and reloaded from a URL via the property contentsURL. This method of loading is for simple HTML content only; SmartClient components should be loaded via the ViewLoader class. NOTE: Since the size of an HTMLFlow component is determined by its HTML contents, this component will draw at varying sizes if given content of varying size. When using HTMLFlow components within a Layout, consider what will happen if the HTMLFlow renders at various sizes. An HTMLFlow which can expand should be placed in a container where other components can render smaller, where the container is allowed to scroll, or where there is padding to expand into. HTMLFlow is a DataBoundComponent but only supports one method at this time, HTMLFlow.fetchRelatedData','fetchRelatedData. 
	 */
	export interface HTMLFlow extends Canvas {
		/** By default an HTMLFlow will explicitly prevent browser caching. Set to true to allow browser caching if the browser would normally do so, in other words, if the HTTP headers returned with the response indicate that the response can be cached.
		 * Flags: IR */
		allowCaching: boolean /* Boolean */;

		/** If true, SmartClient components created while executing the loaded HTML are captured for rendering inside the HTMLFlow. Only applies when contentsType is not "page".
		 * Flags: IR, Group: contentLoading */
		captureSCComponents: boolean /* Boolean */;

		/** The contents of a canvas or label widget. Any HTML string is acceptable.
		 * Flags: IRW, Group: contents */
		contents: string /* HTMLString */;

		/** The default setting of null or 'fragment' indicates that HTML loaded from HTMLFlow.contentsURL is assumed to be an HTML fragment rather than a complete page. Set to "page" to load HTML as a standalone page, via an IFRAME. contentsType:"page" should only be used for controlled HTML content, and only when such content cannot be delivered as an HTML fragment instead (the default). To dynamically load SmartClient components, use ViewLoader, never this mechanism (click noFrames','here for why). Loading HTML content as a fragment is less resource intensive and avoids visual artifacts such as translucent media becoming opaque or disappearing when placed over an IFRAME. Loading third-party, uncontrolled content could lead to the surrounding page disappearing if a user clicks on an HTML link with target=_top. With contentsType:"page", HTMLFlow.loadingMessage is not supported, and only "GET" is supported for HTMLFlow.httpMethod','httpMethod. Note that a native bug has been observed in Internet Explorer version 10 whereby if an HTMLFlow with contentsType set to "page" loads a page containing an HTML &lt;frameset&gt;, when the HTMLFlow is Canvas.hide','hidden, it can interfere with the rendering of other elements on the page. Setting Canvas.shrinkElementOnHide to true will work around this behavior.
		 * Flags: IR, Group: contentLoading */
		contentsType: ContentsType;

		/** URL to load content from. If specified, this component will load HTML content from the specified URL when it is first drawn. This feature relies on the XMLHttpRequest object which can be disabled by end-users in some supported browsers. See platformDependencies for more information.
		 * Flags: IRW, Group: contentLoading */
		contentsURL: string /* URL */;

		/** Parameters to be sent to the contentsURL when fetching content.
		 * Flags: IRW, Group: contentLoading */
		contentsURLParams: any /* Object */;

		/** Dynamic contents allows the contents string to be treated as a simple, but powerful template. When this attribute is set to true, expressions of the form &#36;{arbitrary JS here} are replaced by the result of the evaluation of the JS code inside the curly brackets. This evaluation happens at draw time. If you want to trigger a re-evaluation of the expressions in the contents string you can call markForRedraw() on the canvas. You can use this feature to build some simple custom components. For example, let's say you want to show the value of a Slider in a Canvas somewhere on the screen. You can do this by observing the valueChanged() method on the slider and calling setContents() on your canvas with the new string or you can set the contents of the canvas to something like: "The slider value is &#36;{sliderInstance.getValue()}." Next you set dynamicContents: true on the canvas, observe valueChanged() on the slider and call canvas.markForRedraw() in that observation. This approach is cleaner than setContents() when the Canvas is aggregating several values or dynamic expressions. Like so: Slider.create({ ID: "mySlider" }); Canvas.create({ ID: "myCanvas", dynamicContents: true, contents: "The slider value is &#36;{mySlider.getValue()}." }); myCanvas.observe(mySlider, "valueChanged", "observer.markForRedraw()"); You can embed an arbitrary number of dynamic expressions in the contents string. The search and replace is optimized for speed. If an error occurs during the evaluation of one of the expressions, a warning is logged to the ISC Developer Console and the error string is embedded in place of the expected value in the Canvas. The value of a function is its return value. The value of any variable is the same as that returned by its toString() representation. Inside the evaluation contentext, this points to the canvas instance that has the dynamicContents string as its contents - in other words the canvas instance on which the template is declared.
		 * Flags: IRWA, Group: contents */
		dynamicContents: boolean /* Boolean */;

		/** If evalScriptBlocks is true, HTMLFlow will pre-process the loaded HTML in order to mimic how the HTML would execute if it were loaded as an independent page or loaded via an IFRAME. This feature is intended to assist with migrating existing applications to SmartClient. evalScriptBlocks is enabled by default when loading remote content (via HTMLFlow.contentsURL) and disabled by default for content supplied via HTMLFlow.setContents. Note that, if evalScriptBlocks is false, &lt;SCRIPT&gt; blocks will still be detected and disabled to avoid the inconsistent results across different browsers. Only applies when contentsType is not "page".
		 * Flags: IR, Group: contentLoading */
		evalScriptBlocks: boolean;

		/** Selects the HTTP method that will be used when fetching content. Valid values are "POST" and "GET".
		 * Flags: IRW, Group: contentLoading */
		httpMethod: SendMethod;

		/** When using HTMLFlow.contentsType','contentsType "page", sets the &lt;iframe&gt; sandbox attribute to the provided value. Use the value "*ALL*" to cause the "sandbox" attribute to be output with no value (which causes full sandboxing). See any HTML reference for other legal values of the "sandbox" attribute, which allow you to remove individual restrictions on the loaded content. Note that SmartClient simply applies the provided value to the generated &lt;iframe&gt; element and cannot fix bugs or differences in sandbox behavior across different browsers.
		 * Flags: IR */
		iframeSandbox: string /* String */;

		/** HTML to show while content is being fetched, active only if the contentsURL property has been set. Use "&#36;{loadingImage}" to include Canvas.loadingImageSrc','a loading image. The loading message will show both during the initial load of content, and during reload if the contents are reloaded or the contentsURL changed. For a first-time only loading message, initialize the contents property instead. Note: the loadingMessage is never displayed when loading complete web pages rather than HTML fragments (see HTMLFlow.contentsType).
		 * Flags: IRW, Group: contentLoading */
		loadingMessage: string /* HTMLString */;

		/** When this HTMLFlow is focused, causes Ctrl-A / Command-A keypresses to select just the content, as opposed to all content on the screen becoming selected. This HTMLFlow must be Canvas.canFocus','focusable in order for this setting to have an effect. Not valid with HTMLFlow.contentsType','contentsType "page". 
		 * Flags: IRW */
		selectContentOnSelectAll: boolean /* Boolean */;


		/* Instance Method Overrides */

		/** 
		 * StringMethod fired when content is completely loaded in this htmlFlow. Has no default implementation. May be observed or overridden as a notification type method to fire custom logic when loading completes. Notes: A call to Canvas.setContents','this.setContents() will cause this notification to be fired when the contents have been set. If HTMLFlow.evalScriptBlocks is true, and the HTML passed into setContents() contains any &lt;script src=... &gt; tags, this callback will be fired asynchronously once the scripts have been loaded from the server and executed, as well as having the widget content updated When using HTMLFlow.contentsURL, this does not apply to htmlFlows with HTMLFlow.contentsType','contentsType set to "page"
		 */
		contentLoaded?(): void; 

		/** 
		 * Changes the contents of a widget to newContents, an HTML string.
		 * @param {string} newContents - an HTML string to be set as the contents of this widget
		 */
		setContents?(newContents?:string): void; 

	} // HTMLFlow

	export interface HTMLFlowStatic<T, P> extends CanvasStatic<T, P> {
	} // HTMLFlowStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a HTMLPane Props argument.
	 * This is derived from the methods in the HTMLPane class and it's parents and their properties marked with the I flag.
	 */
	export interface HTMLPaneProps extends HTMLFlowProps {
	} // HTMLPaneProps


	/**
	 * Use the HTMLPane component to display HTML content in a pane of specified size. If the HTML content is larger than the size of the pane, the pane will provide scrollbars for viewing clipped content. You can set the size of an HTMLPane directly via the width and height properties, or indirectly by placing the HTMLPane in a container component (Layout, Window, SectionStack, etc) that manages the sizes of its members. 
	 */
	export interface HTMLPane extends HTMLFlow {
	} // HTMLPane

	export interface HTMLPaneStatic<T, P> extends HTMLFlowStatic<T, P> {
	} // HTMLPaneStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a IButton Props argument.
	 * This is derived from the methods in the IButton class and it's parents and their properties marked with the I flag.
	 */
	export interface IButtonProps  {
	} // IButtonProps


	/**
	 * The IButton widget class is a class that implements the same APIs as the Button class. Depending on the current skin, IButtons may be on the StretchImgButton component, which renders via images, or may be based on the Button component, which renders via CSS styles. 
	 */
	export interface IButton  {
	} // IButton

	export interface IButtonStatic<T, P> extends ClassStatic<T, P> {
	} // IButtonStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a Img Props argument.
	 * This is derived from the methods in the Img class and it's parents and their properties marked with the I flag.
	 */
	export interface ImgProps extends StatefulCanvasProps {
		/** Setting this attribute configures an image map for this image. The value is expected as a sequence of &lg;AREA&gt tags - e.g: Img.create({ src: "myChart.gif", activeAreaHTML: "&lt;AREA shape='rect' coords='10,50,30,200' title='30' href='javascript:alert(\"30 units\")'&gt;" + "&lt;AREA shape='rect' coords='50,90,80,200' title='22' href='javascript:alert(\"22 units\")'&gt;" }); <u>Implementation notes:</u> Quotes in the activeAreaHTML must be escaped or alternated appropriately. Image maps do not stretch to fit scaled images. You must ensure that the dimensions of your Img component match the anticipated width and height of your image map (which will typically match the native dimensions of your image). To change the image map of an existing Img component, first set yourImg.activeAreaHTML, then call yourImg.markForRedraw(). Calls to yourImg.setSrc() will not automatically update the image map. activeAreaHTML is not supported on tiled Img components (imageType:"tile"). Native browser support for image map focus/blur, keyboard events, and certain AREA tag attributes (eg NOHREF, DEFAULT...) varies by platform. If your image map HTML uses attributes beyond the basics (shape, coords, href, title), you should test on all supported browsers to ensure that it functions as expected. 
		 * Flags: IRWA, Group: appearance */
		activeAreaHTML?: string /* String of HTML AREA tags */; // Flags=IRWA
		/** If specified this property will be included as the alt text for the image HMTL element. This is useful for improving application accessibility. altText and hover prompt / tooltip behavior: Note that some browsers, including Internet Explorer 9, show a native hover tooltip containing the img tag's alt attribute. Developers should not rely on this behavior to show the user a hover prompt - instead the Img.prompt attribute should be used. To set alt text and ensure a hover prompt shows up in all browsers, developers may set Img.prompt and altText to the same value. If both these attributes are set, the standard SmartClient prompt behavior will show a hover prompt in most browsers, but will be suppressed for browsers where a native tooltip is shown for altText. Note that setting altText and prompt to different values is not recommended - the prompt value will be ignored in favor of the altText in this case.
		 * Flags: IRW, Group: accessibility */
		altText?: string /* String */; // Flags=IRW
		/** Default class used to construct the EditProxy for this component when the component is Canvas.setEditMode','first placed into edit mode.
		 * Flags: IR */
		editProxyConstructor?: string /* SCClassName */; // Flags=IR
		/** Explicit size for the image, for Img.imageType settings that would normally use the image's natural size (applies to Img.imageType "center" and "normal" only).
		 * Flags: IR */
		imageHeight?: number /* integer */; // Flags=IR
		/** Indicates whether the image should be tiled/cropped, stretched, or centered when the size of this widget does not match the size of the image. CENTER shows the image in it's natural size, but can't do so while the transparency fix is active for IE. The transparency fix can be manually disabled by setting Img.usePNGFix to false. See ImageStyle for further details.
		 * Flags: IRW, Group: appearance */
		imageType?: ImageStyle; // Flags=IRW
		/** Explicit size for the image, for Img.imageType settings that would normally use the image's natural size (applies to Img.imageType "center" and "normal" only).
		 * Flags: IR */
		imageWidth?: number /* integer */; // Flags=IR
		/** The value of this attribute is specified as the value of the 'name' attribute in the resulting HTML. Note: this attribute is ignored if the imageType is set to "tile"
		 * Flags: IA */
		name?: string; // Flags=IA
		/** Prompt displayed in hover canvas if Canvas.showHover','showHover is true.
		 * Flags: IRW, Group: hovers */
		prompt?: string /* HTMLString */; // Flags=IRW
		/** Determines whether any specified StatefulCanvas.getTitle','title will be displayed for this component. Applies to Image-based components only, where the title will be rendered out in a label floating over the component
		 * Flags: IRWA */
		showTitle?: boolean /* Boolean */; // Flags=IRWA
		/** Convenience for setting height and width to the same value, at init time only
		 * Flags: IR, Group: sizing */
		size?: number /* Number */; // Flags=IR
		/** The base filename for the image. This value will be combined with any specified StatefulCanvas.state','state to form a combined URL, changing the appearance of the component as the state changes. The following table lists out the standard set of combined URLs that may be generated. Subclasses may support additional state-derived media of course. Note that the src URL will be split such that the extension is always applied to the end of the combined string. For example in the following table, if src was set to "blank.gif", the Selected+Focused URL would be "blank_Selected_Focused.gif". <table> <tr><td>URL for Img source</td><td>Description</td></tr> <tr><td>src+extension</td><td>Default URL</td></tr> <tr><td>src+"_Selected"+extension</td> <td>Applied when StatefulCanvas.selected is set to true</td></tr> <tr><td>src+"_Focused"+extension</td> <td>Applied when the component has keyboard focus, if StatefulCanvas.showFocused is true, and StatefulCanvas.showFocusedAsOver is not true.</td></tr> <tr><td>src+"_Over"+extension</td> <td>Applied when the user rolls over the component if StatefulCanvas.showRollOver is set to true</td></tr> <tr><td>src+"_Down"+extension</td> <td>Applied when the user presses the mouse button over over the component if StatefulCanvas.showDown is set to true</td></tr> <tr><td>src+"_Disabled"+extension</td> <td>Applied to Canvas.disabled component if StatefulCanvas.showDisabled is true.</td></tr> <tr><td colspan=2>Combined states</td></tr> <tr><td>src+"_Selected_Focused"+extension</td> <td>Combined Selected and focused state</td></tr> <tr><td>src+"_Selected_Over"+extension</td> <td>Combined Selected and rollOver state</td></tr> <tr><td>src+"_Focused_Over"+extension</td> <td>Combined Focused and rollOver state</td></tr> <tr><td>src+"_Selected_Focused_Over"+extension</td> <td>Combined Selected, Focused and rollOver state</td></tr> <tr><td>src+"_Selected_Down"+extension</td> <td>Combined Selected and mouse-down state</td></tr> <tr><td>src+"_Focused_Down"+extension</td> <td>Combined Focused and mouse-down state</td></tr> <tr><td>src+"_Selected_Focused_Down"+extension</td> <td>Combined Selected, Focused and mouse-down state</td></tr> <tr><td>src+"_Selected_Disabled"+extension</td> <td>Combined Selected and Disabled state</td></tr> </table>
		 * Flags: IRW, Group: appearance */
		src?: string /* SCImgURL */; // Flags=IRW
		/** If false, never apply the png fix needed in Internet Explorer to make png transparency work correctly.
		 * Flags: IR */
		usePNGFix?: boolean /* Boolean */; // Flags=IR

		/* Method Overrides */

	} // ImgProps


	/**
	 * The Img widget class implements a simple widget that displays a single image. 
	 */
	export interface Img extends StatefulCanvas {
		/** Setting this attribute configures an image map for this image. The value is expected as a sequence of &lg;AREA&gt tags - e.g: Img.create({ src: "myChart.gif", activeAreaHTML: "&lt;AREA shape='rect' coords='10,50,30,200' title='30' href='javascript:alert(\"30 units\")'&gt;" + "&lt;AREA shape='rect' coords='50,90,80,200' title='22' href='javascript:alert(\"22 units\")'&gt;" }); <u>Implementation notes:</u> Quotes in the activeAreaHTML must be escaped or alternated appropriately. Image maps do not stretch to fit scaled images. You must ensure that the dimensions of your Img component match the anticipated width and height of your image map (which will typically match the native dimensions of your image). To change the image map of an existing Img component, first set yourImg.activeAreaHTML, then call yourImg.markForRedraw(). Calls to yourImg.setSrc() will not automatically update the image map. activeAreaHTML is not supported on tiled Img components (imageType:"tile"). Native browser support for image map focus/blur, keyboard events, and certain AREA tag attributes (eg NOHREF, DEFAULT...) varies by platform. If your image map HTML uses attributes beyond the basics (shape, coords, href, title), you should test on all supported browsers to ensure that it functions as expected. 
		 * Flags: IRWA, Group: appearance */
		activeAreaHTML: string /* String of HTML AREA tags */;

		/** If specified this property will be included as the alt text for the image HMTL element. This is useful for improving application accessibility. altText and hover prompt / tooltip behavior: Note that some browsers, including Internet Explorer 9, show a native hover tooltip containing the img tag's alt attribute. Developers should not rely on this behavior to show the user a hover prompt - instead the Img.prompt attribute should be used. To set alt text and ensure a hover prompt shows up in all browsers, developers may set Img.prompt and altText to the same value. If both these attributes are set, the standard SmartClient prompt behavior will show a hover prompt in most browsers, but will be suppressed for browsers where a native tooltip is shown for altText. Note that setting altText and prompt to different values is not recommended - the prompt value will be ignored in favor of the altText in this case.
		 * Flags: IRW, Group: accessibility */
		altText: string /* String */;

		/** Default class used to construct the EditProxy for this component when the component is Canvas.setEditMode','first placed into edit mode.
		 * Flags: IR */
		editProxyConstructor: string /* SCClassName */;

		/** Explicit size for the image, for Img.imageType settings that would normally use the image's natural size (applies to Img.imageType "center" and "normal" only).
		 * Flags: IR */
		imageHeight: number /* integer */;

		/** Indicates whether the image should be tiled/cropped, stretched, or centered when the size of this widget does not match the size of the image. CENTER shows the image in it's natural size, but can't do so while the transparency fix is active for IE. The transparency fix can be manually disabled by setting Img.usePNGFix to false. See ImageStyle for further details.
		 * Flags: IRW, Group: appearance */
		imageType: ImageStyle;

		/** Explicit size for the image, for Img.imageType settings that would normally use the image's natural size (applies to Img.imageType "center" and "normal" only).
		 * Flags: IR */
		imageWidth: number /* integer */;

		/** The value of this attribute is specified as the value of the 'name' attribute in the resulting HTML. Note: this attribute is ignored if the imageType is set to "tile"
		 * Flags: IA */
		name: string;

		/** Prompt displayed in hover canvas if Canvas.showHover','showHover is true.
		 * Flags: IRW, Group: hovers */
		prompt: string /* HTMLString */;

		/** Determines whether any specified StatefulCanvas.getTitle','title will be displayed for this component. Applies to Image-based components only, where the title will be rendered out in a label floating over the component
		 * Flags: IRWA */
		showTitle: boolean /* Boolean */;

		/** Convenience for setting height and width to the same value, at init time only
		 * Flags: IR, Group: sizing */
		size: number /* Number */;

		/** The base filename for the image. This value will be combined with any specified StatefulCanvas.state','state to form a combined URL, changing the appearance of the component as the state changes. The following table lists out the standard set of combined URLs that may be generated. Subclasses may support additional state-derived media of course. Note that the src URL will be split such that the extension is always applied to the end of the combined string. For example in the following table, if src was set to "blank.gif", the Selected+Focused URL would be "blank_Selected_Focused.gif". <table> <tr><td>URL for Img source</td><td>Description</td></tr> <tr><td>src+extension</td><td>Default URL</td></tr> <tr><td>src+"_Selected"+extension</td> <td>Applied when StatefulCanvas.selected is set to true</td></tr> <tr><td>src+"_Focused"+extension</td> <td>Applied when the component has keyboard focus, if StatefulCanvas.showFocused is true, and StatefulCanvas.showFocusedAsOver is not true.</td></tr> <tr><td>src+"_Over"+extension</td> <td>Applied when the user rolls over the component if StatefulCanvas.showRollOver is set to true</td></tr> <tr><td>src+"_Down"+extension</td> <td>Applied when the user presses the mouse button over over the component if StatefulCanvas.showDown is set to true</td></tr> <tr><td>src+"_Disabled"+extension</td> <td>Applied to Canvas.disabled component if StatefulCanvas.showDisabled is true.</td></tr> <tr><td colspan=2>Combined states</td></tr> <tr><td>src+"_Selected_Focused"+extension</td> <td>Combined Selected and focused state</td></tr> <tr><td>src+"_Selected_Over"+extension</td> <td>Combined Selected and rollOver state</td></tr> <tr><td>src+"_Focused_Over"+extension</td> <td>Combined Focused and rollOver state</td></tr> <tr><td>src+"_Selected_Focused_Over"+extension</td> <td>Combined Selected, Focused and rollOver state</td></tr> <tr><td>src+"_Selected_Down"+extension</td> <td>Combined Selected and mouse-down state</td></tr> <tr><td>src+"_Focused_Down"+extension</td> <td>Combined Focused and mouse-down state</td></tr> <tr><td>src+"_Selected_Focused_Down"+extension</td> <td>Combined Selected, Focused and mouse-down state</td></tr> <tr><td>src+"_Selected_Disabled"+extension</td> <td>Combined Selected and Disabled state</td></tr> </table>
		 * Flags: IRW, Group: appearance */
		src: string /* SCImgURL */;

		/** If false, never apply the png fix needed in Internet Explorer to make png transparency work correctly.
		 * Flags: IR */
		usePNGFix: boolean /* Boolean */;


		/* Instance Method Overrides */

	} // Img

	export interface ImgStatic<T, P> extends StatefulCanvasStatic<T, P> {
	} // ImgStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a ImgButton Props argument.
	 * This is derived from the methods in the ImgButton class and it's parents and their properties marked with the I flag.
	 */
	export interface ImgButtonProps  {
		/** Behavior on state changes -- BUTTON, RADIO or CHECKBOX
		 * Flags: IRW, Group: state */
		actionType?: SelectionType; // Flags=IRW
		/** Horizontal alignment of this component's title.
		 * Flags: IRW, Group: appearance */
		align?: Alignment; // Flags=IRW
		/** If true, ignore the specified size of this widget and always size just large enough to accommodate the title. If setWidth() is explicitly called on an autoFit:true button, autoFit will be reset to false. Note that for StretchImgButton instances, autoFit will occur horizontally only, as unpredictable vertical sizing is likely to distort the media. If you do want vertical auto-fit, this can be achieved by simply setting a small height, and having overflow:"visible"
		 * Flags: IRW, Group: sizing */
		autoFit?: boolean; // Flags=IRW
		/** Base CSS style className applied to the component. As the component changes StatefulCanvas.state and/or is selected, suffixes will be added to the base style. In some cases more than one suffix will be appended to reflect a combined state ("Selected" + "Disabled", for example). See StatefulCanvas.getStateSuffix for a description of the default set of suffixes which may be applied to the baseStyle
		 * Flags: IRW */
		baseStyle?: string /* CSSStyleName */; // Flags=IRW
		/** If set to true, if the StatefulCanvas.title','title of this button contains the specified Canvas.accessKey','accessKey, when the title is displayed to the user it will be modified to include HTML to underline the accessKey. Note that this property may cause titles that include HTML (rather than simple strings) to be inappropriately modified, so should be disabled if your title string includes HTML characters.
		 * Flags: IRW */
		hiliteAccessKey?: boolean; // Flags=IRW
		/** Optional icon to be shown with the button title text. Specify as the partial URL to an image, relative to the imgDir of this component. Note that the string "blank" is a valid setting for this attribute and will always result in the system blank image, with no state suffixes applied. Typically, this might be used when an iconStyle is also specified and the iconStyle renders the icon via a stateful background-image or other CSS approach.
		 * Flags: IRW, Group: buttonIcon */
		icon?: string /* SCImgURL */; // Flags=IRW
		/** If this button is showing an icon should it be right or left aligned?
		 * Flags: IR, Group: buttonIcon */
		iconAlign?: string; // Flags=IR
		/** Height in pixels of the icon image. If unset, defaults to StatefulCanvas.iconSize','iconSize.
		 * Flags: IR, Group: buttonIcon */
		iconHeight?: number /* integer */; // Flags=IR
		/** If this button is showing an icon should it appear to the left or right of the title? valid options are "left" and "right".
		 * Flags: IR, Group: buttonIcon */
		iconOrientation?: string; // Flags=IR
		/** Size in pixels of the icon image. The StatefulCanvas.iconWidth','iconWidth and StatefulCanvas.iconHeight','iconHeight properties can be used to configure width and height separately. Note: When configuring the properties of a StatefulCanvas (or derivative) AutoChild','AutoChild, it is best to set the iconWidth and iconHeight to the same value rather than setting an iconSize. This is because certain skins or customizations thereto might set the iconWidth and iconHeight, making the customization of the AutoChild's iconSize ineffective.
		 * Flags: IR, Group: buttonIcon */
		iconSize?: number /* int */; // Flags=IR
		/** Pixels between icon and title text.
		 * Flags: IR, Group: buttonIcon */
		iconSpacing?: number /* int */; // Flags=IR
		/** Width in pixels of the icon image. If unset, defaults to StatefulCanvas.iconSize','iconSize.
		 * Flags: IR, Group: buttonIcon */
		iconWidth?: number /* integer */; // Flags=IR
		/** Horizontal padding to be applied to this widget's label. If this value is null, the label will be given a horizontal padding of zero. The specified amount of padding is applied to the left and right edges of the button, so the total amount of padding is 2x the specified value.
		 * Flags: IRW */
		labelHPad?: number; // Flags=IRW
		/** Vertical padding to be applied to this widget's label. If this value is null, the label will be given a vertial padding of zero. The specified amount of padding is applied to the top and bottom edges of the button, so the total amount of padding is 2x the specified value.
		 * Flags: IRW */
		labelVPad?: number; // Flags=IRW
		/** String identifier for this canvas's mutually exclusive selection group.
		 * Flags: IRWA, Group: state */
		radioGroup?: string; // Flags=IRWA
		/** Whether this component is selected. For some components, selection affects appearance.
		 * Flags: IRW, Group: state */
		selected?: boolean /* Boolean */; // Flags=IRW
		/** If true and the title is clipped, then a hover containing the full title of this button is enabled.
		 * Flags: IRW, Group: hovers */
		showClippedTitleOnHover?: boolean /* Boolean */; // Flags=IRW
		/** Should we visibly change state when disabled?
		 * Flags: IRW, Group: state */
		showDisabled?: boolean /* Boolean */; // Flags=IRW
		/** If using an icon for this button, whether to switch the icon image if the button becomes disabled.
		 * Flags: IR, Group: buttonIcon */
		showDisabledIcon?: boolean /* Boolean */; // Flags=IR
		/** Should we visibly change state when the mouse goes down in this object?
		 * Flags: IRW, Group: state */
		showDown?: boolean /* Boolean */; // Flags=IRW
		/** If using an icon for this button, whether to switch the icon image when the mouse goes down on the button.
		 * Flags: IR, Group: buttonIcon */
		showDownIcon?: boolean /* Boolean */; // Flags=IR
		/** Should we visibly change state when the canvas receives focus? If StatefulCanvas.showFocusedAsOver is true, then "over" will be used to indicate focus. Otherwise a separate "focused" state will be used.
		 * Flags: IRW, Group: state */
		showFocused?: boolean /* Boolean */; // Flags=IRW
		/** If using an icon for this button, whether to switch the icon image when the button receives focus. If StatefulCanvas.showFocusedAsOver is true, the "Over" icon will be displayed when the canvas has focus, otherwise a separate "Focused" icon will be displayed
		 * Flags: IR, Group: buttonIcon */
		showFocusedIcon?: boolean /* Boolean */; // Flags=IR
		/** Should we visibly change state when the mouse goes over this object?
		 * Flags: IRW, Group: state */
		showRollOver?: boolean /* Boolean */; // Flags=IRW
		/** If using an icon for this button, whether to switch the icon image on mouse rollover.
		 * Flags: IR, Group: buttonIcon */
		showRollOverIcon?: boolean /* Boolean */; // Flags=IR
		/** If using an icon for this button, whether to switch the icon image when the button becomes selected.
		 * Flags: IR, Group: buttonIcon */
		showSelectedIcon?: boolean /* Boolean */; // Flags=IR
		/** Determines whether any specified StatefulCanvas.getTitle','title will be displayed for this component. Applies to Image-based components only, where the title will be rendered out in a label floating over the component
		 * Flags: IRWA */
		showTitle?: boolean /* Boolean */; // Flags=IRWA
		/** The base filename for the image. This value will be combined with any specified StatefulCanvas.state','state to form a combined URL, changing the appearance of the component as the state changes. The following table lists out the standard set of combined URLs that may be generated. Subclasses may support additional state-derived media of course. Note that the src URL will be split such that the extension is always applied to the end of the combined string. For example in the following table, if src was set to "blank.gif", the Selected+Focused URL would be "blank_Selected_Focused.gif". <table> <tr><td>URL for Img source</td><td>Description</td></tr> <tr><td>src+extension</td><td>Default URL</td></tr> <tr><td>src+"_Selected"+extension</td> <td>Applied when StatefulCanvas.selected is set to true</td></tr> <tr><td>src+"_Focused"+extension</td> <td>Applied when the component has keyboard focus, if StatefulCanvas.showFocused is true, and StatefulCanvas.showFocusedAsOver is not true.</td></tr> <tr><td>src+"_Over"+extension</td> <td>Applied when the user rolls over the component if StatefulCanvas.showRollOver is set to true</td></tr> <tr><td>src+"_Down"+extension</td> <td>Applied when the user presses the mouse button over over the component if StatefulCanvas.showDown is set to true</td></tr> <tr><td>src+"_Disabled"+extension</td> <td>Applied to Canvas.disabled component if StatefulCanvas.showDisabled is true.</td></tr> <tr><td colspan=2>Combined states</td></tr> <tr><td>src+"_Selected_Focused"+extension</td> <td>Combined Selected and focused state</td></tr> <tr><td>src+"_Selected_Over"+extension</td> <td>Combined Selected and rollOver state</td></tr> <tr><td>src+"_Focused_Over"+extension</td> <td>Combined Focused and rollOver state</td></tr> <tr><td>src+"_Selected_Focused_Over"+extension</td> <td>Combined Selected, Focused and rollOver state</td></tr> <tr><td>src+"_Selected_Down"+extension</td> <td>Combined Selected and mouse-down state</td></tr> <tr><td>src+"_Focused_Down"+extension</td> <td>Combined Focused and mouse-down state</td></tr> <tr><td>src+"_Selected_Focused_Down"+extension</td> <td>Combined Selected, Focused and mouse-down state</td></tr> <tr><td>src+"_Selected_Disabled"+extension</td> <td>Combined Selected and Disabled state</td></tr> </table>
		 * Flags: IRW, Group: appearance */
		src?: string /* SCImgURL */; // Flags=IRW
		/** Current "state" of this widget. The state setting is automatically updated as the user interacts with the component (see StatefulCanvas.showRollOver, StatefulCanvas.showDown, StatefulCanvas.showDisabled). StatefulCanvases will have a different appearance based on their current state. By default this is handled by changing the css className applied to the StatefulCanvas - see StatefulCanvas.baseStyle and StatefulCanvas.getStateSuffix for a description of how this is done. For Img or StretchImg based subclasses of StatefulCanvas, the appearance may also be updated by changing the src of the rendered image. See Img.src and StretchImgButton.src for a description of how the URL is modified to reflect the state of the widget in this case.
		 * Flags: IRWA, Group: state */
		state?: State; // Flags=IRWA
		/** The title HTML to display in this button.
		 * Flags: IRW, Group: basics */
		title?: string /* HTMLString */; // Flags=IRW
		/** Vertical alignment of this component's title.
		 * Flags: IRW, Group: appearance */
		valign?: VerticalAlignment; // Flags=IRW

		/* Method Overrides */

	} // ImgButtonProps


	/**
	 * A Img that behaves like a button, going through up/down/over state transitions in response to user events. Supports an optional title, and will auto-size to accommodate the title text if overflow is set to "visible". Example uses are Window minimize/close buttons. 
	 */
	export interface ImgButton  {
		/** Behavior on state changes -- BUTTON, RADIO or CHECKBOX
		 * Flags: IRW, Group: state */
		actionType: SelectionType;

		/** Horizontal alignment of this component's title.
		 * Flags: IRW, Group: appearance */
		align: Alignment;

		/** If true, ignore the specified size of this widget and always size just large enough to accommodate the title. If setWidth() is explicitly called on an autoFit:true button, autoFit will be reset to false. Note that for StretchImgButton instances, autoFit will occur horizontally only, as unpredictable vertical sizing is likely to distort the media. If you do want vertical auto-fit, this can be achieved by simply setting a small height, and having overflow:"visible"
		 * Flags: IRW, Group: sizing */
		autoFit: boolean;

		/** Base CSS style className applied to the component. As the component changes StatefulCanvas.state and/or is selected, suffixes will be added to the base style. In some cases more than one suffix will be appended to reflect a combined state ("Selected" + "Disabled", for example). See StatefulCanvas.getStateSuffix for a description of the default set of suffixes which may be applied to the baseStyle
		 * Flags: IRW */
		baseStyle: string /* CSSStyleName */;

		/** If set to true, if the StatefulCanvas.title','title of this button contains the specified Canvas.accessKey','accessKey, when the title is displayed to the user it will be modified to include HTML to underline the accessKey. Note that this property may cause titles that include HTML (rather than simple strings) to be inappropriately modified, so should be disabled if your title string includes HTML characters.
		 * Flags: IRW */
		hiliteAccessKey: boolean;

		/** Optional icon to be shown with the button title text. Specify as the partial URL to an image, relative to the imgDir of this component. Note that the string "blank" is a valid setting for this attribute and will always result in the system blank image, with no state suffixes applied. Typically, this might be used when an iconStyle is also specified and the iconStyle renders the icon via a stateful background-image or other CSS approach.
		 * Flags: IRW, Group: buttonIcon */
		icon: string /* SCImgURL */;

		/** If this button is showing an icon should it be right or left aligned?
		 * Flags: IR, Group: buttonIcon */
		iconAlign: string;

		/** Height in pixels of the icon image. If unset, defaults to StatefulCanvas.iconSize','iconSize.
		 * Flags: IR, Group: buttonIcon */
		iconHeight: number /* integer */;

		/** If this button is showing an icon should it appear to the left or right of the title? valid options are "left" and "right".
		 * Flags: IR, Group: buttonIcon */
		iconOrientation: string;

		/** Size in pixels of the icon image. The StatefulCanvas.iconWidth','iconWidth and StatefulCanvas.iconHeight','iconHeight properties can be used to configure width and height separately. Note: When configuring the properties of a StatefulCanvas (or derivative) AutoChild','AutoChild, it is best to set the iconWidth and iconHeight to the same value rather than setting an iconSize. This is because certain skins or customizations thereto might set the iconWidth and iconHeight, making the customization of the AutoChild's iconSize ineffective.
		 * Flags: IR, Group: buttonIcon */
		iconSize: number /* int */;

		/** Pixels between icon and title text.
		 * Flags: IR, Group: buttonIcon */
		iconSpacing: number /* int */;

		/** Width in pixels of the icon image. If unset, defaults to StatefulCanvas.iconSize','iconSize.
		 * Flags: IR, Group: buttonIcon */
		iconWidth: number /* integer */;

		/** Horizontal padding to be applied to this widget's label. If this value is null, the label will be given a horizontal padding of zero. The specified amount of padding is applied to the left and right edges of the button, so the total amount of padding is 2x the specified value.
		 * Flags: IRW */
		labelHPad: number;

		/** Vertical padding to be applied to this widget's label. If this value is null, the label will be given a vertial padding of zero. The specified amount of padding is applied to the top and bottom edges of the button, so the total amount of padding is 2x the specified value.
		 * Flags: IRW */
		labelVPad: number;

		/** String identifier for this canvas's mutually exclusive selection group.
		 * Flags: IRWA, Group: state */
		radioGroup: string;

		/** Whether this component is selected. For some components, selection affects appearance.
		 * Flags: IRW, Group: state */
		selected: boolean /* Boolean */;

		/** If true and the title is clipped, then a hover containing the full title of this button is enabled.
		 * Flags: IRW, Group: hovers */
		showClippedTitleOnHover: boolean /* Boolean */;

		/** Should we visibly change state when disabled?
		 * Flags: IRW, Group: state */
		showDisabled: boolean /* Boolean */;

		/** If using an icon for this button, whether to switch the icon image if the button becomes disabled.
		 * Flags: IR, Group: buttonIcon */
		showDisabledIcon: boolean /* Boolean */;

		/** Should we visibly change state when the mouse goes down in this object?
		 * Flags: IRW, Group: state */
		showDown: boolean /* Boolean */;

		/** If using an icon for this button, whether to switch the icon image when the mouse goes down on the button.
		 * Flags: IR, Group: buttonIcon */
		showDownIcon: boolean /* Boolean */;

		/** Should we visibly change state when the canvas receives focus? If StatefulCanvas.showFocusedAsOver is true, then "over" will be used to indicate focus. Otherwise a separate "focused" state will be used.
		 * Flags: IRW, Group: state */
		showFocused: boolean /* Boolean */;

		/** If using an icon for this button, whether to switch the icon image when the button receives focus. If StatefulCanvas.showFocusedAsOver is true, the "Over" icon will be displayed when the canvas has focus, otherwise a separate "Focused" icon will be displayed
		 * Flags: IR, Group: buttonIcon */
		showFocusedIcon: boolean /* Boolean */;

		/** Should we visibly change state when the mouse goes over this object?
		 * Flags: IRW, Group: state */
		showRollOver: boolean /* Boolean */;

		/** If using an icon for this button, whether to switch the icon image on mouse rollover.
		 * Flags: IR, Group: buttonIcon */
		showRollOverIcon: boolean /* Boolean */;

		/** If using an icon for this button, whether to switch the icon image when the button becomes selected.
		 * Flags: IR, Group: buttonIcon */
		showSelectedIcon: boolean /* Boolean */;

		/** Determines whether any specified StatefulCanvas.getTitle','title will be displayed for this component. Applies to Image-based components only, where the title will be rendered out in a label floating over the component
		 * Flags: IRWA */
		showTitle: boolean /* Boolean */;

		/** The base filename for the image. This value will be combined with any specified StatefulCanvas.state','state to form a combined URL, changing the appearance of the component as the state changes. The following table lists out the standard set of combined URLs that may be generated. Subclasses may support additional state-derived media of course. Note that the src URL will be split such that the extension is always applied to the end of the combined string. For example in the following table, if src was set to "blank.gif", the Selected+Focused URL would be "blank_Selected_Focused.gif". <table> <tr><td>URL for Img source</td><td>Description</td></tr> <tr><td>src+extension</td><td>Default URL</td></tr> <tr><td>src+"_Selected"+extension</td> <td>Applied when StatefulCanvas.selected is set to true</td></tr> <tr><td>src+"_Focused"+extension</td> <td>Applied when the component has keyboard focus, if StatefulCanvas.showFocused is true, and StatefulCanvas.showFocusedAsOver is not true.</td></tr> <tr><td>src+"_Over"+extension</td> <td>Applied when the user rolls over the component if StatefulCanvas.showRollOver is set to true</td></tr> <tr><td>src+"_Down"+extension</td> <td>Applied when the user presses the mouse button over over the component if StatefulCanvas.showDown is set to true</td></tr> <tr><td>src+"_Disabled"+extension</td> <td>Applied to Canvas.disabled component if StatefulCanvas.showDisabled is true.</td></tr> <tr><td colspan=2>Combined states</td></tr> <tr><td>src+"_Selected_Focused"+extension</td> <td>Combined Selected and focused state</td></tr> <tr><td>src+"_Selected_Over"+extension</td> <td>Combined Selected and rollOver state</td></tr> <tr><td>src+"_Focused_Over"+extension</td> <td>Combined Focused and rollOver state</td></tr> <tr><td>src+"_Selected_Focused_Over"+extension</td> <td>Combined Selected, Focused and rollOver state</td></tr> <tr><td>src+"_Selected_Down"+extension</td> <td>Combined Selected and mouse-down state</td></tr> <tr><td>src+"_Focused_Down"+extension</td> <td>Combined Focused and mouse-down state</td></tr> <tr><td>src+"_Selected_Focused_Down"+extension</td> <td>Combined Selected, Focused and mouse-down state</td></tr> <tr><td>src+"_Selected_Disabled"+extension</td> <td>Combined Selected and Disabled state</td></tr> </table>
		 * Flags: IRW, Group: appearance */
		src: string /* SCImgURL */;

		/** Current "state" of this widget. The state setting is automatically updated as the user interacts with the component (see StatefulCanvas.showRollOver, StatefulCanvas.showDown, StatefulCanvas.showDisabled). StatefulCanvases will have a different appearance based on their current state. By default this is handled by changing the css className applied to the StatefulCanvas - see StatefulCanvas.baseStyle and StatefulCanvas.getStateSuffix for a description of how this is done. For Img or StretchImg based subclasses of StatefulCanvas, the appearance may also be updated by changing the src of the rendered image. See Img.src and StretchImgButton.src for a description of how the URL is modified to reflect the state of the widget in this case.
		 * Flags: IRWA, Group: state */
		state: State;

		/** The title HTML to display in this button.
		 * Flags: IRW, Group: basics */
		title: string /* HTMLString */;

		/** Vertical alignment of this component's title.
		 * Flags: IRW, Group: appearance */
		valign: VerticalAlignment;


		/* Instance Method Overrides */

	} // ImgButton

	export interface ImgButtonStatic<T, P> extends ClassStatic<T, P> {
	} // ImgButtonStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a isc Props argument.
	 * This is derived from the methods in the isc class and it's parents and their properties marked with the I flag.
	 */
	export interface iscProps  {

		/* Method Overrides */

	} // iscProps


	/**
	 * The isc object contains global methods and objects of the Isomorphic SmartClient framework. See also simpleNamesMode','Simple Names mode. 
	 */
	export interface isc  {

		/* Instance Method Overrides */

	} // isc

	export interface iscStatic  {

	/* Methods */

		/** 
		 * Show a modal dialog with a message, icon, and "Yes" and "No" buttons. See Dialog.askIcon. The callback will receive boolean true for a Yes button click, boolean false for a No button click, or null if the Dialog is dismissed via the close button.
		 * @param {string} message - message to display
		 * @param {Callback} callback - Callback to fire when the user clicks a button to dismiss the dialog. This has the single parameter 'value', indicating the value returned by the Warn dialog from 'okClick()' etc.
		 * @param {DialogProps} properties - additional properties for the Dialog. To set Dialog.buttons','custom buttons for the Dialog, set properties.buttons to an array of buttons eg: { buttons : [Dialog.OK, Dialog.CANCEL] }
		 */
		ask(message:string, callback?:Callback, properties?:DialogProps /* Dialog Properties */): void; 

		/** 
		 * Show a modal dialog with a text entry box, asking the user to enter a value. As with other convenience methods that show Dialogs, such as isc.warn, the dialog is shown and the function immediately returns. When the user responds, the provided callback is called. If the user clicks OK, the value typed in is passed to the callback (including the empty string ("") if nothing was entered. If the user clicks cancel, the value passed to the callback is null. A default value for the text field can be passed via properties.defaultValue. Keyboard focus is automatically placed in the text entry field, and hitting the enter key is the equivalent of pressing OK.
		 * @param {string} message - message to display
		 * @param {Callback} callback - Callback to fire when the user clicks a button to dismiss the dialog. This has the single parameter 'value', indicating the user entry, or null if cancel was pressed or the window closed
		 * @param {DialogProps} properties - additional properties for the Dialog. To set Dialog.buttons','custom buttons for the Dialog, set properties.buttons to an array of buttons eg: { buttons : [Dialog.OK, Dialog.CANCEL] }
		 */
		askForValue(message:string, callback?:Callback, properties?:DialogProps /* Dialog Properties */): void; 

		/** 
		 * Is some property specified on the object passed in? This will return true if object[propertyName] has ever been set to any value, and not deleted. May return true even if object[propertyName] === undefined if the property is present on the object and has been explicitly set to undefined.
		 * @param {any} object - Object to test
		 * @param {string} propertyName - Which property is being tested for?
		 */
		propertyDefined(object:any /* object */, propertyName:string): boolean; 

		/** 
		 * Show a modal dialog with a message, icon, and "OK" button. Intended for notifications which are not really warnings (default icon is less severe). See Dialog.sayIcon. The callback will receive boolean true for an OK button click, or null if the Dialog is dismissed via the close button.
		 * @param {string} message - message to display
		 * @param {Callback} callback - Optional Callback to fire when the user dismisses the dialog. This has the single parameter 'value', indicating the value returned by the Warn dialog from 'okClick()' etc.
		 * @param {DialogProps} properties - additional properties for the Dialog. To set Dialog.buttons','custom buttons for the Dialog, set properties.buttons to an array of buttons eg: { buttons : [Dialog.OK, Dialog.CANCEL] }
		 */
		say(message:string, callback?:Callback, properties?:DialogProps /* Dialog Properties */): void; 

		/** 
		 * Show a modal dialog with a message, icon, and "OK" button. See Dialog.warnIcon. The callback will receive boolean true for an OK button click, or null if the Dialog is dismissed via the close button.
		 * @param {string} message - message to display
		 * @param {Callback} callback - Optional Callback to fire when the user dismisses the dialog. This has the single parameter 'value', indicating the value returned by the Warn dialog from 'okClick()' etc.
		 * @param {DialogProps} properties - additional properties for the Dialog. To set Dialog.buttons','custom buttons for the Dialog, set properties.buttons to an array of buttons eg: { buttons : [Dialog.OK, Dialog.CANCEL] }
		 */
		warn(message:string, callback?:Callback, properties?:DialogProps /* Dialog Properties */): void; 

	} // iscStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a Label Props argument.
	 * This is derived from the methods in the Label class and it's parents and their properties marked with the I flag.
	 */
	export interface LabelProps extends ButtonProps {
		/** Horizontal alignment of label text. See Alignment type for details.
		 * Flags: IRW, Group: positioning */
		align?: Alignment; // Flags=IRW
		/** If true, ignore the specified size of this widget and always size just large enough to accommodate the title. If setWidth() is explicitly called on an autoFit:true button, autoFit will be reset to false. Note that for StretchImgButton instances, autoFit will occur horizontally only, as unpredictable vertical sizing is likely to distort the media. If you do want vertical auto-fit, this can be achieved by simply setting a small height, and having overflow:"visible"
		 * Flags: IRW, Group: sizing */
		autoFit?: boolean; // Flags=IRW
		/** The contents of a canvas or label widget. Any HTML string is acceptable.
		 * Flags: IRW, Group: contents */
		contents?: string /* HTMLString */; // Flags=IRW
		/** Dynamic contents allows the contents string to be treated as a simple, but powerful template. When this attribute is set to true, expressions of the form &#36;{arbitrary JS here} are replaced by the result of the evaluation of the JS code inside the curly brackets. This evaluation happens at draw time. If you want to trigger a re-evaluation of the expressions in the contents string you can call markForRedraw() on the canvas. You can use this feature to build some simple custom components. For example, let's say you want to show the value of a Slider in a Canvas somewhere on the screen. You can do this by observing the valueChanged() method on the slider and calling setContents() on your canvas with the new string or you can set the contents of the canvas to something like: "The slider value is &#36;{sliderInstance.getValue()}." Next you set dynamicContents: true on the canvas, observe valueChanged() on the slider and call canvas.markForRedraw() in that observation. This approach is cleaner than setContents() when the Canvas is aggregating several values or dynamic expressions. Like so: Slider.create({ ID: "mySlider" }); Canvas.create({ ID: "myCanvas", dynamicContents: true, contents: "The slider value is &#36;{mySlider.getValue()}." }); myCanvas.observe(mySlider, "valueChanged", "observer.markForRedraw()"); You can embed an arbitrary number of dynamic expressions in the contents string. The search and replace is optimized for speed. If an error occurs during the evaluation of one of the expressions, a warning is logged to the ISC Developer Console and the error string is embedded in place of the expected value in the Canvas. The value of a function is its return value. The value of any variable is the same as that returned by its toString() representation. Inside the evaluation contentext, this points to the canvas instance that has the dynamicContents string as its contents - in other words the canvas instance on which the template is declared.
		 * Flags: IRWA, Group: contents */
		dynamicContents?: boolean /* Boolean */; // Flags=IRWA
		/** Default class used to construct the EditProxy for this component when the component is Canvas.setEditMode','first placed into edit mode.
		 * Flags: IR */
		editProxyConstructor?: string /* SCClassName */; // Flags=IR
		/** Optional icon to be shown with the button title text. Specify as the partial URL to an image, relative to the imgDir of this component. Note that the string "blank" is a valid setting for this attribute and will always result in the system blank image, with no state suffixes applied. Typically, this might be used when an iconStyle is also specified and the iconStyle renders the icon via a stateful background-image or other CSS approach.
		 * Flags: IRW, Group: buttonIcon */
		icon?: string /* SCImgURL */; // Flags=IRW
		/** If this button is showing an icon should it be right or left aligned?
		 * Flags: IR, Group: buttonIcon */
		iconAlign?: string; // Flags=IR
		/** Height in pixels of the icon image. If unset, defaults to StatefulCanvas.iconSize','iconSize.
		 * Flags: IR, Group: buttonIcon */
		iconHeight?: number /* integer */; // Flags=IR
		/** If this button is showing an icon should it appear to the left or right of the title? valid options are "left" and "right".
		 * Flags: IR, Group: buttonIcon */
		iconOrientation?: string; // Flags=IR
		/** Size in pixels of the icon image. The StatefulCanvas.iconWidth','iconWidth and StatefulCanvas.iconHeight','iconHeight properties can be used to configure width and height separately. Note: When configuring the properties of a StatefulCanvas (or derivative) AutoChild','AutoChild, it is best to set the iconWidth and iconHeight to the same value rather than setting an iconSize. This is because certain skins or customizations thereto might set the iconWidth and iconHeight, making the customization of the AutoChild's iconSize ineffective.
		 * Flags: IR, Group: buttonIcon */
		iconSize?: number /* int */; // Flags=IR
		/** Pixels between icon and title text.
		 * Flags: IR, Group: buttonIcon */
		iconSpacing?: number /* int */; // Flags=IR
		/** Width in pixels of the icon image. If unset, defaults to StatefulCanvas.iconSize','iconSize.
		 * Flags: IR, Group: buttonIcon */
		iconWidth?: number /* integer */; // Flags=IR
		/** If using an icon for this button, whether to switch the icon image if the button becomes disabled.
		 * Flags: IR, Group: buttonIcon */
		showDisabledIcon?: boolean /* Boolean */; // Flags=IR
		/** If using an icon for this button, whether to switch the icon image when the mouse goes down on the button.
		 * Flags: IR, Group: buttonIcon */
		showDownIcon?: boolean /* Boolean */; // Flags=IR
		/** If using an icon for this button, whether to switch the icon image when the button receives focus. If StatefulCanvas.showFocusedAsOver is true, the "Over" icon will be displayed when the canvas has focus, otherwise a separate "Focused" icon will be displayed
		 * Flags: IR, Group: buttonIcon */
		showFocusedIcon?: boolean /* Boolean */; // Flags=IR
		/** If using an icon for this button, whether to switch the icon image on mouse rollover.
		 * Flags: IR, Group: buttonIcon */
		showRollOverIcon?: boolean /* Boolean */; // Flags=IR
		/** If using an icon for this button, whether to switch the icon image when the button becomes selected.
		 * Flags: IR, Group: buttonIcon */
		showSelectedIcon?: boolean /* Boolean */; // Flags=IR
		/** Set the CSS class for this widget. For a Label, this is equivalent to setting Button.baseStyle.
		 * Flags: IRW */
		styleName?: string /* CSSStyleName */; // Flags=IRW
		/** Vertical alignment of label text. See VerticalAlignment type for details.
		 * Flags: IRW, Group: positioning */
		valign?: VerticalAlignment; // Flags=IRW
		/** If false, the label text will not be wrapped to the next line.
		 * Flags: IRW, Group: sizing */
		wrap?: boolean /* Boolean */; // Flags=IRW

		/* Method Overrides */

		/** 
		 * Changes the contents of a widget to newContents, an HTML string. When Canvas.dynamicContents','dynamicContents is set, setContents() can also be called with no arguments to cause contents to be re-evaluated.
		 * @param {string} newContents - an HTML string to be set as the contents of this widget
		 */
		setContents?(newContents?:string): void; 

	} // LabelProps


	/**
	 * Labels display a small amount of Label.align','alignable Label.contents','text with optional Label.icon','icon and Label.autoFit','autoFit. For a general-purpose container for HTML content, use HTMLFlow or HTMLPane instead. 
	 */
	export interface Label extends Button {
		/** Horizontal alignment of label text. See Alignment type for details.
		 * Flags: IRW, Group: positioning */
		align: Alignment;

		/** If true, ignore the specified size of this widget and always size just large enough to accommodate the title. If setWidth() is explicitly called on an autoFit:true button, autoFit will be reset to false. Note that for StretchImgButton instances, autoFit will occur horizontally only, as unpredictable vertical sizing is likely to distort the media. If you do want vertical auto-fit, this can be achieved by simply setting a small height, and having overflow:"visible"
		 * Flags: IRW, Group: sizing */
		autoFit: boolean;

		/** The contents of a canvas or label widget. Any HTML string is acceptable.
		 * Flags: IRW, Group: contents */
		contents: string /* HTMLString */;

		/** Dynamic contents allows the contents string to be treated as a simple, but powerful template. When this attribute is set to true, expressions of the form &#36;{arbitrary JS here} are replaced by the result of the evaluation of the JS code inside the curly brackets. This evaluation happens at draw time. If you want to trigger a re-evaluation of the expressions in the contents string you can call markForRedraw() on the canvas. You can use this feature to build some simple custom components. For example, let's say you want to show the value of a Slider in a Canvas somewhere on the screen. You can do this by observing the valueChanged() method on the slider and calling setContents() on your canvas with the new string or you can set the contents of the canvas to something like: "The slider value is &#36;{sliderInstance.getValue()}." Next you set dynamicContents: true on the canvas, observe valueChanged() on the slider and call canvas.markForRedraw() in that observation. This approach is cleaner than setContents() when the Canvas is aggregating several values or dynamic expressions. Like so: Slider.create({ ID: "mySlider" }); Canvas.create({ ID: "myCanvas", dynamicContents: true, contents: "The slider value is &#36;{mySlider.getValue()}." }); myCanvas.observe(mySlider, "valueChanged", "observer.markForRedraw()"); You can embed an arbitrary number of dynamic expressions in the contents string. The search and replace is optimized for speed. If an error occurs during the evaluation of one of the expressions, a warning is logged to the ISC Developer Console and the error string is embedded in place of the expected value in the Canvas. The value of a function is its return value. The value of any variable is the same as that returned by its toString() representation. Inside the evaluation contentext, this points to the canvas instance that has the dynamicContents string as its contents - in other words the canvas instance on which the template is declared.
		 * Flags: IRWA, Group: contents */
		dynamicContents: boolean /* Boolean */;

		/** Default class used to construct the EditProxy for this component when the component is Canvas.setEditMode','first placed into edit mode.
		 * Flags: IR */
		editProxyConstructor: string /* SCClassName */;

		/** Optional icon to be shown with the button title text. Specify as the partial URL to an image, relative to the imgDir of this component. Note that the string "blank" is a valid setting for this attribute and will always result in the system blank image, with no state suffixes applied. Typically, this might be used when an iconStyle is also specified and the iconStyle renders the icon via a stateful background-image or other CSS approach.
		 * Flags: IRW, Group: buttonIcon */
		icon: string /* SCImgURL */;

		/** If this button is showing an icon should it be right or left aligned?
		 * Flags: IR, Group: buttonIcon */
		iconAlign: string;

		/** Height in pixels of the icon image. If unset, defaults to StatefulCanvas.iconSize','iconSize.
		 * Flags: IR, Group: buttonIcon */
		iconHeight: number /* integer */;

		/** If this button is showing an icon should it appear to the left or right of the title? valid options are "left" and "right".
		 * Flags: IR, Group: buttonIcon */
		iconOrientation: string;

		/** Size in pixels of the icon image. The StatefulCanvas.iconWidth','iconWidth and StatefulCanvas.iconHeight','iconHeight properties can be used to configure width and height separately. Note: When configuring the properties of a StatefulCanvas (or derivative) AutoChild','AutoChild, it is best to set the iconWidth and iconHeight to the same value rather than setting an iconSize. This is because certain skins or customizations thereto might set the iconWidth and iconHeight, making the customization of the AutoChild's iconSize ineffective.
		 * Flags: IR, Group: buttonIcon */
		iconSize: number /* int */;

		/** Pixels between icon and title text.
		 * Flags: IR, Group: buttonIcon */
		iconSpacing: number /* int */;

		/** Width in pixels of the icon image. If unset, defaults to StatefulCanvas.iconSize','iconSize.
		 * Flags: IR, Group: buttonIcon */
		iconWidth: number /* integer */;

		/** If using an icon for this button, whether to switch the icon image if the button becomes disabled.
		 * Flags: IR, Group: buttonIcon */
		showDisabledIcon: boolean /* Boolean */;

		/** If using an icon for this button, whether to switch the icon image when the mouse goes down on the button.
		 * Flags: IR, Group: buttonIcon */
		showDownIcon: boolean /* Boolean */;

		/** If using an icon for this button, whether to switch the icon image when the button receives focus. If StatefulCanvas.showFocusedAsOver is true, the "Over" icon will be displayed when the canvas has focus, otherwise a separate "Focused" icon will be displayed
		 * Flags: IR, Group: buttonIcon */
		showFocusedIcon: boolean /* Boolean */;

		/** If using an icon for this button, whether to switch the icon image on mouse rollover.
		 * Flags: IR, Group: buttonIcon */
		showRollOverIcon: boolean /* Boolean */;

		/** If using an icon for this button, whether to switch the icon image when the button becomes selected.
		 * Flags: IR, Group: buttonIcon */
		showSelectedIcon: boolean /* Boolean */;

		/** Set the CSS class for this widget. For a Label, this is equivalent to setting Button.baseStyle.
		 * Flags: IRW */
		styleName: string /* CSSStyleName */;

		/** Vertical alignment of label text. See VerticalAlignment type for details.
		 * Flags: IRW, Group: positioning */
		valign: VerticalAlignment;

		/** If false, the label text will not be wrapped to the next line.
		 * Flags: IRW, Group: sizing */
		wrap: boolean /* Boolean */;


		/* Instance Method Overrides */

		/** 
		 * Changes the contents of a widget to newContents, an HTML string. When Canvas.dynamicContents','dynamicContents is set, setContents() can also be called with no arguments to cause contents to be re-evaluated.
		 * @param {string} newContents - an HTML string to be set as the contents of this widget
		 */
		setContents?(newContents?:string): void; 

	} // Label

	export interface LabelStatic<T, P> extends ButtonStatic<T, P> {
	} // LabelStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a Layout Props argument.
	 * This is derived from the methods in the Layout class and it's parents and their properties marked with the I flag.
	 */
	export interface LayoutProps extends CanvasProps {
		/** Alignment of all members in this Layout on the length axis (vertical for a VLayout, horizontal for an HLayout). Defaults to "top" for vertical Layouts, and "left" for horizontal Layouts. Horizontal layouts should only be set to Alignment, and vertical layouts to VerticalAlignment, otherwise they will be considered invalid values, and assigning an invalid value here will log a warning to the Developer Console. For alignment on the breadth axis, see Layout.defaultLayoutAlign and Canvas.layoutAlign. When attempting to center components be sure that you have set a specific size on the component(s) involved. If components fill all available space in the layout, centering looks the same as not centering. Similarly, if a component has no visible boundary (like a border), it can appear similar to when it's not centered if the component is larger than you expect - use the Watch tab in the Developer Console to see the component's extents visually.
		 * Flags: IRW, Group: layoutPolicy */
		align?: Alignment | VerticalAlignment /* Alignment or VerticalAlignment */; // Flags=IRW
		/** If true when members are added / removed, they should be animated as they are shown or hidden in position
		 * Flags: IRW, Group: animation */
		animateMembers?: boolean; // Flags=IRW
		/** If specified this is the duration of show/hide animations when members are being shown or hidden due to being added / removed from this layout.
		 * Flags: IRWA, Group: animation */
		animateMemberTime?: number; // Flags=IRWA
		/** Layouts provide a default implementation of a drag and drop interaction. If you set Canvas.canAcceptDrop','canAcceptDrop:true and canDropComponents:true on a Layout, when a droppable Canvas (Canvas.canDrop','canDrop:true is dragged over the layout, it will show a dropLine (a simple insertion line) at the drop location. When the drop occurs, the dragTarget (obtained using EventHandler.getDragTarget) is added as a member of this layout at the location shown by the dropLine (calculated by Layout.getDropPosition). This default behavior allows either members or external components that have Canvas.canDragReposition (or Canvas.canDrag) and Canvas.canDrop set to true to be added to or reordered within the Layout. You can control the thickness of the dropLine via Layout.dropLineThickness and you can customize the style using css styling in the skin file (look for .layoutDropLine in skin_styles.css for your skin). If you want to dynamically create a component to be added to the Layout in response to a drop event you can do so as follows: isc.VLayout.create({ ...various layout properties... canDropComponents: true, drop : function () { // create the new component var newMember = isc.Canvas.create(); // add to the layout at the current drop position // (the dropLine will be showing here) this.addMember(newMember, this.getDropPosition()); // hide the dropLine that was automatically shown // by builtin SmartClient methods this.hideDropLine(); } }); If you want to completely suppress the builtin drag and drop logic, but still receive drag and drop events for your own custom implementation, set Canvas.canAcceptDrop to true and canDropComponents to false on your Layout.
		 * Flags: IRA, Group: dragdrop */
		canDropComponents?: boolean /* Boolean */; // Flags=IRA
		/** Specifies the default alignment for layout members on the breadth axis (horizontal axis for a VLayout, vertical axis for an HLayout). Can be overridden on a per-member basis by setting Canvas.layoutAlign. If unset, default member layout alignment will be "top" for a horizontal layout, and "left" for a vertical layout, or "right" if in Page.isRTL','RTL mode. When attempting to center components be sure that you have set a specific size on the component(s) involved. If components fill all available space in the layout, centering looks the same as not centering. Similarly, if a component has no visible boundary (like a border), it can appear similar to when it's not centered if the component is larger than you expect - use the Watch tab in the Developer Console to see the component's extents visually.
		 * Flags: IRW, Group: layoutMember */
		defaultLayoutAlign?: Alignment | VerticalAlignment /* Alignment or VerticalAlignment */; // Flags=IRW
		/** Policy for whether resize bars are shown on members by default. Note that this setting changes the effect of Canvas.showResizeBar for members of this layout.
		 * Flags: IRW */
		defaultResizeBars?: LayoutResizeBarPolicy; // Flags=IRW
		/** Thickness, in pixels of the dropLine shown during drag and drop when Layout.canDropComponents is set to true. See the discussion in Layout for more info.
		 * Flags: IRA, Group: dragdrop */
		dropLineThickness?: number; // Flags=IRA
		/** Default class used to construct the EditProxy for this component when the component is Canvas.setEditMode','first placed into edit mode.
		 * Flags: IR */
		editProxyConstructor?: string /* SCClassName */; // Flags=IR
		/** Whether the layout policy is continuously enforced as new members are added or removed and as members are resized. This setting implies that any member that resizes larger, or any added member, will take space from other members in order to allow the overall layout to stay the same size.
		 * Flags: IRWA, Group: layoutPolicy */
		enforcePolicy?: boolean /* Boolean */; // Flags=IRWA
		/** Sizing policy applied to members on horizontal axis
		 * Flags: IRWA, Group: layoutPolicy */
		hPolicy?: LayoutPolicy; // Flags=IRWA
		/** Space outside of all members, on the bottom side. Defaults to Layout.layoutMargin. Requires a manual call to setLayoutMargin() if changed on the fly.
		 * Flags: IRW, Group: layoutMargin */
		layoutBottomMargin?: number /* integer */; // Flags=IRW
		/** Space outside of all members, on the left-hand side. Defaults to Layout.layoutMargin. Requires a manual call to setLayoutMargin() if changed on the fly.
		 * Flags: IRW, Group: layoutMargin */
		layoutLeftMargin?: number /* integer */; // Flags=IRW
		/** Space outside of all members. This attribute, along with Layout.layoutLeftMargin and related properties does not have a true setter method. It may be assigned directly at runtime. After setting the property, Layout.setLayoutMargin may be called with no arguments to reflow the layout.
		 * Flags: IRW, Group: layoutMargin */
		layoutMargin?: number /* integer */; // Flags=IRW
		/** Space outside of all members, on the right-hand side. Defaults to Layout.layoutMargin. Requires a manual call to setLayoutMargin() if changed on the fly.
		 * Flags: IRW, Group: layoutMargin */
		layoutRightMargin?: number /* integer */; // Flags=IRW
		/** Space outside of all members, on the top side. Defaults to Layout.layoutMargin. Requires a manual call to setLayoutMargin() if changed on the fly.
		 * Flags: IRW, Group: layoutMargin */
		layoutTopMargin?: number /* integer */; // Flags=IRW
		/** Whether to leave a gap for a vertical scrollbar even when one is not actually present. This setting avoids the layout resizing all members when the vertical scrollbar is introduced or removed, which can avoid unnecessary screen shifting and improve performance.
		 * Flags: IR */
		leaveScrollbarGap?: boolean /* Boolean */; // Flags=IR
		/** Part of the automatedTesting system, strategy to use when generated locators for members from within this Layout's members array.
		 * Flags: IRWA, Group: autoTest */
		locateMembersBy?: LocatorStrategy; // Flags=IRWA
		/** LocatorTypeStrategy to use when finding members within this layout.
		 * Flags: IRWA, Group: autoTest */
		locateMembersType?: LocatorTypeStrategy; // Flags=IRWA
		/** If set, a Layout with breadthPolicy:"fill" will specially interpret a percentage breadth on a member as a percentage of available space excluding the Layout.layoutMargin. If false, percentages work exactly as for a non-member, with layoutMargins, if any, ignored.
		 * Flags: IR */
		managePercentBreadth?: boolean /* Boolean */; // Flags=IR
		/** Number of pixels by which each member should overlap the preceding member, used for creating an "stack of cards" appearance for the members of a Layout. memberOverlap can be used in conjunction with Layout.stackZIndex to create a particular visual stacking order. Note that overlap of individual members can be accomplished with a negative setting for Canvas.extraSpace.
		 * Flags: IR, Group: layoutMember */
		memberOverlap?: number /* positiveInteger */; // Flags=IR
		/** An array of canvases that will be contained within this layout. You can set the following properties on these canvases (in addition to the standard component properties): Canvas.layoutAlign','layoutAlign -- specifies the member's alignment along the breadth axis; valid values are "top", "center" and "bottom" for a horizontal layout and "left", "center" and "right" for a vertical layout (see Layout.defaultLayoutAlign for default implementation.) Canvas.showResizeBar','showResizeBar -- set to true to show a resize bar (default is false) Height and width settings found on members are interpreted by the Layout according to the Layout.vPolicy','layout policy. Note that it is valid to have null slots in the provided members Array, and the Layout will ignore those slots. This can be useful to keep code compact, for example, when constructing the members Array, you might use an expression that either returns a component or null depending on whether the component should be present. If the expression returns null, the null slot will be ignored by the Layout.
		 * Flags: IRW */
		members?: Array<Canvas | string>; // Flags=IRW
		/** Space between each member of the layout. Requires a manual call to reflow() if changed on the fly.
		 * Flags: IRW, Group: layoutMargin */
		membersMargin?: number /* int */; // Flags=IRW
		/** Set this property to cause the layout to assign the breadths of other members as if the available breadth is actually wide enough to accommodate the minBreadthMember (even though the Layout might not actually be that wide, and may overflow its assigned size along the breadth axis due to the breadth of the minBreadthMember. Without this property set, members of a layout aren't ever expanded in breadth (by the layout) to fit an overflow of the layout along the breadth axis. Setting this property will make sure all members (other than the one specified) get expanded to fill the full visual breadth of the layout (assuming they are configured to use 100% layout breadth).
		 * Flags: IRWA */
		minBreadthMember?: string | number | Canvas /* String | int | Canvas */; // Flags=IRWA
		/** Minimum size, in pixels, below which flexible-sized members should never be shrunk, even if this requires the Layout to overflow. Note that this property only applies along the length axis of the Layout, and has no affect on breadth. Does not apply to members given a fixed size in pixels - such members will never be shrunk below their specified size in general.
		 * Flags: IRW, Group: layoutPolicy */
		minMemberLength?: number /* int */; // Flags=IRW
		/** A Layout may overflow if it has one or more members with a fixed width or height, or that themselves overflow. For details on member sizing see LayoutPolicy. Note that for overflow: "auto", "scroll", or "visible", members exceeding the Layout's specified breadth will lose any alignment set via Layout.defaultLayoutAlign or Canvas.layoutAlign.
		 * Flags: IRW, Group: layoutPolicy */
		overflow?: Overflow; // Flags=IRW
		/** If this widget has padding specified (as Canvas.padding','this.padding or in the CSS style applied to this layout), should it show up as space outside the members, similar to layoutMargin? If this setting is false, padding will not affect member positioning (as CSS padding normally does not affect absolutely positioned children). Leaving this setting true allows a designer to more effectively control layout purely from CSS. Note that Layout.layoutMargin if specified, takes precedence over this value.
		 * Flags: IRWA, Group: layoutMargin */
		paddingAsLayoutMargin?: boolean /* Boolean */; // Flags=IRWA
		/** If Layout.showDragPlaceHolder','this.showDragPlaceHolder is true, this defaults object determines the default appearance of the placeholder displayed when the user drags a widget out of this layout. Default value for this property sets the placeholder Canvas.styleName','styleName to "layoutPlaceHolder" To modify this object, use Class.changeDefaults
		 * Flags: IR, Group: dragdrop */
		placeHolderDefaults?: CanvasProps /* Canvas Properties */; // Flags=IR
		/** If Layout.showDragPlaceHolder','this.showDragPlaceHolder is true, this properties object can be used to customize the appearance of the placeholder displayed when the user drags a widget out of this layout.
		 * Flags: IR, Group: dragdrop */
		placeHolderProperties?: CanvasProps /* canvas properties */; // Flags=IR
		/** Default class to use for creating Layout.resizeBar','resizeBars. This may be overridden by resizeBarConstructor. Classes that are valid by default are Splitbar, ImgSplitbar, and Snapbar.
		 * Flags: AIRW */
		resizeBarClass?: string /* String */; // Flags=AIRW
		/** Thickness of the resizeBar in pixels.
		 * Flags: AIRW */
		resizeBarSize?: number /* int */; // Flags=AIRW
		/** Reverse the order of stacking for this Layout, so that the last member is shown first. Requires a manual call to reflow() if changed on the fly. In RTL mode, for horizontal Layouts the value of this flag will be flipped during initialization.
		 * Flags: IRW, Group: layoutPolicy */
		reverseOrder?: boolean /* Boolean */; // Flags=IRW
		/** If set to true, when a member is dragged out of layout, a visible placeholder canvas will be displayed in place of the dragged widget for the duration of the drag and drop interaction.
		 * Flags: IRW, Group: dragdrop */
		showDragPlaceHolder?: boolean; // Flags=IRW
		/** Controls whether to show a drop-indicator during a drag and drop operation. Set to false if you either don't want to show drop-lines, or plan to create your own.
		 * Flags: IRW, Group: dragdrop */
		showDropLines?: boolean; // Flags=IRW
		/** For use in conjunction with Layout.memberOverlap, controls the z-stacking order of members. If set to "lastOnTop", members stack from the first member at bottom to the last member at top. If set to "firstOnTop", members stack from the last member at bottom to the first member at top.
		 * Flags: IR */
		stackZIndex?: string; // Flags=IR
		/** Should this layout appear with members stacked vertically or horizontally. Defaults to false if unspecified.
		 * Flags: IRW, Group: layoutPolicy */
		vertical?: boolean; // Flags=IRW
		/** Sizing policy applied to members on vertical axis
		 * Flags: IRWA, Group: layoutPolicy */
		vPolicy?: LayoutPolicy; // Flags=IRWA

		/* Method Overrides */

		/** 
		 * Add a canvas to the layout, optionally at a specific position. Depending on the layout policy, adding a new member may cause existing members to resize. When adding a member to a drawn Layout, the layout will not immediately reflow, that is, the member will not immediately draw and existing members will not immediately resize. This is to allow multiple new members to be added and multiple manual resizes to take place without requiring layout members to redraw and resize multiple times. To force an immediate reflow in order to, for example, find out what size a newly added member has been assigned, call Layout.reflowNow.
		 * @param {Canvas} newMember - the canvas object to be added to the layout
		 * @param {number} position - the position in the layout to place newMember (starts with 0); if omitted, it will be added at the last position
		 */
		addMember?(newMember:Canvas, position?:number /* Integer */): void; 

	} // LayoutProps


	/**
	 * Arranges a set of "member" Canvases in horizontal or vertical stacks, applying a layout policy to determine member heights and widths. A Layout manages a set of "member" Canvases provided as Layout.members. Layouts can have both "members", whose position and size are managed by the Layout, and normal Canvas children, which manage their own position and size. Rather than using the Layout class directly, use the HLayout, VLayout, HStack and VStack classes, which are subclasses of Layout preconfigured for horizontal or vertical stacking, with the "fill" (VLayout) or "none" (VStack) LayoutPolicy','policies already set. Layouts and Stacks may be nested to create arbitrarily complex layouts. Since Layouts can be either horizontally or vertically oriented, throughout the documentation of Layout and it's subclasses, the term "length" refers to the axis of stacking, and the term "breadth" refers to the other axis. Hence, "length" means height in the context of a VLayout or VStack, but means width in the context of an HLayout or HStack. To show a resizer bar after (to the right or bottom of) a layout member, set Canvas.showResizeBar','showResizeBar to true on that member component (not on the HLayout or VLayout). Resizer bars override Layout.membersMargin','membersMargin spacing. Like other Canvas subclasses, Layout and Stack components may have % width and height values. To create a dynamically-resizing layout that occupies the entire page (or entire parent component), set width and height to "100%". 
	 */
	export interface Layout extends Canvas {
		/** Alignment of all members in this Layout on the length axis (vertical for a VLayout, horizontal for an HLayout). Defaults to "top" for vertical Layouts, and "left" for horizontal Layouts. Horizontal layouts should only be set to Alignment, and vertical layouts to VerticalAlignment, otherwise they will be considered invalid values, and assigning an invalid value here will log a warning to the Developer Console. For alignment on the breadth axis, see Layout.defaultLayoutAlign and Canvas.layoutAlign. When attempting to center components be sure that you have set a specific size on the component(s) involved. If components fill all available space in the layout, centering looks the same as not centering. Similarly, if a component has no visible boundary (like a border), it can appear similar to when it's not centered if the component is larger than you expect - use the Watch tab in the Developer Console to see the component's extents visually.
		 * Flags: IRW, Group: layoutPolicy */
		align: Alignment | VerticalAlignment /* Alignment or VerticalAlignment */;

		/** If true when members are added / removed, they should be animated as they are shown or hidden in position
		 * Flags: IRW, Group: animation */
		animateMembers: boolean;

		/** If specified this is the duration of show/hide animations when members are being shown or hidden due to being added / removed from this layout.
		 * Flags: IRWA, Group: animation */
		animateMemberTime: number;

		/** Layouts provide a default implementation of a drag and drop interaction. If you set Canvas.canAcceptDrop','canAcceptDrop:true and canDropComponents:true on a Layout, when a droppable Canvas (Canvas.canDrop','canDrop:true is dragged over the layout, it will show a dropLine (a simple insertion line) at the drop location. When the drop occurs, the dragTarget (obtained using EventHandler.getDragTarget) is added as a member of this layout at the location shown by the dropLine (calculated by Layout.getDropPosition). This default behavior allows either members or external components that have Canvas.canDragReposition (or Canvas.canDrag) and Canvas.canDrop set to true to be added to or reordered within the Layout. You can control the thickness of the dropLine via Layout.dropLineThickness and you can customize the style using css styling in the skin file (look for .layoutDropLine in skin_styles.css for your skin). If you want to dynamically create a component to be added to the Layout in response to a drop event you can do so as follows: isc.VLayout.create({ ...various layout properties... canDropComponents: true, drop : function () { // create the new component var newMember = isc.Canvas.create(); // add to the layout at the current drop position // (the dropLine will be showing here) this.addMember(newMember, this.getDropPosition()); // hide the dropLine that was automatically shown // by builtin SmartClient methods this.hideDropLine(); } }); If you want to completely suppress the builtin drag and drop logic, but still receive drag and drop events for your own custom implementation, set Canvas.canAcceptDrop to true and canDropComponents to false on your Layout.
		 * Flags: IRA, Group: dragdrop */
		canDropComponents: boolean /* Boolean */;

		/** Specifies the default alignment for layout members on the breadth axis (horizontal axis for a VLayout, vertical axis for an HLayout). Can be overridden on a per-member basis by setting Canvas.layoutAlign. If unset, default member layout alignment will be "top" for a horizontal layout, and "left" for a vertical layout, or "right" if in Page.isRTL','RTL mode. When attempting to center components be sure that you have set a specific size on the component(s) involved. If components fill all available space in the layout, centering looks the same as not centering. Similarly, if a component has no visible boundary (like a border), it can appear similar to when it's not centered if the component is larger than you expect - use the Watch tab in the Developer Console to see the component's extents visually.
		 * Flags: IRW, Group: layoutMember */
		defaultLayoutAlign: Alignment | VerticalAlignment /* Alignment or VerticalAlignment */;

		/** Policy for whether resize bars are shown on members by default. Note that this setting changes the effect of Canvas.showResizeBar for members of this layout.
		 * Flags: IRW */
		defaultResizeBars: LayoutResizeBarPolicy;

		/** Line showed to mark the drop position when components are being dragged onto this Layout. A simple Canvas typically styled via CSS. The default dropLine.styleName is "layoutDropLine".
		 * Flags: R */
		dropLine:  Canvas /* AutoChild Canvas */;

		/** Thickness, in pixels of the dropLine shown during drag and drop when Layout.canDropComponents is set to true. See the discussion in Layout for more info.
		 * Flags: IRA, Group: dragdrop */
		dropLineThickness: number;

		/** Default class used to construct the EditProxy for this component when the component is Canvas.setEditMode','first placed into edit mode.
		 * Flags: IR */
		editProxyConstructor: string /* SCClassName */;

		/** Whether the layout policy is continuously enforced as new members are added or removed and as members are resized. This setting implies that any member that resizes larger, or any added member, will take space from other members in order to allow the overall layout to stay the same size.
		 * Flags: IRWA, Group: layoutPolicy */
		enforcePolicy: boolean /* Boolean */;

		/** Sizing policy applied to members on horizontal axis
		 * Flags: IRWA, Group: layoutPolicy */
		hPolicy: LayoutPolicy;

		/** Space outside of all members, on the bottom side. Defaults to Layout.layoutMargin. Requires a manual call to setLayoutMargin() if changed on the fly.
		 * Flags: IRW, Group: layoutMargin */
		layoutBottomMargin: number /* integer */;

		/** Space outside of all members, on the left-hand side. Defaults to Layout.layoutMargin. Requires a manual call to setLayoutMargin() if changed on the fly.
		 * Flags: IRW, Group: layoutMargin */
		layoutLeftMargin: number /* integer */;

		/** Space outside of all members. This attribute, along with Layout.layoutLeftMargin and related properties does not have a true setter method. It may be assigned directly at runtime. After setting the property, Layout.setLayoutMargin may be called with no arguments to reflow the layout.
		 * Flags: IRW, Group: layoutMargin */
		layoutMargin: number /* integer */;

		/** Space outside of all members, on the right-hand side. Defaults to Layout.layoutMargin. Requires a manual call to setLayoutMargin() if changed on the fly.
		 * Flags: IRW, Group: layoutMargin */
		layoutRightMargin: number /* integer */;

		/** Space outside of all members, on the top side. Defaults to Layout.layoutMargin. Requires a manual call to setLayoutMargin() if changed on the fly.
		 * Flags: IRW, Group: layoutMargin */
		layoutTopMargin: number /* integer */;

		/** Whether to leave a gap for a vertical scrollbar even when one is not actually present. This setting avoids the layout resizing all members when the vertical scrollbar is introduced or removed, which can avoid unnecessary screen shifting and improve performance.
		 * Flags: IR */
		leaveScrollbarGap: boolean /* Boolean */;

		/** Part of the automatedTesting system, strategy to use when generated locators for members from within this Layout's members array.
		 * Flags: IRWA, Group: autoTest */
		locateMembersBy: LocatorStrategy;

		/** LocatorTypeStrategy to use when finding members within this layout.
		 * Flags: IRWA, Group: autoTest */
		locateMembersType: LocatorTypeStrategy;

		/** If set, a Layout with breadthPolicy:"fill" will specially interpret a percentage breadth on a member as a percentage of available space excluding the Layout.layoutMargin. If false, percentages work exactly as for a non-member, with layoutMargins, if any, ignored.
		 * Flags: IR */
		managePercentBreadth: boolean /* Boolean */;

		/** Number of pixels by which each member should overlap the preceding member, used for creating an "stack of cards" appearance for the members of a Layout. memberOverlap can be used in conjunction with Layout.stackZIndex to create a particular visual stacking order. Note that overlap of individual members can be accomplished with a negative setting for Canvas.extraSpace.
		 * Flags: IR, Group: layoutMember */
		memberOverlap: number /* positiveInteger */;

		/** An array of canvases that will be contained within this layout. You can set the following properties on these canvases (in addition to the standard component properties): Canvas.layoutAlign','layoutAlign -- specifies the member's alignment along the breadth axis; valid values are "top", "center" and "bottom" for a horizontal layout and "left", "center" and "right" for a vertical layout (see Layout.defaultLayoutAlign for default implementation.) Canvas.showResizeBar','showResizeBar -- set to true to show a resize bar (default is false) Height and width settings found on members are interpreted by the Layout according to the Layout.vPolicy','layout policy. Note that it is valid to have null slots in the provided members Array, and the Layout will ignore those slots. This can be useful to keep code compact, for example, when constructing the members Array, you might use an expression that either returns a component or null depending on whether the component should be present. If the expression returns null, the null slot will be ignored by the Layout.
		 * Flags: IRW */
		members: Array<Canvas | string>;

		/** Space between each member of the layout. Requires a manual call to reflow() if changed on the fly.
		 * Flags: IRW, Group: layoutMargin */
		membersMargin: number /* int */;

		/** Set this property to cause the layout to assign the breadths of other members as if the available breadth is actually wide enough to accommodate the minBreadthMember (even though the Layout might not actually be that wide, and may overflow its assigned size along the breadth axis due to the breadth of the minBreadthMember. Without this property set, members of a layout aren't ever expanded in breadth (by the layout) to fit an overflow of the layout along the breadth axis. Setting this property will make sure all members (other than the one specified) get expanded to fill the full visual breadth of the layout (assuming they are configured to use 100% layout breadth).
		 * Flags: IRWA */
		minBreadthMember: string | number | Canvas /* String | int | Canvas */;

		/** Minimum size, in pixels, below which flexible-sized members should never be shrunk, even if this requires the Layout to overflow. Note that this property only applies along the length axis of the Layout, and has no affect on breadth. Does not apply to members given a fixed size in pixels - such members will never be shrunk below their specified size in general.
		 * Flags: IRW, Group: layoutPolicy */
		minMemberLength: number /* int */;

		/** A Layout may overflow if it has one or more members with a fixed width or height, or that themselves overflow. For details on member sizing see LayoutPolicy. Note that for overflow: "auto", "scroll", or "visible", members exceeding the Layout's specified breadth will lose any alignment set via Layout.defaultLayoutAlign or Canvas.layoutAlign.
		 * Flags: IRW, Group: layoutPolicy */
		overflow: Overflow;

		/** If this widget has padding specified (as Canvas.padding','this.padding or in the CSS style applied to this layout), should it show up as space outside the members, similar to layoutMargin? If this setting is false, padding will not affect member positioning (as CSS padding normally does not affect absolutely positioned children). Leaving this setting true allows a designer to more effectively control layout purely from CSS. Note that Layout.layoutMargin if specified, takes precedence over this value.
		 * Flags: IRWA, Group: layoutMargin */
		paddingAsLayoutMargin: boolean /* Boolean */;

		/** If Layout.showDragPlaceHolder','this.showDragPlaceHolder is true, this defaults object determines the default appearance of the placeholder displayed when the user drags a widget out of this layout. Default value for this property sets the placeholder Canvas.styleName','styleName to "layoutPlaceHolder" To modify this object, use Class.changeDefaults
		 * Flags: IR, Group: dragdrop */
		placeHolderDefaults: CanvasProps /* Canvas Properties */;

		/** If Layout.showDragPlaceHolder','this.showDragPlaceHolder is true, this properties object can be used to customize the appearance of the placeholder displayed when the user drags a widget out of this layout.
		 * Flags: IR, Group: dragdrop */
		placeHolderProperties: CanvasProps /* canvas properties */;

		/** A MultiAutoChild created to resize members of this Layout. A resize bar will be created for any member of this Layout that has Canvas.showResizeBar','showResizeBar set to true. Resize bars will be instances of the class specified by Layout.resizeBarClass by default, and will automatically be sized to the member's breadth, and to the thickness specified by Layout.resizeBarSize. To customize the appearance or behavior of resizeBars within some layout a custom resize bar class can be created by subclassing Splitbar or ImgSplitbar and setting Layout.resizeBarClass or resizeBarConstructor to this custom class. Alternatively, resizeBarProperties may be specified. See autoChildUsage for more information. The built-in Splitbar class supports drag resizing of its target member, and clicking on the bar with a mouse to collapse/uncollapse the target member.
		 * Flags: A */
		resizeBar:  Splitbar /* MultiAutoChild Splitbar */;

		/** Default class to use for creating Layout.resizeBar','resizeBars. This may be overridden by resizeBarConstructor. Classes that are valid by default are Splitbar, ImgSplitbar, and Snapbar.
		 * Flags: AIRW */
		resizeBarClass: string /* String */;

		/** Thickness of the resizeBar in pixels.
		 * Flags: AIRW */
		resizeBarSize: number /* int */;

		/** Reverse the order of stacking for this Layout, so that the last member is shown first. Requires a manual call to reflow() if changed on the fly. In RTL mode, for horizontal Layouts the value of this flag will be flipped during initialization.
		 * Flags: IRW, Group: layoutPolicy */
		reverseOrder: boolean /* Boolean */;

		/** If set to true, when a member is dragged out of layout, a visible placeholder canvas will be displayed in place of the dragged widget for the duration of the drag and drop interaction.
		 * Flags: IRW, Group: dragdrop */
		showDragPlaceHolder: boolean;

		/** Controls whether to show a drop-indicator during a drag and drop operation. Set to false if you either don't want to show drop-lines, or plan to create your own.
		 * Flags: IRW, Group: dragdrop */
		showDropLines: boolean;

		/** For use in conjunction with Layout.memberOverlap, controls the z-stacking order of members. If set to "lastOnTop", members stack from the first member at bottom to the last member at top. If set to "firstOnTop", members stack from the last member at bottom to the first member at top.
		 * Flags: IR */
		stackZIndex: string;

		/** Should this layout appear with members stacked vertically or horizontally. Defaults to false if unspecified.
		 * Flags: IRW, Group: layoutPolicy */
		vertical: boolean;

		/** Sizing policy applied to members on vertical axis
		 * Flags: IRWA, Group: layoutPolicy */
		vPolicy: LayoutPolicy;


		/* Instance Method Overrides */

		/** 
		 * Add a canvas to the layout, optionally at a specific position. Depending on the layout policy, adding a new member may cause existing members to resize. When adding a member to a drawn Layout, the layout will not immediately reflow, that is, the member will not immediately draw and existing members will not immediately resize. This is to allow multiple new members to be added and multiple manual resizes to take place without requiring layout members to redraw and resize multiple times. To force an immediate reflow in order to, for example, find out what size a newly added member has been assigned, call Layout.reflowNow.
		 * @param {Canvas} newMember - the canvas object to be added to the layout
		 * @param {number} position - the position in the layout to place newMember (starts with 0); if omitted, it will be added at the last position
		 */
		addMember?(newMember:Canvas, position?:number /* Integer */): void; 

	} // Layout

	export interface LayoutStatic<T, P> extends CanvasStatic<T, P> {
	} // LayoutStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a LayoutSpacer Props argument.
	 * This is derived from the methods in the LayoutSpacer class and it's parents and their properties marked with the I flag.
	 */
	export interface LayoutSpacerProps extends CanvasProps {
	} // LayoutSpacerProps


	/**
	 * Add a spacer to a Layout that takes up space just like a normal member, without actually drawing anything. A LayoutSpacer is semantically equivalent to using an empty canvas, but higher performance for this particular use case. 
	 */
	export interface LayoutSpacer extends Canvas {
	} // LayoutSpacer

	export interface LayoutSpacerStatic<T, P> extends CanvasStatic<T, P> {
	} // LayoutSpacerStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a ListGrid Props argument.
	 * This is derived from the methods in the ListGrid class and it's parents and their properties marked with the I flag.
	 */
	export interface ListGridProps extends VLayoutProps {
		/** When ListGrid.useAdvancedFieldPicker is set, total number of available fields that must be present in the grid before the advanced field picker interface is used instead of the normal columns submenu. Set to 0 to have the advanced picker always used (when useAdvancedFieldPicker is true).
		 * Flags: IR */
		advancedFieldPickerThreshold?: number /* int */; // Flags=IR
		/** For use with ListGrid.showFilterEditor:true, allows simple search expressions to be entered into filter fields, as though DynamicForm.allowExpressions were true. Can also be enabled or disabled on a field-by-field basis via ListGridField.filterEditorProperties.
		 * Flags: IR, Group: advancedFilter */
		allowFilterExpressions?: boolean; // Flags=IR
		/** Causes a menu item titled ListGrid.filterUsingText','"Filter using" to appear in the ListGrid.showHeaderContextMenu','headerContextMenu that allows the end user to pick an advanced OperatorId','search operator to use for this field. Once an operator has been chosen, the active operator is indicated by an ListGrid.operatorIcon placed within the field (you can alternatively cause the icon to ListGrid.alwaysShowOperatorIcon','always be present). The operatorIcon shows the same textual representation of the search operator as is used by the FormItem.allowExpressions feature. Clicking on the icon provides a second way to modify the search operator. This feature is enabled by default if DataSource.supportsAdvancedCriteria is true, for all fields where it is normally possible to filter by typing in a search string. This excludes field types such as "date" or "boolean" which show specialized filter controls. Use ListGridField.allowFilterOperators to disable this interface for individual fields, or set DataSourceField.canFilter to false to disallow filtering entirely for a field. Note that this feature is similar to ListGrid.allowFilterExpressions, which allows the end users to directly type in characters such as "&gt;" to control filtering. allowFilterOperators is easier to use and more discoverable than allowFilterExpressions, and also avoids the drawback where special characters like "&gt;" cannot be used in filter values. However, allowFilterExpressions allows users to make use of certain operators that allowFilterOperators does not support, such as using the "betweenInclusive" operator by typing "5...10". When both allowfilterExpressions and allowFilterOperators are set, filter expressions entered in to the edit-area are parsed and the operator automatically applied to the ListGrid.operatorIcon.
		 * Flags: IR */
		allowFilterOperators?: boolean /* Boolean */; // Flags=IR
		/** Should cells in this grid be allowed to span multiple rows? If set to true, the ListGrid.getRowSpan method will be called for every cell when rendering out the listGrid to determine how many rows the cell should span. See ListGrid.getRowSpan for more details
		 * Flags: IR */
		allowRowSpanning?: boolean /* Boolean */; // Flags=IR
		/** Optional css style to apply to the body if ListGrid.alternateRecordStyles is true for this grid. If unset ListGrid.bodyStyleName will be used to style the body regardless of the ListGrid.alternateRecordStyles','alternateRecordStyles setting.
		 * Flags: IRWA */
		alternateBodyStyleName?: string /* CSSStyleName */; // Flags=IRWA
		/** The number of consecutive columns to draw in the same style before alternating, when GridRenderer.alternateColumnStyles','alternateColumnStyles is true.
		 * Flags: IRW, Group: cellStyling */
		alternateFieldFrequency?: number; // Flags=IRW
		/** Whether alternating columns (or blocks of columns, depending on GridRenderer.alternateColumnFrequency) should be drawn in alternating styles, in order to create a vertical "ledger" effect for easier reading. If enabled, the cell style for alternate rows will have the ${isc.DocUtils.linkForRef('alternateColumnSuffix')} appended to it. See also ${isc.DocUtils.linkForRef('alternateRowStyles')}.
		 * Flags: IRW, Group: cellStyling */
		alternateFieldStyles?: boolean; // Flags=IRW
		/** The number of consecutive rows to draw in the same style before alternating, when GridRenderer.alternateRowStyles','alternateRowStyles is true.
		 * Flags: IRW, Group: cellStyling */
		alternateRecordFrequency?: number; // Flags=IRW
		/** Whether alternating rows (or blocks of rows, depending on GridRenderer.alternateRowFrequency) should be drawn in alternating styles, in order to create a "ledger" effect for easier reading. If enabled, the cell style for alternate rows will have the ${isc.DocUtils.linkForRef('alternateRowSuffix')} appended to it. See also ${isc.DocUtils.linkForRef('alternateColumnStyles')}.
		 * Flags: IRW, Group: cellStyling */
		alternateRecordStyles?: boolean /* Boolean */; // Flags=IRW
		/** Suffix to append to GridRenderer.alternateRowStyles','alternate rows. Note that if GridRenderer.alternateColumnStyles is enabled, cells which fall into both an alternate row and column will have both suffixes appended - for example "cellDarkAltCol".
		 * Flags: IRW, Group: cellStyling */
		alternateRecordSuffix?: string /* String */; // Flags=IRW
		/** When this attribute is set, editors will be rendered into every row of the grid rather than showing up in a single record at a time. This attribute is only valid when ListGrid.editByCell is false
		 * Flags: IR, Group: editing */
		alwaysShowEditors?: boolean; // Flags=IR
		/** When ListGrid.allowFilterOperators is enabled, whether to show the ListGrid.operatorIcon for all filterable fields, or only for fields where the user has explicitly chosen a search operator different from the default operator for the field. The default operator for a field is determined by ListGrid.autoFetchTextMatchStyle or by setting ListGridField.filterOperator for a specific field.
		 * Flags: IR */
		alwaysShowOperatorIcon?: boolean /* Boolean */; // Flags=IR
		/** When animating folder opening / closing, this property can be set to apply an animated acceleration effect. This allows the animation speed to be "weighted", for example expanding or collapsing at a faster rate toward the beginning of the animation than at the end. For a ListGrid, this property applies when ListGrid.canGroupBy','grouping is enabled.
		 * Flags: IRW, Group: animation */
		animateFolderEffect?: AnimationAcceleration; // Flags=IRW
		/** If ListGrid.animateFolders is true for this grid, this number can be set to designate the maximum number of rows to animate at a time when opening / closing a folder. For a ListGrid, this property applies when ListGrid.canGroupBy','grouping is enabled.
		 * Flags: IRW, Group: animation */
		animateFolderMaxRows?: number /* integer */; // Flags=IRW
		/** If true, when folders are opened / closed children will be animated into view. For a ListGrid, this property applies when ListGrid.canGroupBy','grouping is enabled.
		 * Flags: IRW, Group: animation */
		animateFolders?: boolean /* Boolean */; // Flags=IRW
		/** When animating folder opening / closing, this property designates the speed of the animation in pixels shown (or hidden) per second. Takes precedence over the TreeGrid.animateFolderTime property, which allows the developer to specify a duration for the animation rather than a speed. For a ListGrid, this property applies when ListGrid.canGroupBy','grouping is enabled.
		 * Flags: IRW, Group: animation */
		animateFolderSpeed?: number; // Flags=IRW
		/** When animating folder opening / closing, if TreeGrid.animateFolderSpeed is not set, this property designates the duration of the animation in ms. For a ListGrid, this property applies when ListGrid.canGroupBy','grouping is enabled.
		 * Flags: IRW, Group: animation */
		animateFolderTime?: number; // Flags=IRW
		/** When ListGrid.canRemoveRecords is enabled, should records be animated out of view when they are removed by the user?
		 * Flags: IRW */
		animateRemoveRecord?: boolean /* Boolean */; // Flags=IRW
		/** When ListGrid.animateRemoveRecord','animating record removal, this property designates the speed of the animation in pixels per second. Takes precedence over the ListGrid.animateRemoveTime property, which allows the developer to specify a duration for the animation rather than a speed.
		 * Flags: IRW, Group: animation */
		animateRemoveSpeed?: number; // Flags=IRW
		/** When animating record removal ListGrid.animateRemoveRecord','(see animateRemoveRecord), if ListGrid.animateRemoveSpeed is not set, this property designates the duration of the animation in ms.
		 * Flags: IRW, Group: animation */
		animateRemoveTime?: number; // Flags=IRW
		/** If the ListGrid.rollOverCanvas','rollOverCanvas is enabled, setting this property to true ensures that when the rollOverCanvas is displayed it is animated into view via Canvas.animateShow. Note that the animation effect may be customized via Canvas.animateShowEffect, Canvas.animateShowTime and Canvas.animateShowAcceleration set in rollOverCanvasProperties.
		 * Flags: IRWA, Group: rowEffects */
		animateRollOver?: boolean /* Boolean */; // Flags=IRWA
		/** If the ListGrid.rollUnderCanvas','rollUnderCanvas is enabled, setting this property to true ensures that when the rollUnderCanvas is displayed it is animated into view via Canvas.animateShow. Note that the animation effect may be customized via Canvas.animateShowEffect, Canvas.animateShowTime and Canvas.animateShowAcceleration set in rollUnderCanvasProperties.
		 * Flags: IRWA, Group: rowEffects */
		animateRollUnder?: boolean /* Boolean */; // Flags=IRWA
		/** If the ListGrid.selectionCanvas','selectionCanvas is enabled, setting this property to true ensures that when the selectionCanvas is displayed it is animated into view via Canvas.animateShow. Note that the animation effect may be customized via Canvas.animateShowEffect, Canvas.animateShowTime and Canvas.animateShowAcceleration set in selectionCanvasProperties.
		 * Flags: IRWA, Group: rowEffects */
		animateSelection?: boolean /* Boolean */; // Flags=IRWA
		/** If the ListGrid.selectionUnderCanvas','selectionUnderCanvas is enabled, setting this property to true ensures that when the selectionUnderCanvas is displayed it is animated into view via Canvas.animateShow. Note that the animation effect may be customized via Canvas.animateShowEffect, Canvas.animateShowTime and Canvas.animateShowAcceleration set in selectionUnderCanvasProperties.
		 * Flags: IRWA, Group: rowEffects */
		animateSelectionUnder?: boolean /* Boolean */; // Flags=IRWA
		/** If ListGridField.userFormula is set for some field, and this grid is showing ListGrid.showGroupSummary','group summaries or a ListGrid.showGridSummary','grid summary, this property determines what field value should be present in those summary rows. Should the field apply the user-formula to the calculated summary row, or should it apply a standard grid or group summary to the user-formula values displayed in the grid? May be overridden at the field level via ListGridField.applyAfterSummary
		 * Flags: IRW */
		applyFormulaAfterSummary?: boolean /* Boolean */; // Flags=IRW
		/** If ListGrid.showRowNumbers is true, should we apply the ListGrid.rowNumberStyle to the ListGrid.rowNumberField
		 * Flags: IRWA, Group: rowNumberField */
		applyRowNumberStyle?: boolean; // Flags=IRWA
		/** Action to perform when the listGrid has keyboard focus (but not editing focus) and a user presses the up or down arrow key. Possible values are: "select" : select the next row in the list (calls recordClick handler) "focus" : move focus to the next row in the list without changing the selection "activate" : select and activate the next row in the list (calls recordDoubleClick handler) "none" : no action null : if ListGrid.selectionAppearance is "checkbox", behaves as if set to "focus"; otherwise, behaves as if set to "select" 
		 * Flags: IRWA, Group: events */
		arrowKeyAction?: string; // Flags=IRWA
		/** The prompt to display while interactivity is blocked during ListGrid.groupByAsyncThreshold','asynchronous grouping.
		 * Flags: IR, Group: i18nMessages */
		asynchGroupingPrompt?: string /* HTMLString */; // Flags=IR
		/** Whether to do inline autoComplete in text fields during inline editing Overridden by ListGridField.autoComplete if specified. If unset picks up the default from the appropriate editor class (subclass of FormItem).
		 * Flags: IRW, Group: autoComplete */
		autoComplete?: AutoComplete; // Flags=IRW
		/** For editable listGrids, outstanding unsaved edits when the user performs a new filter or sort will be discarded by default. This flag determines whether we should save such edits automatically in this case. See also ListGrid.confirmDiscardEdits, which allows the user to choose whether to save or discard the unsaved edits.
		 * Flags: IRW, Group: editing */
		autoConfirmSaveEdits?: boolean /* Boolean */; // Flags=IRW
		/** If true, when this component is first drawn, automatically call this.fetchData(). Criteria for this fetch may be picked up from ListGrid.initialCriteria, and textMatchStyle may be specified via ListGrid.autoFetchTextMatchStyle','autoFetchTextMatchStyle. <span style='color:red'>NOTE:</span> if autoFetchData is set, calling ListGrid.fetchData','fetchData() before draw will cause two requests to be issued, one from the manual call to fetchData() and one from the autoFetchData setting. The second request will use only ListGrid.initialCriteria and not any other criteria or settings from the first request. Generally, turn off autoFetchData if you are going to manually call ListGrid.fetchData','fetchData() at any time.
		 * Flags: IR, Group: databinding */
		autoFetchData?: boolean; // Flags=IR
		/** If true, for fields where ListGridField.optionDataSource is specified, a valueMap will be automatically created by making a DataSource.fetchData call against the specified dataSource and extracting a valueMap from the returned records based on the displayField and valueField. If set to false, valueMaps will not be automatically fetched. In this case, setting field.optionDataSource is effectively a shortcut for setting optionDataSource on the editor via ListGridField.editorProperties. Can also be disabled on a per-field basis with ListGridField.autoFetchDisplayMap.
		 * Flags: IRW, Group: display_values */
		autoFetchDisplayMap?: boolean /* Boolean */; // Flags=IRW
		/** When this grid is initially filtered via ListGrid.autoFetchData, or filtered by the user via the ListGrid.showFilterEditor','filterEditor, this attribute can be used to set the textMatchStyle on the dsRequest passed to fetchData(). To use a mixture of textMatchStyles, set an appropriate FormItem.operator','operator on a field's ListGridField.filterEditorProperties','filterEditorProperties.
		 * Flags: IR, Group: dataBinding */
		autoFetchTextMatchStyle?: TextMatchStyle; // Flags=IR
		/** If we're showing a ListGrid.showHeaderContextMenu','headerContextMenu for this grid, and ListGrid.canAutoFitFields is true, this attribute will be shown as the menu item title for an item to perform a one-time autoFit of all visible fields via the ListGrid.autoFitField method.
		 * Flags: IRW, Group: i18nMessages */
		autoFitAllText?: string; // Flags=IRW
		/** If ListGrid.autoFitFieldWidths is enabled and the calculated field sizes are wide enough that horizontal scrolling would be introduced, this attribute may be set to an array of fieldNames, causing those fields to be clipped rather than forcing horizontal scrollbars to appear. Note: If any ListGridField.frozen','frozen columns are included in this list they will not be clipped.
		 * Flags: IR, Group: autoFitFields */
		autoFitClipFields?: Array<string> /* Array of String */; // Flags=IR
		/** Should this ListGrid automatically expand to accommodate the size of records and fields? Valid settings are "vertical": expand vertically to accommodate records. "horizontal": expand horizontally to accommodate fields. "both": expand horizontally and vertically to accommodate content. How far the ListGrid will expand may be limited via the following properties: ListGrid.autoFitMaxHeight, ListGrid.autoFitMaxRecords, ListGrid.autoFitMaxWidth, ListGrid.autoFitMaxColumns. Note that this property causes the grid as a whole to expand to fit records or fields. To have the fields or records themselves expand to fit cell contents, see ListGrid.autoFitFieldWidths and ListGrid.fixedRecordHeights.
		 * Flags: IRW, Group: autoFitData */
		autoFitData?: Autofit; // Flags=IRW
		/** Should listGrids automatically size date fields to fit their values or titles? If set to "value", fields of type date will be rendered at the size specified by ListGrid.defaultDateFieldWidth, (or ListGrid.defaultEditableDateFieldWidth for editable fields). This static value is appropriate for dates rendered with the standard short-date formatter. If set to "title" or "both", the drawn width of the title will be taken into account when sizing the column. This is achieved by enabling ListGridField.autoFitWidth','autoFitWidth:true on date fields when this property is set to anything other than "none", setting the ListGridField.autoFitWidthApproach to the value specified here and having logic in ListGrid.getDefaultFieldWidth pick up the ListGrid.defaultDateFieldWidth or ListGrid.defaultEditableDateFieldWidth if appropriate.
		 * Flags: IRW, Group: autoFitFields */
		autoFitDateFields?: AutoFitWidthApproach; // Flags=IRW
		/** The field to expand if ListGrid.autoFitFieldWidths and ListGrid.autoFitFieldsFillViewport are enabled and auto-fitting will not fill all available horizontal space. If unset, will default to the text field with the longest DataSourceField.length if length is set, otherwise, the first text field with no width specified. Note that expanding ListGridField.frozen','frozen columns is not supported.
		 * Flags: IR, Group: autoFitFields */
		autoFitExpandField?: string /* String */; // Flags=IR
		/** If ListGrid.autoFitData is set to "vertical" or "both", setting this property will cause the ListGrid body to size large enough to accomodate the actual data and also leave this many extra rows' worth of blank space below the last record. If a maximum size is specified via ListGrid.autoFitMaxHeight or ListGrid.autoFitMaxRecords, it will still be respected. Once the data set is large enough to fill or exceed that space, this property no longer has an effect.
		 * Flags: IRW, Group: autoFitData */
		autoFitExtraRecords?: number; // Flags=IRW
		/** If ListGrid.autoFitFieldWidths is enabled, and extra space is available after autofitting all fields, should the grid automatically expand one field to fill the extra space. When enabled, the field to expand may be specified via ListGrid.autoFitExpandField. Note this logic will not expand a ListGridField.frozen','frozen column.
		 * Flags: IR, Group: autoFitFields */
		autoFitFieldsFillViewport?: boolean /* Boolean */; // Flags=IR
		/** If we're showing a ListGrid.showHeaderContextMenu','headerContextMenu for this grid, and user-driven auto fit of fields is enabled via ListGridField.canAutoFitWidth or ListGrid.canAutoFitFields, this attribute will be shown as the menu item title for an item to perform a one-time autoFit of the field to its title or content via a call to ListGrid.autoFitField.
		 * Flags: IRW, Group: i18nMessages */
		autoFitFieldText?: string; // Flags=IRW
		/** Should ListGrid fields autofit their widths to titles or content? This property may be overridden on a per-field basis via ListGridField.autoFitWidth. Developers may wish to consider disabling autoFit for fields known to have exceptionally long content as this can lead to large horizontal scrollbars and unwieldy UI. The ListGrid.autoFitWidthApproach controls whether fitting is to values, titles or both. This property may also be overridden on a per field basis. If ListGridField.width','field.width is also set on the field, it will be taken as a minimum width. ListGrid.minFieldWidth will also be respected. By default, the entire available width of the grid will still be used, by allocating any "extra" space to specific columns - see ListGrid.autoFitFieldsFillViewport for details on controlling this behavior. When this feature is enabled, autofitting is active on an ongoing basis. Autofitting will be performed: whenever the dataset is completely changed or rows are added or removed whenever a field which is autofitting is changed on a manual call to ListGrid.autoFitField or ListGrid.autoFitFields Auto-fitting behavior continues until the user resizes the field manually, at which point it stops. The user can also perform a one-time auto-fit of fields via the header context menu if ListGrid.canAutoFitFields is enabled. When autofitting to column values, ListGrid.getDefaultFieldWidth will be called to determine the space required for a field's values. This method uses values from the rendered set of rows to calculate the required column width, which means the field width may still be smaller than values from non-rendered rows. See ListGrid.showAllRecords and ListGrid.drawAheadRatio) to control incremental rendering of rows. Note that for icon type fields, the ListGrid.autoFitIconFields property setting may turn on auto-fit-width behavior for specific fields by default, even if autoFitFieldWidths is false for the grid as a whole. Using this feature has a performance penalty roughly comparable to always rendering one additional field per field where autofitting is enabled. Specifically, enabling it for all fields would be comparable to both doubling the number of fields and disabling ListGrid.showAllColumns','horizontal incremental rendering. In a grid where only half the fields are normally visible and hence only half are normally rendered, this would be roughly 4 times slower overall. This performance penalty is a result of ListGrid.getDefaultFieldWidth having to render out the data set offscreen and measure the rendered content - it does not apply for cases where this method can return a simple fixed values (as with icon fields). Which fields are currently autofitting is saved as part of the ListGrid.getViewState','view state of the ListGrid.
		 * Flags: IR, Group: autoFitFields */
		autoFitFieldWidths?: boolean /* Boolean */; // Flags=IR
		/** If this property is set to true, header buttons for either ListGrid.fields','fields or ListGrid.headerSpans','header spans will automatically expand to accommodate their titles vertically. This means if you have a "tall" title - typically a long string where ListGridField.wrap is set to true such that you end up with several lines of text - the button will render large enough to accommodate it. If necessary this will cause the header for the grid as a whole to expand beyond the specified ListGrid.headerHeight. Note that you need not set HeaderSpan.height or ListGrid.headerSpanHeight if you set this property, but if you do, they will be used as minimum values.
		 * Flags: IR */
		autoFitHeaderHeights?: boolean; // Flags=IR
		/** SmartClient listGrids have special logic to automatically size fields that are displayed as an icon - that is fields with ListGridFieldType','type:"icon", fields displaying only ListGridField.showValueIconOnly','value icons, and boolean fields (which are rendered as a checkmark type icon by default. This attribute controls this behavior - governing whether icon fields should be sized to fit their content (icon), title, or whether to disable this behavior. Setting this value to "title" or "iconWidth" will cause ListGridField.autoFitWidth to be enabled by default for all icon fields with the ListGridField.autoFitWidthApproach set to "value" or "both" as appropriate. Note that the width required for the icons is calculated by ListGrid.getDefaultFieldWidth which performs a simple calculation based on the specified icon width for these types of fields. This setting governs default behavior for icon fields - for specific fields within a grid, this default behavior can be overridden by setting an explicit ListGridField.width or explicitly enabling ListGridField.autoFitWidth and setting ListGridField.autoFitWidthApproach on the field in question.
		 * Flags: IRW, Group: autoFitFields */
		autoFitIconFields?: AutoFitIconFieldType; // Flags=IRW
		/** If ListGrid.autoFitData is set to "horizontal" or "both" this property provides the maximum number of columns for which the ListGrid will expand. If more columns are present, scrolling will be introduced to reach them as normal. If unset the ListGrid will expand to accommodate as many columns as are defined for the grid.
		 * Flags: IRW, Group: autoFitData */
		autoFitMaxColumns?: number; // Flags=IRW
		/** If ListGrid.autoFitData is set to "vertical" or "both" this property provides an upper limit on how far the ListGrid will expand vertically to accommodate its content. If content exceeds this height, scrollbars will be introduced as usual. In addition to this property, ListGrid.autoFitMaxRecords allows you to limit vertical expansion based on the number of rows to be rendered.
		 * Flags: IRW, Group: autoFitData */
		autoFitMaxHeight?: number; // Flags=IRW
		/** If ListGrid.autoFitData is set to "vertical" or "both" this property provides the maximum number of records for which the ListGrid will expand. If more records are present, scrolling will be introduced to reach them as normal. If unset, by default the ListGrid will expand to accommodate as many records as are present.
		 * Flags: IRW, Group: autoFitData */
		autoFitMaxRecords?: number; // Flags=IRW
		/** If ListGrid.autoFitData is set to "horizontal" or "both" this property provides an upper limit on how far the ListGrid will expand horizontally to accommodate its content. Value may be specified as a numeric pixel value or a percentage value. If content exceeds this width, scrollbars will be introduced as usual. In addition to this property, ListGrid.autoFitMaxColumns allows you to limit horizontal expansion based on the number of columns to be rendered.
		 * Flags: IRW, Group: autoFitData */
		autoFitMaxWidth?: number | string /* Integer | String */; // Flags=IRW
		/** Should listGrids automatically size time fields to fit their values or titles? If set to "value", fields of type time will be rendered at the size specified by ListGrid.defaultTimeFieldWidth. This static value is appropriate for dates rendered with the standard time formatter. If set to "title" or "both", the drawn width of the title will be taken into account when sizing the column. This is achieved by enabling ListGridField.autoFitWidth','autoFitWidth:true on date fields when this property is set to anything other than "none", setting the ListGridField.autoFitWidthApproach to the value specified here and having logic in ListGrid.getDefaultFieldWidth pick up the ListGrid.defaultTimeFieldWidth if appropriate.
		 * Flags: IRW, Group: autoFitFields */
		autoFitTimeFields?: AutoFitWidthApproach; // Flags=IRW
		/** When a user requests column autofitting via the ListGrid.getHeaderContextMenuItems','header context menu or via a ListGrid.headerAutoFitEvent','mouse gesture, what autofit approach is used.
		 * Flags: IRW, Group: autoFitFields */
		autoFitWidthApproach?: AutoFitWidthApproach; // Flags=IRW
		/** If this ListGrid is editable, should edits be saved out when the user finishes editing a row (or a cell if ListGrid.saveByCell is true). The default of true indicates that edits will be ListGrid.saveByCell','automatically saved as the user navigates through the grid and/or EnterKeyEditAction','hits \'Enter\' to end editing. See the editing','Grid Editing overview for details. Setting autoSaveEdits false creates a "mass update" / "mass delete" interaction where edits will be retained for all edited cells (across rows if appropriate) until ListGrid.saveEdits is called to save a particular row, or ListGrid.saveAllEdits is called to save all changes in a batch. Note: when ListGrid.groupByField','listGrid grouping is enabled, or when working with hierarchical data in a TreeGrid, users have the option to hide records from view by collapsing the parent folder or group. This, in conjunction with autoSaveEdits being set to false can lead to a case where a user is unable to save edits due to validation errors on hidden rows. Therefore we recommend developers consider having validators in place such that errors are caught and displayed to the user on change or editor exit rather than being caught only when saving is attempted. If it's not possible for all validation to be performed immediately on row exit, we recommend that a different UI design be used that does not involve autoSaveEdits being set to false.
		 * Flags: IRWA, Group: editing */
		autoSaveEdits?: boolean /* Boolean */; // Flags=IRWA
		/** If this listGrid has specified ListGrid.headerSpans, setting this attribute to true will cause spans to expand to accommodate long titles if necessary.
		 * Flags: IR, Group: headerSpan */
		autoSizeHeaderSpans?: boolean /* Boolean */; // Flags=IR
		/** Has no effect unless ListGrid.showBackgroundComponents is true. Canvas created and embedded in the body behind a given record. When ListGridRecord.backgroundComponent is set, this autoChild canvas will be constructed (if listGridRecord.backgroundComponent is not already a Canvas) and its properties combined with those of listGridRecord.backgroundComponent and then displayed behind a specific record in the page's z-order, meaning it will only be visible if the cell styling is transparent.
		 * Flags: IR, Group: rowEffects */
		backgroundComponent?:  Canvas /* MultiAutoChild Canvas */; // Flags=IR
		/** If the result of a formula evaluation is invalid (specifically, if isNaN(result)==true), badFormulaResultValue is displayed instead. The default value is ".".
		 * Flags: IRW, Group: formulaFields */
		badFormulaResultValue?: string /* String */; // Flags=IRW
		/** GridRenderer.baseStyle','base cell style for this listGrid. If this property is unset, base style may be derived from ListGrid.normalBaseStyle or ListGrid.tallBaseStyle as described in ListGrid.getBaseStyle. See cellStyleSuffixes for details on how stateful suffixes are combined with the base style to generate stateful cell styles.
		 * Flags: IR, Group: appearance */
		baseStyle?: string /* CSSStyleName */; // Flags=IR
		/** Background color applied to the ListGrid body (that is, the area of the grid where data values are rendered). Note that this will typically not be visible to the user unless there are few enough rows that there is visible space in the body below the last row. To style data cells, override ListGrid.baseStyle instead.
		 * Flags: IRW, Group: appearance */
		bodyBackgroundColor?: string; // Flags=IRW
		/** Overflow setting for the "body", that is, the area of the grid where data values are rendered. This is a very advanced setting which is typically only changed by subclasses of ListGrid which never show a header. To achieve auto-fitting, instead use properties such as ListGrid.autoFitData, ListGrid.autoFitFieldWidths and ListGrid.fixedRecordHeights.
		 * Flags: IRWA, Group: sizing */
		bodyOverflow?: Overflow; // Flags=IRWA
		/** CSS style used for the body of this grid. If applying a background-color to the body via a CSS style applied using this property, be sure to set ListGrid.bodyBackgroundColor to null.
		 * Flags: IRW, Group: appearance */
		bodyStyleName?: string /* CSSStyleName */; // Flags=IRW
		/** An optional CSS style to apply to the checkbox image. If supplied, and the checkbox is enabled, the base style is suffixed with "True", "False", or "Partial" if the checkbox is selected, unselected, or partially selected; if the checkbox is disabled, the suffix is "TrueDisabled", "FalseDisabled", or "PartialDisabled". NOTE: This attribute is not supported by TreeGrid.
		 * Flags: IRA, Group: imageColumns */
		booleanBaseStyle?: string /* CSSStyleName */; // Flags=IRA
		/** Image to display for a false value in a boolean field. Default null value or the special value "blank" means no image will be displayed. To turn this off explicitly set ListGridField.suppressValueIcon to true If this, ListGrid.booleanTrueImage and ListGrid.booleanPartialImage are unset, this will be set to the default CheckboxItem.uncheckedImage. When skinning','spriting is enabled, this property will not be used to locate an image, instead, the image is drawn via CSS based on the ListGrid.booleanBaseStyle property.
		 * Flags: IRWA, Group: imageColumns */
		booleanFalseImage?: string /* SCImgURL */; // Flags=IRWA
		/** Height for the ListGrid.booleanTrueImage, ListGrid.booleanFalseImage and ListGrid.booleanPartialImage. Note: If ListGrid.booleanTrueImage is unset, the CheckboxItem.checkedImage will be used to indicate a true value in a boolean field. In this case this property is ignored in favor of CheckboxItem.valueIconHeight.
		 * Flags: IRWA, Group: imageColumns */
		booleanImageHeight?: number; // Flags=IRWA
		/** Width for the ListGrid.booleanTrueImage, ListGrid.booleanFalseImage and ListGrid.booleanPartialImage. Note: If ListGrid.booleanTrueImage is unset, the CheckboxItem.checkedImage will be used to indicate a true value in a boolean field. In this case this property is ignored in favor of CheckboxItem.valueIconWidth.
		 * Flags: IRWA, Group: imageColumns */
		booleanImageWidth?: number; // Flags=IRWA
		/** Image to display for a partially true value in a boolean field (typically selection). The special value "blank" means that no image will be shown. To turn this off explicitly set ListGridField.suppressValueIcon to true. If this, ListGrid.booleanTrueImage and ListGrid.booleanFalseImage are unset, this will be set to the default CheckboxItem.partialSelectedImage. When skinning','spriting is enabled, this property will not be used to locate an image, instead, the image is drawn via CSS based on the ListGrid.booleanBaseStyle property.
		 * Flags: IRWA, Group: imageColumns */
		booleanPartialImage?: string /* SCImgURL */; // Flags=IRWA
		/** Image to display for a true value in a boolean field. The special value "blank" means that no image will be shown. To turn this off explicitly set ListGridField.suppressValueIcon to true. If this, ListGrid.booleanFalseImage and ListGrid.booleanPartialImage are unset, this will be set to the default CheckboxItem.checkedImage. When skinning','spriting is enabled, this property will not be used to locate an image, instead, the image is drawn via CSS based on the ListGrid.booleanBaseStyle property.
		 * Flags: IRWA, Group: imageColumns */
		booleanTrueImage?: string /* SCImgURL */; // Flags=IRWA
		/** Indicates whether records can be dropped into this listGrid.
		 * Flags: IRW, Group: dragging */
		canAcceptDroppedRecords?: boolean /* Boolean */; // Flags=IRW
		/** Adds an item to the header context menu allowing users to launch a dialog to define a new field based on values present in other fields, using the FormulaBuilder. User-added formula fields can be persisted via ListGrid.getFieldState and ListGrid.setFieldState.
		 * Flags: IRW, Group: formulaFields */
		canAddFormulaFields?: boolean; // Flags=IRW
		/** Adds an item to the header context menu allowing users to launch a dialog to define a new text field that can contain both user-defined text and the formatted values present in other fields, using the SummaryBuilder. User-added summary fields can be persisted via ListGrid.getFieldState and ListGrid.setFieldState.
		 * Flags: IRW, Group: summaryFields */
		canAddSummaryFields?: boolean; // Flags=IRW
		/** Can the user perform one-time autofit for specific columns in this grid? If set to true, the default header menu will include options to auto fit ListGrid.autoFitAllText','all fields such that they fit their content or titles as specified via ListGridField.autoFitWidthApproach. Autofitting of individual fields via a ListGrid.autoFitFieldText','header context menu item, or the ListGrid.headerAutoFitEvent will also be enabled when this property is set unless ListGridField.canAutoFitWidth is explicitly set to false Note that the ability to perform one-time autofitting of fields via this subsystem is separate from the programmatic autofit behavior enabled via ListGrid.autoFitFieldWidths. This subsystem is requires canResizeFields be enabled and will be disabled if that property is set to false
		 * Flags: IRW, Group: autoFitFields */
		canAutoFitFields?: boolean /* Boolean */; // Flags=IRW
		/** If this is an editable listGrid, and this.confirmCancelEditing is true this property is used as the message to display in the confirmation dismissal prompt.
		 * Flags: IRW, Group: editing */
		cancelEditingConfirmationMessage?: string; // Flags=IRW
		/** Can a group be collapsed/expanded? When true a collapse/expand icon is shown (ListGrid.groupIcon','groupIcon) and the user can collapse or expand the group by clicking either the row as a whole or the opener icon (see ListGrid.collapseGroupOnRowClick); When false the group icon is not shown and clicking on the row does not change group state. Additionally GroupStartOpen','groupStartOpen is initialized to "all".
		 * Flags: IR, Group: grouping */
		canCollapseGroup?: boolean /* Boolean */; // Flags=IR
		/** Indicates whether records can be dragged from this listGrid and dropped elsewhere. <strong>NOTE:</strong> If canDragRecordsOut is initially enabled or might be dynamically enabled after the grid is created, it may be desirable to disable Canvas.useTouchScrolling','touch scrolling so that touch-dragging a record starts a drag operation rather than a scroll. If Canvas.disableTouchScrollingForDrag is set to true, then touch scrolling will be disabled automatically. However, for accessibility','accessibility reasons, it is recommended to leave touch scrolling enabled and provide an alternative set of controls that can be used to perform drag and drop of records out of the grid.
		 * Flags: IRW, Group: dragging */
		canDragRecordsOut?: boolean /* Boolean */; // Flags=IRW
		/** If this property is true, users can drag the mouse to select several rows or cells. This is mutually exclusive with rearranging rows or cells by dragging. <strong>NOTE:</strong> If canDragSelect is initially enabled or might be dynamically enabled after the grid is created, it may be desirable to disable Canvas.useTouchScrolling','touch scrolling so that touch-dragging records/cells selects them rather than starting a scroll. If Canvas.disableTouchScrollingForDrag is set to true, then touch scrolling will be disabled automatically. However, for accessibility','accessibility reasons, it is recommended to leave touch scrolling enabled and provide an alternative set of controls that can be used to perform drag-selection.
		 * Flags: IRW, Group: selection */
		canDragSelect?: boolean /* Boolean */; // Flags=IRW
		/** If this property is true, users can drag the mouse to select text within grid rows. This is mutually exclusive with ListGrid.canReorderRecords','rearranging rows or cells by dragging, and with ListGrid.canDragSelect','drag selection of rows.
		 * Flags: IRW, Group: selection */
		canDragSelectText?: boolean /* Boolean */; // Flags=IRW
		/** If set to false, dropping over an empty part of the grid body is disallowed and the no-drop indicator is displayed.
		 * Flags: IRW, Group: dragdrop */
		canDropInEmptyArea?: boolean /* Boolean */; // Flags=IRW
		/** Can the user edit cells in this listGrid? Can be set for the listGrid, and overridden for individual fields. If 'canEdit' is false at the listGrid level, fields can never be edited - in this case the canEdit property on individual fields will be ignored. If 'canEdit' is set to true at the listGrid level, setting the 'canEdit' property to false at the field level will prevent the field from being edited inline. If 'canEdit' is not set at the listGrid level, setting 'canEdit' to true at the field level enables the field to be edited inline.
		 * Flags: IRW, Group: editing */
		canEdit?: boolean /* Boolean */; // Flags=IRW
		/** If this component is bound to a dataSource, this attribute may be specified to customize what fields from the dataSource may be edited by default. For example the SearchForm class has this attribute set to "canFilter" which allows search forms to edit dataSource fields marked as canEdit:false (but not those marked as canFilter:false). Note that if canEdit is explicitly specified on a field in the DataBoundComponent.fields array, that property will be respected in preference to the canEditAttribute value. (See FormItem.canEdit, ListGridField.canEdit). Also note that individual dataBoundComponents may have additional logic around whether a field can be edited - for example ListGrid.canEditCell may be overridden.
		 * Flags: IRA */
		canEditFieldAttribute?: string; // Flags=IRA
		/** Adds an item to the header context menu allowing users to launch a dialog to define grid hilites using the HiliteEditor. User-added hilites can be persisted via DataBoundComponent.getHiliteState and DataBoundComponent.setHiliteState.
		 * Flags: IRW, Group: hiliting */
		canEditHilites?: boolean; // Flags=IRW
		/** If set to true, the ListGrid.useAdvancedFieldPicker','advanced field picker provides an interface allowing users to modify fields' titles. Note that when enabled, the ListGrid.getFieldState','field state for this component will include field titles.
		 * Flags: IRW */
		canEditTitles?: boolean; // Flags=IRW
		/** When ListGrid.canExpandRecords is true, this property indicates whether multiple records can be expanded simultaneously. If set to false, expanding a record will automatically collapse any record which is already expanded. The default value is true.
		 * Flags: IRWA, Group: expansionField */
		canExpandMultipleRecords?: boolean /* Boolean */; // Flags=IRWA
		/** Property name on a record that will be checked to determine whether a record can be expanded.
		 * Flags: IR, Group: expansionField */
		canExpandRecordProperty?: string; // Flags=IR
		/** When set to true, shows an additional field at the beginning of the field-list (respecting RTL) to allow users to expand and collapse individual records. See ListGrid.expandRecord and ListGrid.expansionMode for details on record expansion. ListGrid.virtualScrolling is automatically enabled when canExpandRecords is set to true. Note that expanded records are not currently supported in conjunction with ListGridField.frozen','frozen fields.
		 * Flags: IRWA, Group: expansionField */
		canExpandRecords?: boolean /* Boolean */; // Flags=IRWA
		/** If the listGrid is empty, should the user be able to put focus into the grid body by tabbing to it? Note that if ListGrid.editOnFocus is true for this grid and ListGrid.listEndEditAction is set to next, having this property set to true will allow users to automatically create a new edit row by simply tabbing into the grid.
		 * Flags: IRA */
		canFocusInEmptyGrid?: boolean; // Flags=IRA
		/** Whether an interface should be shown to allow user is allowed to dynamically "freeze" or "unfreeze" columns with respect to horizontally scrolling. If unset, this property defaults to true unless: ListGrid.fixedRecordHeights','this.fixedRecordHeights is false ListGrid.bodyOverflow','this.bodyOverflow is "visible" ListGrid.autoFitData','this.autoFitData is set to "horizontal" or "both" Any field has overflow set to "visible" Note that the canFreezeFields setting enables or disables the user interface for freezing and unfreezing fields only. Fields can be programmatically frozen via setting ListGridField.frozen','field.frozen to true when the grid is created, or dynamically frozen and unfrozen via ListGrid.freezeField and ListGrid.unfreezeField.
		 * Flags: IRW, Group: frozenFields */
		canFreezeFields?: boolean; // Flags=IRW
		/** If false, grouping via context menu will be disabled.
		 * Flags: IRW, Group: grouping */
		canGroupBy?: boolean /* Boolean */; // Flags=IRW
		/** If true, cellHover and rowHover events will fire and then a hover will be shown (if not canceled) when the user leaves the mouse over a row / cell unless the corresponding field has ListGridField.showHover','showHover set to false. If unset or null, the hover will be shown if the corresponding field has showHover:true. If false, then hovers are disabled. Note that standard hovers override ListGrid.showClippedValuesOnHover','clipped value hovers. Thus, to enable clipped value hovers, canHover must be unset or null and the corresponding field must have showHover unset or null as well.
		 * Flags: IRW, Group: hovers */
		canHover?: boolean; // Flags=IRW
		/** When true, indicates that this ListGrid supports grouping on multiple fields.
		 * Flags: IRW */
		canMultiGroup?: boolean; // Flags=IRW
		/** When true, indicates that this ListGrid supports sorting on multiple fields. Note that even when set to true, multi-field sorting may not be available if the grid is databound and the DataSource.canMultiSort','DataSource doesn\'t support multi-sort, or if sorting for a field is ListGridField.canSortClientOnly','client-only but not all data is available.
		 * Flags: IRW */
		canMultiSort?: boolean /* Boolean */; // Flags=IRW
		/** Indicates whether the field picker item and submenu should be present in the header context menu. This menu allows the user to hide visible fields and show hidden fields. By default only fields explicitly included in the ListGrid.fields array will be available in this menu, unless ListGrid.canPickOmittedFields is set to true for a databound grid. A specific field can be omitted from the column picker via ListGridField.canHide.
		 * Flags: IRW */
		canPickFields?: boolean /* Boolean */; // Flags=IRW
		/** If this grid has a specified ListGrid.dataSource, and ListGrid.useAllDataSourceFields is false, setting this property to true will cause all dataSource fields not included in the specified set of fields to show up in the ListGrid.canPickFields','field picker menu item. Has no effect if ListGrid.fields is unset (as in this case all dataSource fields will be displayed by default), or if ListGrid.canPickFields is false.
		 * Flags: IR */
		canPickOmittedFields?: boolean /* Boolean */; // Flags=IR
		/** If set, provide UI for the user to remove records from the grid as an additional field showing the ListGrid.removeIcon, which, when clicked, will call ListGrid.removeRecordClick which removes the row from the data set (or if ListGrid.deferRemoval is true changes the ListGrid.markRecordRemoved status for the record). Individual records can be marked to prevent removal - see ListGrid.recordCanRemoveProperty. To add a confirmation dialog before a record is removed, set ListGrid.warnOnRemoval. If deferring removal, the record will appear marked with the ListGrid.removedCSSText until the removal is committed via a call to ListGrid.saveEdits. Otherwise, the record will disappear from view. If ListGrid.animateRemoveRecord is true, the removed record will appear to shrink out of view when it is removed. By default the field will display the ListGrid.removeIcon next to each record, and will be rendered as the rightmost column. Two mechanisms exist to further modify this field: To change the position of the remove-field, include an explicitly specified field with the attribute ListGridField.isRemoveField','isRemoveField:true set. This will then be used as the remove field instead of adding a field to the beginning of the set of columns. Additional direct configuration of the remove field may be achieved by modifying ListGrid.removeFieldProperties. If ListGrid.deferRemoval is true, when a record is marked as removed, the the icon will change to display the ListGrid.unremoveIcon for this row. Clicking on this icon will call ListGrid.unmarkRecordRemoved to mark the record as no longer pending deletion.
		 * Flags: IR, Group: databinding */
		canRemoveRecords?: boolean /* Boolean */; // Flags=IR
		/** Indicates whether fields in this listGrid can be reordered by dragging and dropping header fields.
		 * Flags: IRW, Group: dragging */
		canReorderFields?: boolean /* Boolean */; // Flags=IRW
		/** Indicates whether records can be reordered by dragging within this ListGrid. <strong>NOTE:</strong> If canReorderRecords is initially enabled or might be ListGrid.setCanReorderRecords','dynamically enabled after the grid is created, it may be desirable to disable Canvas.useTouchScrolling','touch scrolling so that touch-dragging a record starts a reorder operation rather than a scroll. If Canvas.disableTouchScrollingForDrag is set to true, then touch scrolling will be disabled automatically. However, for accessibility','accessibility reasons, it is recommended to leave touch scrolling enabled and provide an alternative set of controls that can be used to perform drag-reordering of records.
		 * Flags: IRW, Group: dragging */
		canReorderRecords?: boolean /* Boolean */; // Flags=IRW
		/** Indicates whether fields in this listGrid can be resized by dragging header fields.
		 * Flags: IRW, Group: dragging */
		canResizeFields?: boolean /* Boolean */; // Flags=IRW
		/** Controls whether a checkbox for selecting all records appears in the header with ListGrid.selectionAppearance','selectionAppearance set to "checkbox"
		 * Flags: IRW, Group: selection */
		canSelectAll?: boolean; // Flags=IRW
		/** Enables cell-level selection behavior as well as ListGrid.useCellRollOvers','cell-level rollover. To query and manipulate cell-level selections, use ListGrid.getCellSelection to retrieve the CellSelection. Note that the ListGrid has a data model of one Record per row, unlike the CubeGrid which supports one CellRecord per cell. For this reason record-oriented APIs that act on the selection will act on entire Records that have any selected cells (examples include drag and drop and transferSelectedData()). More generally, canSelectCells is primarily intended to enable developers to build Excel-like interactions on local datasets, by using ListGrid.setData plus ListGrid.saveLocally:true rather than record-oriented DataSources and data binding. The following keyboard selection behaviors are enabled with this property in addition to standard single-selection Arrow Key navigation: SHIFT + [Arrow Key]: begin or continue incremental selection SHIFT + CTRL + [Arrow Key]: incremental selection to the end of row or column CTRL + A: select all cells (enabled only with ListGrid.canSelectAll) Incremental selection allows selection of rows and columns of cells via keyboard or mouse provided the shift key is down. Behavior is designed to match Excel. Thus, if a previous selection has begun, cells will be selected from that origin. Users may also navigate through cells using the Tab and Shift+Tab keypresses if ListGrid.navigateOnTab is true. When a user tabs to the end of the row, the ListGrid.rowEndEditAction is used to determine whether to shift selection to the next row, return to the beginning of the same row, or simply move on through the page's tab order.
		 * Flags: IR */
		canSelectCells?: boolean /* Boolean */; // Flags=IR
		/** Controls whether a checkbox for selecting ListGrid.groupBy','groups appears in the group node if SelectionAppearance is set to "checkbox"
		 * Flags: IRW, Group: selection */
		canSelectGroups?: boolean; // Flags=IRW
		/** Enables or disables interactive sorting behavior for this listGrid. Does not affect sorting by direct calls to the ListGrid.sort','sort or ListGrid.setSort','setSort methods.
		 * Flags: IRW, Group: sorting */
		canSort?: boolean /* Boolean */; // Flags=IRW
		/** Should the header be included in the tab-order for the page? If not explicitly specified, the header will be included in the tab order for the page if isc.setScreenReaderMode','isc.setScreenReaderMode() is called.
		 * Flags: IR, Group: accessibility */
		canTabToHeader?: boolean; // Flags=IR
		/** The default height of each row in pixels.
		 * Flags: IRW, Group: cellStyling */
		cellHeight?: number; // Flags=IRW
		/** The amount of empty space, in pixels, surrounding each value in its cell.
		 * Flags: IRW, Group: cellStyling */
		cellPadding?: number; // Flags=IRW
		/** Name of the SmartClient Class to be used when creating charts. Must support the Chart interface.
		 * Flags: IR */
		chartConstructor?: string /* Classname */; // Flags=IR
		/** Default type of chart to plot.
		 * Flags: IRW */
		chartType?: ChartType; // Flags=IRW
		/** Returns the specially generated checkbox field used when SelectionAppearance is "checkbox". Created via the AutoChild pattern so that checkboxFieldDefaults and checkboxFieldProperties are available for skinning purposes. Note that ListGridField.shouldPrint is false for the checkboxField by default - if you want this column to show up in the grid's print view, use checkboxFieldProperties to set this property to true. This field will render an icon to indicate the selected state of each row, which, when clicked will toggle the selection state. The icon src may be configured using ListGrid.checkboxFieldTrueImage and ListGrid.checkboxFieldFalseImage, as well as ListGrid.checkboxFieldImageWidth and ListGrid.checkboxFieldImageHeight. The checkboxField can be detected by calling ListGrid.isCheckboxField on any ListGridField object.
		 * Flags: IR, Group: checkboxField */
		checkboxField?:  ListGridField /* AutoChild ListGridField */; // Flags=IR
		/** If ListGrid.selectionAppearance is set to "checkbox" this property determines the image to display in the checkbox field for an unselected row. If unset, the ListGrid.booleanFalseImage will be used. Note that the special value "blank" means that no image will be shown.
		 * Flags: IRWA, Group: checkboxField */
		checkboxFieldFalseImage?: string /* SCImgURL */; // Flags=IRWA
		/** How much horizontal space should the ListGrid.getCheckboxField','checkbox field leave around the checkbox icon when ListGrid.selectionAppearance is set to "checkbox"? The automatically generated checkbox field will be sized to the width of the checkbox icon (specified via ListGrid.checkboxFieldImageWidth or ListGrid.booleanImageWidth) plus this value.
		 * Flags: IR, Group: checkboxField */
		checkboxFieldHSpace?: number /* int */; // Flags=IR
		/** If ListGrid.selectionAppearance is set to "checkbox" this property may be set to govern the height of the checkbox image displayed to indicate whether a row is selected. If unset, the checkboxField image will be sized to match the ListGrid.booleanImageHeight for this grid.
		 * Flags: IR, Group: checkboxField */
		checkboxFieldImageHeight?: number /* integer */; // Flags=IR
		/** If ListGrid.selectionAppearance is set to "checkbox" this property may be set to govern the width of the checkbox image displayed to indicate whether a row is selected. If unset, the checkboxField image will be sized to match the ListGrid.booleanImageWidth for this grid.
		 * Flags: IR, Group: checkboxField */
		checkboxFieldImageWidth?: number /* integer */; // Flags=IR
		/** If ListGrid.selectionAppearance is set to "checkbox" this property determines the image to display in the checkbox field for a partially selected row. If unset, the ListGrid.booleanPartialImage will be used. Note that the special value "blank" means that no image will be shown.
		 * Flags: IRWA, Group: checkboxField */
		checkboxFieldPartialImage?: string /* SCImgURL */; // Flags=IRWA
		/** If ListGrid.selectionAppearance is set to "checkbox" this property determines the image to display in the checkbox field for a selected row. If unset, the ListGrid.booleanTrueImage will be used. Note that the special value "blank" means that no image will be shown.
		 * Flags: IRWA, Group: checkboxField */
		checkboxFieldTrueImage?: string /* SCImgURL */; // Flags=IRWA
		/** For ExpansionMode','expansionModes that show another grid or tree, what the child's expansionMode should be. Default value null means no further expansion.
		 * Flags: IRWA, Group: expansionField */
		childExpansionMode?: ExpansionMode; // Flags=IRWA
		/** If we're showing a ListGrid.showHeaderContextMenu','headerContextMenu for this grid, this attribute will be shown as the menu item title to clear any existing sort on all fields. This menu-item is displayed only in the context menu for the sorter button.
		 * Flags: IRW, Group: i18nMessages */
		clearAllSortingText?: string; // Flags=IRW
		/** If we're showing a ListGrid.showHeaderContextMenu','headerContextMenu for this grid, and a ListGrid.showFilterEditor','filter-editor is visible, this attribute will be shown as the menu item title to clear any existing filter. This menu-item is displayed only in the context menu for the sorter button.
		 * Flags: IRW, Group: i18nMessages */
		clearFilterText?: string; // Flags=IRW
		/** If we're showing a ListGrid.showHeaderContextMenu','headerContextMenu for this grid, this attribute will be shown as the menu item title to clear an existing sort on this field.
		 * Flags: IRW, Group: i18nMessages */
		clearSortFieldText?: string; // Flags=IRW
		/** Whether the ListGrid should manage the clipping of titles of header buttons, showing ellipses if the title is clipped, and potentially showing the full title on ListGrid.showClippedHeaderTitlesOnHover','hover. In some cases this may be preferable to the button component's default clipping behavior because if a ListGrid.showSortArrow','sort arrow or sort numeral is displayed for a header, then the button's default clipping behavior may clip the sort arrow/numeral whereas ListGrid-managed title clipping utilizes special HTML which keeps the sort arrow/numeral visible. This feature is automatically enabled if supported by the browser. The only supported use of this attribute is to <em>disable</em> the feature by setting clipHeaderTitles to false. Note that this feature is incompatible with ListGridField.wrap, and will automatically be disabled for wrapping fields.
		 * Flags: IRA, Group: gridHeader */
		clipHeaderTitles?: boolean /* Boolean */; // Flags=IRA
		/** If ListGrid.canCollapseGroup is true, will a click anywhere on the group row toggle the group's expanded state? If false, the user must click the ListGrid.groupIcon directly to toggle the group.
		 * Flags: IR, Group: grouping */
		collapseGroupOnRowClick?: boolean; // Flags=IR
		/** If we're showing a ListGrid.showHeaderContextMenu','headerContextMenu for this grid, and multi-grouping is enabled, this attribute is used as the title for a menu item that opens a MultiGroupDialog to configure the grouping for this grid.
		 * Flags: IRW, Group: i18nMessages */
		configureGroupingText?: string; // Flags=IRW
		/** If we're showing a ListGrid.showHeaderContextMenu','headerContextMenu for this grid, and multi-sorting is enabled, this attribute is used as the title for a menu item that opens a MultiSortDialog to configure the sort-specification for this grid. This menu-item is displayed only in the context menu for the sorter button.
		 * Flags: IRW, Group: i18nMessages */
		configureSortText?: string; // Flags=IRW
		/** If this is an editable listGrid, when the user attempts to cancel an edit, should we display a confirmation prompt before discarding the edited values for the record?
		 * Flags: IRW, Group: editing */
		confirmCancelEditing?: boolean /* Boolean */; // Flags=IRW
		/** For editable listGrids, outstanding unsaved edits when the user performs a new filter or sort will be discarded. This flag determines whether we should display a confirmation dialog with options to save or discard the edits, or cancel the action in this case.
		 * Flags: IRW, Group: editing */
		confirmDiscardEdits?: boolean /* Boolean */; // Flags=IRW
		/** If this.confirmDiscardEdits is true, this property can be used to customize the error message string displayed to the user in a dialog with options to cancel the action, or save or discard pending edits in response to sort/filter actions that would otherwise drop unsaved edit values.
		 * Flags: IRW, Group: editing */
		confirmDiscardEditsMessage?: string; // Flags=IRW
		/** A list of ListGridRecord objects, specifying the data to be used to populate the ListGrid. In ListGrids, the data array specifies rows. When using a DataSource, rather than directly providing data, you will typically call ListGrid.fetchData instead, which will automatically establish data as a ResultSet','ResultSet (see the ListGrid.fetchData docs for details). If you call fetchData, any previously supplied data is discarded. Also, it is not necessary to call setData() after calling ListGrid.fetchData. When calling setData(), direct changes to the list using Framework APIs such as List.add or List.remove will be automatically observed and the ListGrid will redraw in response. However, direct changes to individual Records will not be automatically observed and require calls to ListGrid.refreshCell or ListGrid.refreshRow to cause the ListGrid to visually update. Calling methods such as ListGrid.updateData, ListGrid.removeData or ListGrid.addData always causes automatic visual refresh. Note that direct manipulation of the data object without using the List APIs (for example by directly assigning a new Record object to some index or calling non-Framework APIs such as pop(), shift(), etc.) will not be reflected in the grid automatically, but developers can call List.dataChanged directly to notify the grid of changes. 
		 * Flags: IRW, Group: data */
		data?: any /* List of ListGridRecord */; // Flags=IRW
		/** Delay in milliseconds before fetching data. Note: the floor value for this attribute is 1. If you set this value to zero, it will be defaulted to 1 for you instead.
		 * Flags: IRWA, Group: databinding */
		dataFetchDelay?: number /* integer */; // Flags=IRWA
		/** How to fetch and manage records retrieve from the server. See FetchMode. This setting only applies to the ResultSet automatically created by calling ListGrid.fetchData','fetchData(). If a pre-existing ResultSet is passed to setData() instead, it's existing setting for ResultSet.fetchMode applies.
		 * Flags: IR, Group: databinding */
		dataFetchMode?: FetchMode; // Flags=IR
		/** When using ListGrid.dataFetchMode','data paging, how many records to fetch at a time. If set to a positive integer, dataPageSize will override the default ResultSet.resultSize','resultSize for ResultSets automatically created when you call ListGrid.fetchData (and similarly for the ResultTree.resultSize','resultSize of ResultTrees). Leaving dataPageSize at its default means to just use the default page size of the data container. Note that regardless of the dataPageSize setting, a component will always fetch all of data that it needs to draw. Settings such as ListGrid.showAllRecords','showAllRecords:true, ListGrid.drawAllMaxCells','drawAllMaxCells and ListGrid.drawAheadRatio','drawAheadRatio can cause more rows than the configured dataPageSize to be fetched.
		 * Flags: IRW, Group: performance */
		dataPageSize?: number /* integer */; // Flags=IRW
		/** The DataSource that this component should bind to for default fields and for performing DSRequest','DataSource requests. Can be specified as either a DataSource instance or the String ID of a DataSource.
		 * Flags: IRW, Group: databinding */
		dataSource?: DataSource | string /* DataSource or ID */; // Flags=IRW
		/** How should Date type values be displayed in this ListGrid by default? This property specifies the default DateDisplayFormat to apply to Date values displayed in this grid for all fields except those of ListGridField.type','type "time" (See also ListGrid.timeFormatter). If ListGrid.datetimeFormatter is specified, that will be applied by default to fields of type "datetime". Note that if ListGridField.dateFormatter or ListGridField.timeFormatter are specified those properties will take precedence over the component level settings. If unset, date values will be formatted according to the system wide DateUtil.setShortDisplayFormat','short display format or DateUtil.setShortDatetimeDisplayFormat','short datetime display format for datetime type fields. If this field is editable the dateFormatter will also be passed to the editor created to edit this field as DateItem.dateFormatter','dateFormatter. In this case you may also need to set ListGrid.dateInputFormat.
		 * Flags: IRW */
		dateFormatter?: DateDisplayFormat; // Flags=IRW
		/** If this is an editable listGrid, this property will specify the DateItem.inputFormat','inputFormat applied to editors for fields of type "date". May be overridden per field via ListGridField.inputFormat.
		 * Flags: IRWA */
		dateInputFormat?: string /* DateInputFormat */; // Flags=IRWA
		/** Display format to use for fields specified as type 'datetime'. Default is to use the system-wide default date time format, configured via DateUtil.setShortDatetimeDisplayFormat. Specify any valid DateDisplayFormat to change the display format for datetimes used by this grid. May be specified as a function. If specified as a function, this function will be executed in the scope of the Date and should return the formatted string. May also be specified at the field level via ListGridField.dateFormatter If this field is editable the dateFormatter will also be passed to the editor created to edit this field as DateItem.dateFormatter','dateFormatter. In this case you may also need to set ListGrid.dateInputFormat.
		 * Flags: IRW, Group: appearance */
		datetimeFormatter?: DateDisplayFormat; // Flags=IRW
		/** Default width for date type fields. See ListGrid.autoFitDateFields for details on how this property is used.
		 * Flags: IRW, Group: autoFitFields */
		defaultDateFieldWidth?: number /* Integer */; // Flags=IRW
		/** Default width for editable date type fields. See ListGrid.autoFitDateFields for details on how this property is used.
		 * Flags: IRW, Group: autoFitFields */
		defaultEditableDateFieldWidth?: number /* Integer */; // Flags=IRW
		/** An array of listGrid field configuration objects. When a listGrid is initialized, if this property is set and there is no value for the fields attribute, this.fields will be defaulted to a generated array of field objects duplicated from this array. This property is useful for cases where a standard set of fields will be displayed in multiple listGrids - for example a subclass of ListGrid intended to display a particular type of data: In this example we would not assign a single ListGrid.fields array directly to the class via addProperties() as every generated instance of this class would then point to the same fields array object. This would cause unexpected behavior such as changes to the field order in one grid effecting other grids on the page. Instead we could use addProperties() on our new subclass to set defaultFields to a standard array of fields to display. Each generated instance of the subclass would then show up with default fields duplicated from this array.
		 * Flags: IRA */
		defaultFields?: Array<ListGridField> /* Array of ListGridField Properties */; // Flags=IRA
		/** Default OperatorId','filter operator to use for text-based fields in this grid's ListGrid.filterEditor','filter editor, when producing AdvancedCriteria. When ListGrid.allowFilterExpressions','allowFilterExpressions or ListGrid.allowFilterOperators','allowFilterOperators are enabled for the grid, the default is DataSource.translatePatternOperators','"iContainsPattern". Otherwise, the default is "iContains". Does not apply to special fields where exact match is obviously the right default setting, such as fields of type:"enum", or fields with a FormItem.valueMap','valueMap or FormItem.optionDataSource','optionDataSource.
		 * Flags: IR */
		defaultFilterOperator?: OperatorId; // Flags=IR
		/** Text to show after the name of the default filterOperator in the ListGrid.showHeaderContextMenu','headerContextMenu when ListGrid.allowFilterOperators is enabled.
		 * Flags: IR, Group: i18nMessages */
		defaultFilterOperatorSuffix?: string /* String */; // Flags=IR
		/** Default width for time type fields. See ListGrid.autoFitDateFields for details on how this property is used.
		 * Flags: IRW, Group: autoFitFields */
		defaultTimeFieldWidth?: number /* Integer */; // Flags=IRW
		/** When enabled, the field shown by ListGrid.canRemoveRecords causes records to be marked for future removal via ListGrid.markRecordRemoved instead of immediately being removed. When a record has been marked for removal, an icon in the canRemoveRecords field allowing it to be unmarked will be displayed. If not explicitly specified by this property, removal of records will be deferred if ListGrid.autoSaveEdits is false for the grid.
		 * Flags: IR, Group: editing */
		deferRemoval?: boolean; // Flags=IR
		/** If ListGrid.canExpandRecords is true and ExpansionMode','listGrid.expansionMode is "related", this property specifies the dataSource for the related records grid to be shown embedded in expanded records. This property may also be specified on a per-record basis - see ListGrid.recordDetailDSProperty
		 * Flags: IRWA */
		detailDS?: string /* String */; // Flags=IRWA
		/** The field whose contents to show in the expanded portion of a record when ListGrid.canExpandRecords','canExpandRecords is true and ExpansionMode','listGrid.expansionMode is detailField.
		 * Flags: IRWA, Group: expansionField */
		detailField?: string /* String */; // Flags=IRWA
		/** If a user is editing a ListGrid.canEdit','canEdit:true listGrid, and they hide a field while the editor is showing, should we discard any edits in the edit row for the field being hidden? Default behavior is to discard the edits - set this flag to false to preserve edits
		 * Flags: IRW */
		discardEditsOnHideField?: boolean; // Flags=IRW
		/** If ListGrid.confirmDiscardEdits is true this is the title for the save button appearing in the lost edits confirmation dialog. Override this for localization if necessary.
		 * Flags: IRW, Group: editing */
		discardEditsSaveButtonTitle?: string; // Flags=IRW
		/** Indicates what to do with data dragged into another DataBoundComponent. See DragDataAction type for details.
		 * Flags: IRW, Group: dragging */
		dragDataAction?: DragDataAction; // Flags=IRW
		/** When records are being dragged from within a ListGrid, what sort of drag-tracker should be displayed? Note that if multiple records are being dragged the displayed tracker will be based on the first selected record.
		 * Flags: IRA, Group: dragTracker */
		dragTrackerMode?: DragTrackerMode; // Flags=IRA
		/** CSS Style to apply to the drag tracker when dragging occurs on this component.
		 * Flags: IRW */
		dragTrackerStyle?: string /* CSSStyleName */; // Flags=IRW
		/** How far should we render rows ahead of the currently visible area? This is expressed as a ratio from viewport size to rendered area size. Tweaking drawAheadRatio allows you to make tradeoffs between continuous scrolling speed vs initial render time and render time when scrolling by large amounts. NOTE: Only applies when showAllRows is false.
		 * Flags: IRW, Group: performance */
		drawAheadRatio?: number /* float */; // Flags=IRW
		/** If drawing all rows would cause less than drawAllMaxCells cells to be rendered, the full dataset will instead be drawn even if ListGrid.showAllRecords','showAllRecords is false and the viewport size and ListGrid.drawAheadRatio setting would normally have caused incremental rendering to be used. The drawAllMaxCells setting prevents incremental rendering from being used in situations where it's really unnecessary, such as a 40 row, 5 column dataset (only 200 cells) which happens to be in a grid with a viewport showing only 20 or so rows. Incremental rendering causes a brief "flash" during scrolling as the visible portion of the dataset is redrawn, and a better scrolling experience can be obtained in this situation by drawing the entire dataset up front, which in this example would have negligible effect on initial draw time. drawAllMaxCells:0 disables this features. You may want to disable this feature if performance is an issue and: you are very frequently redraw a grid you do a lot of computation when rendering each cell (eg formulas) you are showing many grids on one screen and the user won't scroll most of them 
		 * Flags: IRWA, Group: performance */
		drawAllMaxCells?: number /* int */; // Flags=IRWA
		/** Determines whether when the user edits a cell in this listGrid the entire row becomes editable, or just the cell that received the edit event. No effect if this.canEdit is false or null.
		 * Flags: IRW, Group: editing */
		editByCell?: boolean; // Flags=IRW
		/** Event that will trigger inline editing, see ListGridEditEvent for options. Note this setting has no effect unless ListGrid.canEdit has been set to enable editing. See also ListGrid.editOnFocus and ListGrid.startEditing.
		 * Flags: IRW, Group: editing */
		editEvent?: ListGridEditEvent; // Flags=IRW
		/** A base name for the CSS class applied to cells when editing has failed. If this listGrid is editable, this style will be applied to any edited cells for which validation failed. As with the default 'baseStyle' property, this style will have "Dark", "Over", "Selected", or "Disabled" appended to it according to the state of the cell. If null, cells for which editing has failed will be rendered using the normal base style classNames, but with custom CSSText applied as derived from this.editFailedCSSText
		 * Flags: IRWA, Group: appearance */
		editFailedBaseStyle?: string /* CSSStyleName */; // Flags=IRWA
		/** Custom CSS text to be applied to cells when editing has failed. If this listGrid is editable, this css text will be applied to any edited cells for which validation failed, on top of the base style for the cell. For further customization of styling for cells that failed editing validation, use this.editFailedBaseStyle instead.
		 * Flags: IRWA, Group: appearance */
		editFailedCSSText?: string; // Flags=IRWA
		/** Should we start editing when the widget has focus and the user presses the "f2" key (if this ListGrid supports editing)? Note that if ListGrid.editEvent is set to "click" or "doubleClick", the Space or Enter key may also be used to start editing, depending on the value for ListGrid.generateClickOnSpace, ListGrid.generateDoubleClickOnSpace, ListGrid.generateClickOnEnter and ListGrid.generateDoubleClickOnEnter. If ListGrid.canEdit is false, or ListGrid.editEvent is set to "none" this property has no effect.
		 * Flags: IRWA, Group: editing */
		editOnF2Keypress?: boolean /* Boolean */; // Flags=IRWA
		/** Should we start editing when this widget receives focus (if this ListGrid supports editing)? Note that this property being set to true will cause editing to occur on a single click, even if ListGrid.editEvent is "doubleClick", because single clicking the grid will place keyboard focus there automatically. If this property is set together with ListGrid.listEndEditAction being set to "next", users can create a new edit row in an empty grid by simply tabbing into the grid.
		 * Flags: IRWA, Group: editing */
		editOnFocus?: boolean; // Flags=IRWA
		/** A base name for the CSS class applied to cells containing pending (unsaved) edits As with the default 'baseStyle' property, this style will have "Dark", "Over", "Selected", or "Disabled" appended to it according to the state of the cell. If this property is null (the default setting), cells with pending edits will pick up custom css text to be applied on top of the normal base style from this.editPendingCSSText.
		 * Flags: IRA, Group: appearance */
		editPendingBaseStyle?: string /* CSSStyleName */; // Flags=IRA
		/** Custom CSS text to be applied to cells with pending edits that have not yet been submitted. For further customization of styling for cells with pending edits use this.editPendingBaseStyle instead.
		 * Flags: IRWA, Group: appearance */
		editPendingCSSText?: string; // Flags=IRWA
		/** Default class used to construct the EditProxy for this component when the component is Canvas.setEditMode','first placed into edit mode.
		 * Flags: IR */
		editProxyConstructor?: string /* SCClassName */; // Flags=IR
		/** The value to display for cells whose value is null or the empty string after applying ListGrid.formatCellValue','formatting and valueMap (if any). This is the grid-wide attribute. You may also set the emptyCellValue on a per-field basis.
		 * Flags: IRW, Group: cellStyling */
		emptyCellValue?: string /* HTMLString */; // Flags=IRW
		/** The string to display in the body of a listGrid with an empty data array, if showEmptyMessage is true.
		 * Flags: IRW, Group: emptyMessage */
		emptyMessage?: string /* HTMLString */; // Flags=IRW
		/** The CSS style name applied to the ListGrid.emptyMessage if displayed.
		 * Flags: IRW, Group: emptyMessage */
		emptyMessageStyle?: string /* CSSStyleName */; // Flags=IRW
		/** For performance reasons, even when ListGrid.fixedRecordHeights is set, vertical clipping is not enforced by default for some kinds of content (such as images) on all browsers. Set ListGrid.enforceVClipping','enforceVClipping:true to enforce clipping for all types of content on all browsers. This additional setting is likely to be phased out as browsers improve.
		 * Flags: IRW */
		enforceVClipping?: boolean /* Boolean */; // Flags=IRW
		/** What to do when a user hits enter while editing a cell: "nextCell": start editing the next editable cell in this record (or the first editable cell in the next record if focus is in the last editable cell in the row) "nextRow": start editing the same field in the next row (skipping any rows where that would be a non-editable cell. "nextRowStart": start editing the first editable cell in the next row. "done": hide the editor (editing is complete) Note that if this.autoSaveEdits is true, this may cause a save of the current edit values
		 * Flags: IRW, Group: editing */
		enterKeyEditAction?: EnterKeyEditAction; // Flags=IRW
		/** In a ListGrid that has a DataSource and has filter criteria that include values for fields declared as FieldType','type "enum" in the DataSource, by default a newly edited row will use those filter criteria as initial values. For example, if a ListGrid is showing all Accounts that have status:"Active" and a new row is created, the new row will default to status:"Active" unless this flag is set to false.
		 * Flags: IR, Group: editing */
		enumCriteriaAsInitialValues?: boolean /* Boolean */; // Flags=IR
		/** Height of the error icon, if we're showing icons when validation errors occur.
		 * Flags: IRW, Group: errorIcon */
		errorIconHeight?: number /* integer */; // Flags=IRW
		/** Src of the image to show as an error icon, if we're showing icons when validation errors occur.
		 * Flags: IRW, Group: errorIcon */
		errorIconSrc?: string /* SCImgURL */; // Flags=IRW
		/** Height of the error icon, if we're showing icons when validation errors occur.
		 * Flags: IRW, Group: errorIcon */
		errorIconWidth?: number /* integer */; // Flags=IRW
		/** What to do when a user hits escape while editing a cell: "cancel": close the editor and discard the current set of edit values "done": just close the editor (the edit is complete, but the edited values are retained). Note that if ListGrid.autoSaveEdits is true, this may cause a save of the current edit values
		 * Flags: IRW, Group: editing */
		escapeKeyEditAction?: EscapeKeyEditAction; // Flags=IRW
		/** For ExpansionMode','expansionModes that show another grid or tree, is that component editable? The default value for this property is false.
		 * Flags: IRWA, Group: expansionField */
		expansionCanEdit?: boolean /* Boolean */; // Flags=IRWA
		/** The method of RecordComponentPoolingMode','component-pooling to employ for ListGrid.canExpandRecords','expansionComponents. The default mode is "destroy", which means that automatically created expansionComponents are destroyed when rows are collapsed.
		 * Flags: IRWA */
		expansionComponentPoolingMode?: ExpansionComponentPoolingMode; // Flags=IRWA
		/** When ListGrid.canExpandRecords','canExpandRecords is true and ListGrid.expansionMode','expansionMode is editor, the prompt to display in a dialog when an expanded row is collapsed while it's nested editor has changed values.
		 * Flags: IR, Group: expansionField */
		expansionEditorSaveDialogPrompt?: string; // Flags=IR
		/** When ListGrid.canExpandRecords','canExpandRecords is true and ListGrid.expansionMode','expansionMode is editor, whether a dialog should be displayed when an expanded row is collapsed while it's nested editor has changed values.
		 * Flags: IR, Group: expansionField */
		expansionEditorShowSaveDialog?: boolean; // Flags=IR
		/** The field providing the facility to expand and collapse rows.
		 * Flags: IRWA, Group: expansionField */
		expansionField?:  ListGridField /* AutoChild ListGridField */; // Flags=IRWA
		/** If ListGrid.canExpandRecords is set to true, this property determines the image to display in the expansion field for collapsed rows. If unset, the ListGrid.booleanFalseImage will be used.
		 * Flags: IRWA, Group: expansionField */
		expansionFieldFalseImage?: string /* SCImgURL */; // Flags=IRWA
		/** If ListGrid.canExpandRecords is set to true, this property may be set to govern the height of the expansion image displayed to indicate whether a row is expanded. If unset, the expansionField image will be sized to match the ListGrid.booleanImageHeight for this grid.
		 * Flags: IR, Group: expansionField */
		expansionFieldImageHeight?: number /* integer */; // Flags=IR
		/** If ListGrid.canExpandRecords is set to true, this property may be set to govern the width of the expansion image displayed to indicate whether a row is expanded. If unset, the expansionField image will be sized to match the ListGrid.booleanImageWidth for this grid.
		 * Flags: IR, Group: expansionField */
		expansionFieldImageWidth?: number /* integer */; // Flags=IR
		/** If ListGrid.canExpandRecords is set to true, this property determines the image to display in the expansion field for expanded rows. If unset, the ListGrid.booleanTrueImage will be used.
		 * Flags: IRWA, Group: expansionField */
		expansionFieldTrueImage?: string /* SCImgURL */; // Flags=IRWA
		/** The ExpansionMode for records in this grid. Default null value means no expansion.
		 * Flags: IRWA, Group: expansionField */
		expansionMode?: ExpansionMode; // Flags=IRWA
		/** When exporting data to Excel/OpenOffice format using ListGrid.exportData','exportData() or ListGrid.exportClientData','exportClientData(), background color to use for even-numbered rows, to create a "banded" or "ledger" effect. Odd-numbered rows will use the ListGrid.exportDefaultBGColor. See exportBGColor for an overview.
		 * Flags: IR, Group: exportBackgroundColor */
		exportAlternateRowBGColor?: string /* CSSColor */; // Flags=IR
		/** Default background color to use when exporting data to Excel/OpenOffice format using ListGrid.exportData','exportData() or ListGrid.exportClientData','exportClientData(). If unset (the default), cells that are not provided a background color by more specific APIs will be the default background color used by the spreadsheet program where they are viewed. See exportBGColor for an overview.
		 * Flags: IR, Group: exportBackgroundColor */
		exportDefaultBGColor?: string /* CSSColor */; // Flags=IR
		/** When exporting data to Excel/OpenOffice format using ListGrid.exportData or ListGrid.exportClientData, whether field ListGridField.align','horizontal header alignments and ListGridField.cellAlign','data value alignments should be replicated in the resulting spreadsheet. If this attribute is not set, cells will be assigned a default alignment by the spreadsheet, which is typically right-aligned for numeric and date values, and left-aligned for everything else (including dates and numbers that have been exported as strings, as would be the case, for example, if DSRequest.exportDatesAsFormattedString is set)
		 * Flags: IRW */
		exportFieldAlignments?: boolean; // Flags=IRW
		/** When exporting data to Excel/OpenOffice format using ListGrid.exportData or ListGrid.exportClientData, whether widths of fields should be replicated in the resulting spreadsheet. Because Excel's unit of measurement for field widths is based on the default system font, there is no exact way to translate field widths in pixels to Excel column widths. The ListGrid.exportWidthScale property can be set to adjust scaling; it's default value errs on the side of making Excel's columns slightly wider than the ListGrid field's actual width to avoid clipping. Note that you can switch off width export for individual fields with the ListGridField.exportFieldWidth flag.
		 * Flags: IRW */
		exportFieldWidths?: boolean; // Flags=IRW
		/** When exporting data to Excel/OpenOffice format using ListGrid.exportData or ListGrid.exportClientData, causes the ListGrid.headerHeight and HeaderSpan.height','headerSpan heights to be applied to the corresponding cells in the spreadsheet.
		 * Flags: IRW */
		exportHeaderHeights?: boolean; // Flags=IRW
		/** Dictates whether the data in this grid should be exported raw by ListGrid.exportClientData','exportClientData(). If set to true, data will not be processed by field-formatters during exports. Decreases the time taken for large exports. This property can also be set at the ListGridField.exportRawValues','field level.
		 * Flags: IR */
		exportRawValues?: boolean /* Boolean */; // Flags=IR
		/** Scaling factor to translate from ListGrid field widths in pixels to Excel/OpenOffice units for field width, which are 1/256th of the width of the widest digit character in the default font for the spreadsheet. See ListGrid.exportFieldWidths for where this is used.
		 * Flags: IRW */
		exportWidthScale?: number /* float */; // Flags=IRW
		/** When exporting data to Excel/OpenOffice format using ListGrid.exportData or ListGrid.exportClientData, whether titles in the ListGrid.header','ListGrid header and ListGrid.headerSpans','headerSpans should be allowed to wrap. Excel will wrap at the column boundary automatically; for explicit control over wrapping, insert "" tags into your titles. See also ListGrid.exportFieldWidths for replicating the widths of fields in the exported spreadsheet.
		 * Flags: IRW */
		exportWrapHeaderTitles?: boolean; // Flags=IRW
		/** Note: This property only has an effect in Internet Explorer Advanced property to improve performance for dynamic styling of gridRenderer cells in Internet Explorer, at the expense of slightly slower initial drawing, and some limitations on supported styling options. fastCellUpdates speeds up the dynamic styling system used by rollovers, selections, and custom styling that calls GridRenderer.refreshCellStyle, at the cost of slightly slower draw() and redraw() times. Notes: When this property is set, ListGrid cells may be styled using the ListGrid.tallBaseStyle. See ListGrid.getBaseStyle for more information. If any cell styles specify a a background image URL, the URL will be resolved relative to the page location rather than the location of the CSS stylesheet. This means cell styles with a background URL should either supply a fully qualified path, or the background image media should be made available at a second location for IE. fastCellUpdates will not work if the styles involved are in an external stylesheet loaded from a remote host. Either the stylesheet containing cell styles needs to be loaded from the same host as the main page, or the cell styles need to be inlined in the html of the bootstrap page. fastCellUpdates will not work if the css styles for cells are defined in a .css file loaded via @import. Instead the .css file should be loaded via a &lt;link ...&gt; tag. 
		 * Flags: I, Group: performance */
		fastCellUpdates?: boolean /* Boolean */; // Flags=I
		/** If we're showing the filterEditor (ListGrid.showFilterEditor is true), and we're re-filtering on every keypress (ListGrid.filterOnKeypress is true), this property is the delay in milliseconds between the user changing the filter and the filter request being kicked off. If multiple changes are made to the filter within this fetch delay, only the most recent will actually cause a re-filter
		 * Flags: IRWA, Group: filterEditor */
		fetchDelay?: number; // Flags=IRWA
		/** Names of properties on ListGridField for which the FieldPicker should show an editing interface, for convenience. For example, specify ["frozen", "decimalPrecision"] to allow end users to modify ListGridField.frozen and ListGridField.decimalPrecision respectively.
		 * Flags: IR */
		fieldPickerFieldProperties?: Array<string> /* Array of String */; // Flags=IR
		/** When set to false, sample values of the FieldPicker are never shown. This property applies to the entire FieldPicker.
		 * Flags: IR */
		fieldPickerShowSampleValues?: boolean /* Boolean */; // Flags=IR
		/** Instance of FieldPickerWindow used if ListGrid.useAdvancedFieldPicker is set.
		 * Flags: IR */
		fieldPickerWindow?:  FieldPickerWindow /* AutoChild FieldPickerWindow */; // Flags=IR
		/** An array of field objects, specifying the order, layout, formatting, and sorting behavior of each field in the listGrid object. In ListGrids, the fields array specifies columns. Each field in the fields array is a ListGridField object. Any listGrid that will display data should have at least one visible field. If ListGrid.dataSource is also set, this value acts as a set of overrides as explained in DataBoundComponent.fields.
		 * Flags: IRW, Group: databinding */
		fields?: Array<ListGridField> /* Array of ListGridField */; // Flags=IRW
		/** Initial ListGridFieldState','field state for the grid. ListGrid.viewState can be used to initialize all view properties of the grid. When doing so, fieldState is not needed because viewState includes it as well. If both are provided, fieldState has priority for field state. To retrieve current state call ListGrid.getFieldState','getFieldState. 
		 * Flags: IRW, Group: viewState */
		fieldState?: string /* String */; // Flags=IRW
		/** If we're showing a ListGrid.showHeaderContextMenu','headerContextMenu for this grid, and ListGrid.canPickFields','this.canPickFields is true, this attribute will be shown as the title for the menu item which contains a submenu with items allowing the user to show and hide fields in the grid.
		 * Flags: IRW, Group: i18nMessages */
		fieldVisibilitySubmenuTitle?: string; // Flags=IRW
		/** The prompt to show when the mouse hovers over the Filter button in the FilterEditor.
		 * Flags: IR, Group: i18nMessages */
		filterButtonPrompt?: string /* String */; // Flags=IR
		/** If ListGrid.showFilterEditor is true, this attribute may be used to customize the filter button shown to the right of the filterEditor row.
		 * Flags: IR */
		filterButtonProperties?: ButtonProps /* Button properties */; // Flags=IR
		/** If we're showing the filterEditor (this.showFilterEditor is true), this property determines whether this list should be filtered every time the user puts focus in a different field in the filter editor.
		 * Flags: IRWA, Group: filterEditor */
		filterByCell?: boolean; // Flags=IRWA
		/** Height for the filterEditor, if shown.
		 * Flags: IRW, Group: filterEditor */
		filterEditorHeight?: number; // Flags=IRW
		/** Properties to apply to the automatically generated ListGrid.filterEditor if ListGrid.showFilterEditor is true.
		 * Flags: IR */
		filterEditorProperties?: RecordEditorProps /* RecordEditor properties */; // Flags=IR
		/** Causes filtering to be performed against the local data set, even when a ListGrid.dataSource is provided. When using this mode, data must be provided to the grid via ListGrid.setData, and must be provided as a simple Array of Records . Note that a ListGrid.dataSource must be provided for filtering to occur even when filtering locally. If this property is set to true, the supplied data is applied as the ResultSet.allRows','complete dataset of a ResultSet, which is then filtered according to the specified criteria, and the results displayed. If false, a normal databound fetch will occur, retrieving records that match the specified criteria from this component's ListGrid.dataSource. filterLocalData includes both calls to ListGrid.fetchData and ListGrid.filterData as well as automatic filtering when the ListGrid.filterEditor is enabled. If this property is not explicitly set, default behavior will filter against the dataSource unless the grid has a specified DataPath','dataPath, in which case filtering will occur locally. See also ListGrid.saveLocally to cause saves to ignore the DataSource and affect the local data set only.
		 * Flags: IRA */
		filterLocalData?: boolean; // Flags=IRA
		/** If we're showing the filterEditor (this.showFilterEditor is true), this property determines whether this list should be filtered every time the user modifies the value in a field of the filter-editor. Can also be set at the field level.
		 * Flags: IRWA, Group: filterEditor */
		filterOnKeypress?: boolean; // Flags=IRWA
		/** Text for the menu item shown in the ListGrid.showHeaderContextMenu','headerContextMenu when ListGrid.allowFilterOperators is enabled.
		 * Flags: IR, Group: i18nMessages */
		filterUsingText?: string /* String */; // Flags=IR
		/** Should we horizontally clip cell contents, or allow columns to expand horizontally to show all contents? If we allow columns to expand, the column width is treated as a minimum. NOTE: the header does not automatically respond to expanded field widths. If your grid is showing a header we'd recommend developers consider setting ListGrid.autoFitFieldWidths rather than using this attribute.
		 * Flags: IRWA, Group: cellStyling */
		fixedFieldWidths?: boolean /* Boolean */; // Flags=IRWA
		/** Should we vertically clip cell contents, or allow rows to expand vertically to show all contents? If we allow rows to expand, the row height as derived from GridRenderer.getRowHeight','getRowHeight() or the default ListGrid.cellHeight is treated as a minimum. Setting fixedRecordHeights to false enables the ListGrid.virtualScrolling system. NOTE: Setting fixedRecordHeights to false for CubeGrid is not supported, though a similar option for the row headers is available as CubeGrid.autoSizeHeaders. By default, for performance reasons, clipping is not enforced for some kinds of content (such as images) on all browsers. Set ListGrid.enforceVClipping','enforceVClipping:true to enforce clipping for all types of content on all browsers. 
		 * Flags: IRWA, Group: cellStyling */
		fixedRecordHeights?: boolean /* Boolean */; // Flags=IRWA
		/** If this grid has specified ListGrid.headerSpans','headerSpans, and ListGrid.showHeaderSpanTitlesInFormulaBuilder','showHeaderSpanTitlesInFormulaBuilder is true, this string will be inserted between the headerSpan title(s) and the field title in the field chooser grid in the FormulaBuilder and SummaryBuilder.
		 * Flags: IRW, Group: i18nMessages */
		formulaBuilderSpanTitleSeparator?: string /* String */; // Flags=IRW
		/** If we're showing a ListGrid.showHeaderContextMenu','headerContextMenu for this grid and ListGrid.canFreezeFields','this.canFreezeFields is true, this string will be shown as the title for the menu item to freeze a currently unfrozen field. This is a dynamic string - text within &#36;{...} will be evaluated as JS code when the message is displayed, with title available as a variable containing the field title. Default value returns "Freeze " + the field's summary title.
		 * Flags: IRWA, Group: i18nMessages */
		freezeFieldText?: string /* HTMLString */; // Flags=IRWA
		/** If we're showing a ListGrid.showHeaderContextMenu','headerContextMenu for this grid and ListGrid.canFreezeFields','this.canFreezeFields is true, this string will be shown as the title for the menu item to freeze fields on the left of the scrollable body.
		 * Flags: IRW, Group: i18nMessages */
		freezeOnLeftText?: string; // Flags=IRW
		/** If we're showing a ListGrid.showHeaderContextMenu','headerContextMenu for this grid and ListGrid.canFreezeFields','this.canFreezeFields is true, this string will be shown as the title for the menu item to freeze fields on the right of the scrollable body.
		 * Flags: IRW, Group: i18nMessages */
		freezeOnRightText?: string; // Flags=IRW
		/** If this listGrid contains any frozen fields, this property can be used to apply a custom baseStyle to all cells in those frozen fields. If unset, the standard base style will be used for both frozen and unfrozen cells.
		 * Flags: IRW, Group: appearance */
		frozenBaseStyle?: string; // Flags=IRW
		/** If this listGrid contains any frozen fields, this property can be used to apply a custom headerBaseStyle to the frozen set of fields. If unset, the standard headerBaseStyle will be used for both frozen and unfrozen cells.
		 * Flags: IR, Group: gridHeader */
		frozenHeaderBaseStyle?: string /* CSSStyleName */; // Flags=IR
		/** If this listGrid contains any frozen fields, this property can be used to apply a custom headerTitleStyle to the frozen set of fields. If unset, the standard headerTitleStyle will be used for both frozen and unfrozen cells.
		 * Flags: IR, Group: gridHeader */
		frozenHeaderTitleStyle?: string /* CSSStyleName */; // Flags=IR
		/** If true, when the user navigates to a cell using arrow keys and hits Enter, the cell will respond to a click event.
		 * Flags: IRWA */
		generateClickOnEnter?: boolean /* Boolean */; // Flags=IRWA
		/** If true, when the user navigates to a cell using arrow keys and hits space, the cell will respond to a click event.
		 * Flags: IRWA */
		generateClickOnSpace?: boolean /* Boolean */; // Flags=IRWA
		/** If true, when the user navigates to a cell using arrow keys and hits Enter, the cell will respond to a double click event.
		 * Flags: IRWA */
		generateDoubleClickOnEnter?: boolean /* Boolean */; // Flags=IRWA
		/** If true, when the user navigates to a cell using arrow keys and hits Space, the cell will respond to a double click event.
		 * Flags: IRWA */
		generateDoubleClickOnSpace?: boolean /* Boolean */; // Flags=IRWA
		/** Array of components that make up this grid. This array controls which standard and/or custom parts will be displayed within this ListGrid. ListGrid is a subclass of VLayout and consists of a number of member components. The standard set of members are automatically generated by the grid, and include (for example) the header (a Toolbar of buttons for each field) and the body (a GridRenderer displaying the actual data contained in the grid). The default value of gridComponents is an Array of ListGridComponents listing the standard components in their default order: gridComponents : ["filterEditor", "header", "body", "summaryRow"] You can override gridComponents to change the order of standard components. You can also omit standard components this way, although it more efficient to use the related "show" property if available (eg ListGrid.showFilterEditor). Note that this array must contain an entry for the "body" - listGrids with no body showing are unsupported. Advanced note: The live components generated for each of these standard ListGridComponent types may differ across different listGrids. For example if this grid has any ListGridField.frozen','frozen fields, the "body" entry will actually be created as an HLayout containing two GridRenderers (one for frozen fields, and one for unfrozen fields). This is really an implementation detail - the "body" entry in the gridComponents array simply specifies where the UI for the body should render within the ListGrid layout. By embedding a Canvas directly in this list you can add arbitrary additional components to the listGrid as members, and have them be displayed alongside the standard automatically generated parts of the ListGrid. Note that having added controls to gridComponents, you can still call APIs directly on those controls to change their appearance, and you can also show() and hide() them if they should not be shown in some circumstances. Tip: custom controls need to set layoutAlign:"center" to appear vertically centered.
		 * Flags: IR */
		gridComponents?: Array<any> /* Array of ListGridComponent | Array of any */; // Flags=IR
		/** If ListGrid.showGridSummary is true, this attribute will be set to true on the record object representing the grid summary row.
		 * Flags: IRW */
		gridSummaryRecordProperty?: string; // Flags=IRW
		/** When grouping is requested with this number of records or more, an asynchronous approach is used to avoid the browser showing a "script is running slowly.." message prompting the user to stop execution of JavaScript. Note that ListGrid.groupByMaxRecords must be set at least as high as ListGrid.groupByAsyncThreshold or asynchronous grouping will never be used. During async grouping, interactivity is blocked and the ListGrid.asynchGroupingPrompt is shown to the user, then hidden when grouping completes; ListGrid.groupByComplete then fires. Note that this async processing covers grouping only - it does not cover whole grid or per-group summaries, client-side sort or filter, or other operations that may cause the browser to show the "script is running slowly" prompt when working with very large sets of records in a grid. At this time, there is no generally effective way to avoid this warning dialog appearing with very large datasets in Microsoft's Internet Explorer (IE). IE's severely flawed detection algorithm for runaway scripts has been shown to interrupt computations after only 0.2 seconds elapsed time even if the computation would have finished in 0.3 seconds. Optimizations that reduce execution time can sometimes trigger the "script running slowly" dialog sooner. Since not every operation can reasonably be made asynchronous, the current recommendation is to avoid working with overly large datasets until the affected versions of IE are obsoleted.
		 * Flags: IRW */
		groupByAsyncThreshold?: number /* int */; // Flags=IRW
		/** List of fields to group grid records. If only a single field is used, that field may be specified as a string. After initialization, use ListGrid.groupBy to update the grouping field list, instead of modifying groupByField directly.
		 * Flags: IR, Group: grouping */
		groupByField?: Array<string> /* String | Array of String */; // Flags=IR
		/** If this grid is ListGrid.groupByField','grouped, and ListGrid.showGroupSummary is true, this attribute may be set to an array of groupBy field names for which group summaries should appear. This is particularly useful for listGrids grouped by more than one field as it allows developers to display the group summary for a particular nested group without showing a summary for every level of the tree.
		 * Flags: IRWA */
		groupByFieldSummaries?: Array<string> /* Array of String */; // Flags=IRWA
		/** Maximum number of records to which a groupBy can be applied. If there are more records, grouping will not be available via the default header context menu, and calls to ListGrid.groupBy will be ignored. The maximum exists because ListGrid grouping is performed in-browser, hence requires loading of all records that match the current filter criteria before records can be grouped. The default maximum represents a number of records which are safe to load in legacy browsers such as Internet Explorer 8 (modern browsers can handle far more), and is also a good upper limit from the perspective of loading data from a database. Going beyond this limit can cause "script running slowly" errors from legacy browsers (as well as high database load). To build an interface for grouping that handles arbitrary data volume, use a TreeGrid with TreeGrid.loadDataOnDemand with server-side grouping code.
		 * Flags: IRW, Group: grouping */
		groupByMaxRecords?: number /* int */; // Flags=IRW
		/** If we're showing a ListGrid.showHeaderContextMenu','headerContextMenu for this grid and ListGrid.canGroupBy','this.canGroupBy is true, this string will be shown as the title for the menu item to toggle the group by setting for a field. This is a dynamic string - text within &#36;{...} will be evaluated as JS code when the message is displayed, with title available as a variable containing the field title. Default value returns "Group by " + the field's summary title.
		 * Flags: IRWA, Group: i18nMessages */
		groupByText?: string /* HTMLString */; // Flags=IRWA
		/** The URL of the base icon for the group icons in this listGrid. Default value may be overridden by the skinning','current skin.
		 * Flags: IRW, Group: grouping */
		groupIcon?: string /* SCImgURL */; // Flags=IRW
		/** Default width and height of group icons for this ListGrid.
		 * Flags: IRW, Group: grouping */
		groupIconSize?: number /* Number */; // Flags=IRW
		/** Default number of pixels by which to indent subgroups relative to parent group.
		 * Flags: IRW, Group: grouping */
		groupIndentSize?: number /* Number */; // Flags=IRW
		/** Default number of pixels by which to indent all groups.
		 * Flags: IRW, Group: grouping */
		groupLeadingIndent?: number /* Number */; // Flags=IRW
		/** ListGrid.getBaseStyle','Base style for ListGrid.groupBy','group rows. Note that this property has no effect if ListGrid.groupNodeStyle is non null.
		 * Flags: IRW, Group: grouping */
		groupNodeBaseStyle?: string /* String */; // Flags=IRW
		/** The CSS style that ListGrid.groupBy','group rows will have. Note that this is not a ListGrid.getBaseStyle','base style, so, if this property is set, group nodes will not show stateful styling (different styles for ListGrid.showRollOver, ListGrid.alternateRecordStyles, etc). To enable stateful styling for groupNodes, set this property to null and specify a ListGrid.groupNodeBaseStyle
		 * Flags: IRW, Group: grouping */
		groupNodeStyle?: string /* String */; // Flags=IRW
		/** When ListGrid.sortByGroupFirst is active, the sorting direction applied for implicit sorting by the field(s) used for grouping. Default of null means that sort direction is based on the current direction of user-configured sort, or is "ascending" if the user has not sorted the data.
		 * Flags: IRW, Group: sorting */
		groupSortDirection?: SortDirection; // Flags=IRW
		/** Describes the default state of ListGrid groups when groupBy is called. Possible values are: "all": open all groups "first": open the first group "none": start with all groups closed Array of group values that should be opened 
		 * Flags: IRW, Group: grouping */
		groupStartOpen?: GroupStartOpen | Array<any> /* GroupStartOpen | Array */; // Flags=IRW
		/** Initial group state for the grid. ListGrid.viewState can be used to initialize all view properties of the grid. When doing so, groupState is not needed because viewState includes it as well. If both are provided, groupState has priority for group state. To retrieve current state call ListGrid.getGroupState','getGroupState. 
		 * Flags: IRW, Group: viewState */
		groupState?: string /* ListGridGroupState */; // Flags=IRW
		/** If ListGrid.showGroupSummary is true, this attribute will be set to true on each record object representing a group-level summary row.
		 * Flags: IRW */
		groupSummaryRecordProperty?: string; // Flags=IRW
		/** ListGridRecord.customStyle for the group-level summary row displayed when ListGrid.showGroupSummary is true.
		 * Flags: IR */
		groupSummaryStyle?: string /* CSSStyleName */; // Flags=IR
		/** Default properties for the automatically generated groupTitleColumn. Default object includes properties to enable autoFitWidth to group title values. To modify the behavior or appearance of this column, developers may set ListGrid.groupTitleColumnProperties at the instance level, or override this object at the class level. If overriding this object, we recommend using Class.changeDefaults rather than replacing this object entirely. See ListGrid.showGroupTitleColumn for an overview of the groupTitleColumn.
		 * Flags: IR */
		groupTitleColumnDefaults?: ListGridField /* ListGridField properties */; // Flags=IR
		/** Custom properties for the automatically generated groupTitleColumn. See ListGrid.showGroupTitleColumn for an overview of the groupTitleColumn.
		 * Flags: IR */
		groupTitleColumnProperties?: ListGridField /* ListGridField properties */; // Flags=IR
		/** When a list grid is ListGrid.groupBy','grouped, each group shows under an auto generated header node. By default the title of the group will be shown, with a hanging indent in this node, and will span all columns in the grid. Setting this property causes the titles of auto-generated group nodes to appear as though they were values of the designated field instead of spanning all columns and record values in the designated groupTitleField will appear indented under the group title in a manner similar to how a TreeGrid shows a Tree. Note if ListGrid.showGroupSummaryInHeader is true, the header nodes will not show a single spanning title value by default - instead they will show the summary values for each field. In this case, if groupTitleField is unset, a ListGrid.showGroupTitleColumn','groupTitleColumn can be automatically generated to show the title for each group.
		 * Flags: IR, Group: grouping */
		groupTitleField?: string /* String */; // Flags=IR
		/** Event on a ListGrid header that triggers auto fitting to data and/or title. Note that if sorting is enabled for the field and the headerAutoFitEvent is "click", both sorting and autofit occur on a click. Only has an impact when ListGrid.canAutoFitFields or ListGridField.canAutoFitWidth is set to true.
		 * Flags: IR, Group: autoFitFields */
		headerAutoFitEvent?: AutoFitEvent; // Flags=IR
		/** BackgroundColor for the header toolbar. Typically this is set to match the color of the header buttons.
		 * Flags: IRW, Group: gridHeader */
		headerBackgroundColor?: string /* CSSColor */; // Flags=IRW
		/** Set the CSS style used for the header as a whole.
		 * Flags: IR, Group: gridHeader */
		headerBarStyle?: string /* CSSStyleName */; // Flags=IR
		/** Button.baseStyle to apply to the buttons in the header, and the sorter, for this ListGrid. Note that, depending on the ListGrid.headerButtonConstructor','Class of the header buttons, you may also need to set ListGrid.headerTitleStyle.
		 * Flags: IR, Group: gridHeader */
		headerBaseStyle?: string /* CSSStyleName */; // Flags=IR
		/** Widget class for this ListGrid's header buttons. If unset, constructor will be picked up directly from the standard Toolbar button constructor.
		 * Flags: IR, Group: gridHeader */
		headerButtonConstructor?: Class; // Flags=IR
		/** Defaults to apply to all header buttons. To modify this object, use Class.changeDefaults','ListGrid.changeDefaults() rather than replacing with an entirely new object.
		 * Flags: IRA, Group: gridHeader */
		headerButtonDefaults?: ButtonProps /* Button Properties */; // Flags=IRA
		/** Properties to apply to all header buttons. Overrides defaults applied via ListGrid.headerButtonDefaults.
		 * Flags: IRA, Group: gridHeader */
		headerButtonProperties?: ButtonProps /* Button Properties */; // Flags=IRA
		/** The height of this listGrid's header, in pixels.
		 * Flags: IRW, Group: gridHeader */
		headerHeight?: number; // Flags=IRW
		/** This property may be set to customize the alignment for the hover shown on ListGrid.headerHover.
		 * Flags: IRW */
		headerHoverAlign?: Alignment; // Flags=IRW
		/** Optional default height for the hover shown on ListGrid.headerHover.
		 * Flags: IRW */
		headerHoverHeight?: number /* Integer */; // Flags=IRW
		/** This property may be set to customize the opacity for the hover shown on ListGrid.headerHover.
		 * Flags: IRW */
		headerHoverOpacity?: number /* Integer */; // Flags=IRW
		/** This property may be set to customize the css style for the hover shown on ListGrid.headerHover.
		 * Flags: IRW */
		headerHoverStyle?: string /* CSSStyleName */; // Flags=IRW
		/** This property may be set to customize the vertical alignment for the hover shown on ListGrid.headerHover.
		 * Flags: IRW */
		headerHoverVAlign?: VerticalAlignment; // Flags=IRW
		/** Optional default width for the hover shown on ListGrid.headerHover.
		 * Flags: IRW */
		headerHoverWidth?: number /* Integer */; // Flags=IRW
		/** This property may be set to customize the wrap attribute for the hover shown on ListGrid.headerHover.
		 * Flags: IRW */
		headerHoverWrap?: boolean /* Boolean */; // Flags=IRW
		/** Constructor for the ListGrid.headerMenuButton. If unset a standard "Button" will be rendered out. Note that this property may be overridden by different skins.
		 * Flags: IRA, Group: headerMenuButton */
		headerMenuButtonConstructor?: string /* className */; // Flags=IRA
		/** If ListGrid.showHeaderMenuButton is true, this property governs the height of the auto-generated headerMenuButton
		 * Flags: IRA, Group: headerMenuButton */
		headerMenuButtonHeight?: any /* measure */; // Flags=IRA
		/** If ListGrid.showHeaderMenuButton is true, this property governs the icon shown on the auto-generated headerMenuButton
		 * Flags: IRA, Group: headerMenuButton */
		headerMenuButtonIcon?: string /* URL */; // Flags=IRA
		/** If ListGrid.showHeaderMenuButton is true, this property governs the height of the icon shown on the auto-generated headerMenuButton
		 * Flags: IRA, Group: headerMenuButton */
		headerMenuButtonIconHeight?: number; // Flags=IRA
		/** If ListGrid.showHeaderMenuButton is true, this property governs the width of the icon shown on the auto-generated headerMenuButton
		 * Flags: IRA, Group: headerMenuButton */
		headerMenuButtonIconWidth?: number; // Flags=IRA
		/** If ListGrid.showHeaderMenuButton is true, this property governs the width of the auto-generated headerMenuButton
		 * Flags: IRA, Group: headerMenuButton */
		headerMenuButtonWidth?: number; // Flags=IRA
		/** If ListGrid.showHeaderShadow is true, the Canvas.shadowColor for the header shadow.
		 * Flags: IRA */
		headerShadowColor?: string /* CSSColor */; // Flags=IRA
		/** If ListGrid.showHeaderShadow is true, the Canvas.shadowHOffset for the header shadow
		 * Flags: IRA */
		headerShadowHOffset?: number /* Number */; // Flags=IRA
		/** If ListGrid.showHeaderShadow is true, the Canvas.shadowSoftness for the header shadow
		 * Flags: IRA */
		headerShadowSoftness?: number /* Number */; // Flags=IRA
		/** If ListGrid.showHeaderShadow is true, the Canvas.shadowVOffset for the header shadow
		 * Flags: IRA */
		headerShadowVOffset?: number /* Number */; // Flags=IRA
		/** ListGrid.headerSpans','headerSpans are created via the AutoChild pattern, hence headerSpanConstructor, headerSpanDefaults and headerSpanProperties are valid.
		 * Flags: IR, Group: headerSpan */
		headerSpan?:  StatefulCanvas /* MultiAutoChild StatefulCanvas */; // Flags=IR
		/** SCClassName','SmartClient Class to use for headerSpans. Typically a Button or StretchImgButton subclass. If unset, headerSpans will be created using the ListGrid.headerButtonConstructor.
		 * Flags: IR, Group: headerSpan */
		headerSpanConstructor?: string /* SCClassName */; // Flags=IR
		/** Default height for a ListGrid.headerSpans','headerSpan with no height specified. If headerSpanHeight is not specified (the default), headerSpans will be 1/2 of ListGrid.headerHeight.
		 * Flags: IR, Group: headerSpan */
		headerSpanHeight?: number /* integer */; // Flags=IR
		/** Header spans are a second level of headers that appear above the normal ListGrid headers, spanning one or more listGrid fields in a manner similar to a column-spanning cell in an HTML table. A header span can be created by simply naming the fields the header should span. The example below creates a headerSpan that spans the first two fields of the ListGrid. isc.ListGrid.create({ headerHeight:40, fields : [ { name:"field1" }, { name:"field2" }, { name:"field3" } ], headerSpans : [ { fields: ["field1", "field2"], title: "Field 1 and 2" } ] }); Header spans can be nested, allowing fields to be grouped by multiple levels of granularity. See HeaderSpan.spans for further information on nesting spans. Header spans will automatically react to resizing of the headers they span, and will be hidden automatically when all of the spanned fields are hidden. Header spans appear in the ListGrid.header','header area of the ListGrid, sharing space with the existing headers, so it's typical to set ListGrid.headerHeight to approximately double its normal height when using headerSpans, or if using nested header spans, the default header height multiplied by the number of levels of header spans to be shown. See HeaderSpan for many properties that allow the control of the appearance of headerSpans. Note that headerSpans are created via the AutoChild pattern, hence you can change the SmartClient component being used, or any of its properties. Neither headerSpans themselves nor the fields within them may be drag reordered, but other unspanned headers may be. A span can only span adjacent fields - if a span is defined and the spanned fields don't sit next to each other in the specified fields array, the fields array will be automatically reordered to match the order specified in the span's HeaderSpan.fields array. Note that headerSpans primarily provide a visual cue for grouping multiple headers together. If you have an OLAP, data "cube" or multi-dimensional data model, the CubeGrid component is the right choice.
		 * Flags: IRW, Group: headerSpan */
		headerSpans?: Array<HeaderSpan> /* Array of HeaderSpan */; // Flags=IRW
		/** Default alignment for ListGrid.headerSpans','headerSpans with no HeaderSpan.valign specified.
		 * Flags: IR, Group: headerSpan */
		headerSpanVAlign?: string /* vAlign */; // Flags=IR
		/** StretchImgButton.titleStyle to apply to the buttons in the header, and the sorter, for this ListGrid. Note that this will typically only have an effect if ListGrid.headerButtonConstructor is set to StretchImgButton or a subclass thereof.
		 * Flags: IR, Group: gridHeader */
		headerTitleStyle?: string /* CSSStyleName */; // Flags=IR
		/** If true, causes the ListGrid.summaryRow','summaryRow component to be hidden if it has no data after summaries have been recalculated
		 * Flags: IRW */
		hideEmptySummaryRow?: boolean /* Boolean */; // Flags=IRW
		/** If set, end users can create advanced hiliting rules that will use the Hilite.replacementValue feature to cause values in hilited cells to be replaced with a user-entered value. For example, a user could create a hilite rule that replaces numeric values ranging from 0.5 to 1.0 with the text "LOW". Specifically, when the "Add Advanced Rule" button is pressed and hiliteCanReplaceValue is true, the user will see a text entry field titled "Replace value with" (ListGrid.hiliteReplaceValueFieldTitle) and if they enter a value, that value will appear in the grid cell in lieu of the cell's original value.
		 * Flags: IR, Group: hiliting */
		hiliteCanReplaceValue?: boolean; // Flags=IR
		/** If this grid has specified ListGrid.headerSpans, and ListGrid.showHeaderSpanTitlesInHiliteEditor is true, this string will be inserted between the headerSpan title and the field title in the hiliteEditor field chooser grid.
		 * Flags: IRW, Group: i18nMessages */
		hiliteEditorSpanTitleSeparator?: string /* String */; // Flags=IRW
		/** If set to true, custom HTML applied as part of hiliting will be applied after ListGrid.formatCellValue','formatting for each cell. If false, hilite HTML will be applied before formatting. This applies to the following hilite properties: Hilite.replacementValue Hilite.htmlBefore Hilite.htmlAfter Hilite.htmlValue May be overridden per field via ListGridField.hiliteHTMLAfterFormat
		 * Flags: IR */
		hiliteHTMLAfterFormat?: boolean; // Flags=IR
		/** Height for hilite icons for this listGrid. Overrides ListGrid.hiliteIconSize','hiliteIconSize. Can be overridden at the field level
		 * Flags: IRW, Group: hiliting */
		hiliteIconHeight?: number; // Flags=IRW
		/** How much padding should there be on the left of ListGrid.hiliteIcons','hilite icons by default? Can be overridden at the field level
		 * Flags: IRW, Group: hiliting */
		hiliteIconLeftPadding?: number; // Flags=IRW
		/** When ListGrid.hiliteIcons','hiliteIcons are present, where the hilite icon will be placed relative to the field value. See HiliteIconPosition. Can be overridden at the field level.
		 * Flags: IR, Group: hiliting */
		hiliteIconPosition?: HiliteIconPosition; // Flags=IR
		/** How much padding should there be on the right of ListGrid.hiliteIcons','hilite icons by default? Can be overridden at the field level
		 * Flags: IRW, Group: hiliting */
		hiliteIconRightPadding?: number; // Flags=IRW
		/** Specifies a list of icons that can be used in DataBoundComponent.editHilites','hilites. hiliteIcons should be specified as an Array of SCImgURL. When present, the hilite editing interface shown when DataBoundComponent.editHilites is called will offer the user a drop down for picking one of these icons when defining either a simple or advanced hilite rule. If the user picks an icon, the created hiliting rule will have Hilite.icon set to the chosen icon. DataBoundComponent.hiliteIconPosition controls where the icon will appear for that field -- the default is that it appears in front of the normal cell content. This can also be overridden at the field level.
		 * Flags: IR, Group: hiliting */
		hiliteIcons?: Array<string> /* Array of String */; // Flags=IR
		/** Default width and height of ListGrid.hiliteIcons','hilite icons for this component. Can be overridden at the component level via explicit ListGrid.hiliteIconWidth','hiliteIconWidth and ListGrid.hiliteIconHeight','hiliteIconHeight, or at the field level via ListGridField.hiliteIconSize','hiliteIconSize, ListGridField.hiliteIconWidth','hiliteIconWidth and ListGridField.hiliteIconHeight','hiliteIconHeight
		 * Flags: IRW, Group: hiliting */
		hiliteIconSize?: number; // Flags=IRW
		/** Width for hilite icons for this component. Overrides ListGrid.hiliteIconSize','hiliteIconSize. Can be overridden at the field level.
		 * Flags: IRW, Group: hiliting */
		hiliteIconWidth?: number; // Flags=IRW
		/** Title used for the text box shown when ListGrid.hiliteCanReplaceValue is set.
		 * Flags: IR, Group: i18nMessages */
		hiliteReplaceValueFieldTitle?: string; // Flags=IR
		/** When the grid body gets keyboard focus, should we highlight the current focus row, using the rollover cell style? This property may be explicitly set to control this behavior independently of ListGrid.showRollOver. Otherwise (if this property is null), we will show the roll-over styling for the keyboard focus row if ListGrid.showRollOver is true.
		 * Flags: IRW */
		hiliteRowOnFocus?: boolean /* Boolean */; // Flags=IRW
		/** When ListGrid.showHoverComponents','showHoverComponents is true, the builtin mode to use when automatically creating a hover component for rows in this grid. A number of builtin modes are provided - see HoverMode. You can also override ListGrid.getCellHoverComponent','getCellHoverComponent() to provide a custom hover widget - in that case, this attribute is ignored.
		 * Flags: IRWA, Group: hoverComponents */
		hoverMode?: HoverMode; // Flags=IRWA
		/** Style to apply to hovers shown over this grid.
		 * Flags: IRWA, Group: hovers */
		hoverStyle?: string /* CSSStyleName */; // Flags=IRWA
		/** When using ListGrid.autoFitFieldWidths, padding in pixels left on each side of fields that show images.
		 * Flags: IR */
		iconPadding?: number /* integer */; // Flags=IR
		/** Default size of thumbnails shown for fieldTypes image and imageFile. Overrideable on a per-field basis via ListGridField.imageSize or ListGridField.imageWidth/ListGridField.imageHeight
		 * Flags: IRW, Group: imageColumns */
		imageSize?: number; // Flags=IRW
		/** When assembling a value for a ListGrid.canAddSummaryFields','summary field, if a referenced field is hilited, should the hilite HTML be included in the summary field value? To control hilites showing in group summaries, see ListGrid.showHilitesInGroupSummary','showHilitesInGroupSummary.
		 * Flags: IRWA */
		includeHilitesInSummaryFields?: boolean; // Flags=IRWA
		/** Property name on a record that will be checked to determine whether a record should be included when calculating totals for the ListGrid.showGridSummary','grid summary.
		 * Flags: IRW */
		includeInSummaryProperty?: string; // Flags=IRW
		/** Criteria to be used when ListGrid.autoFetchData is set. This property supports dynamicCriteria - use Criterion.valuePath to refer to values in the Canvas.ruleScope.
		 * Flags: IR, Group: searchCriteria */
		initialCriteria?: Criteria; // Flags=IR
		/** An array of SortSpecifier objects used to set up the initial sort configuration for this grid. If specified, this will be used instead of any ListGrid.sortField specified.
		 * Flags: IR, Group: sorting */
		initialSort?: Array<SortSpecifier> /* Array of SortSpecifier */; // Flags=IR
		/** If true, if the user clicks on the scroll buttons at the end of the track or clicks once on the scroll track, there will be an instant redraw of the grid content so that the user doesn't see any blank space. For drag scrolling or other types of scrolling, the ListGrid.scrollRedrawDelay applies.
		 * Flags: IRW, Group: performance */
		instantScrollTrackRedraw?: boolean /* Boolean */; // Flags=IRW
		/** Value to display to the user if showing summary values (through ListGrid.showGridSummary, ListGrid.showGroupSummary or ListGridFieldType','listGridFieldType:"summary"), and the summary function returns "null" (implying it was unable to calculate a valid summary value). This property will only be used in the default formatting behavior. If an explicit formatter has been specified - via ListGrid.formatCellValue or ListGridField.formatGridSummary','formatGridSummary(), for example - this property has no effect.
		 * Flags: IRWA */
		invalidSummaryValue?: string; // Flags=IRWA
		/** If record[this.isSeparatorProperty] is set for some record, the record will be displayed as a simple separator row.
		 * Flags: IRW */
		isSeparatorProperty?: string; // Flags=IRW
		/** If ListGrid.showHeaderMenuButton is true, when auto-fitting fields to the title width via ListGrid.autoFitFieldWidths or ListGridField.autoFitWidth, should the button be sized such that there is enough space for the header menu button to show without covering the field title? May be explicitly specified at the ListGridField.leaveHeaderMenuButtonSpace','field level or at the ListGrid.leaveHeaderMenuButtonSpace','grid level. If not explicitly specified space will be left for fields with ListGridField.align set to "left" or "right", but not for fields with align set to "center".
		 * Flags: IWA, Group: headerMenuButton */
		leaveHeaderMenuButtonSpace?: boolean; // Flags=IWA
		/** Whether to leave a gap for the vertical scrollbar, even when it's not present. Note that if leaveScrollbarGap is false and vertical scrolling is introduced, fields will be resized to fit the smaller body area if possible, in order to avoid horizontal scrolling also being required.
		 * Flags: IRW, Group: appearance */
		leaveScrollbarGap?: boolean /* Boolean */; // Flags=IRW
		/** Property name on a record that will hold the link text for that record. This property is configurable to avoid possible collision with data values in the record. Use ListGridField.linkTextProperty if you have more than one link field and
		 * Flags: IRW, Group: display_values */
		linkTextProperty?: string; // Flags=IRW
		/** If the user is editing the last record in this listGrid, and attempts to navigate beyond the last row either by tabbing off the last editable field, or using the down arrow key, this property determines what action to take: "next": start editing a new record at the end of the list. "done": hide the editor "stop": leave focus in the cell being edited "none": no action See the editing','Grid Editing overview and also the unsavedRecords','Editing Unsaved Records overview for context about how newly added records behave.
		 * Flags: IRW, Group: editing */
		listEndEditAction?: RowEndEditAction; // Flags=IRW
		/** The string to display in the body of a listGrid while data is being loaded. Use "&#36;{loadingImage}" to include Canvas.loadingImageSrc','a loading image.
		 * Flags: IRW, Group: emptyMessage */
		loadingDataMessage?: string /* HTMLString */; // Flags=IRW
		/** The CSS style name applied to the loadingDataMessage string if displayed.
		 * Flags: IRW, Group: emptyMessage */
		loadingDataMessageStyle?: string /* CSSStyleName */; // Flags=IRW
		/** If you have a databound listGrid and you scroll out of the currently loaded dataset, by default you will see blank rows until the server returns the data for those rows. The loadingMessage attribute allows you to specify arbitrary html that will be shown in each such "blank" record while the data for that record is loading.
		 * Flags: IR, Group: emptyMessage */
		loadingMessage?: string; // Flags=IR
		/** When AutoTest.getElement is used to parse locator strings generated by AutoTest.getLocator for a cell in this grid, how should the column be identified? Note that getLocator() will actually store all available information about the column in the generated string -- this attribute effects how a stored string will be parsed only. Valid options area: "fieldName" Attempt to identify by fieldName. "index" Attempt to identify by colNum (index in the fields array). If unset, default behavior is to identify by fieldName (if available), otherwise by index.
		 * Flags: IRW, Group: autoTest */
		locateColumnsBy?: string; // Flags=IRW
		/** When AutoTest.getElement is used to parse locator strings generated by AutoTest.getLocator for a cell in this grid, how should the row be identified? Note that getLocator() will actually store all available information about the row in the generated string -- this attribute effects how a stored string will be parsed only. Valid options area: "primaryKey" Only applies to databound grids: If the cell in question has a primary key cell value, use it to identify cells in autoTest locator strings. "titleField" If the cell in question has a value for the ListGrid.getTitleField','titleField, use it to identify cells in autoTest locator strings "targetCellValue" Identify rows by storing the cell value for the target row / field in autoTest locator strings "index"The rowNum will be used to identify the row. If unset, default behavior is to identify by primary key (if available), otherwise by titleField (if available), otherwise by cell value (if available), and lastly by index.
		 * Flags: IRW, Group: autoTest */
		locateRowsBy?: string; // Flags=IRW
		/** When the length of the field specified by DataSourceField.length exceeds this value, the ListGrid shows an edit field of type ListGrid.longTextEditorType rather than the standard text field when the field enters inline edit mode.
		 * Flags: IRW, Group: editing */
		longTextEditorThreshold?: number /* int */; // Flags=IRW
		/** When the length of the field specified by DataSourceField.length exceeds this.longTextEditorThreshold show an edit field of this type rather than the standard text field when the field enters inline edit mode.
		 * Flags: IRW, Group: editing */
		longTextEditorType?: string; // Flags=IRW
		/** When ListGrid.canExpandRecords and ListGrid.canExpandMultipleRecords are both true, this property dictates the number of records which can be expanded simultaneously. If the expanded record count hits the value of this property, further attempts to expand records will result in a popup warning (see ListGrid.maxExpandedRecordsPrompt) and expansion will be cancelled. The default value is null, meaning there is no limit on the number of expanded records.
		 * Flags: IRWA, Group: expansionField */
		maxExpandedRecords?: number /* integer */; // Flags=IRWA
		/** This is a dynamic string - text within &#36;{...} will be evaluated as JS code when the message is displayed. Note that the local variable count will be available and set to this.maxExpandedRecords. The string will be executed in the scope of the ListGrid so this may also be used to determine other information about this grid. Default value returns This grid is limited to [ListGrid.maxExpandedRecords] simultaneously expanded records. Please collapse some expanded records and retry. 
		 * Flags: IR, Group: i18nMessages */
		maxExpandedRecordsPrompt?: string /* HTMLString */; // Flags=IR
		/** Minimum size, in pixels, for ListGrid headers.
		 * Flags: IRW */
		minFieldWidth?: number /* int */; // Flags=IRW
		/** If a summary format string contains an invalid field reference, replace the reference with the missingSummaryFieldValue. The default value is "-".
		 * Flags: IRW, Group: summaryFields */
		missingSummaryFieldValue?: string /* String */; // Flags=IRW
		/** If this property is true, any mouse click outside of the open cell editors will end editing mode, hiding the cell editors and saving any changes to those cell values.
		 * Flags: IRWA, Group: editing */
		modalEditing?: boolean; // Flags=IRWA
		/** Class level defaults to apply to the MultiSortDialog which gets automatically generated when DataBoundComponent.askForSort is called. See also ListGrid.showHeaderSpanTitlesInSortEditor and ListGrid.sortEditorSpanTitleSeparator
		 * Flags: IR */
		multiSortDialogDefaults?: MultiSortDialogProps /* MultiSortDialog properties */; // Flags=IR
		/** Properties to apply to the MultiSortDialog which gets automatically generated when DataBoundComponent.askForSort is called. See also ListGrid.showHeaderSpanTitlesInSortEditor and ListGrid.sortEditorSpanTitleSeparator
		 * Flags: IR */
		multiSortDialogProperties?: MultiSortDialogProps /* MultiSortDialog properties */; // Flags=IR
		/** If ListGrid.canSelectCells is true, this property allows the user to navigate through the cells of a grid using Tab and Shift+Tab keypresses. When a user tabs to the end of the row, the ListGrid.rowEndEditAction is used to determine whether to shift selection to the next row, return to the beginning of the same row, or simply move on through the page's tab order.
		 * Flags: IRW */
		navigateOnTab?: boolean; // Flags=IRW
		/** If true, validation will not occur as a result of cell editing for this grid.
		 * Flags: IRWA, Group: gridValidation */
		neverValidate?: boolean; // Flags=IRWA
		/** "Normal" baseStyle for this listGrid. Only applies if ListGrid.baseStyle is set to null. If baseStyle is unset, this property will be used as a base cell style if the grid is showing fixed height rows, and the specified cellHeight matches ListGrid.normalCellHeight (and in Internet Explorer, ListGrid.fastCellUpdates is false). Otherwise ListGrid.tallBaseStyle will be used. Having separate styles defined for fixed vs. variable height rows allows the developer to specify css which is designed to render at a specific height (typically using background images, which won't scale), without breaking support for styling rows of variable height. See cellStyleSuffixes for details on how stateful suffixes are combined with the base style to generate stateful cell styles.
		 * Flags: IR */
		normalBaseStyle?: string /* CSSStyleName */; // Flags=IR
		/** If ListGrid.baseStyle is unset, base style will be derived from ListGrid.normalBaseStyle if this grid has fixed row heights and the specified ListGrid.cellHeight matches this value. Otherwise ListGrid.tallBaseStyle will be used.
		 * Flags: IRWA */
		normalCellHeight?: number; // Flags=IRWA
		/** Default alias to use for groups with no value
		 * Flags: IRW, Group: grouping */
		nullGroupTitle?: string /* String */; // Flags=IRW
		/** The CSS style name applied to the DataBoundComponent.offlineMessage','offlineMessage if displayed.
		 * Flags: IRW, Group: offlineGroup */
		offlineMessageStyle?: string /* CSSStyleName */; // Flags=IRW
		/** Inline icon shown inside ListGrid.showFilterEditor','filter editor fields when ListGrid.allowFilterOperators is enabled.
		 * Flags: I */
		operatorIcon?:  FormItemIcon /* MultiAutoChild FormItemIcon */; // Flags=I
		/** Name of a CSS Style to use as the ListGrid.baseStyle for a cell that is currently a selection origin for shifted incremental cell selection. Only has an effect if ListGrid.canSelectCells is true. 
		 * Flags: IRW */
		originBaseStyle?: string /* CSSStyleName */; // Flags=IRW
		/** Since ListGrid.body is configured with overflow: auto by default, no overflow is expected for the ListGrid itself so by default it has overflow: hidden.
		 * Flags: IRW */
		overflow?: Overflow; // Flags=IRW
		/** Should recycled ListGrid.showRecordComponents','record components, be pooled per column or per record. Only applies if ListGrid.showRecordComponentsByCell is true. When ListGrid.recordComponentPoolingMode is "recycle" and you have components of different types in different columns, set this property to true to ensure that components intended for one column are not recycled for use in another column that should have a different component. If no components applicable to a particular column are available in the pool, the system calls ListGrid.createRecordComponent','createRecordComponent.
		 * Flags: IRW */
		poolComponentsPerColumn?: boolean /* Boolean */; // Flags=IRW
		/** Whether cell contents should wrap during printing. Equivalent to Autofit, but specific to printed output.
		 * Flags: IRW, Group: printing */
		printAutoFit?: boolean /* Boolean */; // Flags=IRW
		/** Style for non-header cells in printed output. Defaults to ListGrid.baseStyle if null.
		 * Flags: IRW, Group: printing */
		printBaseStyle?: string /* CSSStyleName */; // Flags=IRW
		/** If set, the ListGrid.booleanBaseStyle','booleanBaseStyle to use when printing','printing.
		 * Flags: IRA, Group: imageColumns */
		printBooleanBaseStyle?: string /* CSSStyleName */; // Flags=IRA
		/** If set, the ListGrid.booleanFalseImage to use when printing','printing. If this, ListGrid.printBooleanTrueImage and ListGrid.printBooleanPartialImage are unset, this will be set to the default CheckboxItem.printUncheckedImage.
		 * Flags: IRWA, Group: imageColumns */
		printBooleanFalseImage?: string /* SCImgURL */; // Flags=IRWA
		/** If set, the ListGrid.booleanPartialImage to use when printing','printing. If this, ListGrid.printBooleanTrueImage and ListGrid.printBooleanFalseImage are unset, this will be set to the default CheckboxItem.printPartialSelectedImage.
		 * Flags: IRWA, Group: imageColumns */
		printBooleanPartialImage?: string /* SCImgURL */; // Flags=IRWA
		/** If set, the ListGrid.booleanTrueImage to use when printing','printing. If this, ListGrid.printBooleanFalseImage and ListGrid.printBooleanPartialImage are unset, this will be set to the default CheckboxItem.printCheckedImage.
		 * Flags: IRWA, Group: imageColumns */
		printBooleanTrueImage?: string /* SCImgURL */; // Flags=IRWA
		/** If set, the ListGrid.checkboxFieldFalseImage to use when printing','printing.
		 * Flags: IRWA, Group: checkboxField */
		printCheckboxFieldFalseImage?: string /* SCImgURL */; // Flags=IRWA
		/** If set, the ListGrid.checkboxFieldPartialImage to use when printing','printing.
		 * Flags: IRWA, Group: checkboxField */
		printCheckboxFieldPartialImage?: string /* SCImgURL */; // Flags=IRWA
		/** If set, the ListGrid.checkboxFieldTrueImage to use when printing','printing.
		 * Flags: IRWA, Group: checkboxField */
		printCheckboxFieldTrueImage?: string /* SCImgURL */; // Flags=IRWA
		/** Style for header cells in printed output. Defaults to ListGrid.headerBaseStyle if null.
		 * Flags: IRW, Group: printing */
		printHeaderStyle?: string /* CSSStyleName */; // Flags=IRW
		/** Advanced property - when generating printHTML for a large ListGrid, rows are printed in batches in order to avoid triggering a native "script is running slowly" browser dialog. For grids with exceptional numbers of columns or complex formatting logic, this number might need to be adjusted downward.
		 * Flags: IRWA, Group: printing */
		printMaxRows?: number /* int */; // Flags=IRWA
		/** Whether cell contents should wrap during printing. Equivalent to ListGrid.wrapCells, but specific to printed output.
		 * Flags: IRW, Group: printing */
		printWrapCells?: boolean /* Boolean */; // Flags=IRW
		/** Alternative to ListGrid.drawAheadRatio, to be used when the user is rapidly changing the grids viewport (for example drag scrolling through the grid). If unspecified ListGrid.drawAheadRatio will be used in all cases
		 * Flags: IRW, Group: performance */
		quickDrawAheadRatio?: number /* float */; // Flags=IRW
		/** This attribute allows custom base styles to be displayed on a per-record basis. To specify a custom base-style for some record set record[listGrid.recordBaseStyleProperty] to the desired base style name - for example if recordBaseStyleProperty is "_baseStyle", set record._baseStyle to the custom base style name.
		 * Flags: IRWA, Group: appearance */
		recordBaseStyleProperty?: string; // Flags=IRWA
		/** If set to false on a record and ListGrid.canRemoveRecords','canRemoveRecords is true, removal of that record is disallowed in the UI. The icon in the remove field is not shown.
		 * Flags: IRA, Group: editing */
		recordCanRemoveProperty?: string /* String */; // Flags=IRA
		/** If set to false on a record, selection of that record is disallowed.
		 * Flags: IRA */
		recordCanSelectProperty?: string /* String */; // Flags=IRA
		/** If ListGrid.showRecordComponents is true, this attribute may be used to specify a standard height for record components. If specified every row in the grid will be sized tall enough to accommodate a recordComponent of this size. Note that if this property is unset, the grid will not be able to know row heights in advance, and ListGridField.frozen','frozen fields are not currently supported in this case. If you are putting a recordComponent in every row, and they all have a consistent height, set recordComponentHeight and you will then be able to use frozen fields and avoid the whitespace side-effect of virtual scrolling by setting ListGrid.virtualScrolling:false. Similarly, if your recordComponents are never tall enough that they will expand the row beyond the ListGrid.cellHeight, set ListGrid.virtualScrolling:false to avoid the whitespace side-effect of ListGrid.virtualScrolling','virtual scrolling and to allow ListGridField.frozen','frozen fields to be used. In this mode, you can have recordComponents on some rows but not others, and recordComponents of different heights, so long as no recordComponent ever causes a row to grow beyond ListGrid.cellHeight (which would happen if the recordComponents height + 2*ListGrid.cellPadding is larger than ListGrid.cellHeight).
		 * Flags: IRWA */
		recordComponentHeight?: number /* Integer */; // Flags=IRWA
		/** The method of RecordComponentPoolingMode','component-pooling to employ for ListGrid.showRecordComponents','recordComponents. The default mode is "viewport", which means that recordComponents are destroyed as soon their record is no longer being rendered (scrolled out of the viewport, eliminated by search criteria, etc). For a large or dynamic data set where the components shown on different rows are similar, switch to "recycle" mode, which pools recordComponents by detaching them from records that are not visible and re-using them in other records. In this mode, you should implement ListGrid.updateRecordComponent to apply any changes to make reused components applicable to the new record they appear in, if necessary. For example, if you have several controls in your recordComponents, and not all of the controls apply to every record, your updateRecordComponent() implementation could simply hide or disable inapplicable controls, and this would be much faster than creating a whole new set of controls every time a given record is scrolled into view. If you are using ListGrid.showRecordComponentsByCell','per-cell recordComponents, and you have components of different types in different columns and still want to take advantage of component recycling, you can set ListGrid.poolComponentsPerColumn to ensure that components intended for one column are not recycled for use in another column that should have a different component. Note that, if different records have distinctly different components embedded in them, or multiple columns in each record embed different components, you should leave the recordComponentPoolingMode at "viewport" if your dataset is very large or use "data" otherwise.
		 * Flags: IRWA */
		recordComponentPoolingMode?: RecordComponentPoolingMode; // Flags=IRWA
		/** if ListGrid.showRecordComponents is true, how should the component appear within the cell. Valid options are "within": the component will be rendered inside the record / cell. Canvas.snapTo may be set to specify where the component should render within the row or cell, and Canvas.snapOffsetTop / Canvas.snapOffsetLeft may be set to indent recordComponents within their parent cells. Note that if unset, the component will show up at the top/left edge for components embedded within an entire row, or for per-cell components, cell align and valign will be respected. Note also that, when rendering components "within" cells, specified component heights will be respected and will change the height of the row. However, if you want components to completely fill a cell at it's default height, set height: "100%" or rows will render at the default height of the component. "expand": the component will be written into the cell below the normal cell content, causing the cell to expand vertically to accommodate it. null: If this attribute is unset, we will default to showing recordComponents with position "within" if ListGrid.showRecordComponentsByCell is true, otherwise using "expand" logic. 
		 * Flags: IRW */
		recordComponentPosition?: EmbeddedPosition; // Flags=IRW
		/** Denotes the name of a property that can be set on records to display a custom style. For example if this property is set to "customStyle", setting record.customStyle to a css styleName will cause the record in question to render out with that styling applied to it. Note that this will be a static style - it will not be modified as the state of the record (selected / over etc) changes.
		 * Flags: IRW */
		recordCustomStyleProperty?: string /* String */; // Flags=IRW
		/** The name of the ListGridRecord property that specifies the DataSource to use when ExpansionMode','listGrid.expansionMode is "related". The default is ListGridRecord.detailDS. Note that you can set the ListGrid.detailDS at the grid level instead if the same dataSource is to be used for all records.
		 * Flags: IRWA */
		recordDetailDSProperty?: string /* String */; // Flags=IRWA
		/** If ListGrid.canAcceptDroppedRecords is true for this listGrid, this property governs whether the user can drop between, or over records within the grid. This controls what RecordDropPosition is passed to the ListGrid.recordDrop event handler.
		 * Flags: IRW */
		recordDropAppearance?: RecordDropAppearance; // Flags=IRW
		/** Property name on a record that should be checked to determine whether the record may be edited. This property is configurable to avoid possible collision with data values in record. With the default setting of "_canEdit", a record can be set non-editable by ensuring record._canEdit == false. For controlling editability for the entire grid or for a field, set grid.canEdit or field.canEdit.
		 * Flags: IRWA, Group: editing */
		recordEditProperty?: string; // Flags=IRWA
		/** Property name on a record that will be checked to determine whether a record is enabled. Setting this property on a record will effect the visual style and interactivity of the record. If set to false the record (row in a ListGrid or TreeGrid) will not highlight when the mouse moves over it, nor will it respond to mouse clicks.
		 * Flags: IR */
		recordEnabledProperty?: string; // Flags=IR
		/** If showing any record summary fields (IE: fields of ListGridFieldType','type:"summary"), this attribute specifies a custom base style to apply to cells in the summary field
		 * Flags: IRWA */
		recordSummaryBaseStyle?: string /* CSSStyleName */; // Flags=IRWA
		/** Custom CSS text to be applied to records that have been ListGrid.markRecordRemoved','marked for removal. This CSS text will be applied on top of standard disabled styling for the cell.
		 * Flags: IRWA, Group: appearance */
		removedCSSText?: string; // Flags=IRWA
		/** Default configuration properties for the "remove field" displayed when ListGrid.canRemoveRecords is enabled. Class.changeDefaults should be used when modifying this object. The default configuration includes a ListGridField.recordClick handler which calls ListGrid.removeData to actually perform the data removal.
		 * Flags: IR */
		removeFieldDefaults?: ListGridField /* ListGridField properties */; // Flags=IR
		/** Configuration properties for the "remove field" displayed when ListGrid.canRemoveRecords is enabled. These configuration settings will be overlaid on top of the ListGrid.removeFieldDefaults.
		 * Flags: IR */
		removeFieldProperties?: ListGridField /* ListGridField properties */; // Flags=IR
		/** The title to use for the ListGrid.removeFieldDefaults','remove field. By default this title is not displayed in the remove column header button as the ListGrid.removeFieldDefaults sets ListGridField.showTitle to false.
		 * Flags: IRWA */
		removeFieldTitle?: string /* String */; // Flags=IRWA
		/** When ListGrid.canRemoveRecords is enabled, default icon to show in the auto-generated field that allows removing records.
		 * Flags: IR */
		removeIcon?: string /* SCImgURL */; // Flags=IR
		/** Default width and height of ListGrid.removeIcon','remove icons for this ListGrid.
		 * Flags: IRW */
		removeIconSize?: number /* Number */; // Flags=IRW
		/** If true, when an update operation occurs on a selected record in a ListGrid.dataSource','databound listGrid, ensure the updated record is re-selected when the operation completes. The ListGrid.reselectOnUpdateNotifications attributes governs whether ListGrid.selectionUpdated and ListGrid.selectionChanged will fire when this occurs.
		 * Flags: IRA */
		reselectOnUpdate?: boolean; // Flags=IRA
		/** if ListGrid.reselectOnUpdate is true, this property governs what selection changed notifications should be triggered when a selected record is edited then automatically reselected when the edited data is merged into the data set.
		 * Flags: IRWA */
		reselectOnUpdateNotifications?: SelectionNotificationType; // Flags=IRWA
		/** If true, the grid contents are redrawn in real time as fields are resized. This can be slow with a large grid and/or on some platforms. By default, this is enabled in modern desktop browsers. This is automatically switched off in mobile browsers.
		 * Flags: IRWA, Group: dragging */
		resizeFieldsInRealTime?: boolean; // Flags=IRWA
		/** If a page is rendered in Page.isRTL','RTL mode, should cell alignments specified ListGridField.cellAlign be reversed (so an align:"right" field will have content aligned on the left and vice versa)? This is true by default to match user expectation that text flows from start-to end and is aligned with the start of text flow (left in LTR mode, right in RTL mode) by default. May be set to false to have the specified alignments be taken literally in RTL mode.
		 * Flags: IRW, Group: RTL */
		reverseRTLAlign?: boolean /* Boolean */; // Flags=IRW
		/** If the user is editing a record in this listGrid, and attempts to navigate to a field beyond the end of the row, via tab (or shift-tab off the first editable field), this property determines what action to take: "next": start editing the next (or previous) record in the list "same": put focus back into the first editable field of the same record. "done": hide the editor "stop": leave focus in the cell being edited "none": no action 
		 * Flags: IRW, Group: editing */
		rowEndEditAction?: RowEndEditAction; // Flags=IRW
		/** An automatically generated field that displays the current row number when ListGrid.showRowNumbers','showRowNumbers is true.
		 * Flags: IRWA, Group: rowNumberField */
		rowNumberField?:  ListGridField /* AutoChild ListGridField */; // Flags=IRWA
		/** The number to start the row-count from - default value is 1.
		 * Flags: IRWA, Group: rowNumberField */
		rowNumberStart?: number; // Flags=IRWA
		/** The CSS Style name for the ListGrid.rowNumberField.
		 * Flags: IRWA, Group: rowNumberField */
		rowNumberStyle?: string /* CSSStyleName */; // Flags=IRWA
		/** If ListGrid.allowRowSpanning is enabled, this property may be used to specify editing behavior for cells that span multiple rows.
		 * Flags: IRWA */
		rowSpanEditMode?: RowSpanEditMode; // Flags=IRWA
		/** Chooses the selection mode when ListGrid.useRowSpanStyling is enabled. See RowSpanSelectionMode.
		 * Flags: IR */
		rowSpanSelectionMode?: RowSpanSelectionMode; // Flags=IR
		/** Whether edits should be saved whenever the user moves between cells in the current edit row. If unset, defaults to ListGrid.editByCell','this.editByCell. To avoid automatic saving entirely, set ListGrid.autoSaveEdits:false.
		 * Flags: IRW, Group: editing */
		saveByCell?: boolean; // Flags=IRW
		/** For grids with a specified ListGrid.dataSource, this property can be set to true to cause the grid directly update its local data set instead of performing an operation against it's configured DataSource. When using this mode, data must be provided to the grid via ListGrid.setData, and must be provided as a simple Array of Records . Setting saveLocally is invalid if either ListGrid.fetchData is called or if a ResultSet is provided as the data model. saveLocally mode includes changes made via ListGrid.canEdit','inline editing, record removal via ListGrid.canRemoveRecords, as well as programmatic calls to ListGrid.updateData, ListGrid.addData','addData() and ListGrid.removeData','removeData(). This also causes saves to be performed synchronously (unlike normal DataSource operations). Note that using this mode also disables the automatic cache synchronization provided by the DataSource system - changes made to this grid are saved only to this grid's data set. See also ListGrid.filterLocalData to allow filtering, such as filtering performed by the ListGrid.filterEditor, to also work only with the local data set. If saveLocally is unset, and ListGrid.filterLocalData is true, the saveLocally behavior is enabled by default
		 * Flags: IRA, Group: databinding */
		saveLocally?: boolean; // Flags=IRA
		/** For editable grids with a specified ListGrid.dataSource, where ListGrid.saveLocally is false, this attribute may be used to specify standard DSRequest properties to apply to all save operations performed by this grid (whether triggered by user interaction, or explicit saveEdits or saveAllEdits call). An example usage would be to customize the prompt displayed while saving is in progress if ListGrid.waitForSave is true. Note that for more advanced customization of save operations, DataBoundComponent.addOperation and DataBoundComponent.updateOperation are available to developers, allowing specification of an explicit OperationBinding for the add / update operation performed on save.
		 * Flags: IRWA, Group: dataBinding */
		saveRequestProperties?: DSRequestProps /* DSRequest Properties */; // Flags=IRWA
		/** When isc.setScreenReaderMode','screen reader mode is enabled, this invisible separator string is written out between each cell value. This string will be picked up by screen readers allowing them to more obviously identify to the user the different cell values as the contents of a row are read aloud. The ListGrid.screenReaderRowSeparator','screenReaderRowSeparator string if any will be written out after the last cell in a row to separate the last cell's value from the screen reader's announcement of the row's number and total number of rows in the grid (such as "3 of 20"). This attribute may be set to null to disable the feature. Note that screen readers vary widely on which punctuation symbols are read aloud, and sometimes it depends on the context of the punctuation. However, the widely-used JAWS, NVDA, and VoiceOver screen readers all read the forward slash '/' as "slash". See <a href='http://www.deque.com/blog/dont-screen-readers-read-whats-screen-part-1-punctuation-typographic-symbols/' target='_blank'>Why Dont Screen Readers Always Read Whats on the Screen? Part 1: Punctuation and Typographic Symbols</a> for a table of findings on which punctuation symbols are read aloud by JAWS, NVDA, and VoiceOver.
		 * Flags: IRA, Group: accessibility */
		screenReaderCellSeparator?: string /* HTMLString */; // Flags=IRA
		/** When isc.setScreenReaderMode','screen reader mode is enabled, this invisible string will be written out after the last cell in a row. This string will be picked up by screen readers allowing them to more obviously identify to the user the end of the row's contents and the screen reader's announcement of the row's number and total number of rows in the grid (such as "3 of 20"). This attribute may be set to null to disable writing out an invisible string at the end of each row. Note that screen readers vary widely on which punctuation symbols are read aloud, and sometimes it depends on the context of the punctuation. However, the widely-used JAWS, NVDA, and VoiceOver screen readers all pause briefly for a comma ',' that is within text. See <a href='http://www.deque.com/blog/dont-screen-readers-read-whats-screen-part-1-punctuation-typographic-symbols/' target='_blank'>Why Dont Screen Readers Always Read Whats on the Screen? Part 1: Punctuation and Typographic Symbols</a> for a table of findings on which punctuation symbols are read aloud by JAWS, NVDA, and VoiceOver.
		 * Flags: IRA, Group: accessibility */
		screenReaderRowSeparator?: string /* HTMLString */; // Flags=IRA
		/** While drag scrolling in an incrementally rendered grid, time in milliseconds to wait before redrawing, after the last mouse movement by the user. This delay may be separately customized for mouse-wheel scrolling via ListGrid.scrollWheelRedrawDelay. See also GridRenderer.instantScrollTrackRedraw for cases where this delay is skipped. <strong>NOTE:</strong> In Browser.isTouch','touch browsers, GridRenderer.touchScrollRedrawDelay','touchScrollRedrawDelay is used instead.
		 * Flags: IRW, Group: performance */
		scrollRedrawDelay?: number /* int */; // Flags=IRW
		/** When scrollToCell is called, this is used as defaults if xPosition weren't explicitly passed into the method.
		 * Flags: IRW */
		scrollToCellXPosition?: Alignment; // Flags=IRW
		/** When scrollToCell is called, this is used as defaults if yPosition weren't explicitly passed into the method.
		 * Flags: IRW */
		scrollToCellYPosition?: VerticalAlignment; // Flags=IRW
		/** While scrolling an incrementally rendered grid, using the mouseWheel, time in milliseconds to wait before redrawing, after the last mouseWheel movement by the user. If not specified ListGrid.scrollRedrawDelay will be used as a default for both drag scrolling and mouseWheel scrolling. Note that if specified, this value will typically be larger than ListGrid.scrollRedrawDelay. From experimentation, the default setting of 250 is typically enough time for a user to rapidly scroll through a grid (rotating the scroll wheel with repeated flicks), without redrawing between rotations, but this will differ depending on how long the redraw takes. A larger delay may be warranted for grids with large numbers of columns, heavy custom formatting, etc. See also GridRenderer.instantScrollTrackRedraw for cases where this delay is skipped.
		 * Flags: IRW, Group: performance */
		scrollWheelRedrawDelay?: number /* Integer */; // Flags=IRW
		/** Returns a snapshot of the current selection within this listGrid as a ListGridSelectedState object. This object can be passed to ListGrid.setSelectedState to reset this grid's selection the current state (assuming the same data is present in the grid).
		 * Flags: IRW, Group: viewState */
		selectedState?: string /* ListGridSelectedState */; // Flags=IRW
		/** If true, show the field-header for the sorted field (or the first field in a ListGrid.canMultiSort','multi-sort grid) in the selected state.
		 * Flags: IRW, Group: sorting */
		selectHeaderOnSort?: boolean /* Boolean */; // Flags=IRW
		/** How selection of rows should be presented to the user. For selectionAppearance:"checkbox" with multiple selection allowed, you would typically use ListGrid.selectionType:"simple" (the default). Because selectionType and selectionAppearance are unrelated, the combination of selectionAppearance:"checkbox" and selectionType:"multiple" results in a grid where multiple selection can only be achieved via shift-click or ctrl-click. If using "checkbox" for a ListGrid, see also ListGrid.checkboxField for customization APIs. If using "checkbox" for a TreeGrid, an extra icon, TreeGrid.getExtraIcon is not supported. Additionally only ListGrid.selectionType:"simple" and "single" are supported. You can also toggle the display of a disabled checkbox on a treeGrid, displayed when the node can't be selected, via TreeGrid.showDisabledSelectionCheckbox. Note that the default behavior when you enable checkbox selection is to continue to show the selected style. This can be changed by setting ListGrid.showSelectedStyle to false.
		 * Flags: IRW, Group: selection */
		selectionAppearance?: SelectionAppearance; // Flags=IRW
		/** If specified, the selection object for this list will use this property to mark records as selected. In other words, if this attribute were set to "isSelected" any records in the listGrid data where "isSelected" is true will show up as selected in the grid. Similarly if records are selected within the grid after the grid has been created, this property will be set to true on the selected records.
		 * Flags: IRA, Group: selection */
		selectionProperty?: string; // Flags=IRA
		/** Defines a listGrid's clickable-selection behavior. The default selection appearance is governed by ListGrid.selectionAppearance: if selectionAppearance is "checkbox", this will be "simple", otherwise, this will be "multiple".
		 * Flags: IRW, Group: selection */
		selectionType?: SelectionStyle; // Flags=IRW
		/** When the user starts editing a row, should the row also be selected? Note that when this attribute is set to true, other all other rows in the grid will be deselected when a record is selected due to editing.
		 * Flags: IRWA, Group: editing */
		selectOnEdit?: boolean /* Boolean */; // Flags=IRWA
		/** When set to false, clicking a record's ListGrid.expansionField','expansion field will not add the record to the current selection.
		 * Flags: IRW */
		selectOnExpandRecord?: boolean; // Flags=IRW
		/** Whether all columns should be drawn all at once, or only columns visible in the viewport. Drawing all columns causes longer initial rendering time, but allows smoother horizontal scrolling. With a very large number of columns, showAllColumns will become too slow.
		 * Flags: IR, Group: performance */
		showAllColumns?: boolean /* Boolean */; // Flags=IR
		/** Whether all rows should be drawn all at once, or only rows visible in the viewport. Drawing all rows causes longer initial rendering time, but allows smoother vertical scrolling. With a very large number of rows, showAllRows will become too slow. See also ListGrid.drawAheadRatio and ListGrid.drawAllMaxCells.
		 * Flags: IRW, Group: performance */
		showAllRecords?: boolean /* Boolean */; // Flags=IRW
		/** If set to false, do not show the ListGrid.asynchGroupingPrompt dialog during ListGrid.groupByAsyncThreshold','asynchronous grouping.
		 * Flags: IR */
		showAsynchGroupingPrompt?: boolean /* Boolean */; // Flags=IR
		/** If true this grid will create and show per-row backgroundComponents as detailed ListGrid.backgroundComponent','here.
		 * Flags: IRW */
		showBackgroundComponents?: boolean /* Boolean */; // Flags=IRW
		/** Whether to show a context menu with standard items for all context clicks on rows in the body.
		 * Flags: IRW */
		showCellContextMenus?: boolean /* Boolean */; // Flags=IRW
		/** If true and a header button's title is clipped, then a hover containing the full field title is enabled.
		 * Flags: IRA, Group: hovers */
		showClippedHeaderTitlesOnHover?: boolean; // Flags=IRA
		/** If true and a cell's value is clipped, then a hover containing the full cell value is enabled. Note that standard cell hovers override clipped value hovers. Thus, to enable clipped value hovers, ListGrid.canHover','canHover must be unset or null and the corresponding field must have ListGridField.showHover','showHover unset or null as well.
		 * Flags: IRA, Group: events */
		showClippedValuesOnHover?: boolean /* Boolean */; // Flags=IRA
		/** Should group summaries be visible when the group is collapsed? This property only applies to ListGrid.groupBy','grouped grids showing ListGrid.showGroupSummary','group summary rows. When set to true, the group summary row(s) for each group will show up under the group header nodes when the group is collapsed, or at then end of the grouped set of data if the group is expanded. This property has no effect if ListGrid.showGroupSummaryInHeader is true.
		 * Flags: IRW, Group: grouping */
		showCollapsedGroupSummary?: boolean /* Boolean */; // Flags=IRW
		/** Whether to include fields marked detail:true from this component's DataSource. When this property is true, the ListGrid will include all detail fields unless fields have been specifically declared using the ListGrid.fields array. Any field which has been included directly in the fields array will be included regardless of the fields detail attribute. Detail fields included will initially be hidden but the user may show these fields via the default header context menu (ListGrid.showHeaderContextMenu). The field's visibility can also be overridden programatically using the standard ListGrid.showField, ListGrid.hideField and ListGridField.showIf APIs, for example, set showIf:"true" to show a detail field initially. Setting this property to false will completely exclude all detail fields from the list grid's fields array, such that they cannot be shown by the user or programmatically.
		 * Flags: IR, Group: databinding */
		showDetailFields?: boolean /* Boolean */; // Flags=IR
		/** Indicates whether the text of the emptyMessage property should be displayed if no data is available.
		 * Flags: IRW, Group: emptyMessage */
		showEmptyMessage?: boolean /* Boolean */; // Flags=IRW
		/** If this grid is editable, and an edit has caused validation failure for some cell, should we show an icon to indicate validation failure?
		 * Flags: IRW, Group: errorIcon */
		showErrorIcons?: boolean; // Flags=IRW
		/** Should this listGrid display a filter row. If true, this ListGrid will be drawn with a single editable row, (separate from the body) with a filter button. Values entered into this row are used as filter criteria to filter this List's data on enter-keypress or filter button click. ListGrid.autoFetchTextMatchStyle determines the textMatchStyle for the request passed to ListGrid.fetchData. The default FormItem.operator','search operator for an item in the filterEditor can be set via ListGridField.filterOperator. When field.filterOperator has been set calls to retrieve the criteria from the grid return AdvancedCriteria. See also ListGrid.allowFilterOperators for a UI that allows end users to change the search operator on the fly Note that if ListGrid.filterData or ListGrid.fetchData is called directly while the filter editor is showing, the filter editor values will be updated to reflect the new set of criteria. If you wish to retain the user entered filter criteria and modify a subset of field values programmatically, this can be achieved by copying the existing set of criteria and adding other changes - something like this: var newCriteria = myListGrid.getFilterEditorCriteria(); isc.DataSource.combineCriteria(newCriteria, { field1:"new value1", field2:"new value2" }); myListGrid.setCriteria(newCriteria); In this example code we're using ListGrid.getFilterEditorCriteria rather than ListGrid.getCriteria - this ensures that if the user has typed a new value into the filter editor, but not yet clicked the filter button, we pick up the value the user entered. This sample code uses DataSource.combineCriteria to combine the existing filterEditorCriteria with some new custom criteria. This technique is applicable to both simple and advanced criteria. If you call filterData() and pass in criteria for dataSource fields that are not present in the ListGrid, these criteria will continue to be applied along with the user-visible criteria. filterEditor and advanced criteria: If a developer calls filterData() on a ListGrid and passes in AdvancedCriteria, expected behavior of the filter editor becomes ambiguous, since AdvancedCriteria has far more complex filter expression support than the ordinary filterEditor can represent. Default behavior for AdvancedCriteria will combine the AdvancedCriteria with the values in the filter editor as follows: If the top level criteria has operator of type "and": Each field in the top level criteria array for which a 'canFilter' true field is shown in the listGrid will show up if the specified operator matches the default filter behavior (based on the ListGrid.autoFetchTextMatchStyle). If the user enters values in the filter editor, these will be combined with the existing AdvancedCriteria by either replacing or adding field level criteria at the top level. If the top level criteria is a single field-criteria: If the field shows up in the listGrid and is canFilter:true, it will be displayed to the user (if the operator matches the default filter behavior for the field). If the user enters new filter criteria in the filterEditor, they will be combined with this existing criterion via a top level "and" operator, or if the user modifies the field for which the criterion already existed, it will be replaced. Otherwise, if there are multiple top level criteria combined with an "or" operator, these will not be shown in the filter editor. Any filter parameters the user enters will be added to the existing criteria via an additional top level "and" operator, meaning the user will essentially filter a subset of the existing criteria 
		 * Flags: IRW, Group: filterEditor */
		showFilterEditor?: boolean; // Flags=IRW
		/** Should this ListGrid show a summary row beneath the last record of the grid. This summary row will contain per-field summary information. See ListGridField.showGridSummary and ListGrid.getGridSummaryFunction for details on how the summary value to be displayed for each column will be calculated. Note that the ListGrid.summaryRow','summaryRow autoChild will be created to actually display the summary row.
		 * Flags: IRW */
		showGridSummary?: boolean /* Boolean */; // Flags=IRW
		/** If this listGrid supports ListGrid.canGroupBy','grouping, setting this property will cause the grid to render an extra row at the end of each group when grouped, containing summary information for the fields. Summary information will be calculated by the ListGridField.getGroupSummary method if specified, otherwise via the specified ListGridField.summaryFunction.
		 * Flags: IRW */
		showGroupSummary?: boolean /* Boolean */; // Flags=IRW
		/** If this grid is ListGrid.groupBy','grouped, and ListGrid.showGroupSummary is true, setting this property causes field summary values for each group to be displayed directly in the group header node, rather than showing up at the bottom of each expanded group. Note that this means the group header node will be showing multiple field values rather than the default display of a single cell spanning all columns containing the group title. Developers may specify an explicit ListGrid.groupTitleField, or rely on the automatically generated ListGrid.showGroupTitleColumn','groupTitleColumn to have group titles be visible as well as the summary values. Also note that multi-line group summaries are not supported when showing the group summary in the group header. If multiple ListGridField.summaryFunction','field summary functions are defined for some field only the first will be displayed when this property is set to true.
		 * Flags: IRW, Group: grouping */
		showGroupSummaryInHeader?: boolean /* Boolean */; // Flags=IRW
		/** If this grid is ListGrid.groupBy','grouped and ListGrid.showGroupSummaryInHeader is true, instead of group header nodes showing up with a single cell value spanning the full set of columns, summaries for each field will show up in the appropriate columns of the header node. In this case there are 2 options for where the group title will show up. Developers may specify an existing field to put the title values into via ListGrid.groupTitleField. If no groupTitleField is specified, this property may be set to true which causes a groupTitleColumn to be automatically generated. Each group header will show the group title in this column (records within the group will not show a value for this column). The column appears in the leftmost position within the grid (unless ListGrid.showRowNumbers is true, in which case this column shows up in the second-leftmost position), and by default will auto-fit to its data. To customize this field, developers may modify ListGrid.groupTitleColumnProperties or ListGrid.groupTitleColumnDefaults at the class level.
		 * Flags: IR */
		showGroupTitleColumn?: boolean /* Boolean */; // Flags=IR
		/** If this is ListGrid.groupBy','grouped and has frozenFields','frozen fields, should the group title show in the frozen or unfrozen body? Setting this property to false will cause the group title to show in the unfrozen body in this case, meaning it will appear to the right of the frozen fields, and scroll horizontally as the user scrolls the unfrozen fields. This can be useful for grids where there isn't enough available space to show the group title text in the frozen body. Note that if ListGrid.groupTitleField is explicitly set, or ListGrid.showGroupSummaryInHeader is true, this property has no effect. In this case rather than the group title showing in a single cell spanning multiple other fields, it will be rendered into a specific column.
		 * Flags: IRWA */
		showGroupTitleInFrozenBody?: boolean; // Flags=IRWA
		/** Should we show the header for this ListGrid?
		 * Flags: IRW, Group: gridHeader */
		showHeader?: boolean /* Boolean */; // Flags=IRW
		/** Whether to show a context menu on the header with standard items for showing and hiding fields. Not supported for CubeGrid.
		 * Flags: IR, Group: gridHeader */
		showHeaderContextMenu?: boolean /* Boolean */; // Flags=IR
		/** If set to true and ListGrid.showHeaderContextMenu','showHeaderContextMenu is true, the ListGrid.headerMenuButton will be displayed when the user rolls over the header buttons in this grid. Not supported for CubeGrid.
		 * Flags: IR, Group: headerMenuButton */
		showHeaderMenuButton?: boolean /* Boolean */; // Flags=IR
		/** Should the header show a drop-shadow? Shadow will be applied to the header, or for a grid with frozen columns, the header layout. Header shadow will only be displayed if Canvas.useCSSShadow','css shadows are being used.
		 * Flags: IRW */
		showHeaderShadow?: boolean /* Boolean */; // Flags=IRW
		/** If this grid has specified ListGrid.headerSpans','headerSpans, should field titles be prefixed with the titles of the headerSpans in which they are contained when using the FormulaBuilder or SummaryBuilder.
		 * Flags: IRW */
		showHeaderSpanTitlesInFormulaBuilder?: boolean /* Boolean */; // Flags=IRW
		/** If this grid has specified ListGrid.headerSpans, should field titles be prefixed with the titles of the headerSpans in which they are contained when using the DataBoundComponent.editHilites','hilite editor.
		 * Flags: IRW */
		showHeaderSpanTitlesInHiliteEditor?: boolean /* Boolean */; // Flags=IRW
		/** If this grid has specified ListGrid.headerSpans','headerSpans, should field titles be prefixed with the titles of the headerSpans in which they are contained when using the MultiSortDialog','multi-sort editor.
		 * Flags: IRW */
		showHeaderSpanTitlesInSortEditor?: boolean /* Boolean */; // Flags=IRW
		/** Determines whether hiliting for any field in this grid is shown in a group summary. This setting affects all fields of the grid. To suppress hilites for a specific field see ListGridField.showHilitesInGroupSummary. Hiliting in summary fields (columns) can be enabled by setting ListGrid.includeHilitesInSummaryFields','includeHiliteInSummaryField to true.
		 * Flags: IRW */
		showHilitesInGroupSummary?: boolean; // Flags=IRW
		/** If true, and canHover is also true, when the user hovers over a cell, hover text will pop up next to the mouse. The contents of the hover is determined by ListGrid.cellHoverHTML.
		 * Flags: IRW, Group: hovers */
		showHover?: boolean /* Boolean */; // Flags=IRW
		/** When set to true and canHover is also true, shows a widget hovering at the mouse point. A number of builtin modes are provided - see HoverMode. Also supported at the ListGridField.showHoverComponents','field-level.
		 * Flags: IRWA, Group: hoverComponents */
		showHoverComponents?: boolean /* Boolean */; // Flags=IRWA
		/** Should partially selected parents (in a Tree data set) be shown with special icon? This has an impact in grouped grids where ListGrid.canSelectGroups is true. The partial icon will show up for the group header node when a group is partially selected.
		 * Flags: IRW */
		showPartialSelection?: boolean /* Boolean */; // Flags=IRW
		/** When enabled, ListGrid.createRecordComponent will be called when saved rows are being rendered, and any returned component will be displayed embedded within the row or cell. recordComponents are not created for newly added rows which have not yet been saved. See the unsavedRecords','Handling Unsaved Records overview for more information. Depending on the ListGrid.showRecordComponentsByCell setting, createRecordComponent() will be called either once per row, or once for every cell. Depending on ListGrid.recordComponentPosition, components can either be placed underneath normal record or cell content ("expand" setting) or placed so that they overlap normal cell content ("within" setting). For the "within" setting, the default is to fill the row or cell, but the component can specify percent size or even use Canvas.snapTo','snapTo-positioning to place itself within the row or cell. The "expand" setting is incompatible with ListGrid.canFreezeFields','frozen columns unless all recordComponents are the same height and they are present in every row, in which case the fixed height of all recordComponents can be set via ListGrid.recordComponentHeight to re-enable frozen fields. Using recordComponents potentially means creating one component for every visible grid row or cell and so can impact performance. Before using this subsystem: consider using ListGridField.valueIcons (possibly with a specified ListGridField.valueIconClick handler) for icons based on field values which may be displayed alone in the cell or alongside standard content (see ListGridField.showValueIconOnly); for clickable icons representing actions that can be taken on a record, also consider using ListGridFieldType','a field of type "icon", or multiple such fields for controls that only need to appear on rollover, consider ListGrid.showRollOverCanvas','rollOver controls if you are trying to customize the editor for a field, you can provide a custom control via ListGridField.editorType, and FormItem.icons are a common way to add clickable buttons. You can also ListGrid.getEditorType','provide different controls per record. These options are usually better that using recordComponents as custom editors, since you won't have to manage issues like making the recordComponent appear only when editing, having changes affect editing','editValues, triggering saves and handling validation errors, etc. See RecordComponentPoolingMode for an overview of how best to optimize use of recordComponents for different data sets. Regardless of the pooling mode, you can explicitly refresh record components via ListGrid.invalidateRecordComponents and ListGrid.refreshRecordComponent. Interaction with ListGrid.autoFitFieldWidths','column auto-fit: per-cell record components are not taken into account when determining the size for column auto fit. The default ListGrid.getDefaultFieldWidth implementation looks at cell content only. We typically recommend that, for fields showing record-components, ListGridField.autoFitWidth and ListGridField.canAutoFitWidth be disabled, or if the record components are of a predictable size, a ListGridField.defaultWidth be specified. This is particularly pertinent where ListGrid.recordComponentPosition is set to "within", in which case cells' content is often empty or completely covered by record-components.
		 * Flags: IRWA */
		showRecordComponents?: boolean; // Flags=IRWA
		/** If true, shows ListGrid.showRecordComponents','recordComponents in cells, rather than just in records.
		 * Flags: IRWA */
		showRecordComponentsByCell?: boolean; // Flags=IRWA
		/** Should we show different styling for the cell the mouse is over? If true, the cell style will have the suffix "Over" appended. Can be overridden on a per-record basis via ListGridRecord.showRollOver.
		 * Flags: IRW, Group: appearance */
		showRollOver?: boolean /* Boolean */; // Flags=IRW
		/** When enabled, when the mouse moves over a row or cell (depending on ListGrid.useCellRollOvers), an arbitrary Canvas can be shown layered on top of the row or cell (the ListGrid.rollOverCanvas), layered underneath the row or cell (the ListGrid.rollUnderCanvas), or both. This can be used to dynamically show controls or informational displays only on rollover. For example, controls to delete a row might appear only on rollover so they do not clutter the static display, or a "rollUnder" Canvas could be used to display additional information that can appear behind normal cell values (like displaying percent complete via as a bar of color that appears behind text values). Canvas.snapTo','snapTo positioning can be used to place the rollOver/rollUnderCanvas. With useCellRollOvers, positioning is relative to the cell, for row-level rollOver, position is relative to the portion of the row that is scrolled into view (this implies a row-level rollOver/UnderCanvas can never be placed horizontally scrolled out of view, but this is possible for a cell-level rollOver). snapTo positioning makes it easy to do something like place a button at the right edge of the grid, next to the scrollbar: just set snapTo:"R" on the rollOverCanvas. The rollOver/rollUnder Canvas can be a single static component (the same for all cells/rows) configured via the AutoChild system, or can instead be provided dynamically by implementing ListGrid.getRollOverCanvas and/or ListGrid.getRollUnderCanvas. The rollOver/rollUnder canvas will be automatically added to the grid's ListGrid.body','body as an ListGrid.addEmbeddedComponent','embedded component. For grids with ListGridField.frozen','frozen fields, the behavior is as follows: If ListGrid.useCellRollOvers is false (the default), embedded components will be added to both the body and the frozen body Otherwise the component will be added to whichever body contains the cell the user is currently over The rollOver/rollUnder canvas added to the frozen body will be created by calling the ListGrid.getFrozenRollOverCanvas or ListGrid.getFrozenRollUnderCanvas methods. The default implementation for these methods matches their equivalents for non-frozen rollOver / rollUnder canvases - it will use the autoChild subsystem to create a canvas from the ListGrid.rollOverCanvas autoChild configuration. showRollOverCanvas has no effect if ListGrid.showRollOver is false. See also ListGrid.showSelectedRollOverCanvas.
		 * Flags: IRWA, Group: rowEffects */
		showRollOverCanvas?: boolean /* Boolean */; // Flags=IRWA
		/** If roll overs are enabled, should the ListGrid.rollUnderCanvas','rollUnderCanvas be displayed? Use of the showRollUnderCanvas is enabled if ListGrid.showRollOver','showRollOver is true, and either ListGrid.showRollOverCanvas','showRollOverCanvas is true and showRollUnderCanvas is unset, or showRollUnderCanvas is explicitly set to true. See also ListGrid.showSelectedRollUnderCanvas.
		 * Flags: IRWA */
		showRollUnderCanvas?: boolean /* Boolean */; // Flags=IRWA
		/** When set to true, shows an additional field at the beginning of the field-list (respecting RTL) that displays the current rowNum for each record.
		 * Flags: IRWA, Group: rowNumberField */
		showRowNumbers?: boolean; // Flags=IRWA
		/** This setting causes the ListGrid.rollOverCanvas','roll over canvas to be displayed when the user rolls over selected records in the grid (but not when rolling over other records). This can be useful to display a "Selected Over" appearance which can't be easily achieved via standard cell styling.
		 * Flags: IRWA, Group: rowEffects */
		showSelectedRollOverCanvas?: boolean /* Boolean */; // Flags=IRWA
		/** This setting causes the ListGrid.rollUnderCanvas','roll under canvas to be displayed when the user rolls over selected records in the grid (but not when rolling over other records). This can be useful to display a "Selected Over" appearance which can't be easily achieved via standard cell styling. As with ListGrid.showRollUnderCanvas, if this property is unset, but the related ListGrid.showSelectedRollOverCanvas property is true, both the the roll under and roll under canvases will be displayed as the user rolls over selected records.
		 * Flags: IRWA, Group: rowEffects */
		showSelectedRollUnderCanvas?: boolean /* Boolean */; // Flags=IRWA
		/** Should the "Selected" style be applied to selected records?
		 * Flags: IRW */
		showSelectedStyle?: boolean /* Boolean */; // Flags=IRW
		/** If ListGrid.selectionType','selectionType is set to "single", setting this property to true means selection will be displayed to the user with the ListGrid.selectionCanvas','selectionCanvas and/or ListGrid.selectionUnderCanvas','selectionUnderCanvas rather than with CSS styling. If showSelectionCanvas is set to true, then the selectionUnderCanvas will automatically be enabled unless ListGrid.showSelectionUnderCanvas','showSelectionUnderCanvas is set to false. NOTE: It is recommended to use the selectionUnderCanvas rather than the selectionCanvas if possible because the selectionCanvas is stacked on top of the selected record and this may interfere with event handling in rare cases. If no interactive components are shown in the selectionCanvas and it simply provides custom styling, then the selectionUnderCanvas should be used instead. With ListGrid.canFreezeFields','frozen fields, the selectionCanvas is displayed only over the non-frozen fields of the selected row.
		 * Flags: IRWA, Group: rowEffects */
		showSelectionCanvas?: boolean /* Boolean */; // Flags=IRWA
		/** If ListGrid.selectionType','selectionType is set to "single", and either ListGrid.showSelectionCanvas','showSelectionCanvas is true and showSelectionUnderCanvas is unset, or showSelectionUnderCanvas is explicitly set to true, then selection will be displayed to the user with the ListGrid.selectionCanvas','selectionCanvas and/or ListGrid.selectionUnderCanvas','selectionUnderCanvas rather than with CSS styling. Setting showSelectionUnderCanvas to false will disable the use of the selectionUnderCanvas. With ListGrid.canFreezeFields','frozen fields, the selectionUnderCanvas is displayed only behind the non-frozen fields of the selected row.
		 * Flags: IRWA, Group: rowEffects */
		showSelectionUnderCanvas?: boolean /* Boolean */; // Flags=IRWA
		/** Indicates whether a sorting arrow should appear for the listGrid, and its location. See SortArrow for details. Clicking the sort arrow reverses the direction of sorting for the current sort column (if any), or sorts the listGrid by its first sortable column. The arrow image on the button indicates the current direction of sorting. If undefined, the sort arrow will show up in the sorted field, and the corner sort button will be displayed if a vertical scrollbar is being displayed
		 * Flags: IRW, Group: sorting */
		showSortArrow?: SortArrow; // Flags=IRW
		/** When multiple fields are sorted, set this to false to hide the sort-numeral displayed by default after the sort-arrows in the header-buttons of sorted fields.
		 * Flags: IRWA */
		showSortNumerals?: boolean; // Flags=IRWA
		/** When ListGrid.headerSpans are in use, whether to show a hierarchical column picker that includes both headerSpans and normal headers, with normal headers indented under headerSpans similarly to how a TreeGrid displays a Tree. If showTreeColumnPicker is false, no column picker will be shown on the headerSpan itself, and the column picker for a clicked on a normal field header will include only normal fields.
		 * Flags: IR, Group: headerSpan */
		showTreeColumnPicker?: boolean /* Boolean */; // Flags=IR
		/** If this list grid is showing any ListGridField.frozen','frozen fields, and a horizontal scrollbar is visible at the bottom of the liquid columns, should an equivalent scrollbar gap be left visible below the frozen columns? Note that if set to true any backgroundColor or border applied to the ListGrid will show up below the bottom row of the frozen column(s).
		 * Flags: IRWA, Group: frozenFields */
		shrinkForFreeze?: boolean /* Boolean */; // Flags=IRWA
		/** If record[this.singleCellValueProperty] is set for some record, the record will be displayed as a single cell spanning every column in the grid, with contents set to the value of record[this.singleCellValueProperty].
		 * Flags: IRW */
		singleCellValueProperty?: string; // Flags=IRW
		/** Where do 'skin' images (those provided with the class) live?
		 * Flags: IRWA, Group: appearance */
		skinImgDir?: string /* URL */; // Flags=IRWA
		/** Image to show when sorting ascending. See ImgProperties for format.
		 * Flags: IRWA, Group: appearance */
		sortAscendingImage?: ImgProperties; // Flags=IRWA
		/** For any fields of FieldType','type "binary", should sorting be performed against the fileName of the value for the field? For SmartClient server backed dataSources, this is applied to the record automatically as described in the binaryFields overview. If set to false, binary fields will be sorted against the record value for the field in question. Client-side sorting does not support this, so developers who actually want to support a sort against the binary itself would typically set ResultSet.useClientSorting to false on the ListGrid.dataProperties block for this grid. Note that this setting will have no effect if DataSourceField.sortByField is specified
		 * Flags: IRW, Group: sorting */
		sortBinaryByFileName?: boolean; // Flags=IRW
		/** If set, whenever grouping is performed by an end user or by a programmatic call to ListGrid.groupBy, data is implicitly sorted by all of the grouped columns, in the order they were passed to groupBy. Any user-configured sorting is applied after sorting by grouped columns. Sorting by grouped fields will be in ascending or descending order according to whether the grid is currently sorted (by any field) in ascending or descending order, defaulting to ascending if the grid is not sorted. Implicit sorting by group can be forced to be always ascending or always descending by setting ListGrid.groupSortDirection. The sorting is "implicit" in the sense that the sorting is not shown in the ListGrid headers, and not shown in the MultiSortDialog if enabled. An end user cannot currently remove the implicit sorting themselves (except by removing the grouping), though it is possible to override it by providing an explicit sort on the group's column. Clicking on the grouped field's header reveals the usual sort indicators with all the same semantics. The correct way to remove implicit sorting programmatically is to call ListGrid.setSortByGroupFirst','setSortByGroupFirst(false). Programmatic calls to ListGrid.getSort will not include the implicit sort in the list of return sort specifiers, and calls to ListGrid.setSort will implicitly add the sorting by grouped columns before the specified sort. Note that directly calling ResultSet.getSort() will include the implicit sort information.
		 * Flags: IRW, Group: sorting */
		sortByGroupFirst?: boolean /* Boolean */; // Flags=IRW
		/** Image to show when sorting descending. See ImgProperties for format.
		 * Flags: IRWA, Group: appearance */
		sortDescendingImage?: ImgProperties; // Flags=IRWA
		/** Sorting direction of this ListGrid. If specified when the ListGrid is initialized, this property will be the default sorting direction for the ListGrid.sortField. May be overridden by specifying ListGridField.sortDirection. After initialization, this property will be updated on ListGrid.sort or ListGrid.setSort to reflect the current sort direction of the grid. When this grid is sorted by multiple fields, the grid's sortDirection reflects the sort direction of the primary sort field.
		 * Flags: IRW, Group: sorting */
		sortDirection?: SortDirection; // Flags=IRW
		/** If this grid has specified ListGrid.headerSpans','headerSpans, and ListGrid.showHeaderSpanTitlesInSortEditor','showHeaderSpanTitlesInSortEditor is true, this string will be inserted between the headerSpan title(s) and the field title in the field chooser grid on the MultiSortDialog','multi-sort editor
		 * Flags: IRW, Group: i18nMessages */
		sortEditorSpanTitleSeparator?: string /* String */; // Flags=IRW
		/** The title for the corner sort button. The title will only Class.changeDefaults','ListGrid.changeDefaults() rather than replacing with an entirely new object.
		 * Flags: IR, Group: i18nMessages */
		sorterButtonTitle?: string; // Flags=IR
		/** Widget class for the corner sort button, if showing. This button displays the current sort direction of the primary sort field (either the only sorted field or the first in a ListGrid.canMultiSort','multi-sort grid) and reverses the direction of that field when clicked. For consistent appearance, this is usually set to match ListGrid.headerButtonConstructor
		 * Flags: IR, Group: gridHeader */
		sorterConstructor?: Class; // Flags=IR
		/** Defaults to apply to the corner sort button. To modify this object, use Class.changeDefaults','ListGrid.changeDefaults() rather than replacing with an entirely new object.
		 * Flags: IRA, Group: gridHeader */
		sorterDefaults?: any /* object */; // Flags=IRA
		/** Properties to apply to the sorter button. Overrides defaults applied via ListGrid.sorterDefaults.
		 * Flags: IRA, Group: gridHeader */
		sorterProperties?: ButtonProps /* Button Properties */; // Flags=IRA
		/** Specifies the field by which this grid should be initially sorted. Can be set to either a ListGridField.name','field name or the index of the field in the fields Array. ListGrids also support being initialized with multiple-field sort via ListGrid.initialSort. If initialSort is specified, it will be used in preference to this property. To sort the grid after it has been initialized, use ListGrid.sort or ListGrid.setSort. Details about the current sort of a live grid can be retrieved by calling ListGrid.getSortField or ListGrid.getSort
		 * Flags: IR, Group: sorting */
		sortField?: string | number /* String | int */; // Flags=IR
		/** If we're showing a ListGrid.showHeaderContextMenu','headerContextMenu for this grid, this attribute will be shown as the menu item title to sort a field in ascending order.
		 * Flags: IRW, Group: i18nMessages */
		sortFieldAscendingText?: string; // Flags=IRW
		/** If we're showing a ListGrid.showHeaderContextMenu','headerContextMenu for this grid, this attribute will be shown as the menu item title to sort a field in descending order.
		 * Flags: IRW, Group: i18nMessages */
		sortFieldDescendingText?: string; // Flags=IRW
		/** When multiple fields are sorted, the Style to apply to the numeral that appears after the sort-arrows in the header-buttons of sorted fields.
		 * Flags: IRWA */
		sortNumeralStyle?: string /* CSSStyleName */; // Flags=IRWA
		/** Initial sort state for the grid. ListGrid.viewState can be used to initialize all view properties of the grid. When doing so, sortState is not needed because viewState includes it as well. If both are provided, sortState has priority for sort state. To retrieve current state call ListGrid.getSortState','getSortState. 
		 * Flags: IRW, Group: viewState */
		sortState?: string /* ListGridSortState */; // Flags=IRW
		/** If this is an editable listGrid, this property determines how failure to save due to validation errors should be displayed to the user. If this property is true, when validation errors occur the errors will be displayed to the user in an alert, and focus will be returned to the first cell to fail validation. If false, the cells that failed validation will be silently styled with the editFailedBaseStyle. Note: stopOnErrors being set to true implies that 'waitForSave' is also true. We will not dismiss the editor until save has completed if stopOnErrors is true.
		 * Flags: IRWA, Group: editing */
		stopOnErrors?: boolean /* Boolean */; // Flags=IRWA
		/** Default CSS class for the ListGrid as a whole.
		 * Flags: IRW, Group: appearance */
		styleName?: string /* CSSStyleName */; // Flags=IRW
		/** If ListGrid.showGridSummary is true, and a ListGrid.summaryRowDataSource is specified this property may be used to specify fetch criteria to apply when retrieving summary data to show in the summary row. If unset, and any filter criteria have been specified for the grid, they will be used.
		 * Flags: IRWA */
		summaryRowCriteria?: Criteria; // Flags=IRWA
		/** If ListGrid.showGridSummary is true, by default summary values are calculated on the client based on the current data-set for the grid (see ListGrid.getGridSummary and ListGrid.getGridSummaryFunction). In some cases however it may make sense to calculate summary values on the server and retrieve them via a dataSource fetch. If set, this property specifies a dataSource to fetch against for the summary row. The dataSource should return a single record with summary data for each field for which summary data should be shown. Note that specifying this property completely bypasses the standard client-side grid summary calculation logic. The fetch may be further customized via ListGrid.summaryRowCriteria and ListGrid.summaryRowFetchRequestProperties
		 * Flags: IRA */
		summaryRowDataSource?: DataSource; // Flags=IRA
		/** If ListGrid.showGridSummary is true, and a ListGrid.summaryRowDataSource is specified this property may be used to customize the fetch request used when retrieving summary data to show in the summary row. An example use case might be specifying a DSRequest.operationId to perform a custom fetch operation which retrieved only summary values based on criteria.
		 * Flags: IRWA */
		summaryRowFetchRequestProperties?: DSRequestProps /* DSRequest Properties */; // Flags=IRWA
		/** Default height for the ListGrid.summaryRow','summary row autoChild. Note that this height is a minimum - the summary row has ListGrid.autoFitData set to "vertical" so if multiple rows are visible in the grid summary, the summaryRow component will expand to accommodate them.
		 * Flags: IR */
		summaryRowHeight?: number /* int */; // Flags=IR
		/** ListGrid.baseStyle for the ListGrid.summaryRow
		 * Flags: IRWA */
		summaryRowStyle?: string /* CSSStyleName */; // Flags=IRWA
		/** "Tall" baseStyle for this listGrid. Only applies if ListGrid.baseStyle is set to null. If baseStyle is unset, this property will be used as a base cell style unless the grid is showing fixed height rows with a specified cellHeight that matches ListGrid.normalCellHeight, in which case ListGrid.normalBaseStyle will be used. Note that in Internet Explorer if ListGrid.fastCellUpdates is true, tallBaseStyle will also be used even if the cellHeight matches the specified normalCellHeight for the grid. See cellStyleSuffixes for details on how stateful suffixes are combined with the base style to generate stateful cell styles.
		 * Flags: IR */
		tallBaseStyle?: string /* CSSStyleName */; // Flags=IR
		/** Display format to use for fields specified as type 'time'. May also be specified at the field level via ListGridField.timeFormatter. If unset, time fields will be formatted based on the system wide Time.shortDisplayFormat. If this field is editable, the timeFormatter will also be passed to the editor created to edit any time type fields as TimeItem.timeFormatter
		 * Flags: IRW, Group: appearance */
		timeFormatter?: TimeDisplayFormat; // Flags=IRW
		/** Best field to use for a user-visible title for an individual record from this grid. If ListGrid.dataSource is non null, this property may be specified on the dataSource instead. If not explicitly set, titleField looks for fields named "title", "name", and "id" in that order. If a field exists with one of those names, it becomes the titleField. If not, then the first field is designated as the titleField.
		 * Flags: IRW */
		titleField?: string; // Flags=IRW
		/** While scrolling an incrementally rendered grid, using the inertial scrolling, time in milliseconds to wait before redrawing, after the last touchScroll by the user. If not specified ListGrid.scrollRedrawDelay will be used as a default for both drag scrolling and touch scrolling. Note that if specified, this value will typically be larger than ListGrid.scrollRedrawDelay. See also GridRenderer.instantScrollTrackRedraw for cases where this delay is skipped.
		 * Flags: IRW, Group: performance */
		touchScrollRedrawDelay?: number /* Integer */; // Flags=IRW
		/** Default image to use for the dragTracker when things are dragged within or out of this list. See ImgProperties for format.
		 * Flags: IRWA, Group: dragTracker */
		trackerImage?: ImgProperties; // Flags=IRWA
		/** If we're showing a ListGrid.showHeaderContextMenu','headerContextMenu for this grid and ListGrid.canFreezeFields','this.canFreezeFields is true, this string will be shown as the title for the menu item to unfreeze a currently frozen field. This is a dynamic string - text within &#36;{...} will be evaluated as JS code when the message is displayed, with title available as a variable containing the field title. Default value returns "Unfreeze " + the field's summary title.
		 * Flags: IRWA, Group: i18nMessages */
		unfreezeFieldText?: string /* HTMLString */; // Flags=IRWA
		/** If we're showing a ListGrid.showHeaderContextMenu','headerContextMenu for this grid, and ListGrid.isGrouped','this.isGrouped is true, this attribute will be shown as the title for the menu item to ungroup the grid.
		 * Flags: IRW, Group: i18nMessages */
		ungroupText?: string; // Flags=IRW
		/** When ListGrid.canRemoveRecords is enabled, this icon will be shown in the auto generated field fro removing records if the record has been marked as removed via ListGrid.markRecordRemoved. At this point, clicking on the icon will unmark the record as removed.
		 * Flags: IR */
		unremoveIcon?: string /* SCImgURL */; // Flags=IR
		/** When ListGrid.headerSpans','headerSpans are in use, this property sets the default vertical alignment for for fields which do not have a headerSpan.
		 * Flags: IR, Group: headerSpan */
		unspannedHeaderVAlign?: string /* vAlign */; // Flags=IR
		/** If set to true, an advanced field picker based on the FieldPicker will be shown instead of the column picker submenu if there are more fields in the grid than ListGrid.advancedFieldPickerThreshold. When there are large numbers of available fields, the FieldPicker-based interface is more usable for both defining visible fields and defining field order.
		 * Flags: IR */
		useAdvancedFieldPicker?: boolean /* Boolean */; // Flags=IR
		/** If true, the set of fields given by the "default binding" (see DataBoundComponent.fields) is used, with any fields specified in component.fields acting as overrides that can suppress or modify the display of individual fields, without having to list the entire set of fields that should be shown. If component.fields contains fields that are not found in the DataSource, they will be shown after the most recently referred to DataSource field. If the new fields appear first, they will be shown first. validationFieldBinding', 'This example shows a mixture of component fields and DataSource fields, and how they interact for validation. This setting may be cleared if a FieldPicker is used to edit the component's field order.
		 * Flags: IRW, Group: databinding */
		useAllDataSourceFields?: boolean; // Flags=IRW
		/** Are rollovers cell-level or row-level?
		 * Flags: IRW */
		useCellRollOvers?: boolean /* Boolean */; // Flags=IRW
		/** Enables copy/paste shortcuts, provided ListGrid.canSelectCells is true The default setting of true means that the value of ListGrid.canSelectCells determines whether copy/paste shortcuts are enabled. Setting this property to false disables said shortcuts unconditionally. Copying is done via copying to a SmartClient-wide "clipboard" - not the OS-level clipboard, which is inaccessible on some browsers - via the methods ListGrid.getSelectedCellData and ListGrid.applyCellData. To copy data to and from applications outside of the browser, use the technique shown in the gridToExcel', 'Grid to Excel and excelToGrid', 'Excel to Grid samples. The following shortcuts are available: CTRL + D: copy cell values from top row of selected cells down to all rows CTRL + R: copy cell values from left column of selected cells right to all columns CTRL + C: copy selected cell values into shared clipboard CTRL + V: paste from shared clipboard into current selection
		 * Flags: IRW */
		useCopyPasteShortcuts?: boolean /* Boolean */; // Flags=IRW
		/** If ListGrid.saveLocally is specified, but this grid is bound to a DataSource which includes remote field validators, by default edits will be saved synchronously and these validators will not be executed. Set this property to true to ensure these remote validators are called when saving edits in saveLocally mode. Note that since these remote validators need to run on the server, saving with this property set is asynchronous, even though the data that ultimately gets updated is already present on the client.
		 * Flags: IRWA, Group: databinding */
		useRemoteValidators?: boolean; // Flags=IRWA
		/** Enables various styling behaviors that potentially make sense when ListGrid.getRowSpan has been overridden to introduce spanning cells, and spanning is largest on the left and smaller as cells go to the right. Specifically: computes ListGrid.alternateRecordStyles','banded styling based on the span of the cell in the left-most column enables ListGrid.canSelectCells','cell-level selection, including ListGrid.useCellRollOvers','cell-level rollover styling enables row-span-sensitive cell selection. See also RowSpanSelectionMode for available behaviors Because this setting enables ListGrid.canSelectCells, it is incompatible with any APIs that expect a record-oriented data model. Because this setting only makes sense when row spanning decreases from the first column to the last, it has unspecified behavior with ListGrid.canReorderFields.
		 * Flags: IR */
		useRowSpanStyling?: boolean; // Flags=IR
		/** Whether client-side validation checks should be performed when the user moves between cells in the current edit row. If unset, defaults to ListGrid.editByCell. Note that validation always occurs when a row is to be saved, so setting ListGrid.saveByCell:true forces validation on cell transitions. To completely disable automatic validation, set ListGrid.neverValidate:true.
		 * Flags: IRW, Group: gridValidation */
		validateByCell?: boolean; // Flags=IRW
		/** If true, validation will be performed on each edited cell when each editor's "change" handler is fired.
		 * Flags: IRW, Group: gridValidation */
		validateOnChange?: boolean; // Flags=IRW
		/** Height for value icons for this listGrid. Overrides ListGrid.valueIconSize. Can be overridden at the field level
		 * Flags: IRW, Group: imageColumns */
		valueIconHeight?: number; // Flags=IRW
		/** How much padding should there be on the left of valueIcons by default Can be overridden at the field level
		 * Flags: IRW, Group: imageColumns */
		valueIconLeftPadding?: number; // Flags=IRW
		/** How much padding should there be on the right of valueIcons by default
		 * Flags: IRW, Group: imageColumns */
		valueIconRightPadding?: number; // Flags=IRW
		/** Default width and height of value icons for this ListGrid. Can be overridden at the listGrid level via explicit ListGrid.valueIconWidth and ListGrid.valueIconHeight, or at the field level via ListGridField.valueIconSize, ListGridField.valueIconWidth and {ListGridField.valueIconHeight}
		 * Flags: IRW, Group: imageColumns */
		valueIconSize?: number; // Flags=IRW
		/** Width for value icons for this listGrid. Overrides ListGrid.valueIconSize. Can be overridden at the field level
		 * Flags: IRW, Group: imageColumns */
		valueIconWidth?: number; // Flags=IRW
		/** Initial ListGridViewState','view state for the grid. Since view state contains field state it is not necessary to set ListGrid.fieldState','fieldState when also setting viewState. If both are provided, fieldState has priority for field state. To retrieve current state call ListGrid.getViewState','getViewState. 
		 * Flags: IRW, Group: viewState */
		viewState?: string /* String */; // Flags=IRW
		/** When incremental rendering is switched on and there are variable record heights, the virtual scrolling mechanism manages the differences in scroll height calculations due to the unknown sizes of un-rendered rows to make the scrollbar and viewport appear correctly. When the virtualScrolling system is active, the last scroll position scrolls the last record to the top of the viewport, leaving blank space underneath. This is a necessary and unavoidable consequence of mapping the position of the scrollbar thumb to an unknown amount of remaining space without being able to know the total scrollable area in advance (since record heights vary). virtualScrolling is switched on automatically when ListGrid.fixedRecordHeights is false and also when using the ListGrid.showRecordComponents','recordComponents subsystem, as recordComponents expand the rows that contain them. This flag should be manually enabled when calling ListGrid.addEmbeddedComponent if embedded components can cause record sizes to expand beyond specified cellHeight. virtualScrolling is also automatically enabled when ListGrid.canExpandRecords is true to handle the fact that expanded rows may render at variable heights.
		 * Flags: IRA */
		virtualScrolling?: boolean; // Flags=IRA
		/** If this is an editable listGrid, this property determines whether the user will be able to dismiss the edit form, or navigate to another cell while the save is in process (before the asynchronous server response returns).
		 * Flags: IRWA, Group: editing */
		waitForSave?: boolean /* Boolean */; // Flags=IRWA
		/** If ListGrid.canRemoveRecords is true, when the user clicks the remove icon for some record, should we show a warning message (defined as ListGrid.warnOnRemovalMessage) and allow the user to cancel removal?
		 * Flags: IRW */
		warnOnRemoval?: boolean /* Boolean */; // Flags=IRW
		/** Warning message to show the user on a click on the 'remove' icon if ListGrid.canRemoveRecords is true and ListGrid.warnOnRemoval is true.
		 * Flags: IRW, Group: i18nMessages */
		warnOnRemovalMessage?: string; // Flags=IRW
		/** If a field has ListGridField.displayField specified and has no ListGridField.optionDataSource, this field will display the value from the displayField of each record by default (for more on this behavior see ListGridField.optionDataSource). If such a field is editable, changing the edit value for the field on some record, without updating the edit value for the associated display field on the same record would mean the user would continue to see the unchanged display field value. Developers can resolve this situation by programmatically setting an edit value for the display field as well as the data field, or avoid it by specifying an optionDataSource and ensuring ListGrid.autoFetchDisplayMap is true, or setting an explicit valueMap for the field. By default, when the edit value on a field with a specified displayField and no optionDataSource is set, we log a warning to notify the developer. This warning may be disabled by setting warnOnUnmappedValueFieldChange to false. Note: There are actually a couple of cases in which the system will automatically derive a new display-field value and apply it to the record: If the edit value was changed by a user actually editing the record (rather than a programmatic call to setEditValue()), and the edit-item had a valueMap or optionDataSource set, we automatically pick up the display value from that item and store it as an edit-value for the displayField of the record If the listGrid has a loaded record in its data set whose valueField value matches the edit value for the valueField, we automatically apply the displayField value from that record as an edit value for the displayField on the newly edited record. In either case, the display value for the record is updated automatically (and the warning would not be logged).
		 * Flags: IRWA */
		warnOnUnmappedValueFieldChange?: boolean /* Boolean */; // Flags=IRWA
		/** Should content within cells be allowed to wrap? Even if content is allowed to wrap, if ListGrid.fixedRecordHeights is set, the content will be clipped off at the cell boundary. Either set a larger, fixed ListGrid.cellHeight to reveal more content, or set ListGrid.fixedRecordHeights to false to allow auto-sizing.
		 * Flags: IRWA */
		wrapCells?: boolean /* Boolean */; // Flags=IRWA
		/** If HeaderSpan.wrap is not explicitly set, should fields wrap? If autofitting, see the docs on that property for the details of how the minimum width for a field is determined.
		 * Flags: IR */
		wrapHeaderSpanTitles?: boolean /* Boolean */; // Flags=IR
		/** If ListGridField.wrap is not explicitly set, should fields wrap? If autofitting, see the docs on that property for the details of how the minimum width for a field is determined.
		 * Flags: IR */
		wrapHeaderTitles?: boolean /* Boolean */; // Flags=IR

		/* Method Overrides */

		/** 
		 * Called when a cell receives a contextclick event.
		 * @param {ListGridRecord} record - cell record as returned by getCellRecord
		 * @param {number} rowNum - row number for the cell
		 * @param {number} colNum - column number of the cell
		 */
		cellContextClick?(record:ListGridRecord, rowNum:number, colNum:number): boolean; 

		/** 
		 * Clear the current criteria used to filter data.
		 * @param {DSCallback} callback - callback to invoke on completion
		 * @param {DSRequest} requestProperties - additional properties to set on the DSRequest that will be issued
		 */
		clearCriteria?(callback?:DSCallback, requestProperties?:DSRequest): void; 

		/** 
		 * Retrieves data from the DataSource that matches the specified criteria. When fetchData() is first called, if data has not already been provided via ListGrid.setData','setData(), this method will create a ResultSet, which will be configured based on component settings such as DataBoundComponent.fetchOperation and DataBoundComponent.dataPageSize, as well as the general purpose ListGrid.dataProperties. The created ResultSet will automatically send a DSRequest to retrieve data from ListGrid.dataSource','listGrid.dataSource, and from then on will automatically manage paging through large datasets, as well as performing filtering and sorting operations inside the browser when possible - see the ResultSet docs for details. NOTE: do not use both DataBoundComponent.autoFetchData','autoFetchData:true and a call to fetchData() - this may result in two DSRequests to fetch data. Use either DataBoundComponent.autoFetchData','autoFetchData and Criteria or a manual call to fetchData() passing criteria. Whether a ResultSet was automatically created or provided via ListGrid.setData','setData(), subsequent calls to fetchData() will simply call ResultSet.setCriteria. Changes to criteria may or may not result in a DSRequest to the server due to ResultSet.useClientFiltering','client-side filtering. You can call DataBoundComponent.willFetchData','willFetchData(criteria) to determine if new criteria will result in a server fetch. If you need to force data to be re-fetched, you can call ListGrid.invalidateCache','invalidateCache() and new data will automatically be fetched from the server using the current criteria and sort direction. NOTE: when using invalidateCache() there is no need to also call fetchData() and in fact this could produce unexpected results. This method takes an optional callback parameter (set to a DSCallback) to fire when the fetch completes. Note that this callback will not fire if no server fetch is performed. In this case the data is updated synchronously, so as soon as this method completes you can interact with the new data. If necessary, you can use DataBoundComponent.willFetchData','willFetchData() to determine whether or not a server fetch will occur when fetchData() is called with new criteria. In addition to the callback parameter for this method, developers can use ListGrid.dataArrived','dataArrived() to be notified every time data is loaded. By default, this method assumes a TextMatchStyle of "exact"; that can be overridden by supplying a different value in the requestProperties parameter. See DataBoundComponent.willFetchData;
		 * @param {Criteria} criteria - Search criteria. If a DynamicForm is passed in as this argument instead of a raw criteria object, will be derived by calling DynamicForm.getValuesAsCriteria
		 * @param {DSCallback} callback - callback to invoke when a fetch is complete. Fires only if server contact was required
		 * @param {DSRequest} requestProperties - additional properties to set on the DSRequest that will be issued
		 */
		fetchData?(criteria?:Criteria, callback?:DSCallback, requestProperties?:DSRequest): void; 

		/** 
		 * Return CSS text for styling this cell, which will be applied in addition to the CSS class for the cell, as overrides. "CSS text" means semicolon-separated style settings, suitable for inclusion in a CSS stylesheet or in a STYLE attribute of an HTML element. 
		 * @param {ListGridRecord} record - cell record as returned by getCellRecord
		 * @param {number} rowNum - row number for the cell
		 * @param {number} colNum - column number of the cell
		 */
		getCellCSSText?(record:ListGridRecord, rowNum:number, colNum:number): string; 

		/** 
		 * Retrieves a copy of the current criteria for this component (may be null). Note: if ListGrid.showFilterEditor is true, the criteria returned by this method may not match the values currently displayed in the filter editor, since the user may have entered values which have not yet been applied to our data. ListGrid.getFilterEditorCriteria may be used to retrieve the current criteria displayed in the filterEditor.
		 */
		getCriteria?(): Criteria; 

		/** 
		 * Given a column number or field name, return the field definition of a field which is visible in the grid. To retrieve the definition of any field, including hidden ones, use ListGrid.getFieldByName','getFieldByName(). When using DataBoundComponent.fields','DataBinding, the field definition may be a mix of information derived from ListGrid.fields and ListGrid.dataSource.
		 * @param {number} colNum - number or id of the field.
		 */
		getField?(colNum:number | string /* int | ID */): ListGridField; 

		/** 
		 * Given a column number or field id, return the field name of a field.
		 * @param {number} colNum - number or id of the field.
		 */
		getFieldName?(colNum:number | string /* number or id */): string; 

		/** 
		 * Return the pointer to a particular record by record number. Synonym for ListGrid.getCellRecord.
		 * @param {number} recordNum - row index of record to return.
		 */
		getRecord?(recordNum:number): ListGridRecord; 

		/** 
		 * Returns all selected records in this grid. <strong>NOTE:</strong> Records in the returned array should be treated as read-only and not modified.
		 * @param {boolean} excludePartialSelections - When true, partially selected records will not be returned. Otherwise, both fully and partially selected records are returned.
		 */
		getSelectedRecords?(excludePartialSelections?:boolean): Array<ListGridRecord> /* Array of ListGridRecord */; 

		/** 
		 * Returns all selected records in this grid. If this grid is ListGrid.isGrouped','grouped, group header nodes will not be included in the returned array. Developers can make use of ListGrid.getGroupTreeSelection to get the selection including the selected group header nodes. <strong>NOTE:</strong> Records in the returned array should be treated as read-only and not modified.
		 * @param {boolean} excludePartialSelections - When true, partially selected records will not be returned. Otherwise, both fully and partially selected records are returned.
		 */
		getSelection?(excludePartialSelections?:boolean /* Boolean */): Array<ListGridRecord> /* Array of ListGridRecord */; 

		/** 
		 * Returns a snapshot of the current view state of this ListGrid. This includes the field, sort, hilite, group, and selected state of the grid, returned as a string representation of a ListGridViewState object. This string can be passed to ListGrid.setViewState to reset this grid's view state to the current state (assuming the same data / fields are present in the grid).
		 */
		getViewState?(): string /* ListGridViewState */; 

		/** 
		 * Marks the widget as "dirty" so that it will be added to a queue for redraw. Redraw of dirty components is handled by a looping timer and will after a very short delay (typically less than 100ms). In most cases it is recommended that developers use markForRedraw() instead of calling Canvas.redraw directly. Since this method queues the redraw, multiple calls to markForRedraw() within a single thread of execution will only lead to a single DOM manipulation which greatly improves application performance.
		 * @param {string} reason - reason for performing the redraw
		 */
		markForRedraw?(reason?:string): void; 

		/** 
		 * Executed when the listGrid receives a 'click' event on an enabled, non-separator record. The default implementation does nothing -- override to perform some action when any record or field is clicked. A record event handler can be specified either as a function to execute, or as a string of script to evaluate. If the handler is defined as a string of script, all the parameters below will be available as variables for use in the script. To do something specific if a particular field is clicked, add a recordClick method or string of script to that field (same parameters) when you're setting up the list. Notes: This will not be called if the click is below the last item of the list. This method is called from the default implementation of ListGrid.rowClick, so if that method is overridden this method may not be fired.
		 * @param {ListGrid} viewer - the listGrid that contains the click event
		 * @param {ListGridRecord} record - the record that was clicked on
		 * @param {number} recordNum - number of the record clicked on in the current set of displayed records (starts with 0)
		 * @param {ListGridField} field - the field that was clicked on (field definition)
		 * @param {number} fieldNum - number of the field clicked on in the listGrid.fields array
		 * @param {any} value - value of the cell (after valueMap, etc. applied)
		 * @param {any} rawValue - raw value of the cell (before valueMap, etc applied)
		 */
		recordClick?(viewer:ListGrid, record:ListGridRecord, recordNum:number, field:ListGridField, fieldNum:number, value:any, rawValue:any): boolean; 

		/** 
		 * Remove a record from this ListGrid. If this grid is bound to a DataSource, it will perform a DataSource "remove" operation to remove records from this component's DataSource. Otherwise the data will be removed from the grid's ListGrid.data','data object. To make changes to the local data object even when a DataSource is present, use ListGrid.saveLocally.
		 * @param {any} data - listGrid record, or primary key values of record to delete.
		 * @param {DSCallback} callback - method to call on operation completion. Note that if this is method does not trigger a dataSource remove operation, the callback will still be fired when the data has been removed, but the dsResponse parameter will be null.
		 * @param {DSRequestProps} requestProperties - additional properties to set on any DSRequest that will be issued
		 */
		removeData?(data:any /* Record */, callback?:DSCallback, requestProperties?:DSRequestProps /* DSRequest Properties */): void; 

		/** 
		 * Select/deselect a Record passed in explicitly, or by index. Note that this method selects records unconditionally, allowing multiple selected records, even when ListGrid.selectionType is "single". To enforce mutually-exclusive record-selection, use ListGrid.selectSingleRecord.
		 * @param {any} record - record (or row number) to select
		 * @param {boolean} newState - new selection state (if null, defaults to true)
		 */
		selectRecord?(record:any | number /* Record | number */, newState?:boolean): void; 

		/** 
		 * Sets this component's filter criteria. Default implementation calls this.data.setCriteria(). Note: if ListGrid.showFilterEditor is true, the ListGrid.setFilterEditorCriteria method may be used to update the values displayed in the filter editor without effecting the data object.
		 * @param {Criteria} param0 - new criteria to show
		 */
		setCriteria?(param0:Criteria | AdvancedCriteria /* Criteria or AdvancedCriteria */): void; 

		/** 
		 * Setter for the ListGrid.showFilterEditor property. Allows the filter editor to be shown or hidden at runtime.
		 * @param {boolean} value - true if the filter editor should be shown, false if it should be hidden
		 */
		setShowFilterEditor?(value:boolean): void; 

		/** 
		 * Reset this grid's view state to match the ListGridViewState object passed in. Used to restore previous state retrieved from the grid by a call to ListGrid.getViewState.
		 * @param {string} viewState - Object describing the desired view state for the grid
		 */
		setViewState?(viewState:string /* ListGridViewState */): void; 

		/** 
		 * Start editing a new row, after the last pre-existing record in the current set of data. This new row will be saved via the "add" dataSourceOperations','DataSource\n operation. See the editing','Grid Editing overview and also the unsavedRecords','Editing Unsaved Records overview for context about how unsaved records behave. You can optionally pass newValues which are the initial values for the newly added record. See also ListGridField.defaultValue as a means of setting default values every time the user begins editing a new record, for instance, by pressing downArrow on the last normal record in the grid when ListGrid.listEndEditAction is "next". If editing is already underway elsewhere in the grid, startEditingNew() behaves just like ListGrid.startEditing.
		 * @param {any} newValues - Optional initial set of properties for the new record
		 * @param {boolean} suppressFocus - Whether to suppress the default behavior of moving focus to the newly shown editor.
		 */
		startEditingNew?(newValues?:any | any /* Map | Record */, suppressFocus?:boolean /* Boolean */): void; 

		/** 
		 * Perform a DataSource "update" operation to update existing records in this component's DataSource.
		 * @param {any} updatedRecord - updated record
		 * @param {DSCallback} callback - method to call on operation completion
		 * @param {DSRequestProps} requestProperties - additional properties to set on the DSRequest that will be issued
		 */
		updateData?(updatedRecord:any /* Record */, callback?:DSCallback, requestProperties?:DSRequestProps /* DSRequest Properties */): void; 

	} // ListGridProps


	/**
	 * A ListGrid is a DataBoundComponent that displays a list of objects in a grid, where each row represents one object and each cell in the row represents one property. 
	 */
	export interface ListGrid extends VLayout {
		/** When ListGrid.useAdvancedFieldPicker is set, total number of available fields that must be present in the grid before the advanced field picker interface is used instead of the normal columns submenu. Set to 0 to have the advanced picker always used (when useAdvancedFieldPicker is true).
		 * Flags: IR */
		advancedFieldPickerThreshold: number /* int */;

		/** For use with ListGrid.showFilterEditor:true, allows simple search expressions to be entered into filter fields, as though DynamicForm.allowExpressions were true. Can also be enabled or disabled on a field-by-field basis via ListGridField.filterEditorProperties.
		 * Flags: IR, Group: advancedFilter */
		allowFilterExpressions: boolean;

		/** Causes a menu item titled ListGrid.filterUsingText','"Filter using" to appear in the ListGrid.showHeaderContextMenu','headerContextMenu that allows the end user to pick an advanced OperatorId','search operator to use for this field. Once an operator has been chosen, the active operator is indicated by an ListGrid.operatorIcon placed within the field (you can alternatively cause the icon to ListGrid.alwaysShowOperatorIcon','always be present). The operatorIcon shows the same textual representation of the search operator as is used by the FormItem.allowExpressions feature. Clicking on the icon provides a second way to modify the search operator. This feature is enabled by default if DataSource.supportsAdvancedCriteria is true, for all fields where it is normally possible to filter by typing in a search string. This excludes field types such as "date" or "boolean" which show specialized filter controls. Use ListGridField.allowFilterOperators to disable this interface for individual fields, or set DataSourceField.canFilter to false to disallow filtering entirely for a field. Note that this feature is similar to ListGrid.allowFilterExpressions, which allows the end users to directly type in characters such as "&gt;" to control filtering. allowFilterOperators is easier to use and more discoverable than allowFilterExpressions, and also avoids the drawback where special characters like "&gt;" cannot be used in filter values. However, allowFilterExpressions allows users to make use of certain operators that allowFilterOperators does not support, such as using the "betweenInclusive" operator by typing "5...10". When both allowfilterExpressions and allowFilterOperators are set, filter expressions entered in to the edit-area are parsed and the operator automatically applied to the ListGrid.operatorIcon.
		 * Flags: IR */
		allowFilterOperators: boolean /* Boolean */;

		/** Should cells in this grid be allowed to span multiple rows? If set to true, the ListGrid.getRowSpan method will be called for every cell when rendering out the listGrid to determine how many rows the cell should span. See ListGrid.getRowSpan for more details
		 * Flags: IR */
		allowRowSpanning: boolean /* Boolean */;

		/** Optional css style to apply to the body if ListGrid.alternateRecordStyles is true for this grid. If unset ListGrid.bodyStyleName will be used to style the body regardless of the ListGrid.alternateRecordStyles','alternateRecordStyles setting.
		 * Flags: IRWA */
		alternateBodyStyleName: string /* CSSStyleName */;

		/** The number of consecutive columns to draw in the same style before alternating, when GridRenderer.alternateColumnStyles','alternateColumnStyles is true.
		 * Flags: IRW, Group: cellStyling */
		alternateFieldFrequency: number;

		/** Whether alternating columns (or blocks of columns, depending on GridRenderer.alternateColumnFrequency) should be drawn in alternating styles, in order to create a vertical "ledger" effect for easier reading. If enabled, the cell style for alternate rows will have the ${isc.DocUtils.linkForRef('alternateColumnSuffix')} appended to it. See also ${isc.DocUtils.linkForRef('alternateRowStyles')}.
		 * Flags: IRW, Group: cellStyling */
		alternateFieldStyles: boolean;

		/** The number of consecutive rows to draw in the same style before alternating, when GridRenderer.alternateRowStyles','alternateRowStyles is true.
		 * Flags: IRW, Group: cellStyling */
		alternateRecordFrequency: number;

		/** Whether alternating rows (or blocks of rows, depending on GridRenderer.alternateRowFrequency) should be drawn in alternating styles, in order to create a "ledger" effect for easier reading. If enabled, the cell style for alternate rows will have the ${isc.DocUtils.linkForRef('alternateRowSuffix')} appended to it. See also ${isc.DocUtils.linkForRef('alternateColumnStyles')}.
		 * Flags: IRW, Group: cellStyling */
		alternateRecordStyles: boolean /* Boolean */;

		/** Suffix to append to GridRenderer.alternateRowStyles','alternate rows. Note that if GridRenderer.alternateColumnStyles is enabled, cells which fall into both an alternate row and column will have both suffixes appended - for example "cellDarkAltCol".
		 * Flags: IRW, Group: cellStyling */
		alternateRecordSuffix: string /* String */;

		/** When this attribute is set, editors will be rendered into every row of the grid rather than showing up in a single record at a time. This attribute is only valid when ListGrid.editByCell is false
		 * Flags: IR, Group: editing */
		alwaysShowEditors: boolean;

		/** When ListGrid.allowFilterOperators is enabled, whether to show the ListGrid.operatorIcon for all filterable fields, or only for fields where the user has explicitly chosen a search operator different from the default operator for the field. The default operator for a field is determined by ListGrid.autoFetchTextMatchStyle or by setting ListGridField.filterOperator for a specific field.
		 * Flags: IR */
		alwaysShowOperatorIcon: boolean /* Boolean */;

		/** When animating folder opening / closing, this property can be set to apply an animated acceleration effect. This allows the animation speed to be "weighted", for example expanding or collapsing at a faster rate toward the beginning of the animation than at the end. For a ListGrid, this property applies when ListGrid.canGroupBy','grouping is enabled.
		 * Flags: IRW, Group: animation */
		animateFolderEffect: AnimationAcceleration;

		/** If ListGrid.animateFolders is true for this grid, this number can be set to designate the maximum number of rows to animate at a time when opening / closing a folder. For a ListGrid, this property applies when ListGrid.canGroupBy','grouping is enabled.
		 * Flags: IRW, Group: animation */
		animateFolderMaxRows: number /* integer */;

		/** If true, when folders are opened / closed children will be animated into view. For a ListGrid, this property applies when ListGrid.canGroupBy','grouping is enabled.
		 * Flags: IRW, Group: animation */
		animateFolders: boolean /* Boolean */;

		/** When animating folder opening / closing, this property designates the speed of the animation in pixels shown (or hidden) per second. Takes precedence over the TreeGrid.animateFolderTime property, which allows the developer to specify a duration for the animation rather than a speed. For a ListGrid, this property applies when ListGrid.canGroupBy','grouping is enabled.
		 * Flags: IRW, Group: animation */
		animateFolderSpeed: number;

		/** When animating folder opening / closing, if TreeGrid.animateFolderSpeed is not set, this property designates the duration of the animation in ms. For a ListGrid, this property applies when ListGrid.canGroupBy','grouping is enabled.
		 * Flags: IRW, Group: animation */
		animateFolderTime: number;

		/** When ListGrid.canRemoveRecords is enabled, should records be animated out of view when they are removed by the user?
		 * Flags: IRW */
		animateRemoveRecord: boolean /* Boolean */;

		/** When ListGrid.animateRemoveRecord','animating record removal, this property designates the speed of the animation in pixels per second. Takes precedence over the ListGrid.animateRemoveTime property, which allows the developer to specify a duration for the animation rather than a speed.
		 * Flags: IRW, Group: animation */
		animateRemoveSpeed: number;

		/** When animating record removal ListGrid.animateRemoveRecord','(see animateRemoveRecord), if ListGrid.animateRemoveSpeed is not set, this property designates the duration of the animation in ms.
		 * Flags: IRW, Group: animation */
		animateRemoveTime: number;

		/** If the ListGrid.rollOverCanvas','rollOverCanvas is enabled, setting this property to true ensures that when the rollOverCanvas is displayed it is animated into view via Canvas.animateShow. Note that the animation effect may be customized via Canvas.animateShowEffect, Canvas.animateShowTime and Canvas.animateShowAcceleration set in rollOverCanvasProperties.
		 * Flags: IRWA, Group: rowEffects */
		animateRollOver: boolean /* Boolean */;

		/** If the ListGrid.rollUnderCanvas','rollUnderCanvas is enabled, setting this property to true ensures that when the rollUnderCanvas is displayed it is animated into view via Canvas.animateShow. Note that the animation effect may be customized via Canvas.animateShowEffect, Canvas.animateShowTime and Canvas.animateShowAcceleration set in rollUnderCanvasProperties.
		 * Flags: IRWA, Group: rowEffects */
		animateRollUnder: boolean /* Boolean */;

		/** If the ListGrid.selectionCanvas','selectionCanvas is enabled, setting this property to true ensures that when the selectionCanvas is displayed it is animated into view via Canvas.animateShow. Note that the animation effect may be customized via Canvas.animateShowEffect, Canvas.animateShowTime and Canvas.animateShowAcceleration set in selectionCanvasProperties.
		 * Flags: IRWA, Group: rowEffects */
		animateSelection: boolean /* Boolean */;

		/** If the ListGrid.selectionUnderCanvas','selectionUnderCanvas is enabled, setting this property to true ensures that when the selectionUnderCanvas is displayed it is animated into view via Canvas.animateShow. Note that the animation effect may be customized via Canvas.animateShowEffect, Canvas.animateShowTime and Canvas.animateShowAcceleration set in selectionUnderCanvasProperties.
		 * Flags: IRWA, Group: rowEffects */
		animateSelectionUnder: boolean /* Boolean */;

		/** If ListGridField.userFormula is set for some field, and this grid is showing ListGrid.showGroupSummary','group summaries or a ListGrid.showGridSummary','grid summary, this property determines what field value should be present in those summary rows. Should the field apply the user-formula to the calculated summary row, or should it apply a standard grid or group summary to the user-formula values displayed in the grid? May be overridden at the field level via ListGridField.applyAfterSummary
		 * Flags: IRW */
		applyFormulaAfterSummary: boolean /* Boolean */;

		/** If ListGrid.showRowNumbers is true, should we apply the ListGrid.rowNumberStyle to the ListGrid.rowNumberField
		 * Flags: IRWA, Group: rowNumberField */
		applyRowNumberStyle: boolean;

		/** Action to perform when the listGrid has keyboard focus (but not editing focus) and a user presses the up or down arrow key. Possible values are: "select" : select the next row in the list (calls recordClick handler) "focus" : move focus to the next row in the list without changing the selection "activate" : select and activate the next row in the list (calls recordDoubleClick handler) "none" : no action null : if ListGrid.selectionAppearance is "checkbox", behaves as if set to "focus"; otherwise, behaves as if set to "select" 
		 * Flags: IRWA, Group: events */
		arrowKeyAction: string;

		/** The prompt to display while interactivity is blocked during ListGrid.groupByAsyncThreshold','asynchronous grouping.
		 * Flags: IR, Group: i18nMessages */
		asynchGroupingPrompt: string /* HTMLString */;

		/** Whether to do inline autoComplete in text fields during inline editing Overridden by ListGridField.autoComplete if specified. If unset picks up the default from the appropriate editor class (subclass of FormItem).
		 * Flags: IRW, Group: autoComplete */
		autoComplete: AutoComplete;

		/** For editable listGrids, outstanding unsaved edits when the user performs a new filter or sort will be discarded by default. This flag determines whether we should save such edits automatically in this case. See also ListGrid.confirmDiscardEdits, which allows the user to choose whether to save or discard the unsaved edits.
		 * Flags: IRW, Group: editing */
		autoConfirmSaveEdits: boolean /* Boolean */;

		/** If true, when this component is first drawn, automatically call this.fetchData(). Criteria for this fetch may be picked up from ListGrid.initialCriteria, and textMatchStyle may be specified via ListGrid.autoFetchTextMatchStyle','autoFetchTextMatchStyle. <span style='color:red'>NOTE:</span> if autoFetchData is set, calling ListGrid.fetchData','fetchData() before draw will cause two requests to be issued, one from the manual call to fetchData() and one from the autoFetchData setting. The second request will use only ListGrid.initialCriteria and not any other criteria or settings from the first request. Generally, turn off autoFetchData if you are going to manually call ListGrid.fetchData','fetchData() at any time.
		 * Flags: IR, Group: databinding */
		autoFetchData: boolean;

		/** If true, for fields where ListGridField.optionDataSource is specified, a valueMap will be automatically created by making a DataSource.fetchData call against the specified dataSource and extracting a valueMap from the returned records based on the displayField and valueField. If set to false, valueMaps will not be automatically fetched. In this case, setting field.optionDataSource is effectively a shortcut for setting optionDataSource on the editor via ListGridField.editorProperties. Can also be disabled on a per-field basis with ListGridField.autoFetchDisplayMap.
		 * Flags: IRW, Group: display_values */
		autoFetchDisplayMap: boolean /* Boolean */;

		/** When this grid is initially filtered via ListGrid.autoFetchData, or filtered by the user via the ListGrid.showFilterEditor','filterEditor, this attribute can be used to set the textMatchStyle on the dsRequest passed to fetchData(). To use a mixture of textMatchStyles, set an appropriate FormItem.operator','operator on a field's ListGridField.filterEditorProperties','filterEditorProperties.
		 * Flags: IR, Group: dataBinding */
		autoFetchTextMatchStyle: TextMatchStyle;

		/** If we're showing a ListGrid.showHeaderContextMenu','headerContextMenu for this grid, and ListGrid.canAutoFitFields is true, this attribute will be shown as the menu item title for an item to perform a one-time autoFit of all visible fields via the ListGrid.autoFitField method.
		 * Flags: IRW, Group: i18nMessages */
		autoFitAllText: string;

		/** If ListGrid.autoFitFieldWidths is enabled and the calculated field sizes are wide enough that horizontal scrolling would be introduced, this attribute may be set to an array of fieldNames, causing those fields to be clipped rather than forcing horizontal scrollbars to appear. Note: If any ListGridField.frozen','frozen columns are included in this list they will not be clipped.
		 * Flags: IR, Group: autoFitFields */
		autoFitClipFields: Array<string> /* Array of String */;

		/** Should this ListGrid automatically expand to accommodate the size of records and fields? Valid settings are "vertical": expand vertically to accommodate records. "horizontal": expand horizontally to accommodate fields. "both": expand horizontally and vertically to accommodate content. How far the ListGrid will expand may be limited via the following properties: ListGrid.autoFitMaxHeight, ListGrid.autoFitMaxRecords, ListGrid.autoFitMaxWidth, ListGrid.autoFitMaxColumns. Note that this property causes the grid as a whole to expand to fit records or fields. To have the fields or records themselves expand to fit cell contents, see ListGrid.autoFitFieldWidths and ListGrid.fixedRecordHeights.
		 * Flags: IRW, Group: autoFitData */
		autoFitData: Autofit;

		/** Should listGrids automatically size date fields to fit their values or titles? If set to "value", fields of type date will be rendered at the size specified by ListGrid.defaultDateFieldWidth, (or ListGrid.defaultEditableDateFieldWidth for editable fields). This static value is appropriate for dates rendered with the standard short-date formatter. If set to "title" or "both", the drawn width of the title will be taken into account when sizing the column. This is achieved by enabling ListGridField.autoFitWidth','autoFitWidth:true on date fields when this property is set to anything other than "none", setting the ListGridField.autoFitWidthApproach to the value specified here and having logic in ListGrid.getDefaultFieldWidth pick up the ListGrid.defaultDateFieldWidth or ListGrid.defaultEditableDateFieldWidth if appropriate.
		 * Flags: IRW, Group: autoFitFields */
		autoFitDateFields: AutoFitWidthApproach;

		/** The field to expand if ListGrid.autoFitFieldWidths and ListGrid.autoFitFieldsFillViewport are enabled and auto-fitting will not fill all available horizontal space. If unset, will default to the text field with the longest DataSourceField.length if length is set, otherwise, the first text field with no width specified. Note that expanding ListGridField.frozen','frozen columns is not supported.
		 * Flags: IR, Group: autoFitFields */
		autoFitExpandField: string /* String */;

		/** If ListGrid.autoFitData is set to "vertical" or "both", setting this property will cause the ListGrid body to size large enough to accomodate the actual data and also leave this many extra rows' worth of blank space below the last record. If a maximum size is specified via ListGrid.autoFitMaxHeight or ListGrid.autoFitMaxRecords, it will still be respected. Once the data set is large enough to fill or exceed that space, this property no longer has an effect.
		 * Flags: IRW, Group: autoFitData */
		autoFitExtraRecords: number;

		/** If ListGrid.autoFitFieldWidths is enabled, and extra space is available after autofitting all fields, should the grid automatically expand one field to fill the extra space. When enabled, the field to expand may be specified via ListGrid.autoFitExpandField. Note this logic will not expand a ListGridField.frozen','frozen column.
		 * Flags: IR, Group: autoFitFields */
		autoFitFieldsFillViewport: boolean /* Boolean */;

		/** If we're showing a ListGrid.showHeaderContextMenu','headerContextMenu for this grid, and user-driven auto fit of fields is enabled via ListGridField.canAutoFitWidth or ListGrid.canAutoFitFields, this attribute will be shown as the menu item title for an item to perform a one-time autoFit of the field to its title or content via a call to ListGrid.autoFitField.
		 * Flags: IRW, Group: i18nMessages */
		autoFitFieldText: string;

		/** Should ListGrid fields autofit their widths to titles or content? This property may be overridden on a per-field basis via ListGridField.autoFitWidth. Developers may wish to consider disabling autoFit for fields known to have exceptionally long content as this can lead to large horizontal scrollbars and unwieldy UI. The ListGrid.autoFitWidthApproach controls whether fitting is to values, titles or both. This property may also be overridden on a per field basis. If ListGridField.width','field.width is also set on the field, it will be taken as a minimum width. ListGrid.minFieldWidth will also be respected. By default, the entire available width of the grid will still be used, by allocating any "extra" space to specific columns - see ListGrid.autoFitFieldsFillViewport for details on controlling this behavior. When this feature is enabled, autofitting is active on an ongoing basis. Autofitting will be performed: whenever the dataset is completely changed or rows are added or removed whenever a field which is autofitting is changed on a manual call to ListGrid.autoFitField or ListGrid.autoFitFields Auto-fitting behavior continues until the user resizes the field manually, at which point it stops. The user can also perform a one-time auto-fit of fields via the header context menu if ListGrid.canAutoFitFields is enabled. When autofitting to column values, ListGrid.getDefaultFieldWidth will be called to determine the space required for a field's values. This method uses values from the rendered set of rows to calculate the required column width, which means the field width may still be smaller than values from non-rendered rows. See ListGrid.showAllRecords and ListGrid.drawAheadRatio) to control incremental rendering of rows. Note that for icon type fields, the ListGrid.autoFitIconFields property setting may turn on auto-fit-width behavior for specific fields by default, even if autoFitFieldWidths is false for the grid as a whole. Using this feature has a performance penalty roughly comparable to always rendering one additional field per field where autofitting is enabled. Specifically, enabling it for all fields would be comparable to both doubling the number of fields and disabling ListGrid.showAllColumns','horizontal incremental rendering. In a grid where only half the fields are normally visible and hence only half are normally rendered, this would be roughly 4 times slower overall. This performance penalty is a result of ListGrid.getDefaultFieldWidth having to render out the data set offscreen and measure the rendered content - it does not apply for cases where this method can return a simple fixed values (as with icon fields). Which fields are currently autofitting is saved as part of the ListGrid.getViewState','view state of the ListGrid.
		 * Flags: IR, Group: autoFitFields */
		autoFitFieldWidths: boolean /* Boolean */;

		/** If this property is set to true, header buttons for either ListGrid.fields','fields or ListGrid.headerSpans','header spans will automatically expand to accommodate their titles vertically. This means if you have a "tall" title - typically a long string where ListGridField.wrap is set to true such that you end up with several lines of text - the button will render large enough to accommodate it. If necessary this will cause the header for the grid as a whole to expand beyond the specified ListGrid.headerHeight. Note that you need not set HeaderSpan.height or ListGrid.headerSpanHeight if you set this property, but if you do, they will be used as minimum values.
		 * Flags: IR */
		autoFitHeaderHeights: boolean;

		/** SmartClient listGrids have special logic to automatically size fields that are displayed as an icon - that is fields with ListGridFieldType','type:"icon", fields displaying only ListGridField.showValueIconOnly','value icons, and boolean fields (which are rendered as a checkmark type icon by default. This attribute controls this behavior - governing whether icon fields should be sized to fit their content (icon), title, or whether to disable this behavior. Setting this value to "title" or "iconWidth" will cause ListGridField.autoFitWidth to be enabled by default for all icon fields with the ListGridField.autoFitWidthApproach set to "value" or "both" as appropriate. Note that the width required for the icons is calculated by ListGrid.getDefaultFieldWidth which performs a simple calculation based on the specified icon width for these types of fields. This setting governs default behavior for icon fields - for specific fields within a grid, this default behavior can be overridden by setting an explicit ListGridField.width or explicitly enabling ListGridField.autoFitWidth and setting ListGridField.autoFitWidthApproach on the field in question.
		 * Flags: IRW, Group: autoFitFields */
		autoFitIconFields: AutoFitIconFieldType;

		/** If ListGrid.autoFitData is set to "horizontal" or "both" this property provides the maximum number of columns for which the ListGrid will expand. If more columns are present, scrolling will be introduced to reach them as normal. If unset the ListGrid will expand to accommodate as many columns as are defined for the grid.
		 * Flags: IRW, Group: autoFitData */
		autoFitMaxColumns: number;

		/** If ListGrid.autoFitData is set to "vertical" or "both" this property provides an upper limit on how far the ListGrid will expand vertically to accommodate its content. If content exceeds this height, scrollbars will be introduced as usual. In addition to this property, ListGrid.autoFitMaxRecords allows you to limit vertical expansion based on the number of rows to be rendered.
		 * Flags: IRW, Group: autoFitData */
		autoFitMaxHeight: number;

		/** If ListGrid.autoFitData is set to "vertical" or "both" this property provides the maximum number of records for which the ListGrid will expand. If more records are present, scrolling will be introduced to reach them as normal. If unset, by default the ListGrid will expand to accommodate as many records as are present.
		 * Flags: IRW, Group: autoFitData */
		autoFitMaxRecords: number;

		/** If ListGrid.autoFitData is set to "horizontal" or "both" this property provides an upper limit on how far the ListGrid will expand horizontally to accommodate its content. Value may be specified as a numeric pixel value or a percentage value. If content exceeds this width, scrollbars will be introduced as usual. In addition to this property, ListGrid.autoFitMaxColumns allows you to limit horizontal expansion based on the number of columns to be rendered.
		 * Flags: IRW, Group: autoFitData */
		autoFitMaxWidth: number | string /* Integer | String */;

		/** Should listGrids automatically size time fields to fit their values or titles? If set to "value", fields of type time will be rendered at the size specified by ListGrid.defaultTimeFieldWidth. This static value is appropriate for dates rendered with the standard time formatter. If set to "title" or "both", the drawn width of the title will be taken into account when sizing the column. This is achieved by enabling ListGridField.autoFitWidth','autoFitWidth:true on date fields when this property is set to anything other than "none", setting the ListGridField.autoFitWidthApproach to the value specified here and having logic in ListGrid.getDefaultFieldWidth pick up the ListGrid.defaultTimeFieldWidth if appropriate.
		 * Flags: IRW, Group: autoFitFields */
		autoFitTimeFields: AutoFitWidthApproach;

		/** When a user requests column autofitting via the ListGrid.getHeaderContextMenuItems','header context menu or via a ListGrid.headerAutoFitEvent','mouse gesture, what autofit approach is used.
		 * Flags: IRW, Group: autoFitFields */
		autoFitWidthApproach: AutoFitWidthApproach;

		/** If this ListGrid is editable, should edits be saved out when the user finishes editing a row (or a cell if ListGrid.saveByCell is true). The default of true indicates that edits will be ListGrid.saveByCell','automatically saved as the user navigates through the grid and/or EnterKeyEditAction','hits \'Enter\' to end editing. See the editing','Grid Editing overview for details. Setting autoSaveEdits false creates a "mass update" / "mass delete" interaction where edits will be retained for all edited cells (across rows if appropriate) until ListGrid.saveEdits is called to save a particular row, or ListGrid.saveAllEdits is called to save all changes in a batch. Note: when ListGrid.groupByField','listGrid grouping is enabled, or when working with hierarchical data in a TreeGrid, users have the option to hide records from view by collapsing the parent folder or group. This, in conjunction with autoSaveEdits being set to false can lead to a case where a user is unable to save edits due to validation errors on hidden rows. Therefore we recommend developers consider having validators in place such that errors are caught and displayed to the user on change or editor exit rather than being caught only when saving is attempted. If it's not possible for all validation to be performed immediately on row exit, we recommend that a different UI design be used that does not involve autoSaveEdits being set to false.
		 * Flags: IRWA, Group: editing */
		autoSaveEdits: boolean /* Boolean */;

		/** If this listGrid has specified ListGrid.headerSpans, setting this attribute to true will cause spans to expand to accommodate long titles if necessary.
		 * Flags: IR, Group: headerSpan */
		autoSizeHeaderSpans: boolean /* Boolean */;

		/** Has no effect unless ListGrid.showBackgroundComponents is true. Canvas created and embedded in the body behind a given record. When ListGridRecord.backgroundComponent is set, this autoChild canvas will be constructed (if listGridRecord.backgroundComponent is not already a Canvas) and its properties combined with those of listGridRecord.backgroundComponent and then displayed behind a specific record in the page's z-order, meaning it will only be visible if the cell styling is transparent.
		 * Flags: IR, Group: rowEffects */
		backgroundComponent:  Canvas /* MultiAutoChild Canvas */;

		/** If the result of a formula evaluation is invalid (specifically, if isNaN(result)==true), badFormulaResultValue is displayed instead. The default value is ".".
		 * Flags: IRW, Group: formulaFields */
		badFormulaResultValue: string /* String */;

		/** GridRenderer.baseStyle','base cell style for this listGrid. If this property is unset, base style may be derived from ListGrid.normalBaseStyle or ListGrid.tallBaseStyle as described in ListGrid.getBaseStyle. See cellStyleSuffixes for details on how stateful suffixes are combined with the base style to generate stateful cell styles.
		 * Flags: IR, Group: appearance */
		baseStyle: string /* CSSStyleName */;

		/** GridRenderer used to render the dataset. Note that this is a multi-instance component when there are frozen fields because in addition to the primary body AutoChild, a "frozen body" AutoChild is created to render the frozen portion of the dataset.
		 * Flags: R */
		body:  GridRenderer /* MultiAutoChild GridRenderer */;

		/** Background color applied to the ListGrid body (that is, the area of the grid where data values are rendered). Note that this will typically not be visible to the user unless there are few enough rows that there is visible space in the body below the last row. To style data cells, override ListGrid.baseStyle instead.
		 * Flags: IRW, Group: appearance */
		bodyBackgroundColor: string;

		/** Overflow setting for the "body", that is, the area of the grid where data values are rendered. This is a very advanced setting which is typically only changed by subclasses of ListGrid which never show a header. To achieve auto-fitting, instead use properties such as ListGrid.autoFitData, ListGrid.autoFitFieldWidths and ListGrid.fixedRecordHeights.
		 * Flags: IRWA, Group: sizing */
		bodyOverflow: Overflow;

		/** CSS style used for the body of this grid. If applying a background-color to the body via a CSS style applied using this property, be sure to set ListGrid.bodyBackgroundColor to null.
		 * Flags: IRW, Group: appearance */
		bodyStyleName: string /* CSSStyleName */;

		/** An optional CSS style to apply to the checkbox image. If supplied, and the checkbox is enabled, the base style is suffixed with "True", "False", or "Partial" if the checkbox is selected, unselected, or partially selected; if the checkbox is disabled, the suffix is "TrueDisabled", "FalseDisabled", or "PartialDisabled". NOTE: This attribute is not supported by TreeGrid.
		 * Flags: IRA, Group: imageColumns */
		booleanBaseStyle: string /* CSSStyleName */;

		/** Image to display for a false value in a boolean field. Default null value or the special value "blank" means no image will be displayed. To turn this off explicitly set ListGridField.suppressValueIcon to true If this, ListGrid.booleanTrueImage and ListGrid.booleanPartialImage are unset, this will be set to the default CheckboxItem.uncheckedImage. When skinning','spriting is enabled, this property will not be used to locate an image, instead, the image is drawn via CSS based on the ListGrid.booleanBaseStyle property.
		 * Flags: IRWA, Group: imageColumns */
		booleanFalseImage: string /* SCImgURL */;

		/** Height for the ListGrid.booleanTrueImage, ListGrid.booleanFalseImage and ListGrid.booleanPartialImage. Note: If ListGrid.booleanTrueImage is unset, the CheckboxItem.checkedImage will be used to indicate a true value in a boolean field. In this case this property is ignored in favor of CheckboxItem.valueIconHeight.
		 * Flags: IRWA, Group: imageColumns */
		booleanImageHeight: number;

		/** Width for the ListGrid.booleanTrueImage, ListGrid.booleanFalseImage and ListGrid.booleanPartialImage. Note: If ListGrid.booleanTrueImage is unset, the CheckboxItem.checkedImage will be used to indicate a true value in a boolean field. In this case this property is ignored in favor of CheckboxItem.valueIconWidth.
		 * Flags: IRWA, Group: imageColumns */
		booleanImageWidth: number;

		/** Image to display for a partially true value in a boolean field (typically selection). The special value "blank" means that no image will be shown. To turn this off explicitly set ListGridField.suppressValueIcon to true. If this, ListGrid.booleanTrueImage and ListGrid.booleanFalseImage are unset, this will be set to the default CheckboxItem.partialSelectedImage. When skinning','spriting is enabled, this property will not be used to locate an image, instead, the image is drawn via CSS based on the ListGrid.booleanBaseStyle property.
		 * Flags: IRWA, Group: imageColumns */
		booleanPartialImage: string /* SCImgURL */;

		/** Image to display for a true value in a boolean field. The special value "blank" means that no image will be shown. To turn this off explicitly set ListGridField.suppressValueIcon to true. If this, ListGrid.booleanFalseImage and ListGrid.booleanPartialImage are unset, this will be set to the default CheckboxItem.checkedImage. When skinning','spriting is enabled, this property will not be used to locate an image, instead, the image is drawn via CSS based on the ListGrid.booleanBaseStyle property.
		 * Flags: IRWA, Group: imageColumns */
		booleanTrueImage: string /* SCImgURL */;

		/** Indicates whether records can be dropped into this listGrid.
		 * Flags: IRW, Group: dragging */
		canAcceptDroppedRecords: boolean /* Boolean */;

		/** Adds an item to the header context menu allowing users to launch a dialog to define a new field based on values present in other fields, using the FormulaBuilder. User-added formula fields can be persisted via ListGrid.getFieldState and ListGrid.setFieldState.
		 * Flags: IRW, Group: formulaFields */
		canAddFormulaFields: boolean;

		/** Adds an item to the header context menu allowing users to launch a dialog to define a new text field that can contain both user-defined text and the formatted values present in other fields, using the SummaryBuilder. User-added summary fields can be persisted via ListGrid.getFieldState and ListGrid.setFieldState.
		 * Flags: IRW, Group: summaryFields */
		canAddSummaryFields: boolean;

		/** Can the user perform one-time autofit for specific columns in this grid? If set to true, the default header menu will include options to auto fit ListGrid.autoFitAllText','all fields such that they fit their content or titles as specified via ListGridField.autoFitWidthApproach. Autofitting of individual fields via a ListGrid.autoFitFieldText','header context menu item, or the ListGrid.headerAutoFitEvent will also be enabled when this property is set unless ListGridField.canAutoFitWidth is explicitly set to false Note that the ability to perform one-time autofitting of fields via this subsystem is separate from the programmatic autofit behavior enabled via ListGrid.autoFitFieldWidths. This subsystem is requires canResizeFields be enabled and will be disabled if that property is set to false
		 * Flags: IRW, Group: autoFitFields */
		canAutoFitFields: boolean /* Boolean */;

		/** If this is an editable listGrid, and this.confirmCancelEditing is true this property is used as the message to display in the confirmation dismissal prompt.
		 * Flags: IRW, Group: editing */
		cancelEditingConfirmationMessage: string;

		/** Can a group be collapsed/expanded? When true a collapse/expand icon is shown (ListGrid.groupIcon','groupIcon) and the user can collapse or expand the group by clicking either the row as a whole or the opener icon (see ListGrid.collapseGroupOnRowClick); When false the group icon is not shown and clicking on the row does not change group state. Additionally GroupStartOpen','groupStartOpen is initialized to "all".
		 * Flags: IR, Group: grouping */
		canCollapseGroup: boolean /* Boolean */;

		/** Indicates whether records can be dragged from this listGrid and dropped elsewhere. <strong>NOTE:</strong> If canDragRecordsOut is initially enabled or might be dynamically enabled after the grid is created, it may be desirable to disable Canvas.useTouchScrolling','touch scrolling so that touch-dragging a record starts a drag operation rather than a scroll. If Canvas.disableTouchScrollingForDrag is set to true, then touch scrolling will be disabled automatically. However, for accessibility','accessibility reasons, it is recommended to leave touch scrolling enabled and provide an alternative set of controls that can be used to perform drag and drop of records out of the grid.
		 * Flags: IRW, Group: dragging */
		canDragRecordsOut: boolean /* Boolean */;

		/** If this property is true, users can drag the mouse to select several rows or cells. This is mutually exclusive with rearranging rows or cells by dragging. <strong>NOTE:</strong> If canDragSelect is initially enabled or might be dynamically enabled after the grid is created, it may be desirable to disable Canvas.useTouchScrolling','touch scrolling so that touch-dragging records/cells selects them rather than starting a scroll. If Canvas.disableTouchScrollingForDrag is set to true, then touch scrolling will be disabled automatically. However, for accessibility','accessibility reasons, it is recommended to leave touch scrolling enabled and provide an alternative set of controls that can be used to perform drag-selection.
		 * Flags: IRW, Group: selection */
		canDragSelect: boolean /* Boolean */;

		/** If this property is true, users can drag the mouse to select text within grid rows. This is mutually exclusive with ListGrid.canReorderRecords','rearranging rows or cells by dragging, and with ListGrid.canDragSelect','drag selection of rows.
		 * Flags: IRW, Group: selection */
		canDragSelectText: boolean /* Boolean */;

		/** If set to false, dropping over an empty part of the grid body is disallowed and the no-drop indicator is displayed.
		 * Flags: IRW, Group: dragdrop */
		canDropInEmptyArea: boolean /* Boolean */;

		/** Can the user edit cells in this listGrid? Can be set for the listGrid, and overridden for individual fields. If 'canEdit' is false at the listGrid level, fields can never be edited - in this case the canEdit property on individual fields will be ignored. If 'canEdit' is set to true at the listGrid level, setting the 'canEdit' property to false at the field level will prevent the field from being edited inline. If 'canEdit' is not set at the listGrid level, setting 'canEdit' to true at the field level enables the field to be edited inline.
		 * Flags: IRW, Group: editing */
		canEdit: boolean /* Boolean */;

		/** If this component is bound to a dataSource, this attribute may be specified to customize what fields from the dataSource may be edited by default. For example the SearchForm class has this attribute set to "canFilter" which allows search forms to edit dataSource fields marked as canEdit:false (but not those marked as canFilter:false). Note that if canEdit is explicitly specified on a field in the DataBoundComponent.fields array, that property will be respected in preference to the canEditAttribute value. (See FormItem.canEdit, ListGridField.canEdit). Also note that individual dataBoundComponents may have additional logic around whether a field can be edited - for example ListGrid.canEditCell may be overridden.
		 * Flags: IRA */
		canEditFieldAttribute: string;

		/** Adds an item to the header context menu allowing users to launch a dialog to define grid hilites using the HiliteEditor. User-added hilites can be persisted via DataBoundComponent.getHiliteState and DataBoundComponent.setHiliteState.
		 * Flags: IRW, Group: hiliting */
		canEditHilites: boolean;

		/** If set to true, the ListGrid.useAdvancedFieldPicker','advanced field picker provides an interface allowing users to modify fields' titles. Note that when enabled, the ListGrid.getFieldState','field state for this component will include field titles.
		 * Flags: IRW */
		canEditTitles: boolean;

		/** When ListGrid.canExpandRecords is true, this property indicates whether multiple records can be expanded simultaneously. If set to false, expanding a record will automatically collapse any record which is already expanded. The default value is true.
		 * Flags: IRWA, Group: expansionField */
		canExpandMultipleRecords: boolean /* Boolean */;

		/** Property name on a record that will be checked to determine whether a record can be expanded.
		 * Flags: IR, Group: expansionField */
		canExpandRecordProperty: string;

		/** When set to true, shows an additional field at the beginning of the field-list (respecting RTL) to allow users to expand and collapse individual records. See ListGrid.expandRecord and ListGrid.expansionMode for details on record expansion. ListGrid.virtualScrolling is automatically enabled when canExpandRecords is set to true. Note that expanded records are not currently supported in conjunction with ListGridField.frozen','frozen fields.
		 * Flags: IRWA, Group: expansionField */
		canExpandRecords: boolean /* Boolean */;

		/** If the listGrid is empty, should the user be able to put focus into the grid body by tabbing to it? Note that if ListGrid.editOnFocus is true for this grid and ListGrid.listEndEditAction is set to next, having this property set to true will allow users to automatically create a new edit row by simply tabbing into the grid.
		 * Flags: IRA */
		canFocusInEmptyGrid: boolean;

		/** Whether an interface should be shown to allow user is allowed to dynamically "freeze" or "unfreeze" columns with respect to horizontally scrolling. If unset, this property defaults to true unless: ListGrid.fixedRecordHeights','this.fixedRecordHeights is false ListGrid.bodyOverflow','this.bodyOverflow is "visible" ListGrid.autoFitData','this.autoFitData is set to "horizontal" or "both" Any field has overflow set to "visible" Note that the canFreezeFields setting enables or disables the user interface for freezing and unfreezing fields only. Fields can be programmatically frozen via setting ListGridField.frozen','field.frozen to true when the grid is created, or dynamically frozen and unfrozen via ListGrid.freezeField and ListGrid.unfreezeField.
		 * Flags: IRW, Group: frozenFields */
		canFreezeFields: boolean;

		/** If false, grouping via context menu will be disabled.
		 * Flags: IRW, Group: grouping */
		canGroupBy: boolean /* Boolean */;

		/** If true, cellHover and rowHover events will fire and then a hover will be shown (if not canceled) when the user leaves the mouse over a row / cell unless the corresponding field has ListGridField.showHover','showHover set to false. If unset or null, the hover will be shown if the corresponding field has showHover:true. If false, then hovers are disabled. Note that standard hovers override ListGrid.showClippedValuesOnHover','clipped value hovers. Thus, to enable clipped value hovers, canHover must be unset or null and the corresponding field must have showHover unset or null as well.
		 * Flags: IRW, Group: hovers */
		canHover: boolean;

		/** When true, indicates that this ListGrid supports grouping on multiple fields.
		 * Flags: IRW */
		canMultiGroup: boolean;

		/** When true, indicates that this ListGrid supports sorting on multiple fields. Note that even when set to true, multi-field sorting may not be available if the grid is databound and the DataSource.canMultiSort','DataSource doesn\'t support multi-sort, or if sorting for a field is ListGridField.canSortClientOnly','client-only but not all data is available.
		 * Flags: IRW */
		canMultiSort: boolean /* Boolean */;

		/** Indicates whether the field picker item and submenu should be present in the header context menu. This menu allows the user to hide visible fields and show hidden fields. By default only fields explicitly included in the ListGrid.fields array will be available in this menu, unless ListGrid.canPickOmittedFields is set to true for a databound grid. A specific field can be omitted from the column picker via ListGridField.canHide.
		 * Flags: IRW */
		canPickFields: boolean /* Boolean */;

		/** If this grid has a specified ListGrid.dataSource, and ListGrid.useAllDataSourceFields is false, setting this property to true will cause all dataSource fields not included in the specified set of fields to show up in the ListGrid.canPickFields','field picker menu item. Has no effect if ListGrid.fields is unset (as in this case all dataSource fields will be displayed by default), or if ListGrid.canPickFields is false.
		 * Flags: IR */
		canPickOmittedFields: boolean /* Boolean */;

		/** If set, provide UI for the user to remove records from the grid as an additional field showing the ListGrid.removeIcon, which, when clicked, will call ListGrid.removeRecordClick which removes the row from the data set (or if ListGrid.deferRemoval is true changes the ListGrid.markRecordRemoved status for the record). Individual records can be marked to prevent removal - see ListGrid.recordCanRemoveProperty. To add a confirmation dialog before a record is removed, set ListGrid.warnOnRemoval. If deferring removal, the record will appear marked with the ListGrid.removedCSSText until the removal is committed via a call to ListGrid.saveEdits. Otherwise, the record will disappear from view. If ListGrid.animateRemoveRecord is true, the removed record will appear to shrink out of view when it is removed. By default the field will display the ListGrid.removeIcon next to each record, and will be rendered as the rightmost column. Two mechanisms exist to further modify this field: To change the position of the remove-field, include an explicitly specified field with the attribute ListGridField.isRemoveField','isRemoveField:true set. This will then be used as the remove field instead of adding a field to the beginning of the set of columns. Additional direct configuration of the remove field may be achieved by modifying ListGrid.removeFieldProperties. If ListGrid.deferRemoval is true, when a record is marked as removed, the the icon will change to display the ListGrid.unremoveIcon for this row. Clicking on this icon will call ListGrid.unmarkRecordRemoved to mark the record as no longer pending deletion.
		 * Flags: IR, Group: databinding */
		canRemoveRecords: boolean /* Boolean */;

		/** Indicates whether fields in this listGrid can be reordered by dragging and dropping header fields.
		 * Flags: IRW, Group: dragging */
		canReorderFields: boolean /* Boolean */;

		/** Indicates whether records can be reordered by dragging within this ListGrid. <strong>NOTE:</strong> If canReorderRecords is initially enabled or might be ListGrid.setCanReorderRecords','dynamically enabled after the grid is created, it may be desirable to disable Canvas.useTouchScrolling','touch scrolling so that touch-dragging a record starts a reorder operation rather than a scroll. If Canvas.disableTouchScrollingForDrag is set to true, then touch scrolling will be disabled automatically. However, for accessibility','accessibility reasons, it is recommended to leave touch scrolling enabled and provide an alternative set of controls that can be used to perform drag-reordering of records.
		 * Flags: IRW, Group: dragging */
		canReorderRecords: boolean /* Boolean */;

		/** Indicates whether fields in this listGrid can be resized by dragging header fields.
		 * Flags: IRW, Group: dragging */
		canResizeFields: boolean /* Boolean */;

		/** Controls whether a checkbox for selecting all records appears in the header with ListGrid.selectionAppearance','selectionAppearance set to "checkbox"
		 * Flags: IRW, Group: selection */
		canSelectAll: boolean;

		/** Enables cell-level selection behavior as well as ListGrid.useCellRollOvers','cell-level rollover. To query and manipulate cell-level selections, use ListGrid.getCellSelection to retrieve the CellSelection. Note that the ListGrid has a data model of one Record per row, unlike the CubeGrid which supports one CellRecord per cell. For this reason record-oriented APIs that act on the selection will act on entire Records that have any selected cells (examples include drag and drop and transferSelectedData()). More generally, canSelectCells is primarily intended to enable developers to build Excel-like interactions on local datasets, by using ListGrid.setData plus ListGrid.saveLocally:true rather than record-oriented DataSources and data binding. The following keyboard selection behaviors are enabled with this property in addition to standard single-selection Arrow Key navigation: SHIFT + [Arrow Key]: begin or continue incremental selection SHIFT + CTRL + [Arrow Key]: incremental selection to the end of row or column CTRL + A: select all cells (enabled only with ListGrid.canSelectAll) Incremental selection allows selection of rows and columns of cells via keyboard or mouse provided the shift key is down. Behavior is designed to match Excel. Thus, if a previous selection has begun, cells will be selected from that origin. Users may also navigate through cells using the Tab and Shift+Tab keypresses if ListGrid.navigateOnTab is true. When a user tabs to the end of the row, the ListGrid.rowEndEditAction is used to determine whether to shift selection to the next row, return to the beginning of the same row, or simply move on through the page's tab order.
		 * Flags: IR */
		canSelectCells: boolean /* Boolean */;

		/** Controls whether a checkbox for selecting ListGrid.groupBy','groups appears in the group node if SelectionAppearance is set to "checkbox"
		 * Flags: IRW, Group: selection */
		canSelectGroups: boolean;

		/** Enables or disables interactive sorting behavior for this listGrid. Does not affect sorting by direct calls to the ListGrid.sort','sort or ListGrid.setSort','setSort methods.
		 * Flags: IRW, Group: sorting */
		canSort: boolean /* Boolean */;

		/** Should the header be included in the tab-order for the page? If not explicitly specified, the header will be included in the tab order for the page if isc.setScreenReaderMode','isc.setScreenReaderMode() is called.
		 * Flags: IR, Group: accessibility */
		canTabToHeader: boolean;

		/** The menu displayed when a cell is right clicked on.
		 * Flags: R */
		cellContextMenu:  Layout /* AutoChild Layout */;

		/** The default height of each row in pixels.
		 * Flags: IRW, Group: cellStyling */
		cellHeight: number;

		/** The amount of empty space, in pixels, surrounding each value in its cell.
		 * Flags: IRW, Group: cellStyling */
		cellPadding: number;

		/** Name of the SmartClient Class to be used when creating charts. Must support the Chart interface.
		 * Flags: IR */
		chartConstructor: string /* Classname */;

		/** Default type of chart to plot.
		 * Flags: IRW */
		chartType: ChartType;

		/** Returns the specially generated checkbox field used when SelectionAppearance is "checkbox". Created via the AutoChild pattern so that checkboxFieldDefaults and checkboxFieldProperties are available for skinning purposes. Note that ListGridField.shouldPrint is false for the checkboxField by default - if you want this column to show up in the grid's print view, use checkboxFieldProperties to set this property to true. This field will render an icon to indicate the selected state of each row, which, when clicked will toggle the selection state. The icon src may be configured using ListGrid.checkboxFieldTrueImage and ListGrid.checkboxFieldFalseImage, as well as ListGrid.checkboxFieldImageWidth and ListGrid.checkboxFieldImageHeight. The checkboxField can be detected by calling ListGrid.isCheckboxField on any ListGridField object.
		 * Flags: IR, Group: checkboxField */
		checkboxField:  ListGridField /* AutoChild ListGridField */;

		/** If ListGrid.selectionAppearance is set to "checkbox" this property determines the image to display in the checkbox field for an unselected row. If unset, the ListGrid.booleanFalseImage will be used. Note that the special value "blank" means that no image will be shown.
		 * Flags: IRWA, Group: checkboxField */
		checkboxFieldFalseImage: string /* SCImgURL */;

		/** How much horizontal space should the ListGrid.getCheckboxField','checkbox field leave around the checkbox icon when ListGrid.selectionAppearance is set to "checkbox"? The automatically generated checkbox field will be sized to the width of the checkbox icon (specified via ListGrid.checkboxFieldImageWidth or ListGrid.booleanImageWidth) plus this value.
		 * Flags: IR, Group: checkboxField */
		checkboxFieldHSpace: number /* int */;

		/** If ListGrid.selectionAppearance is set to "checkbox" this property may be set to govern the height of the checkbox image displayed to indicate whether a row is selected. If unset, the checkboxField image will be sized to match the ListGrid.booleanImageHeight for this grid.
		 * Flags: IR, Group: checkboxField */
		checkboxFieldImageHeight: number /* integer */;

		/** If ListGrid.selectionAppearance is set to "checkbox" this property may be set to govern the width of the checkbox image displayed to indicate whether a row is selected. If unset, the checkboxField image will be sized to match the ListGrid.booleanImageWidth for this grid.
		 * Flags: IR, Group: checkboxField */
		checkboxFieldImageWidth: number /* integer */;

		/** If ListGrid.selectionAppearance is set to "checkbox" this property determines the image to display in the checkbox field for a partially selected row. If unset, the ListGrid.booleanPartialImage will be used. Note that the special value "blank" means that no image will be shown.
		 * Flags: IRWA, Group: checkboxField */
		checkboxFieldPartialImage: string /* SCImgURL */;

		/** If ListGrid.selectionAppearance is set to "checkbox" this property determines the image to display in the checkbox field for a selected row. If unset, the ListGrid.booleanTrueImage will be used. Note that the special value "blank" means that no image will be shown.
		 * Flags: IRWA, Group: checkboxField */
		checkboxFieldTrueImage: string /* SCImgURL */;

		/** For ExpansionMode','expansionModes that show another grid or tree, what the child's expansionMode should be. Default value null means no further expansion.
		 * Flags: IRWA, Group: expansionField */
		childExpansionMode: ExpansionMode;

		/** If we're showing a ListGrid.showHeaderContextMenu','headerContextMenu for this grid, this attribute will be shown as the menu item title to clear any existing sort on all fields. This menu-item is displayed only in the context menu for the sorter button.
		 * Flags: IRW, Group: i18nMessages */
		clearAllSortingText: string;

		/** If we're showing a ListGrid.showHeaderContextMenu','headerContextMenu for this grid, and a ListGrid.showFilterEditor','filter-editor is visible, this attribute will be shown as the menu item title to clear any existing filter. This menu-item is displayed only in the context menu for the sorter button.
		 * Flags: IRW, Group: i18nMessages */
		clearFilterText: string;

		/** If we're showing a ListGrid.showHeaderContextMenu','headerContextMenu for this grid, this attribute will be shown as the menu item title to clear an existing sort on this field.
		 * Flags: IRW, Group: i18nMessages */
		clearSortFieldText: string;

		/** Whether the ListGrid should manage the clipping of titles of header buttons, showing ellipses if the title is clipped, and potentially showing the full title on ListGrid.showClippedHeaderTitlesOnHover','hover. In some cases this may be preferable to the button component's default clipping behavior because if a ListGrid.showSortArrow','sort arrow or sort numeral is displayed for a header, then the button's default clipping behavior may clip the sort arrow/numeral whereas ListGrid-managed title clipping utilizes special HTML which keeps the sort arrow/numeral visible. This feature is automatically enabled if supported by the browser. The only supported use of this attribute is to <em>disable</em> the feature by setting clipHeaderTitles to false. Note that this feature is incompatible with ListGridField.wrap, and will automatically be disabled for wrapping fields.
		 * Flags: IRA, Group: gridHeader */
		clipHeaderTitles: boolean /* Boolean */;

		/** If ListGrid.canCollapseGroup is true, will a click anywhere on the group row toggle the group's expanded state? If false, the user must click the ListGrid.groupIcon directly to toggle the group.
		 * Flags: IR, Group: grouping */
		collapseGroupOnRowClick: boolean;

		/** If we're showing a ListGrid.showHeaderContextMenu','headerContextMenu for this grid, and multi-grouping is enabled, this attribute is used as the title for a menu item that opens a MultiGroupDialog to configure the grouping for this grid.
		 * Flags: IRW, Group: i18nMessages */
		configureGroupingText: string;

		/** If we're showing a ListGrid.showHeaderContextMenu','headerContextMenu for this grid, and multi-sorting is enabled, this attribute is used as the title for a menu item that opens a MultiSortDialog to configure the sort-specification for this grid. This menu-item is displayed only in the context menu for the sorter button.
		 * Flags: IRW, Group: i18nMessages */
		configureSortText: string;

		/** If this is an editable listGrid, when the user attempts to cancel an edit, should we display a confirmation prompt before discarding the edited values for the record?
		 * Flags: IRW, Group: editing */
		confirmCancelEditing: boolean /* Boolean */;

		/** For editable listGrids, outstanding unsaved edits when the user performs a new filter or sort will be discarded. This flag determines whether we should display a confirmation dialog with options to save or discard the edits, or cancel the action in this case.
		 * Flags: IRW, Group: editing */
		confirmDiscardEdits: boolean /* Boolean */;

		/** If this.confirmDiscardEdits is true, this property can be used to customize the error message string displayed to the user in a dialog with options to cancel the action, or save or discard pending edits in response to sort/filter actions that would otherwise drop unsaved edit values.
		 * Flags: IRW, Group: editing */
		confirmDiscardEditsMessage: string;

		/** A list of ListGridRecord objects, specifying the data to be used to populate the ListGrid. In ListGrids, the data array specifies rows. When using a DataSource, rather than directly providing data, you will typically call ListGrid.fetchData instead, which will automatically establish data as a ResultSet','ResultSet (see the ListGrid.fetchData docs for details). If you call fetchData, any previously supplied data is discarded. Also, it is not necessary to call setData() after calling ListGrid.fetchData. When calling setData(), direct changes to the list using Framework APIs such as List.add or List.remove will be automatically observed and the ListGrid will redraw in response. However, direct changes to individual Records will not be automatically observed and require calls to ListGrid.refreshCell or ListGrid.refreshRow to cause the ListGrid to visually update. Calling methods such as ListGrid.updateData, ListGrid.removeData or ListGrid.addData always causes automatic visual refresh. Note that direct manipulation of the data object without using the List APIs (for example by directly assigning a new Record object to some index or calling non-Framework APIs such as pop(), shift(), etc.) will not be reflected in the grid automatically, but developers can call List.dataChanged directly to notify the grid of changes. 
		 * Flags: IRW, Group: data */
		data: any /* List of ListGridRecord */;

		/** Delay in milliseconds before fetching data. Note: the floor value for this attribute is 1. If you set this value to zero, it will be defaulted to 1 for you instead.
		 * Flags: IRWA, Group: databinding */
		dataFetchDelay: number /* integer */;

		/** How to fetch and manage records retrieve from the server. See FetchMode. This setting only applies to the ResultSet automatically created by calling ListGrid.fetchData','fetchData(). If a pre-existing ResultSet is passed to setData() instead, it's existing setting for ResultSet.fetchMode applies.
		 * Flags: IR, Group: databinding */
		dataFetchMode: FetchMode;

		/** When using ListGrid.dataFetchMode','data paging, how many records to fetch at a time. If set to a positive integer, dataPageSize will override the default ResultSet.resultSize','resultSize for ResultSets automatically created when you call ListGrid.fetchData (and similarly for the ResultTree.resultSize','resultSize of ResultTrees). Leaving dataPageSize at its default means to just use the default page size of the data container. Note that regardless of the dataPageSize setting, a component will always fetch all of data that it needs to draw. Settings such as ListGrid.showAllRecords','showAllRecords:true, ListGrid.drawAllMaxCells','drawAllMaxCells and ListGrid.drawAheadRatio','drawAheadRatio can cause more rows than the configured dataPageSize to be fetched.
		 * Flags: IRW, Group: performance */
		dataPageSize: number /* integer */;

		/** The DataSource that this component should bind to for default fields and for performing DSRequest','DataSource requests. Can be specified as either a DataSource instance or the String ID of a DataSource.
		 * Flags: IRW, Group: databinding */
		dataSource: DataSource | string /* DataSource or ID */;

		/** How should Date type values be displayed in this ListGrid by default? This property specifies the default DateDisplayFormat to apply to Date values displayed in this grid for all fields except those of ListGridField.type','type "time" (See also ListGrid.timeFormatter). If ListGrid.datetimeFormatter is specified, that will be applied by default to fields of type "datetime". Note that if ListGridField.dateFormatter or ListGridField.timeFormatter are specified those properties will take precedence over the component level settings. If unset, date values will be formatted according to the system wide DateUtil.setShortDisplayFormat','short display format or DateUtil.setShortDatetimeDisplayFormat','short datetime display format for datetime type fields. If this field is editable the dateFormatter will also be passed to the editor created to edit this field as DateItem.dateFormatter','dateFormatter. In this case you may also need to set ListGrid.dateInputFormat.
		 * Flags: IRW */
		dateFormatter: DateDisplayFormat;

		/** If this is an editable listGrid, this property will specify the DateItem.inputFormat','inputFormat applied to editors for fields of type "date". May be overridden per field via ListGridField.inputFormat.
		 * Flags: IRWA */
		dateInputFormat: string /* DateInputFormat */;

		/** Display format to use for fields specified as type 'datetime'. Default is to use the system-wide default date time format, configured via DateUtil.setShortDatetimeDisplayFormat. Specify any valid DateDisplayFormat to change the display format for datetimes used by this grid. May be specified as a function. If specified as a function, this function will be executed in the scope of the Date and should return the formatted string. May also be specified at the field level via ListGridField.dateFormatter If this field is editable the dateFormatter will also be passed to the editor created to edit this field as DateItem.dateFormatter','dateFormatter. In this case you may also need to set ListGrid.dateInputFormat.
		 * Flags: IRW, Group: appearance */
		datetimeFormatter: DateDisplayFormat;

		/** Default width for date type fields. See ListGrid.autoFitDateFields for details on how this property is used.
		 * Flags: IRW, Group: autoFitFields */
		defaultDateFieldWidth: number /* Integer */;

		/** Default width for editable date type fields. See ListGrid.autoFitDateFields for details on how this property is used.
		 * Flags: IRW, Group: autoFitFields */
		defaultEditableDateFieldWidth: number /* Integer */;

		/** An array of listGrid field configuration objects. When a listGrid is initialized, if this property is set and there is no value for the fields attribute, this.fields will be defaulted to a generated array of field objects duplicated from this array. This property is useful for cases where a standard set of fields will be displayed in multiple listGrids - for example a subclass of ListGrid intended to display a particular type of data: In this example we would not assign a single ListGrid.fields array directly to the class via addProperties() as every generated instance of this class would then point to the same fields array object. This would cause unexpected behavior such as changes to the field order in one grid effecting other grids on the page. Instead we could use addProperties() on our new subclass to set defaultFields to a standard array of fields to display. Each generated instance of the subclass would then show up with default fields duplicated from this array.
		 * Flags: IRA */
		defaultFields: Array<ListGridField> /* Array of ListGridField Properties */;

		/** Default OperatorId','filter operator to use for text-based fields in this grid's ListGrid.filterEditor','filter editor, when producing AdvancedCriteria. When ListGrid.allowFilterExpressions','allowFilterExpressions or ListGrid.allowFilterOperators','allowFilterOperators are enabled for the grid, the default is DataSource.translatePatternOperators','"iContainsPattern". Otherwise, the default is "iContains". Does not apply to special fields where exact match is obviously the right default setting, such as fields of type:"enum", or fields with a FormItem.valueMap','valueMap or FormItem.optionDataSource','optionDataSource.
		 * Flags: IR */
		defaultFilterOperator: OperatorId;

		/** Text to show after the name of the default filterOperator in the ListGrid.showHeaderContextMenu','headerContextMenu when ListGrid.allowFilterOperators is enabled.
		 * Flags: IR, Group: i18nMessages */
		defaultFilterOperatorSuffix: string /* String */;

		/** Default width for time type fields. See ListGrid.autoFitDateFields for details on how this property is used.
		 * Flags: IRW, Group: autoFitFields */
		defaultTimeFieldWidth: number /* Integer */;

		/** When enabled, the field shown by ListGrid.canRemoveRecords causes records to be marked for future removal via ListGrid.markRecordRemoved instead of immediately being removed. When a record has been marked for removal, an icon in the canRemoveRecords field allowing it to be unmarked will be displayed. If not explicitly specified by this property, removal of records will be deferred if ListGrid.autoSaveEdits is false for the grid.
		 * Flags: IR, Group: editing */
		deferRemoval: boolean;

		/** If ListGrid.canExpandRecords is true and ExpansionMode','listGrid.expansionMode is "related", this property specifies the dataSource for the related records grid to be shown embedded in expanded records. This property may also be specified on a per-record basis - see ListGrid.recordDetailDSProperty
		 * Flags: IRWA */
		detailDS: string /* String */;

		/** The field whose contents to show in the expanded portion of a record when ListGrid.canExpandRecords','canExpandRecords is true and ExpansionMode','listGrid.expansionMode is detailField.
		 * Flags: IRWA, Group: expansionField */
		detailField: string /* String */;

		/** If a user is editing a ListGrid.canEdit','canEdit:true listGrid, and they hide a field while the editor is showing, should we discard any edits in the edit row for the field being hidden? Default behavior is to discard the edits - set this flag to false to preserve edits
		 * Flags: IRW */
		discardEditsOnHideField: boolean;

		/** If ListGrid.confirmDiscardEdits is true this is the title for the save button appearing in the lost edits confirmation dialog. Override this for localization if necessary.
		 * Flags: IRW, Group: editing */
		discardEditsSaveButtonTitle: string;

		/** Indicates what to do with data dragged into another DataBoundComponent. See DragDataAction type for details.
		 * Flags: IRW, Group: dragging */
		dragDataAction: DragDataAction;

		/** When records are being dragged from within a ListGrid, what sort of drag-tracker should be displayed? Note that if multiple records are being dragged the displayed tracker will be based on the first selected record.
		 * Flags: IRA, Group: dragTracker */
		dragTrackerMode: DragTrackerMode;

		/** CSS Style to apply to the drag tracker when dragging occurs on this component.
		 * Flags: IRW */
		dragTrackerStyle: string /* CSSStyleName */;

		/** How far should we render rows ahead of the currently visible area? This is expressed as a ratio from viewport size to rendered area size. Tweaking drawAheadRatio allows you to make tradeoffs between continuous scrolling speed vs initial render time and render time when scrolling by large amounts. NOTE: Only applies when showAllRows is false.
		 * Flags: IRW, Group: performance */
		drawAheadRatio: number /* float */;

		/** If drawing all rows would cause less than drawAllMaxCells cells to be rendered, the full dataset will instead be drawn even if ListGrid.showAllRecords','showAllRecords is false and the viewport size and ListGrid.drawAheadRatio setting would normally have caused incremental rendering to be used. The drawAllMaxCells setting prevents incremental rendering from being used in situations where it's really unnecessary, such as a 40 row, 5 column dataset (only 200 cells) which happens to be in a grid with a viewport showing only 20 or so rows. Incremental rendering causes a brief "flash" during scrolling as the visible portion of the dataset is redrawn, and a better scrolling experience can be obtained in this situation by drawing the entire dataset up front, which in this example would have negligible effect on initial draw time. drawAllMaxCells:0 disables this features. You may want to disable this feature if performance is an issue and: you are very frequently redraw a grid you do a lot of computation when rendering each cell (eg formulas) you are showing many grids on one screen and the user won't scroll most of them 
		 * Flags: IRWA, Group: performance */
		drawAllMaxCells: number /* int */;

		/** Determines whether when the user edits a cell in this listGrid the entire row becomes editable, or just the cell that received the edit event. No effect if this.canEdit is false or null.
		 * Flags: IRW, Group: editing */
		editByCell: boolean;

		/** Event that will trigger inline editing, see ListGridEditEvent for options. Note this setting has no effect unless ListGrid.canEdit has been set to enable editing. See also ListGrid.editOnFocus and ListGrid.startEditing.
		 * Flags: IRW, Group: editing */
		editEvent: ListGridEditEvent;

		/** A base name for the CSS class applied to cells when editing has failed. If this listGrid is editable, this style will be applied to any edited cells for which validation failed. As with the default 'baseStyle' property, this style will have "Dark", "Over", "Selected", or "Disabled" appended to it according to the state of the cell. If null, cells for which editing has failed will be rendered using the normal base style classNames, but with custom CSSText applied as derived from this.editFailedCSSText
		 * Flags: IRWA, Group: appearance */
		editFailedBaseStyle: string /* CSSStyleName */;

		/** Custom CSS text to be applied to cells when editing has failed. If this listGrid is editable, this css text will be applied to any edited cells for which validation failed, on top of the base style for the cell. For further customization of styling for cells that failed editing validation, use this.editFailedBaseStyle instead.
		 * Flags: IRWA, Group: appearance */
		editFailedCSSText: string;

		/** Should we start editing when the widget has focus and the user presses the "f2" key (if this ListGrid supports editing)? Note that if ListGrid.editEvent is set to "click" or "doubleClick", the Space or Enter key may also be used to start editing, depending on the value for ListGrid.generateClickOnSpace, ListGrid.generateDoubleClickOnSpace, ListGrid.generateClickOnEnter and ListGrid.generateDoubleClickOnEnter. If ListGrid.canEdit is false, or ListGrid.editEvent is set to "none" this property has no effect.
		 * Flags: IRWA, Group: editing */
		editOnF2Keypress: boolean /* Boolean */;

		/** Should we start editing when this widget receives focus (if this ListGrid supports editing)? Note that this property being set to true will cause editing to occur on a single click, even if ListGrid.editEvent is "doubleClick", because single clicking the grid will place keyboard focus there automatically. If this property is set together with ListGrid.listEndEditAction being set to "next", users can create a new edit row in an empty grid by simply tabbing into the grid.
		 * Flags: IRWA, Group: editing */
		editOnFocus: boolean;

		/** A base name for the CSS class applied to cells containing pending (unsaved) edits As with the default 'baseStyle' property, this style will have "Dark", "Over", "Selected", or "Disabled" appended to it according to the state of the cell. If this property is null (the default setting), cells with pending edits will pick up custom css text to be applied on top of the normal base style from this.editPendingCSSText.
		 * Flags: IRA, Group: appearance */
		editPendingBaseStyle: string /* CSSStyleName */;

		/** Custom CSS text to be applied to cells with pending edits that have not yet been submitted. For further customization of styling for cells with pending edits use this.editPendingBaseStyle instead.
		 * Flags: IRWA, Group: appearance */
		editPendingCSSText: string;

		/** Default class used to construct the EditProxy for this component when the component is Canvas.setEditMode','first placed into edit mode.
		 * Flags: IR */
		editProxyConstructor: string /* SCClassName */;

		/** The value to display for cells whose value is null or the empty string after applying ListGrid.formatCellValue','formatting and valueMap (if any). This is the grid-wide attribute. You may also set the emptyCellValue on a per-field basis.
		 * Flags: IRW, Group: cellStyling */
		emptyCellValue: string /* HTMLString */;

		/** The string to display in the body of a listGrid with an empty data array, if showEmptyMessage is true.
		 * Flags: IRW, Group: emptyMessage */
		emptyMessage: string /* HTMLString */;

		/** The CSS style name applied to the ListGrid.emptyMessage if displayed.
		 * Flags: IRW, Group: emptyMessage */
		emptyMessageStyle: string /* CSSStyleName */;

		/** For performance reasons, even when ListGrid.fixedRecordHeights is set, vertical clipping is not enforced by default for some kinds of content (such as images) on all browsers. Set ListGrid.enforceVClipping','enforceVClipping:true to enforce clipping for all types of content on all browsers. This additional setting is likely to be phased out as browsers improve.
		 * Flags: IRW */
		enforceVClipping: boolean /* Boolean */;

		/** What to do when a user hits enter while editing a cell: "nextCell": start editing the next editable cell in this record (or the first editable cell in the next record if focus is in the last editable cell in the row) "nextRow": start editing the same field in the next row (skipping any rows where that would be a non-editable cell. "nextRowStart": start editing the first editable cell in the next row. "done": hide the editor (editing is complete) Note that if this.autoSaveEdits is true, this may cause a save of the current edit values
		 * Flags: IRW, Group: editing */
		enterKeyEditAction: EnterKeyEditAction;

		/** In a ListGrid that has a DataSource and has filter criteria that include values for fields declared as FieldType','type "enum" in the DataSource, by default a newly edited row will use those filter criteria as initial values. For example, if a ListGrid is showing all Accounts that have status:"Active" and a new row is created, the new row will default to status:"Active" unless this flag is set to false.
		 * Flags: IR, Group: editing */
		enumCriteriaAsInitialValues: boolean /* Boolean */;

		/** Height of the error icon, if we're showing icons when validation errors occur.
		 * Flags: IRW, Group: errorIcon */
		errorIconHeight: number /* integer */;

		/** Src of the image to show as an error icon, if we're showing icons when validation errors occur.
		 * Flags: IRW, Group: errorIcon */
		errorIconSrc: string /* SCImgURL */;

		/** Height of the error icon, if we're showing icons when validation errors occur.
		 * Flags: IRW, Group: errorIcon */
		errorIconWidth: number /* integer */;

		/** What to do when a user hits escape while editing a cell: "cancel": close the editor and discard the current set of edit values "done": just close the editor (the edit is complete, but the edited values are retained). Note that if ListGrid.autoSaveEdits is true, this may cause a save of the current edit values
		 * Flags: IRW, Group: editing */
		escapeKeyEditAction: EscapeKeyEditAction;

		/** For ExpansionMode','expansionModes that show another grid or tree, is that component editable? The default value for this property is false.
		 * Flags: IRWA, Group: expansionField */
		expansionCanEdit: boolean /* Boolean */;

		/** The method of RecordComponentPoolingMode','component-pooling to employ for ListGrid.canExpandRecords','expansionComponents. The default mode is "destroy", which means that automatically created expansionComponents are destroyed when rows are collapsed.
		 * Flags: IRWA */
		expansionComponentPoolingMode: ExpansionComponentPoolingMode;

		/** Automatically generated HTMLFlow for displaying the contents of ListGrid.detailField','a specified field in a record's expanded section when ExpansionMode','listGrid.expansionMode is detailField. This component is an AutoChild and as such may be customized via listGrid.expansionDetailFieldProperties and listGrid.expansionDetailFieldDefaults. Note, however, that this is a multi-instance component (potentially one per record), so it is created using Class.createAutoChild','createAutoChild() not Class.addAutoChild','addAutoChild(), and no default single instance is created by name on the grid.
		 * Flags: RA, Group: expansionField */
		expansionDetailField:  HTMLFlow /* MultiAutoChild HTMLFlow */;

		/** Automatically generated HLayout appearing in a record's expanded section when ExpansionMode','listGrid.expansionMode is detailRelated. This component contains two other autoChild components, a DetailViewer for viewing fields from the record which are not already present in the grid and a separate embedded ListGrid for displaying other data related to this record via record.detailDS. See ListGrid.expansionDetails and ListGrid.expansionRelated for more information. This component is an AutoChild and as such may be customized via listGrid.expansionDetailRelatedProperties and listGrid.expansionDetailRelatedDefaults. Note, however, that this is a multi-instance component (potentially one per record), so it is created using Class.createAutoChild','createAutoChild() not Class.addAutoChild','addAutoChild(), and no default single instance is created by name on the grid.
		 * Flags: RA, Group: expansionField */
		expansionDetailRelated:  HLayout /* MultiAutoChild HLayout */;

		/** Automatically generated DetailViewer for displaying the details of a record in its expanded section when ExpansionMode','listGrid.expansionMode is details. Note that only those fields which do not already appear in the grid are displayed in the expanded section. This component is an AutoChild and as such may be customized via listGrid.expansionDetailsProperties and listGrid.expansionDetailsDefaults. Note, however, that this is a multi-instance component (potentially one per record), so it is created using Class.createAutoChild','createAutoChild() not Class.addAutoChild','addAutoChild(), and no default single instance is created by name on the grid.
		 * Flags: RA, Group: expansionField */
		expansionDetails:  DetailViewer /* MultiAutoChild DetailViewer */;

		/** Automatically generated DynamicForm for editing the details of a record in its expanded section when ExpansionMode','listGrid.expansionMode is editor. Note that only those fields which do not already appear in the grid will appear in the expanded section. According to the value of ListGrid.showExpansionEditorSaveButton, a save button is shown beneath the editor. You can save the values in the editor by clicking this button This component is an AutoChild and as such may be customized via listGrid.expansionEditorProperties and listGrid.expansionEditorDefaults. Note, however, that this is a multi-instance component (potentially one per record), so it is created using Class.createAutoChild','createAutoChild() not Class.addAutoChild','addAutoChild(), and no default single instance is created by name on the grid.
		 * Flags: RA, Group: expansionField */
		expansionEditor:  DynamicForm /* MultiAutoChild DynamicForm */;

		/** When ExpansionMode is editor, should the row be collapsed following a save initiated by the expansion-component's ListGrid.expansionEditorSaveButton','save button.
		 * Flags: RW, Group: expansionField */
		expansionEditorCollapseOnSave: boolean /* Boolean */;

		/** Automatically generated IButton for saving the values in the expanded portion of a ListGrid row. This component is an AutoChild and as such may be customized via listGrid.expansionEditorSaveButtonProperties and listGrid.expansionEditorSaveButtonDefaults. Note, however, that this is a multi-instance component (potentially one per record), so it is created using Class.createAutoChild','createAutoChild() not Class.addAutoChild','addAutoChild(), and no default single instance is created by name on the grid.
		 * Flags: RA, Group: expansionField */
		expansionEditorSaveButton:  IButton /* MultiAutoChild IButton */;

		/** The title for the ListGrid.expansionEditorSaveButton.
		 * Flags: RWA, Group: expansionField */
		expansionEditorSaveButtonTitle: string /* String */;

		/** When ListGrid.canExpandRecords','canExpandRecords is true and ListGrid.expansionMode','expansionMode is editor, the prompt to display in a dialog when an expanded row is collapsed while it's nested editor has changed values.
		 * Flags: IR, Group: expansionField */
		expansionEditorSaveDialogPrompt: string;

		/** When ListGrid.canExpandRecords','canExpandRecords is true and ListGrid.expansionMode','expansionMode is editor, whether a dialog should be displayed when an expanded row is collapsed while it's nested editor has changed values.
		 * Flags: IR, Group: expansionField */
		expansionEditorShowSaveDialog: boolean;

		/** The field providing the facility to expand and collapse rows.
		 * Flags: IRWA, Group: expansionField */
		expansionField:  ListGridField /* AutoChild ListGridField */;

		/** If ListGrid.canExpandRecords is set to true, this property determines the image to display in the expansion field for collapsed rows. If unset, the ListGrid.booleanFalseImage will be used.
		 * Flags: IRWA, Group: expansionField */
		expansionFieldFalseImage: string /* SCImgURL */;

		/** If ListGrid.canExpandRecords is set to true, this property may be set to govern the height of the expansion image displayed to indicate whether a row is expanded. If unset, the expansionField image will be sized to match the ListGrid.booleanImageHeight for this grid.
		 * Flags: IR, Group: expansionField */
		expansionFieldImageHeight: number /* integer */;

		/** If ListGrid.canExpandRecords is set to true, this property may be set to govern the width of the expansion image displayed to indicate whether a row is expanded. If unset, the expansionField image will be sized to match the ListGrid.booleanImageWidth for this grid.
		 * Flags: IR, Group: expansionField */
		expansionFieldImageWidth: number /* integer */;

		/** If ListGrid.canExpandRecords is set to true, this property determines the image to display in the expansion field for expanded rows. If unset, the ListGrid.booleanTrueImage will be used.
		 * Flags: IRWA, Group: expansionField */
		expansionFieldTrueImage: string /* SCImgURL */;

		/** Automatically generated VLayout which fills a record's expanded section and contains other builtin ExpansionMode','expansion-components. You can also override ListGrid.getExpansionComponent','getExpansionComponent() to provide components of your own specification. This component is an AutoChild and as such may be customized via listGrid.expansionLayoutProperties and listGrid.expansionLayoutDefaults. Note, however, that this is a multi-instance component (potentially one per record), so it is created using Class.createAutoChild','createAutoChild() not Class.addAutoChild','addAutoChild(), and no default single instance is created by name on the grid.
		 * Flags: RA, Group: expansionField */
		expansionLayout:  VLayout /* MultiAutoChild VLayout */;

		/** The ExpansionMode for records in this grid. Default null value means no expansion.
		 * Flags: IRWA, Group: expansionField */
		expansionMode: ExpansionMode;

		/** Automatically generated ListGrid for displaying data related to a record in its expanded section when ExpansionMode','listGrid.expansionMode is related. The DataSource containing the related data is provided by ListGrid.getRelatedDataSource','getRelatedDataSource() which, by default, returns the DataSource referred to in ListGridRecord.detailDS. This component is an AutoChild and as such may be customized via listGrid.expansionRelatedProperties and listGrid.expansionRelatedDefaults. Note, however, that this is a multi-instance component (potentially one per record), so it is created using Class.createAutoChild','createAutoChild() not Class.addAutoChild','addAutoChild(), and no default single instance is created by name on the grid.
		 * Flags: RA, Group: expansionField */
		expansionRelated:  ListGrid /* MultiAutoChild ListGrid */;

		/** When exporting data to Excel/OpenOffice format using ListGrid.exportData','exportData() or ListGrid.exportClientData','exportClientData(), background color to use for even-numbered rows, to create a "banded" or "ledger" effect. Odd-numbered rows will use the ListGrid.exportDefaultBGColor. See exportBGColor for an overview.
		 * Flags: IR, Group: exportBackgroundColor */
		exportAlternateRowBGColor: string /* CSSColor */;

		/** Default background color to use when exporting data to Excel/OpenOffice format using ListGrid.exportData','exportData() or ListGrid.exportClientData','exportClientData(). If unset (the default), cells that are not provided a background color by more specific APIs will be the default background color used by the spreadsheet program where they are viewed. See exportBGColor for an overview.
		 * Flags: IR, Group: exportBackgroundColor */
		exportDefaultBGColor: string /* CSSColor */;

		/** When exporting data to Excel/OpenOffice format using ListGrid.exportData or ListGrid.exportClientData, whether field ListGridField.align','horizontal header alignments and ListGridField.cellAlign','data value alignments should be replicated in the resulting spreadsheet. If this attribute is not set, cells will be assigned a default alignment by the spreadsheet, which is typically right-aligned for numeric and date values, and left-aligned for everything else (including dates and numbers that have been exported as strings, as would be the case, for example, if DSRequest.exportDatesAsFormattedString is set)
		 * Flags: IRW */
		exportFieldAlignments: boolean;

		/** When exporting data to Excel/OpenOffice format using ListGrid.exportData or ListGrid.exportClientData, whether widths of fields should be replicated in the resulting spreadsheet. Because Excel's unit of measurement for field widths is based on the default system font, there is no exact way to translate field widths in pixels to Excel column widths. The ListGrid.exportWidthScale property can be set to adjust scaling; it's default value errs on the side of making Excel's columns slightly wider than the ListGrid field's actual width to avoid clipping. Note that you can switch off width export for individual fields with the ListGridField.exportFieldWidth flag.
		 * Flags: IRW */
		exportFieldWidths: boolean;

		/** When exporting data to Excel/OpenOffice format using ListGrid.exportData or ListGrid.exportClientData, causes the ListGrid.headerHeight and HeaderSpan.height','headerSpan heights to be applied to the corresponding cells in the spreadsheet.
		 * Flags: IRW */
		exportHeaderHeights: boolean;

		/** Dictates whether the data in this grid should be exported raw by ListGrid.exportClientData','exportClientData(). If set to true, data will not be processed by field-formatters during exports. Decreases the time taken for large exports. This property can also be set at the ListGridField.exportRawValues','field level.
		 * Flags: IR */
		exportRawValues: boolean /* Boolean */;

		/** Scaling factor to translate from ListGrid field widths in pixels to Excel/OpenOffice units for field width, which are 1/256th of the width of the widest digit character in the default font for the spreadsheet. See ListGrid.exportFieldWidths for where this is used.
		 * Flags: IRW */
		exportWidthScale: number /* float */;

		/** When exporting data to Excel/OpenOffice format using ListGrid.exportData or ListGrid.exportClientData, whether titles in the ListGrid.header','ListGrid header and ListGrid.headerSpans','headerSpans should be allowed to wrap. Excel will wrap at the column boundary automatically; for explicit control over wrapping, insert "" tags into your titles. See also ListGrid.exportFieldWidths for replicating the widths of fields in the exported spreadsheet.
		 * Flags: IRW */
		exportWrapHeaderTitles: boolean;

		/** Note: This property only has an effect in Internet Explorer Advanced property to improve performance for dynamic styling of gridRenderer cells in Internet Explorer, at the expense of slightly slower initial drawing, and some limitations on supported styling options. fastCellUpdates speeds up the dynamic styling system used by rollovers, selections, and custom styling that calls GridRenderer.refreshCellStyle, at the cost of slightly slower draw() and redraw() times. Notes: When this property is set, ListGrid cells may be styled using the ListGrid.tallBaseStyle. See ListGrid.getBaseStyle for more information. If any cell styles specify a a background image URL, the URL will be resolved relative to the page location rather than the location of the CSS stylesheet. This means cell styles with a background URL should either supply a fully qualified path, or the background image media should be made available at a second location for IE. fastCellUpdates will not work if the styles involved are in an external stylesheet loaded from a remote host. Either the stylesheet containing cell styles needs to be loaded from the same host as the main page, or the cell styles need to be inlined in the html of the bootstrap page. fastCellUpdates will not work if the css styles for cells are defined in a .css file loaded via @import. Instead the .css file should be loaded via a &lt;link ...&gt; tag. 
		 * Flags: I, Group: performance */
		fastCellUpdates: boolean /* Boolean */;

		/** If we're showing the filterEditor (ListGrid.showFilterEditor is true), and we're re-filtering on every keypress (ListGrid.filterOnKeypress is true), this property is the delay in milliseconds between the user changing the filter and the filter request being kicked off. If multiple changes are made to the filter within this fetch delay, only the most recent will actually cause a re-filter
		 * Flags: IRWA, Group: filterEditor */
		fetchDelay: number;

		/** Names of properties on ListGridField for which the FieldPicker should show an editing interface, for convenience. For example, specify ["frozen", "decimalPrecision"] to allow end users to modify ListGridField.frozen and ListGridField.decimalPrecision respectively.
		 * Flags: IR */
		fieldPickerFieldProperties: Array<string> /* Array of String */;

		/** When set to false, sample values of the FieldPicker are never shown. This property applies to the entire FieldPicker.
		 * Flags: IR */
		fieldPickerShowSampleValues: boolean /* Boolean */;

		/** Instance of FieldPickerWindow used if ListGrid.useAdvancedFieldPicker is set.
		 * Flags: IR */
		fieldPickerWindow:  FieldPickerWindow /* AutoChild FieldPickerWindow */;

		/** An array of field objects, specifying the order, layout, formatting, and sorting behavior of each field in the listGrid object. In ListGrids, the fields array specifies columns. Each field in the fields array is a ListGridField object. Any listGrid that will display data should have at least one visible field. If ListGrid.dataSource is also set, this value acts as a set of overrides as explained in DataBoundComponent.fields.
		 * Flags: IRW, Group: databinding */
		fields: Array<ListGridField> /* Array of ListGridField */;

		/** Initial ListGridFieldState','field state for the grid. ListGrid.viewState can be used to initialize all view properties of the grid. When doing so, fieldState is not needed because viewState includes it as well. If both are provided, fieldState has priority for field state. To retrieve current state call ListGrid.getFieldState','getFieldState. 
		 * Flags: IRW, Group: viewState */
		fieldState: string /* String */;

		/** If we're showing a ListGrid.showHeaderContextMenu','headerContextMenu for this grid, and ListGrid.canPickFields','this.canPickFields is true, this attribute will be shown as the title for the menu item which contains a submenu with items allowing the user to show and hide fields in the grid.
		 * Flags: IRW, Group: i18nMessages */
		fieldVisibilitySubmenuTitle: string;

		/** The prompt to show when the mouse hovers over the Filter button in the FilterEditor.
		 * Flags: IR, Group: i18nMessages */
		filterButtonPrompt: string /* String */;

		/** If ListGrid.showFilterEditor is true, this attribute may be used to customize the filter button shown to the right of the filterEditor row.
		 * Flags: IR */
		filterButtonProperties: ButtonProps /* Button properties */;

		/** If we're showing the filterEditor (this.showFilterEditor is true), this property determines whether this list should be filtered every time the user puts focus in a different field in the filter editor.
		 * Flags: IRWA, Group: filterEditor */
		filterByCell: boolean;

		/** If ListGrid.showFilterEditor is set to true, the filterEditor is automatically created as an AutoChild. Developers may customize the AutoChild using ListGrid.filterEditorProperties.
		 * Flags: R */
		filterEditor: RecordEditor  /* RecordEditor AutoChild */;

		/** Height for the filterEditor, if shown.
		 * Flags: IRW, Group: filterEditor */
		filterEditorHeight: number;

		/** Properties to apply to the automatically generated ListGrid.filterEditor if ListGrid.showFilterEditor is true.
		 * Flags: IR */
		filterEditorProperties: RecordEditorProps /* RecordEditor properties */;

		/** Causes filtering to be performed against the local data set, even when a ListGrid.dataSource is provided. When using this mode, data must be provided to the grid via ListGrid.setData, and must be provided as a simple Array of Records . Note that a ListGrid.dataSource must be provided for filtering to occur even when filtering locally. If this property is set to true, the supplied data is applied as the ResultSet.allRows','complete dataset of a ResultSet, which is then filtered according to the specified criteria, and the results displayed. If false, a normal databound fetch will occur, retrieving records that match the specified criteria from this component's ListGrid.dataSource. filterLocalData includes both calls to ListGrid.fetchData and ListGrid.filterData as well as automatic filtering when the ListGrid.filterEditor is enabled. If this property is not explicitly set, default behavior will filter against the dataSource unless the grid has a specified DataPath','dataPath, in which case filtering will occur locally. See also ListGrid.saveLocally to cause saves to ignore the DataSource and affect the local data set only.
		 * Flags: IRA */
		filterLocalData: boolean;

		/** If we're showing the filterEditor (this.showFilterEditor is true), this property determines whether this list should be filtered every time the user modifies the value in a field of the filter-editor. Can also be set at the field level.
		 * Flags: IRWA, Group: filterEditor */
		filterOnKeypress: boolean;

		/** Text for the menu item shown in the ListGrid.showHeaderContextMenu','headerContextMenu when ListGrid.allowFilterOperators is enabled.
		 * Flags: IR, Group: i18nMessages */
		filterUsingText: string /* String */;

		/** Should we horizontally clip cell contents, or allow columns to expand horizontally to show all contents? If we allow columns to expand, the column width is treated as a minimum. NOTE: the header does not automatically respond to expanded field widths. If your grid is showing a header we'd recommend developers consider setting ListGrid.autoFitFieldWidths rather than using this attribute.
		 * Flags: IRWA, Group: cellStyling */
		fixedFieldWidths: boolean /* Boolean */;

		/** Should we vertically clip cell contents, or allow rows to expand vertically to show all contents? If we allow rows to expand, the row height as derived from GridRenderer.getRowHeight','getRowHeight() or the default ListGrid.cellHeight is treated as a minimum. Setting fixedRecordHeights to false enables the ListGrid.virtualScrolling system. NOTE: Setting fixedRecordHeights to false for CubeGrid is not supported, though a similar option for the row headers is available as CubeGrid.autoSizeHeaders. By default, for performance reasons, clipping is not enforced for some kinds of content (such as images) on all browsers. Set ListGrid.enforceVClipping','enforceVClipping:true to enforce clipping for all types of content on all browsers. 
		 * Flags: IRWA, Group: cellStyling */
		fixedRecordHeights: boolean /* Boolean */;

		/** If this grid has specified ListGrid.headerSpans','headerSpans, and ListGrid.showHeaderSpanTitlesInFormulaBuilder','showHeaderSpanTitlesInFormulaBuilder is true, this string will be inserted between the headerSpan title(s) and the field title in the field chooser grid in the FormulaBuilder and SummaryBuilder.
		 * Flags: IRW, Group: i18nMessages */
		formulaBuilderSpanTitleSeparator: string /* String */;

		/** If we're showing a ListGrid.showHeaderContextMenu','headerContextMenu for this grid and ListGrid.canFreezeFields','this.canFreezeFields is true, this string will be shown as the title for the menu item to freeze a currently unfrozen field. This is a dynamic string - text within &#36;{...} will be evaluated as JS code when the message is displayed, with title available as a variable containing the field title. Default value returns "Freeze " + the field's summary title.
		 * Flags: IRWA, Group: i18nMessages */
		freezeFieldText: string /* HTMLString */;

		/** If we're showing a ListGrid.showHeaderContextMenu','headerContextMenu for this grid and ListGrid.canFreezeFields','this.canFreezeFields is true, this string will be shown as the title for the menu item to freeze fields on the left of the scrollable body.
		 * Flags: IRW, Group: i18nMessages */
		freezeOnLeftText: string;

		/** If we're showing a ListGrid.showHeaderContextMenu','headerContextMenu for this grid and ListGrid.canFreezeFields','this.canFreezeFields is true, this string will be shown as the title for the menu item to freeze fields on the right of the scrollable body.
		 * Flags: IRW, Group: i18nMessages */
		freezeOnRightText: string;

		/** If this listGrid contains any frozen fields, this property can be used to apply a custom baseStyle to all cells in those frozen fields. If unset, the standard base style will be used for both frozen and unfrozen cells.
		 * Flags: IRW, Group: appearance */
		frozenBaseStyle: string;

		/** If this listGrid contains any frozen fields, this property can be used to apply a custom headerBaseStyle to the frozen set of fields. If unset, the standard headerBaseStyle will be used for both frozen and unfrozen cells.
		 * Flags: IR, Group: gridHeader */
		frozenHeaderBaseStyle: string /* CSSStyleName */;

		/** If this listGrid contains any frozen fields, this property can be used to apply a custom headerTitleStyle to the frozen set of fields. If unset, the standard headerTitleStyle will be used for both frozen and unfrozen cells.
		 * Flags: IR, Group: gridHeader */
		frozenHeaderTitleStyle: string /* CSSStyleName */;

		/** Automatically generated canvas embedded in the grid's frozen body if ListGrid.showRollOver','showRollOver is true and ListGrid.showRollOverCanvas','showRollOverCanvas is true or for selected records, if ListGrid.showSelectedRollOverCanvas','showSelectedRollOverCanvas is true. This component will be created and displayed above the current rollOver row or cell in the frozen body. The frozenRollOverCanvas will be created using the AutoChild subsystem, and will derive its configuration from the ListGrid.rollOverCanvas autoChild properties ("rollOverCanvasProperties", et al). The frozenRollOverCanvas has the following read-only attributes set: - this.grid - a pointer to the grid - this.record - a pointer to the current roll over record object in the grid
		 * Flags: RA, Group: rowEffects */
		frozenRollOverCanvas: Canvas;

		/** Automatically generated canvas embedded in the grid's frozen body as a ListGrid.rollUnderCanvas','roll under canvas. This component will be created and displayed above the current rollOver row or cell in the frozen body. The frozenRollUnderCanvas will be created using the AutoChild subsystem, and will derive its configuration from the ListGrid.rollUnderCanvas autoChild properties ("rollUnderCanvasProperties", et al). The frozenRollUnderCanvas has the following read-only attributes set: - this.grid - a pointer to the grid - this.record - a pointer to the current roll over record object in the grid
		 * Flags: RA, Group: rowEffects */
		frozenRollUnderCanvas: Canvas;

		/** If true, when the user navigates to a cell using arrow keys and hits Enter, the cell will respond to a click event.
		 * Flags: IRWA */
		generateClickOnEnter: boolean /* Boolean */;

		/** If true, when the user navigates to a cell using arrow keys and hits space, the cell will respond to a click event.
		 * Flags: IRWA */
		generateClickOnSpace: boolean /* Boolean */;

		/** If true, when the user navigates to a cell using arrow keys and hits Enter, the cell will respond to a double click event.
		 * Flags: IRWA */
		generateDoubleClickOnEnter: boolean /* Boolean */;

		/** If true, when the user navigates to a cell using arrow keys and hits Space, the cell will respond to a double click event.
		 * Flags: IRWA */
		generateDoubleClickOnSpace: boolean /* Boolean */;

		/** Array of components that make up this grid. This array controls which standard and/or custom parts will be displayed within this ListGrid. ListGrid is a subclass of VLayout and consists of a number of member components. The standard set of members are automatically generated by the grid, and include (for example) the header (a Toolbar of buttons for each field) and the body (a GridRenderer displaying the actual data contained in the grid). The default value of gridComponents is an Array of ListGridComponents listing the standard components in their default order: gridComponents : ["filterEditor", "header", "body", "summaryRow"] You can override gridComponents to change the order of standard components. You can also omit standard components this way, although it more efficient to use the related "show" property if available (eg ListGrid.showFilterEditor). Note that this array must contain an entry for the "body" - listGrids with no body showing are unsupported. Advanced note: The live components generated for each of these standard ListGridComponent types may differ across different listGrids. For example if this grid has any ListGridField.frozen','frozen fields, the "body" entry will actually be created as an HLayout containing two GridRenderers (one for frozen fields, and one for unfrozen fields). This is really an implementation detail - the "body" entry in the gridComponents array simply specifies where the UI for the body should render within the ListGrid layout. By embedding a Canvas directly in this list you can add arbitrary additional components to the listGrid as members, and have them be displayed alongside the standard automatically generated parts of the ListGrid. Note that having added controls to gridComponents, you can still call APIs directly on those controls to change their appearance, and you can also show() and hide() them if they should not be shown in some circumstances. Tip: custom controls need to set layoutAlign:"center" to appear vertically centered.
		 * Flags: IR */
		gridComponents: Array<any> /* Array of ListGridComponent | Array of any */;

		/** If ListGrid.showGridSummary is true, this attribute will be set to true on the record object representing the grid summary row.
		 * Flags: IRW */
		gridSummaryRecordProperty: string;

		/** When grouping is requested with this number of records or more, an asynchronous approach is used to avoid the browser showing a "script is running slowly.." message prompting the user to stop execution of JavaScript. Note that ListGrid.groupByMaxRecords must be set at least as high as ListGrid.groupByAsyncThreshold or asynchronous grouping will never be used. During async grouping, interactivity is blocked and the ListGrid.asynchGroupingPrompt is shown to the user, then hidden when grouping completes; ListGrid.groupByComplete then fires. Note that this async processing covers grouping only - it does not cover whole grid or per-group summaries, client-side sort or filter, or other operations that may cause the browser to show the "script is running slowly" prompt when working with very large sets of records in a grid. At this time, there is no generally effective way to avoid this warning dialog appearing with very large datasets in Microsoft's Internet Explorer (IE). IE's severely flawed detection algorithm for runaway scripts has been shown to interrupt computations after only 0.2 seconds elapsed time even if the computation would have finished in 0.3 seconds. Optimizations that reduce execution time can sometimes trigger the "script running slowly" dialog sooner. Since not every operation can reasonably be made asynchronous, the current recommendation is to avoid working with overly large datasets until the affected versions of IE are obsoleted.
		 * Flags: IRW */
		groupByAsyncThreshold: number /* int */;

		/** List of fields to group grid records. If only a single field is used, that field may be specified as a string. After initialization, use ListGrid.groupBy to update the grouping field list, instead of modifying groupByField directly.
		 * Flags: IR, Group: grouping */
		groupByField: Array<string> /* String | Array of String */;

		/** If this grid is ListGrid.groupByField','grouped, and ListGrid.showGroupSummary is true, this attribute may be set to an array of groupBy field names for which group summaries should appear. This is particularly useful for listGrids grouped by more than one field as it allows developers to display the group summary for a particular nested group without showing a summary for every level of the tree.
		 * Flags: IRWA */
		groupByFieldSummaries: Array<string> /* Array of String */;

		/** Maximum number of records to which a groupBy can be applied. If there are more records, grouping will not be available via the default header context menu, and calls to ListGrid.groupBy will be ignored. The maximum exists because ListGrid grouping is performed in-browser, hence requires loading of all records that match the current filter criteria before records can be grouped. The default maximum represents a number of records which are safe to load in legacy browsers such as Internet Explorer 8 (modern browsers can handle far more), and is also a good upper limit from the perspective of loading data from a database. Going beyond this limit can cause "script running slowly" errors from legacy browsers (as well as high database load). To build an interface for grouping that handles arbitrary data volume, use a TreeGrid with TreeGrid.loadDataOnDemand with server-side grouping code.
		 * Flags: IRW, Group: grouping */
		groupByMaxRecords: number /* int */;

		/** If we're showing a ListGrid.showHeaderContextMenu','headerContextMenu for this grid and ListGrid.canGroupBy','this.canGroupBy is true, this string will be shown as the title for the menu item to toggle the group by setting for a field. This is a dynamic string - text within &#36;{...} will be evaluated as JS code when the message is displayed, with title available as a variable containing the field title. Default value returns "Group by " + the field's summary title.
		 * Flags: IRWA, Group: i18nMessages */
		groupByText: string /* HTMLString */;

		/** The URL of the base icon for the group icons in this listGrid. Default value may be overridden by the skinning','current skin.
		 * Flags: IRW, Group: grouping */
		groupIcon: string /* SCImgURL */;

		/** Default width and height of group icons for this ListGrid.
		 * Flags: IRW, Group: grouping */
		groupIconSize: number /* Number */;

		/** Default number of pixels by which to indent subgroups relative to parent group.
		 * Flags: IRW, Group: grouping */
		groupIndentSize: number /* Number */;

		/** Default number of pixels by which to indent all groups.
		 * Flags: IRW, Group: grouping */
		groupLeadingIndent: number /* Number */;

		/** ListGrid.getBaseStyle','Base style for ListGrid.groupBy','group rows. Note that this property has no effect if ListGrid.groupNodeStyle is non null.
		 * Flags: IRW, Group: grouping */
		groupNodeBaseStyle: string /* String */;

		/** The CSS style that ListGrid.groupBy','group rows will have. Note that this is not a ListGrid.getBaseStyle','base style, so, if this property is set, group nodes will not show stateful styling (different styles for ListGrid.showRollOver, ListGrid.alternateRecordStyles, etc). To enable stateful styling for groupNodes, set this property to null and specify a ListGrid.groupNodeBaseStyle
		 * Flags: IRW, Group: grouping */
		groupNodeStyle: string /* String */;

		/** When ListGrid.sortByGroupFirst is active, the sorting direction applied for implicit sorting by the field(s) used for grouping. Default of null means that sort direction is based on the current direction of user-configured sort, or is "ascending" if the user has not sorted the data.
		 * Flags: IRW, Group: sorting */
		groupSortDirection: SortDirection;

		/** Describes the default state of ListGrid groups when groupBy is called. Possible values are: "all": open all groups "first": open the first group "none": start with all groups closed Array of group values that should be opened 
		 * Flags: IRW, Group: grouping */
		groupStartOpen: GroupStartOpen | Array<any> /* GroupStartOpen | Array */;

		/** Initial group state for the grid. ListGrid.viewState can be used to initialize all view properties of the grid. When doing so, groupState is not needed because viewState includes it as well. If both are provided, groupState has priority for group state. To retrieve current state call ListGrid.getGroupState','getGroupState. 
		 * Flags: IRW, Group: viewState */
		groupState: string /* ListGridGroupState */;

		/** If ListGrid.showGroupSummary is true, this attribute will be set to true on each record object representing a group-level summary row.
		 * Flags: IRW */
		groupSummaryRecordProperty: string;

		/** ListGridRecord.customStyle for the group-level summary row displayed when ListGrid.showGroupSummary is true.
		 * Flags: IR */
		groupSummaryStyle: string /* CSSStyleName */;

		/** Default properties for the automatically generated groupTitleColumn. Default object includes properties to enable autoFitWidth to group title values. To modify the behavior or appearance of this column, developers may set ListGrid.groupTitleColumnProperties at the instance level, or override this object at the class level. If overriding this object, we recommend using Class.changeDefaults rather than replacing this object entirely. See ListGrid.showGroupTitleColumn for an overview of the groupTitleColumn.
		 * Flags: IR */
		groupTitleColumnDefaults: ListGridField /* ListGridField properties */;

		/** Custom properties for the automatically generated groupTitleColumn. See ListGrid.showGroupTitleColumn for an overview of the groupTitleColumn.
		 * Flags: IR */
		groupTitleColumnProperties: ListGridField /* ListGridField properties */;

		/** When a list grid is ListGrid.groupBy','grouped, each group shows under an auto generated header node. By default the title of the group will be shown, with a hanging indent in this node, and will span all columns in the grid. Setting this property causes the titles of auto-generated group nodes to appear as though they were values of the designated field instead of spanning all columns and record values in the designated groupTitleField will appear indented under the group title in a manner similar to how a TreeGrid shows a Tree. Note if ListGrid.showGroupSummaryInHeader is true, the header nodes will not show a single spanning title value by default - instead they will show the summary values for each field. In this case, if groupTitleField is unset, a ListGrid.showGroupTitleColumn','groupTitleColumn can be automatically generated to show the title for each group.
		 * Flags: IR, Group: grouping */
		groupTitleField: string /* String */;

		/** The data tree that results from a call to ListGrid.groupBy. This will be a ResultTree if ListGrid.dataSource is present, otherwise it will be a Tree.
		 * Flags: R, Group: grouping */
		groupTree:  Tree /* AutoChild Tree */;

		/** A Toolbar used to manager the headers shown for each column of the grid.
		 * Flags: R, Group: gridHeader */
		header:  Layout /* AutoChild Layout */;

		/** Event on a ListGrid header that triggers auto fitting to data and/or title. Note that if sorting is enabled for the field and the headerAutoFitEvent is "click", both sorting and autofit occur on a click. Only has an impact when ListGrid.canAutoFitFields or ListGridField.canAutoFitWidth is set to true.
		 * Flags: IR, Group: autoFitFields */
		headerAutoFitEvent: AutoFitEvent;

		/** BackgroundColor for the header toolbar. Typically this is set to match the color of the header buttons.
		 * Flags: IRW, Group: gridHeader */
		headerBackgroundColor: string /* CSSColor */;

		/** Set the CSS style used for the header as a whole.
		 * Flags: IR, Group: gridHeader */
		headerBarStyle: string /* CSSStyleName */;

		/** Button.baseStyle to apply to the buttons in the header, and the sorter, for this ListGrid. Note that, depending on the ListGrid.headerButtonConstructor','Class of the header buttons, you may also need to set ListGrid.headerTitleStyle.
		 * Flags: IR, Group: gridHeader */
		headerBaseStyle: string /* CSSStyleName */;

		/** Widget class for this ListGrid's header buttons. If unset, constructor will be picked up directly from the standard Toolbar button constructor.
		 * Flags: IR, Group: gridHeader */
		headerButtonConstructor: Class;

		/** Defaults to apply to all header buttons. To modify this object, use Class.changeDefaults','ListGrid.changeDefaults() rather than replacing with an entirely new object.
		 * Flags: IRA, Group: gridHeader */
		headerButtonDefaults: ButtonProps /* Button Properties */;

		/** Properties to apply to all header buttons. Overrides defaults applied via ListGrid.headerButtonDefaults.
		 * Flags: IRA, Group: gridHeader */
		headerButtonProperties: ButtonProps /* Button Properties */;

		/** The context menu displayed for column headers.
		 * Flags: R, Group: gridHeader */
		headerContextMenu:  Canvas /* AutoChild Canvas */;

		/** The height of this listGrid's header, in pixels.
		 * Flags: IRW, Group: gridHeader */
		headerHeight: number;

		/** This property may be set to customize the alignment for the hover shown on ListGrid.headerHover.
		 * Flags: IRW */
		headerHoverAlign: Alignment;

		/** Optional default height for the hover shown on ListGrid.headerHover.
		 * Flags: IRW */
		headerHoverHeight: number /* Integer */;

		/** This property may be set to customize the opacity for the hover shown on ListGrid.headerHover.
		 * Flags: IRW */
		headerHoverOpacity: number /* Integer */;

		/** This property may be set to customize the css style for the hover shown on ListGrid.headerHover.
		 * Flags: IRW */
		headerHoverStyle: string /* CSSStyleName */;

		/** This property may be set to customize the vertical alignment for the hover shown on ListGrid.headerHover.
		 * Flags: IRW */
		headerHoverVAlign: VerticalAlignment;

		/** Optional default width for the hover shown on ListGrid.headerHover.
		 * Flags: IRW */
		headerHoverWidth: number /* Integer */;

		/** This property may be set to customize the wrap attribute for the hover shown on ListGrid.headerHover.
		 * Flags: IRW */
		headerHoverWrap: boolean /* Boolean */;

		/** If ListGrid.showHeaderMenuButton is true, when the user rolls over the header buttons in this grid the headerMenuButton will be shown over the header button in question. When clicked this button will display the standard header context menu (see ListGrid.displayHeaderContextMenu). headerMenuButton','Several properties exist to customize the appearance of the headerMenuButton. Also see the AutoChild documentation for information on how to make free-form modifications to autoChild widgets
		 * Flags: RA, Group: headerMenuButton */
		headerMenuButton:  StatefulCanvas /* AutoChild StatefulCanvas */;

		/** Constructor for the ListGrid.headerMenuButton. If unset a standard "Button" will be rendered out. Note that this property may be overridden by different skins.
		 * Flags: IRA, Group: headerMenuButton */
		headerMenuButtonConstructor: string /* className */;

		/** If ListGrid.showHeaderMenuButton is true, this property governs the height of the auto-generated headerMenuButton
		 * Flags: IRA, Group: headerMenuButton */
		headerMenuButtonHeight: any /* measure */;

		/** If ListGrid.showHeaderMenuButton is true, this property governs the icon shown on the auto-generated headerMenuButton
		 * Flags: IRA, Group: headerMenuButton */
		headerMenuButtonIcon: string /* URL */;

		/** If ListGrid.showHeaderMenuButton is true, this property governs the height of the icon shown on the auto-generated headerMenuButton
		 * Flags: IRA, Group: headerMenuButton */
		headerMenuButtonIconHeight: number;

		/** If ListGrid.showHeaderMenuButton is true, this property governs the width of the icon shown on the auto-generated headerMenuButton
		 * Flags: IRA, Group: headerMenuButton */
		headerMenuButtonIconWidth: number;

		/** If ListGrid.showHeaderMenuButton is true, this property governs the width of the auto-generated headerMenuButton
		 * Flags: IRA, Group: headerMenuButton */
		headerMenuButtonWidth: number;

		/** If ListGrid.showHeaderShadow is true, the Canvas.shadowColor for the header shadow.
		 * Flags: IRA */
		headerShadowColor: string /* CSSColor */;

		/** If ListGrid.showHeaderShadow is true, the Canvas.shadowHOffset for the header shadow
		 * Flags: IRA */
		headerShadowHOffset: number /* Number */;

		/** If ListGrid.showHeaderShadow is true, the Canvas.shadowSoftness for the header shadow
		 * Flags: IRA */
		headerShadowSoftness: number /* Number */;

		/** If ListGrid.showHeaderShadow is true, the Canvas.shadowVOffset for the header shadow
		 * Flags: IRA */
		headerShadowVOffset: number /* Number */;

		/** ListGrid.headerSpans','headerSpans are created via the AutoChild pattern, hence headerSpanConstructor, headerSpanDefaults and headerSpanProperties are valid.
		 * Flags: IR, Group: headerSpan */
		headerSpan:  StatefulCanvas /* MultiAutoChild StatefulCanvas */;

		/** SCClassName','SmartClient Class to use for headerSpans. Typically a Button or StretchImgButton subclass. If unset, headerSpans will be created using the ListGrid.headerButtonConstructor.
		 * Flags: IR, Group: headerSpan */
		headerSpanConstructor: string /* SCClassName */;

		/** Default height for a ListGrid.headerSpans','headerSpan with no height specified. If headerSpanHeight is not specified (the default), headerSpans will be 1/2 of ListGrid.headerHeight.
		 * Flags: IR, Group: headerSpan */
		headerSpanHeight: number /* integer */;

		/** Header spans are a second level of headers that appear above the normal ListGrid headers, spanning one or more listGrid fields in a manner similar to a column-spanning cell in an HTML table. A header span can be created by simply naming the fields the header should span. The example below creates a headerSpan that spans the first two fields of the ListGrid. isc.ListGrid.create({ headerHeight:40, fields : [ { name:"field1" }, { name:"field2" }, { name:"field3" } ], headerSpans : [ { fields: ["field1", "field2"], title: "Field 1 and 2" } ] }); Header spans can be nested, allowing fields to be grouped by multiple levels of granularity. See HeaderSpan.spans for further information on nesting spans. Header spans will automatically react to resizing of the headers they span, and will be hidden automatically when all of the spanned fields are hidden. Header spans appear in the ListGrid.header','header area of the ListGrid, sharing space with the existing headers, so it's typical to set ListGrid.headerHeight to approximately double its normal height when using headerSpans, or if using nested header spans, the default header height multiplied by the number of levels of header spans to be shown. See HeaderSpan for many properties that allow the control of the appearance of headerSpans. Note that headerSpans are created via the AutoChild pattern, hence you can change the SmartClient component being used, or any of its properties. Neither headerSpans themselves nor the fields within them may be drag reordered, but other unspanned headers may be. A span can only span adjacent fields - if a span is defined and the spanned fields don't sit next to each other in the specified fields array, the fields array will be automatically reordered to match the order specified in the span's HeaderSpan.fields array. Note that headerSpans primarily provide a visual cue for grouping multiple headers together. If you have an OLAP, data "cube" or multi-dimensional data model, the CubeGrid component is the right choice.
		 * Flags: IRW, Group: headerSpan */
		headerSpans: Array<HeaderSpan> /* Array of HeaderSpan */;

		/** Default alignment for ListGrid.headerSpans','headerSpans with no HeaderSpan.valign specified.
		 * Flags: IR, Group: headerSpan */
		headerSpanVAlign: string /* vAlign */;

		/** StretchImgButton.titleStyle to apply to the buttons in the header, and the sorter, for this ListGrid. Note that this will typically only have an effect if ListGrid.headerButtonConstructor is set to StretchImgButton or a subclass thereof.
		 * Flags: IR, Group: gridHeader */
		headerTitleStyle: string /* CSSStyleName */;

		/** If true, causes the ListGrid.summaryRow','summaryRow component to be hidden if it has no data after summaries have been recalculated
		 * Flags: IRW */
		hideEmptySummaryRow: boolean /* Boolean */;

		/** If set, end users can create advanced hiliting rules that will use the Hilite.replacementValue feature to cause values in hilited cells to be replaced with a user-entered value. For example, a user could create a hilite rule that replaces numeric values ranging from 0.5 to 1.0 with the text "LOW". Specifically, when the "Add Advanced Rule" button is pressed and hiliteCanReplaceValue is true, the user will see a text entry field titled "Replace value with" (ListGrid.hiliteReplaceValueFieldTitle) and if they enter a value, that value will appear in the grid cell in lieu of the cell's original value.
		 * Flags: IR, Group: hiliting */
		hiliteCanReplaceValue: boolean;

		/** If this grid has specified ListGrid.headerSpans, and ListGrid.showHeaderSpanTitlesInHiliteEditor is true, this string will be inserted between the headerSpan title and the field title in the hiliteEditor field chooser grid.
		 * Flags: IRW, Group: i18nMessages */
		hiliteEditorSpanTitleSeparator: string /* String */;

		/** If set to true, custom HTML applied as part of hiliting will be applied after ListGrid.formatCellValue','formatting for each cell. If false, hilite HTML will be applied before formatting. This applies to the following hilite properties: Hilite.replacementValue Hilite.htmlBefore Hilite.htmlAfter Hilite.htmlValue May be overridden per field via ListGridField.hiliteHTMLAfterFormat
		 * Flags: IR */
		hiliteHTMLAfterFormat: boolean;

		/** Height for hilite icons for this listGrid. Overrides ListGrid.hiliteIconSize','hiliteIconSize. Can be overridden at the field level
		 * Flags: IRW, Group: hiliting */
		hiliteIconHeight: number;

		/** How much padding should there be on the left of ListGrid.hiliteIcons','hilite icons by default? Can be overridden at the field level
		 * Flags: IRW, Group: hiliting */
		hiliteIconLeftPadding: number;

		/** When ListGrid.hiliteIcons','hiliteIcons are present, where the hilite icon will be placed relative to the field value. See HiliteIconPosition. Can be overridden at the field level.
		 * Flags: IR, Group: hiliting */
		hiliteIconPosition: HiliteIconPosition;

		/** How much padding should there be on the right of ListGrid.hiliteIcons','hilite icons by default? Can be overridden at the field level
		 * Flags: IRW, Group: hiliting */
		hiliteIconRightPadding: number;

		/** Specifies a list of icons that can be used in DataBoundComponent.editHilites','hilites. hiliteIcons should be specified as an Array of SCImgURL. When present, the hilite editing interface shown when DataBoundComponent.editHilites is called will offer the user a drop down for picking one of these icons when defining either a simple or advanced hilite rule. If the user picks an icon, the created hiliting rule will have Hilite.icon set to the chosen icon. DataBoundComponent.hiliteIconPosition controls where the icon will appear for that field -- the default is that it appears in front of the normal cell content. This can also be overridden at the field level.
		 * Flags: IR, Group: hiliting */
		hiliteIcons: Array<string> /* Array of String */;

		/** Default width and height of ListGrid.hiliteIcons','hilite icons for this component. Can be overridden at the component level via explicit ListGrid.hiliteIconWidth','hiliteIconWidth and ListGrid.hiliteIconHeight','hiliteIconHeight, or at the field level via ListGridField.hiliteIconSize','hiliteIconSize, ListGridField.hiliteIconWidth','hiliteIconWidth and ListGridField.hiliteIconHeight','hiliteIconHeight
		 * Flags: IRW, Group: hiliting */
		hiliteIconSize: number;

		/** Width for hilite icons for this component. Overrides ListGrid.hiliteIconSize','hiliteIconSize. Can be overridden at the field level.
		 * Flags: IRW, Group: hiliting */
		hiliteIconWidth: number;

		/** Title used for the text box shown when ListGrid.hiliteCanReplaceValue is set.
		 * Flags: IR, Group: i18nMessages */
		hiliteReplaceValueFieldTitle: string;

		/** When the grid body gets keyboard focus, should we highlight the current focus row, using the rollover cell style? This property may be explicitly set to control this behavior independently of ListGrid.showRollOver. Otherwise (if this property is null), we will show the roll-over styling for the keyboard focus row if ListGrid.showRollOver is true.
		 * Flags: IRW */
		hiliteRowOnFocus: boolean /* Boolean */;

		/** When ListGrid.showHoverComponents','showHoverComponents is true, the builtin mode to use when automatically creating a hover component for rows in this grid. A number of builtin modes are provided - see HoverMode. You can also override ListGrid.getCellHoverComponent','getCellHoverComponent() to provide a custom hover widget - in that case, this attribute is ignored.
		 * Flags: IRWA, Group: hoverComponents */
		hoverMode: HoverMode;

		/** Style to apply to hovers shown over this grid.
		 * Flags: IRWA, Group: hovers */
		hoverStyle: string /* CSSStyleName */;

		/** When using ListGrid.autoFitFieldWidths, padding in pixels left on each side of fields that show images.
		 * Flags: IR */
		iconPadding: number /* integer */;

		/** Default size of thumbnails shown for fieldTypes image and imageFile. Overrideable on a per-field basis via ListGridField.imageSize or ListGridField.imageWidth/ListGridField.imageHeight
		 * Flags: IRW, Group: imageColumns */
		imageSize: number;

		/** When assembling a value for a ListGrid.canAddSummaryFields','summary field, if a referenced field is hilited, should the hilite HTML be included in the summary field value? To control hilites showing in group summaries, see ListGrid.showHilitesInGroupSummary','showHilitesInGroupSummary.
		 * Flags: IRWA */
		includeHilitesInSummaryFields: boolean;

		/** Property name on a record that will be checked to determine whether a record should be included when calculating totals for the ListGrid.showGridSummary','grid summary.
		 * Flags: IRW */
		includeInSummaryProperty: string;

		/** Criteria to be used when ListGrid.autoFetchData is set. This property supports dynamicCriteria - use Criterion.valuePath to refer to values in the Canvas.ruleScope.
		 * Flags: IR, Group: searchCriteria */
		initialCriteria: Criteria;

		/** An array of SortSpecifier objects used to set up the initial sort configuration for this grid. If specified, this will be used instead of any ListGrid.sortField specified.
		 * Flags: IR, Group: sorting */
		initialSort: Array<SortSpecifier> /* Array of SortSpecifier */;

		/** If true, if the user clicks on the scroll buttons at the end of the track or clicks once on the scroll track, there will be an instant redraw of the grid content so that the user doesn't see any blank space. For drag scrolling or other types of scrolling, the ListGrid.scrollRedrawDelay applies.
		 * Flags: IRW, Group: performance */
		instantScrollTrackRedraw: boolean /* Boolean */;

		/** Value to display to the user if showing summary values (through ListGrid.showGridSummary, ListGrid.showGroupSummary or ListGridFieldType','listGridFieldType:"summary"), and the summary function returns "null" (implying it was unable to calculate a valid summary value). This property will only be used in the default formatting behavior. If an explicit formatter has been specified - via ListGrid.formatCellValue or ListGridField.formatGridSummary','formatGridSummary(), for example - this property has no effect.
		 * Flags: IRWA */
		invalidSummaryValue: string;

		/** True if this listGrid is grouped, false otherwise
		 * Flags: R, Group: grouping */
		isGrouped: boolean;

		/** If record[this.isSeparatorProperty] is set for some record, the record will be displayed as a simple separator row.
		 * Flags: IRW */
		isSeparatorProperty: string;

		/** If ListGrid.showHeaderMenuButton is true, when auto-fitting fields to the title width via ListGrid.autoFitFieldWidths or ListGridField.autoFitWidth, should the button be sized such that there is enough space for the header menu button to show without covering the field title? May be explicitly specified at the ListGridField.leaveHeaderMenuButtonSpace','field level or at the ListGrid.leaveHeaderMenuButtonSpace','grid level. If not explicitly specified space will be left for fields with ListGridField.align set to "left" or "right", but not for fields with align set to "center".
		 * Flags: IWA, Group: headerMenuButton */
		leaveHeaderMenuButtonSpace: boolean;

		/** Whether to leave a gap for the vertical scrollbar, even when it's not present. Note that if leaveScrollbarGap is false and vertical scrolling is introduced, fields will be resized to fit the smaller body area if possible, in order to avoid horizontal scrolling also being required.
		 * Flags: IRW, Group: appearance */
		leaveScrollbarGap: boolean /* Boolean */;

		/** Property name on a record that will hold the link text for that record. This property is configurable to avoid possible collision with data values in the record. Use ListGridField.linkTextProperty if you have more than one link field and
		 * Flags: IRW, Group: display_values */
		linkTextProperty: string;

		/** If the user is editing the last record in this listGrid, and attempts to navigate beyond the last row either by tabbing off the last editable field, or using the down arrow key, this property determines what action to take: "next": start editing a new record at the end of the list. "done": hide the editor "stop": leave focus in the cell being edited "none": no action See the editing','Grid Editing overview and also the unsavedRecords','Editing Unsaved Records overview for context about how newly added records behave.
		 * Flags: IRW, Group: editing */
		listEndEditAction: RowEndEditAction;

		/** The string to display in the body of a listGrid while data is being loaded. Use "&#36;{loadingImage}" to include Canvas.loadingImageSrc','a loading image.
		 * Flags: IRW, Group: emptyMessage */
		loadingDataMessage: string /* HTMLString */;

		/** The CSS style name applied to the loadingDataMessage string if displayed.
		 * Flags: IRW, Group: emptyMessage */
		loadingDataMessageStyle: string /* CSSStyleName */;

		/** If you have a databound listGrid and you scroll out of the currently loaded dataset, by default you will see blank rows until the server returns the data for those rows. The loadingMessage attribute allows you to specify arbitrary html that will be shown in each such "blank" record while the data for that record is loading.
		 * Flags: IR, Group: emptyMessage */
		loadingMessage: string;

		/** When AutoTest.getElement is used to parse locator strings generated by AutoTest.getLocator for a cell in this grid, how should the column be identified? Note that getLocator() will actually store all available information about the column in the generated string -- this attribute effects how a stored string will be parsed only. Valid options area: "fieldName" Attempt to identify by fieldName. "index" Attempt to identify by colNum (index in the fields array). If unset, default behavior is to identify by fieldName (if available), otherwise by index.
		 * Flags: IRW, Group: autoTest */
		locateColumnsBy: string;

		/** When AutoTest.getElement is used to parse locator strings generated by AutoTest.getLocator for a cell in this grid, how should the row be identified? Note that getLocator() will actually store all available information about the row in the generated string -- this attribute effects how a stored string will be parsed only. Valid options area: "primaryKey" Only applies to databound grids: If the cell in question has a primary key cell value, use it to identify cells in autoTest locator strings. "titleField" If the cell in question has a value for the ListGrid.getTitleField','titleField, use it to identify cells in autoTest locator strings "targetCellValue" Identify rows by storing the cell value for the target row / field in autoTest locator strings "index"The rowNum will be used to identify the row. If unset, default behavior is to identify by primary key (if available), otherwise by titleField (if available), otherwise by cell value (if available), and lastly by index.
		 * Flags: IRW, Group: autoTest */
		locateRowsBy: string;

		/** When the length of the field specified by DataSourceField.length exceeds this value, the ListGrid shows an edit field of type ListGrid.longTextEditorType rather than the standard text field when the field enters inline edit mode.
		 * Flags: IRW, Group: editing */
		longTextEditorThreshold: number /* int */;

		/** When the length of the field specified by DataSourceField.length exceeds this.longTextEditorThreshold show an edit field of this type rather than the standard text field when the field enters inline edit mode.
		 * Flags: IRW, Group: editing */
		longTextEditorType: string;

		/** When ListGrid.canExpandRecords and ListGrid.canExpandMultipleRecords are both true, this property dictates the number of records which can be expanded simultaneously. If the expanded record count hits the value of this property, further attempts to expand records will result in a popup warning (see ListGrid.maxExpandedRecordsPrompt) and expansion will be cancelled. The default value is null, meaning there is no limit on the number of expanded records.
		 * Flags: IRWA, Group: expansionField */
		maxExpandedRecords: number /* integer */;

		/** This is a dynamic string - text within &#36;{...} will be evaluated as JS code when the message is displayed. Note that the local variable count will be available and set to this.maxExpandedRecords. The string will be executed in the scope of the ListGrid so this may also be used to determine other information about this grid. Default value returns This grid is limited to [ListGrid.maxExpandedRecords] simultaneously expanded records. Please collapse some expanded records and retry. 
		 * Flags: IR, Group: i18nMessages */
		maxExpandedRecordsPrompt: string /* HTMLString */;

		/** Minimum size, in pixels, for ListGrid headers.
		 * Flags: IRW */
		minFieldWidth: number /* int */;

		/** If a summary format string contains an invalid field reference, replace the reference with the missingSummaryFieldValue. The default value is "-".
		 * Flags: IRW, Group: summaryFields */
		missingSummaryFieldValue: string /* String */;

		/** If this property is true, any mouse click outside of the open cell editors will end editing mode, hiding the cell editors and saving any changes to those cell values.
		 * Flags: IRWA, Group: editing */
		modalEditing: boolean;

		/** Class level defaults to apply to the MultiSortDialog which gets automatically generated when DataBoundComponent.askForSort is called. See also ListGrid.showHeaderSpanTitlesInSortEditor and ListGrid.sortEditorSpanTitleSeparator
		 * Flags: IR */
		multiSortDialogDefaults: MultiSortDialogProps /* MultiSortDialog properties */;

		/** Properties to apply to the MultiSortDialog which gets automatically generated when DataBoundComponent.askForSort is called. See also ListGrid.showHeaderSpanTitlesInSortEditor and ListGrid.sortEditorSpanTitleSeparator
		 * Flags: IR */
		multiSortDialogProperties: MultiSortDialogProps /* MultiSortDialog properties */;

		/** If ListGrid.canSelectCells is true, this property allows the user to navigate through the cells of a grid using Tab and Shift+Tab keypresses. When a user tabs to the end of the row, the ListGrid.rowEndEditAction is used to determine whether to shift selection to the next row, return to the beginning of the same row, or simply move on through the page's tab order.
		 * Flags: IRW */
		navigateOnTab: boolean;

		/** If true, validation will not occur as a result of cell editing for this grid.
		 * Flags: IRWA, Group: gridValidation */
		neverValidate: boolean;

		/** "Normal" baseStyle for this listGrid. Only applies if ListGrid.baseStyle is set to null. If baseStyle is unset, this property will be used as a base cell style if the grid is showing fixed height rows, and the specified cellHeight matches ListGrid.normalCellHeight (and in Internet Explorer, ListGrid.fastCellUpdates is false). Otherwise ListGrid.tallBaseStyle will be used. Having separate styles defined for fixed vs. variable height rows allows the developer to specify css which is designed to render at a specific height (typically using background images, which won't scale), without breaking support for styling rows of variable height. See cellStyleSuffixes for details on how stateful suffixes are combined with the base style to generate stateful cell styles.
		 * Flags: IR */
		normalBaseStyle: string /* CSSStyleName */;

		/** If ListGrid.baseStyle is unset, base style will be derived from ListGrid.normalBaseStyle if this grid has fixed row heights and the specified ListGrid.cellHeight matches this value. Otherwise ListGrid.tallBaseStyle will be used.
		 * Flags: IRWA */
		normalCellHeight: number;

		/** Default alias to use for groups with no value
		 * Flags: IRW, Group: grouping */
		nullGroupTitle: string /* String */;

		/** The CSS style name applied to the DataBoundComponent.offlineMessage','offlineMessage if displayed.
		 * Flags: IRW, Group: offlineGroup */
		offlineMessageStyle: string /* CSSStyleName */;

		/** Inline icon shown inside ListGrid.showFilterEditor','filter editor fields when ListGrid.allowFilterOperators is enabled.
		 * Flags: I */
		operatorIcon:  FormItemIcon /* MultiAutoChild FormItemIcon */;

		/** When grouped, a copy of the original ungrouped data.
		 * Flags: R, Group: grouping */
		originalData: any /* object */;

		/** Name of a CSS Style to use as the ListGrid.baseStyle for a cell that is currently a selection origin for shifted incremental cell selection. Only has an effect if ListGrid.canSelectCells is true. 
		 * Flags: IRW */
		originBaseStyle: string /* CSSStyleName */;

		/** Since ListGrid.body is configured with overflow: auto by default, no overflow is expected for the ListGrid itself so by default it has overflow: hidden.
		 * Flags: IRW */
		overflow: Overflow;

		/** Should recycled ListGrid.showRecordComponents','record components, be pooled per column or per record. Only applies if ListGrid.showRecordComponentsByCell is true. When ListGrid.recordComponentPoolingMode is "recycle" and you have components of different types in different columns, set this property to true to ensure that components intended for one column are not recycled for use in another column that should have a different component. If no components applicable to a particular column are available in the pool, the system calls ListGrid.createRecordComponent','createRecordComponent.
		 * Flags: IRW */
		poolComponentsPerColumn: boolean /* Boolean */;

		/** Whether cell contents should wrap during printing. Equivalent to Autofit, but specific to printed output.
		 * Flags: IRW, Group: printing */
		printAutoFit: boolean /* Boolean */;

		/** Style for non-header cells in printed output. Defaults to ListGrid.baseStyle if null.
		 * Flags: IRW, Group: printing */
		printBaseStyle: string /* CSSStyleName */;

		/** If set, the ListGrid.booleanBaseStyle','booleanBaseStyle to use when printing','printing.
		 * Flags: IRA, Group: imageColumns */
		printBooleanBaseStyle: string /* CSSStyleName */;

		/** If set, the ListGrid.booleanFalseImage to use when printing','printing. If this, ListGrid.printBooleanTrueImage and ListGrid.printBooleanPartialImage are unset, this will be set to the default CheckboxItem.printUncheckedImage.
		 * Flags: IRWA, Group: imageColumns */
		printBooleanFalseImage: string /* SCImgURL */;

		/** If set, the ListGrid.booleanPartialImage to use when printing','printing. If this, ListGrid.printBooleanTrueImage and ListGrid.printBooleanFalseImage are unset, this will be set to the default CheckboxItem.printPartialSelectedImage.
		 * Flags: IRWA, Group: imageColumns */
		printBooleanPartialImage: string /* SCImgURL */;

		/** If set, the ListGrid.booleanTrueImage to use when printing','printing. If this, ListGrid.printBooleanFalseImage and ListGrid.printBooleanPartialImage are unset, this will be set to the default CheckboxItem.printCheckedImage.
		 * Flags: IRWA, Group: imageColumns */
		printBooleanTrueImage: string /* SCImgURL */;

		/** If set, the ListGrid.checkboxFieldFalseImage to use when printing','printing.
		 * Flags: IRWA, Group: checkboxField */
		printCheckboxFieldFalseImage: string /* SCImgURL */;

		/** If set, the ListGrid.checkboxFieldPartialImage to use when printing','printing.
		 * Flags: IRWA, Group: checkboxField */
		printCheckboxFieldPartialImage: string /* SCImgURL */;

		/** If set, the ListGrid.checkboxFieldTrueImage to use when printing','printing.
		 * Flags: IRWA, Group: checkboxField */
		printCheckboxFieldTrueImage: string /* SCImgURL */;

		/** Style for header cells in printed output. Defaults to ListGrid.headerBaseStyle if null.
		 * Flags: IRW, Group: printing */
		printHeaderStyle: string /* CSSStyleName */;

		/** Advanced property - when generating printHTML for a large ListGrid, rows are printed in batches in order to avoid triggering a native "script is running slowly" browser dialog. For grids with exceptional numbers of columns or complex formatting logic, this number might need to be adjusted downward.
		 * Flags: IRWA, Group: printing */
		printMaxRows: number /* int */;

		/** Whether cell contents should wrap during printing. Equivalent to ListGrid.wrapCells, but specific to printed output.
		 * Flags: IRW, Group: printing */
		printWrapCells: boolean /* Boolean */;

		/** Alternative to ListGrid.drawAheadRatio, to be used when the user is rapidly changing the grids viewport (for example drag scrolling through the grid). If unspecified ListGrid.drawAheadRatio will be used in all cases
		 * Flags: IRW, Group: performance */
		quickDrawAheadRatio: number /* float */;

		/** This attribute allows custom base styles to be displayed on a per-record basis. To specify a custom base-style for some record set record[listGrid.recordBaseStyleProperty] to the desired base style name - for example if recordBaseStyleProperty is "_baseStyle", set record._baseStyle to the custom base style name.
		 * Flags: IRWA, Group: appearance */
		recordBaseStyleProperty: string;

		/** If set to false on a record and ListGrid.canRemoveRecords','canRemoveRecords is true, removal of that record is disallowed in the UI. The icon in the remove field is not shown.
		 * Flags: IRA, Group: editing */
		recordCanRemoveProperty: string /* String */;

		/** If set to false on a record, selection of that record is disallowed.
		 * Flags: IRA */
		recordCanSelectProperty: string /* String */;

		/** If ListGrid.showRecordComponents is true, this attribute may be used to specify a standard height for record components. If specified every row in the grid will be sized tall enough to accommodate a recordComponent of this size. Note that if this property is unset, the grid will not be able to know row heights in advance, and ListGridField.frozen','frozen fields are not currently supported in this case. If you are putting a recordComponent in every row, and they all have a consistent height, set recordComponentHeight and you will then be able to use frozen fields and avoid the whitespace side-effect of virtual scrolling by setting ListGrid.virtualScrolling:false. Similarly, if your recordComponents are never tall enough that they will expand the row beyond the ListGrid.cellHeight, set ListGrid.virtualScrolling:false to avoid the whitespace side-effect of ListGrid.virtualScrolling','virtual scrolling and to allow ListGridField.frozen','frozen fields to be used. In this mode, you can have recordComponents on some rows but not others, and recordComponents of different heights, so long as no recordComponent ever causes a row to grow beyond ListGrid.cellHeight (which would happen if the recordComponents height + 2*ListGrid.cellPadding is larger than ListGrid.cellHeight).
		 * Flags: IRWA */
		recordComponentHeight: number /* Integer */;

		/** The method of RecordComponentPoolingMode','component-pooling to employ for ListGrid.showRecordComponents','recordComponents. The default mode is "viewport", which means that recordComponents are destroyed as soon their record is no longer being rendered (scrolled out of the viewport, eliminated by search criteria, etc). For a large or dynamic data set where the components shown on different rows are similar, switch to "recycle" mode, which pools recordComponents by detaching them from records that are not visible and re-using them in other records. In this mode, you should implement ListGrid.updateRecordComponent to apply any changes to make reused components applicable to the new record they appear in, if necessary. For example, if you have several controls in your recordComponents, and not all of the controls apply to every record, your updateRecordComponent() implementation could simply hide or disable inapplicable controls, and this would be much faster than creating a whole new set of controls every time a given record is scrolled into view. If you are using ListGrid.showRecordComponentsByCell','per-cell recordComponents, and you have components of different types in different columns and still want to take advantage of component recycling, you can set ListGrid.poolComponentsPerColumn to ensure that components intended for one column are not recycled for use in another column that should have a different component. Note that, if different records have distinctly different components embedded in them, or multiple columns in each record embed different components, you should leave the recordComponentPoolingMode at "viewport" if your dataset is very large or use "data" otherwise.
		 * Flags: IRWA */
		recordComponentPoolingMode: RecordComponentPoolingMode;

		/** if ListGrid.showRecordComponents is true, how should the component appear within the cell. Valid options are "within": the component will be rendered inside the record / cell. Canvas.snapTo may be set to specify where the component should render within the row or cell, and Canvas.snapOffsetTop / Canvas.snapOffsetLeft may be set to indent recordComponents within their parent cells. Note that if unset, the component will show up at the top/left edge for components embedded within an entire row, or for per-cell components, cell align and valign will be respected. Note also that, when rendering components "within" cells, specified component heights will be respected and will change the height of the row. However, if you want components to completely fill a cell at it's default height, set height: "100%" or rows will render at the default height of the component. "expand": the component will be written into the cell below the normal cell content, causing the cell to expand vertically to accommodate it. null: If this attribute is unset, we will default to showing recordComponents with position "within" if ListGrid.showRecordComponentsByCell is true, otherwise using "expand" logic. 
		 * Flags: IRW */
		recordComponentPosition: EmbeddedPosition;

		/** Denotes the name of a property that can be set on records to display a custom style. For example if this property is set to "customStyle", setting record.customStyle to a css styleName will cause the record in question to render out with that styling applied to it. Note that this will be a static style - it will not be modified as the state of the record (selected / over etc) changes.
		 * Flags: IRW */
		recordCustomStyleProperty: string /* String */;

		/** The name of the ListGridRecord property that specifies the DataSource to use when ExpansionMode','listGrid.expansionMode is "related". The default is ListGridRecord.detailDS. Note that you can set the ListGrid.detailDS at the grid level instead if the same dataSource is to be used for all records.
		 * Flags: IRWA */
		recordDetailDSProperty: string /* String */;

		/** If ListGrid.canAcceptDroppedRecords is true for this listGrid, this property governs whether the user can drop between, or over records within the grid. This controls what RecordDropPosition is passed to the ListGrid.recordDrop event handler.
		 * Flags: IRW */
		recordDropAppearance: RecordDropAppearance;

		/** Property name on a record that should be checked to determine whether the record may be edited. This property is configurable to avoid possible collision with data values in record. With the default setting of "_canEdit", a record can be set non-editable by ensuring record._canEdit == false. For controlling editability for the entire grid or for a field, set grid.canEdit or field.canEdit.
		 * Flags: IRWA, Group: editing */
		recordEditProperty: string;

		/** Property name on a record that will be checked to determine whether a record is enabled. Setting this property on a record will effect the visual style and interactivity of the record. If set to false the record (row in a ListGrid or TreeGrid) will not highlight when the mouse moves over it, nor will it respond to mouse clicks.
		 * Flags: IR */
		recordEnabledProperty: string;

		/** If showing any record summary fields (IE: fields of ListGridFieldType','type:"summary"), this attribute specifies a custom base style to apply to cells in the summary field
		 * Flags: IRWA */
		recordSummaryBaseStyle: string /* CSSStyleName */;

		/** Custom CSS text to be applied to records that have been ListGrid.markRecordRemoved','marked for removal. This CSS text will be applied on top of standard disabled styling for the cell.
		 * Flags: IRWA, Group: appearance */
		removedCSSText: string;

		/** Default configuration properties for the "remove field" displayed when ListGrid.canRemoveRecords is enabled. Class.changeDefaults should be used when modifying this object. The default configuration includes a ListGridField.recordClick handler which calls ListGrid.removeData to actually perform the data removal.
		 * Flags: IR */
		removeFieldDefaults: ListGridField /* ListGridField properties */;

		/** Configuration properties for the "remove field" displayed when ListGrid.canRemoveRecords is enabled. These configuration settings will be overlaid on top of the ListGrid.removeFieldDefaults.
		 * Flags: IR */
		removeFieldProperties: ListGridField /* ListGridField properties */;

		/** The title to use for the ListGrid.removeFieldDefaults','remove field. By default this title is not displayed in the remove column header button as the ListGrid.removeFieldDefaults sets ListGridField.showTitle to false.
		 * Flags: IRWA */
		removeFieldTitle: string /* String */;

		/** When ListGrid.canRemoveRecords is enabled, default icon to show in the auto-generated field that allows removing records.
		 * Flags: IR */
		removeIcon: string /* SCImgURL */;

		/** Default width and height of ListGrid.removeIcon','remove icons for this ListGrid.
		 * Flags: IRW */
		removeIconSize: number /* Number */;

		/** If true, when an update operation occurs on a selected record in a ListGrid.dataSource','databound listGrid, ensure the updated record is re-selected when the operation completes. The ListGrid.reselectOnUpdateNotifications attributes governs whether ListGrid.selectionUpdated and ListGrid.selectionChanged will fire when this occurs.
		 * Flags: IRA */
		reselectOnUpdate: boolean;

		/** if ListGrid.reselectOnUpdate is true, this property governs what selection changed notifications should be triggered when a selected record is edited then automatically reselected when the edited data is merged into the data set.
		 * Flags: IRWA */
		reselectOnUpdateNotifications: SelectionNotificationType;

		/** If true, the grid contents are redrawn in real time as fields are resized. This can be slow with a large grid and/or on some platforms. By default, this is enabled in modern desktop browsers. This is automatically switched off in mobile browsers.
		 * Flags: IRWA, Group: dragging */
		resizeFieldsInRealTime: boolean;

		/** If a page is rendered in Page.isRTL','RTL mode, should cell alignments specified ListGridField.cellAlign be reversed (so an align:"right" field will have content aligned on the left and vice versa)? This is true by default to match user expectation that text flows from start-to end and is aligned with the start of text flow (left in LTR mode, right in RTL mode) by default. May be set to false to have the specified alignments be taken literally in RTL mode.
		 * Flags: IRW, Group: RTL */
		reverseRTLAlign: boolean /* Boolean */;

		/** AutoChild created and embedded in the grid if ListGrid.showRollOver','showRollOver is true and ListGrid.showRollOverCanvas','showRollOverCanvas is true or for selected records, if ListGrid.showSelectedRollOverCanvas','showSelectedRollOverCanvas is true. This component will be created and displayed above the current rollOver row or cell. Note that if this grid has frozen fields, the AutoChild subsystem will use the rollOverCanvas configuration settings to create the ListGrid.frozenRollOverCanvas (displayed in the frozen listGrid body). The rollOverCanvas has the following read-only attributes set: - this.grid - a pointer to the grid - this.record - a pointer to the current roll over record object in the grid
		 * Flags: RA, Group: rowEffects */
		rollOverCanvas:  Canvas /* AutoChild Canvas */;

		/** AutoChild created and embedded in the grid if ListGrid.showRollOver','showRollOver is true, and either ListGrid.showRollOverCanvas','showRollOverCanvas is true and ListGrid.showRollUnderCanvas','showRollUnderCanvas is unset, or showRollUnderCanvas is explicitly set to true. This component will be created and displayed behind the current rollOver row or cell in the page's z-order, meaning that it will only be visible if the cell styling is transparent. Note that if this grid has frozen fields, the AutoChild subsystem will use the rollUnderCanvas configuration settings to create the ListGrid.frozenRollUnderCanvas (displayed in the frozen listGrid body). The rollUnderCanvas has the following read-only attributes set: - this.grid - a pointer to the grid - this.record - a pointer to the current roll over record object in the grid
		 * Flags: RA, Group: rowEffects */
		rollUnderCanvas:  Canvas /* AutoChild Canvas */;

		/** If the user is editing a record in this listGrid, and attempts to navigate to a field beyond the end of the row, via tab (or shift-tab off the first editable field), this property determines what action to take: "next": start editing the next (or previous) record in the list "same": put focus back into the first editable field of the same record. "done": hide the editor "stop": leave focus in the cell being edited "none": no action 
		 * Flags: IRW, Group: editing */
		rowEndEditAction: RowEndEditAction;

		/** An automatically generated field that displays the current row number when ListGrid.showRowNumbers','showRowNumbers is true.
		 * Flags: IRWA, Group: rowNumberField */
		rowNumberField:  ListGridField /* AutoChild ListGridField */;

		/** The number to start the row-count from - default value is 1.
		 * Flags: IRWA, Group: rowNumberField */
		rowNumberStart: number;

		/** The CSS Style name for the ListGrid.rowNumberField.
		 * Flags: IRWA, Group: rowNumberField */
		rowNumberStyle: string /* CSSStyleName */;

		/** If ListGrid.allowRowSpanning is enabled, this property may be used to specify editing behavior for cells that span multiple rows.
		 * Flags: IRWA */
		rowSpanEditMode: RowSpanEditMode;

		/** Chooses the selection mode when ListGrid.useRowSpanStyling is enabled. See RowSpanSelectionMode.
		 * Flags: IR */
		rowSpanSelectionMode: RowSpanSelectionMode;

		/** Whether edits should be saved whenever the user moves between cells in the current edit row. If unset, defaults to ListGrid.editByCell','this.editByCell. To avoid automatic saving entirely, set ListGrid.autoSaveEdits:false.
		 * Flags: IRW, Group: editing */
		saveByCell: boolean;

		/** For grids with a specified ListGrid.dataSource, this property can be set to true to cause the grid directly update its local data set instead of performing an operation against it's configured DataSource. When using this mode, data must be provided to the grid via ListGrid.setData, and must be provided as a simple Array of Records . Setting saveLocally is invalid if either ListGrid.fetchData is called or if a ResultSet is provided as the data model. saveLocally mode includes changes made via ListGrid.canEdit','inline editing, record removal via ListGrid.canRemoveRecords, as well as programmatic calls to ListGrid.updateData, ListGrid.addData','addData() and ListGrid.removeData','removeData(). This also causes saves to be performed synchronously (unlike normal DataSource operations). Note that using this mode also disables the automatic cache synchronization provided by the DataSource system - changes made to this grid are saved only to this grid's data set. See also ListGrid.filterLocalData to allow filtering, such as filtering performed by the ListGrid.filterEditor, to also work only with the local data set. If saveLocally is unset, and ListGrid.filterLocalData is true, the saveLocally behavior is enabled by default
		 * Flags: IRA, Group: databinding */
		saveLocally: boolean;

		/** For editable grids with a specified ListGrid.dataSource, where ListGrid.saveLocally is false, this attribute may be used to specify standard DSRequest properties to apply to all save operations performed by this grid (whether triggered by user interaction, or explicit saveEdits or saveAllEdits call). An example usage would be to customize the prompt displayed while saving is in progress if ListGrid.waitForSave is true. Note that for more advanced customization of save operations, DataBoundComponent.addOperation and DataBoundComponent.updateOperation are available to developers, allowing specification of an explicit OperationBinding for the add / update operation performed on save.
		 * Flags: IRWA, Group: dataBinding */
		saveRequestProperties: DSRequestProps /* DSRequest Properties */;

		/** When isc.setScreenReaderMode','screen reader mode is enabled, this invisible separator string is written out between each cell value. This string will be picked up by screen readers allowing them to more obviously identify to the user the different cell values as the contents of a row are read aloud. The ListGrid.screenReaderRowSeparator','screenReaderRowSeparator string if any will be written out after the last cell in a row to separate the last cell's value from the screen reader's announcement of the row's number and total number of rows in the grid (such as "3 of 20"). This attribute may be set to null to disable the feature. Note that screen readers vary widely on which punctuation symbols are read aloud, and sometimes it depends on the context of the punctuation. However, the widely-used JAWS, NVDA, and VoiceOver screen readers all read the forward slash '/' as "slash". See <a href='http://www.deque.com/blog/dont-screen-readers-read-whats-screen-part-1-punctuation-typographic-symbols/' target='_blank'>Why Dont Screen Readers Always Read Whats on the Screen? Part 1: Punctuation and Typographic Symbols</a> for a table of findings on which punctuation symbols are read aloud by JAWS, NVDA, and VoiceOver.
		 * Flags: IRA, Group: accessibility */
		screenReaderCellSeparator: string /* HTMLString */;

		/** When isc.setScreenReaderMode','screen reader mode is enabled, this invisible string will be written out after the last cell in a row. This string will be picked up by screen readers allowing them to more obviously identify to the user the end of the row's contents and the screen reader's announcement of the row's number and total number of rows in the grid (such as "3 of 20"). This attribute may be set to null to disable writing out an invisible string at the end of each row. Note that screen readers vary widely on which punctuation symbols are read aloud, and sometimes it depends on the context of the punctuation. However, the widely-used JAWS, NVDA, and VoiceOver screen readers all pause briefly for a comma ',' that is within text. See <a href='http://www.deque.com/blog/dont-screen-readers-read-whats-screen-part-1-punctuation-typographic-symbols/' target='_blank'>Why Dont Screen Readers Always Read Whats on the Screen? Part 1: Punctuation and Typographic Symbols</a> for a table of findings on which punctuation symbols are read aloud by JAWS, NVDA, and VoiceOver.
		 * Flags: IRA, Group: accessibility */
		screenReaderRowSeparator: string /* HTMLString */;

		/** While drag scrolling in an incrementally rendered grid, time in milliseconds to wait before redrawing, after the last mouse movement by the user. This delay may be separately customized for mouse-wheel scrolling via ListGrid.scrollWheelRedrawDelay. See also GridRenderer.instantScrollTrackRedraw for cases where this delay is skipped. <strong>NOTE:</strong> In Browser.isTouch','touch browsers, GridRenderer.touchScrollRedrawDelay','touchScrollRedrawDelay is used instead.
		 * Flags: IRW, Group: performance */
		scrollRedrawDelay: number /* int */;

		/** When scrollToCell is called, this is used as defaults if xPosition weren't explicitly passed into the method.
		 * Flags: IRW */
		scrollToCellXPosition: Alignment;

		/** When scrollToCell is called, this is used as defaults if yPosition weren't explicitly passed into the method.
		 * Flags: IRW */
		scrollToCellYPosition: VerticalAlignment;

		/** While scrolling an incrementally rendered grid, using the mouseWheel, time in milliseconds to wait before redrawing, after the last mouseWheel movement by the user. If not specified ListGrid.scrollRedrawDelay will be used as a default for both drag scrolling and mouseWheel scrolling. Note that if specified, this value will typically be larger than ListGrid.scrollRedrawDelay. From experimentation, the default setting of 250 is typically enough time for a user to rapidly scroll through a grid (rotating the scroll wheel with repeated flicks), without redrawing between rotations, but this will differ depending on how long the redraw takes. A larger delay may be warranted for grids with large numbers of columns, heavy custom formatting, etc. See also GridRenderer.instantScrollTrackRedraw for cases where this delay is skipped.
		 * Flags: IRW, Group: performance */
		scrollWheelRedrawDelay: number /* Integer */;

		/** Returns a snapshot of the current selection within this listGrid as a ListGridSelectedState object. This object can be passed to ListGrid.setSelectedState to reset this grid's selection the current state (assuming the same data is present in the grid).
		 * Flags: IRW, Group: viewState */
		selectedState: string /* ListGridSelectedState */;

		/** If true, show the field-header for the sorted field (or the first field in a ListGrid.canMultiSort','multi-sort grid) in the selected state.
		 * Flags: IRW, Group: sorting */
		selectHeaderOnSort: boolean /* Boolean */;

		/** The Selection object associated with the listGrid.
		 * Flags: RA, Group: selection */
		selection: Selection;

		/** How selection of rows should be presented to the user. For selectionAppearance:"checkbox" with multiple selection allowed, you would typically use ListGrid.selectionType:"simple" (the default). Because selectionType and selectionAppearance are unrelated, the combination of selectionAppearance:"checkbox" and selectionType:"multiple" results in a grid where multiple selection can only be achieved via shift-click or ctrl-click. If using "checkbox" for a ListGrid, see also ListGrid.checkboxField for customization APIs. If using "checkbox" for a TreeGrid, an extra icon, TreeGrid.getExtraIcon is not supported. Additionally only ListGrid.selectionType:"simple" and "single" are supported. You can also toggle the display of a disabled checkbox on a treeGrid, displayed when the node can't be selected, via TreeGrid.showDisabledSelectionCheckbox. Note that the default behavior when you enable checkbox selection is to continue to show the selected style. This can be changed by setting ListGrid.showSelectedStyle to false.
		 * Flags: IRW, Group: selection */
		selectionAppearance: SelectionAppearance;

		/** AutoChild created and embedded in the grid if ListGrid.showSelectionCanvas','showSelectionCanvas is true and the ListGrid.selectionType','selectionType is "single". This component will be created and displayed above the selected record whenever the selection changes. NOTE: It is recommended to use the ListGrid.selectionUnderCanvas','selectionUnderCanvas rather than the selectionCanvas if possible because the selectionCanvas is stacked on top of the selected record and this may interfere with event handling in rare cases. If no interactive components are shown in the selectionCanvas and it simply provides custom styling, then the selectionUnderCanvas should be used instead. The selectionCanvas has the following read-only attributes set: - this.grid - a pointer to the grid - this.record - a pointer to the currently selected record in the grid
		 * Flags: RA, Group: rowEffects */
		selectionCanvas:  Canvas /* AutoChild Canvas */;

		/** If specified, the selection object for this list will use this property to mark records as selected. In other words, if this attribute were set to "isSelected" any records in the listGrid data where "isSelected" is true will show up as selected in the grid. Similarly if records are selected within the grid after the grid has been created, this property will be set to true on the selected records.
		 * Flags: IRA, Group: selection */
		selectionProperty: string;

		/** Defines a listGrid's clickable-selection behavior. The default selection appearance is governed by ListGrid.selectionAppearance: if selectionAppearance is "checkbox", this will be "simple", otherwise, this will be "multiple".
		 * Flags: IRW, Group: selection */
		selectionType: SelectionStyle;

		/** AutoChild created and embedded in the grid if ListGrid.showSelectionCanvas','showSelectionCanvas is true and ListGrid.showSelectionUnderCanvas','showSelectionUnderCanvas is unset, or showSelectionUnderCanvas is explicitly set to true, and the ListGrid.selectionType','selectionType is "single". This component will be created and displayed behind the selected record whenever the selection changes. The selectionUnderCanvas has the following read-only attributes set: - this.grid - a pointer to the grid - this.record - a pointer to the currently selected record object in the grid
		 * Flags: RA, Group: rowEffects */
		selectionUnderCanvas:  Canvas /* AutoChild Canvas */;

		/** When the user starts editing a row, should the row also be selected? Note that when this attribute is set to true, other all other rows in the grid will be deselected when a record is selected due to editing.
		 * Flags: IRWA, Group: editing */
		selectOnEdit: boolean /* Boolean */;

		/** When set to false, clicking a record's ListGrid.expansionField','expansion field will not add the record to the current selection.
		 * Flags: IRW */
		selectOnExpandRecord: boolean;

		/** Whether all columns should be drawn all at once, or only columns visible in the viewport. Drawing all columns causes longer initial rendering time, but allows smoother horizontal scrolling. With a very large number of columns, showAllColumns will become too slow.
		 * Flags: IR, Group: performance */
		showAllColumns: boolean /* Boolean */;

		/** Whether all rows should be drawn all at once, or only rows visible in the viewport. Drawing all rows causes longer initial rendering time, but allows smoother vertical scrolling. With a very large number of rows, showAllRows will become too slow. See also ListGrid.drawAheadRatio and ListGrid.drawAllMaxCells.
		 * Flags: IRW, Group: performance */
		showAllRecords: boolean /* Boolean */;

		/** If set to false, do not show the ListGrid.asynchGroupingPrompt dialog during ListGrid.groupByAsyncThreshold','asynchronous grouping.
		 * Flags: IR */
		showAsynchGroupingPrompt: boolean /* Boolean */;

		/** If true this grid will create and show per-row backgroundComponents as detailed ListGrid.backgroundComponent','here.
		 * Flags: IRW */
		showBackgroundComponents: boolean /* Boolean */;

		/** Whether to show a context menu with standard items for all context clicks on rows in the body.
		 * Flags: IRW */
		showCellContextMenus: boolean /* Boolean */;

		/** If true and a header button's title is clipped, then a hover containing the full field title is enabled.
		 * Flags: IRA, Group: hovers */
		showClippedHeaderTitlesOnHover: boolean;

		/** If true and a cell's value is clipped, then a hover containing the full cell value is enabled. Note that standard cell hovers override clipped value hovers. Thus, to enable clipped value hovers, ListGrid.canHover','canHover must be unset or null and the corresponding field must have ListGridField.showHover','showHover unset or null as well.
		 * Flags: IRA, Group: events */
		showClippedValuesOnHover: boolean /* Boolean */;

		/** Should group summaries be visible when the group is collapsed? This property only applies to ListGrid.groupBy','grouped grids showing ListGrid.showGroupSummary','group summary rows. When set to true, the group summary row(s) for each group will show up under the group header nodes when the group is collapsed, or at then end of the grouped set of data if the group is expanded. This property has no effect if ListGrid.showGroupSummaryInHeader is true.
		 * Flags: IRW, Group: grouping */
		showCollapsedGroupSummary: boolean /* Boolean */;

		/** Whether to include fields marked detail:true from this component's DataSource. When this property is true, the ListGrid will include all detail fields unless fields have been specifically declared using the ListGrid.fields array. Any field which has been included directly in the fields array will be included regardless of the fields detail attribute. Detail fields included will initially be hidden but the user may show these fields via the default header context menu (ListGrid.showHeaderContextMenu). The field's visibility can also be overridden programatically using the standard ListGrid.showField, ListGrid.hideField and ListGridField.showIf APIs, for example, set showIf:"true" to show a detail field initially. Setting this property to false will completely exclude all detail fields from the list grid's fields array, such that they cannot be shown by the user or programmatically.
		 * Flags: IR, Group: databinding */
		showDetailFields: boolean /* Boolean */;

		/** Indicates whether the text of the emptyMessage property should be displayed if no data is available.
		 * Flags: IRW, Group: emptyMessage */
		showEmptyMessage: boolean /* Boolean */;

		/** If this grid is editable, and an edit has caused validation failure for some cell, should we show an icon to indicate validation failure?
		 * Flags: IRW, Group: errorIcon */
		showErrorIcons: boolean;

		/** When ExpansionMode is editor, should a Save button be shown below the the expanded editor? Note that if an expanded-row containing an editor is collapsed while changes are outstanding, changes will be either be automatically updated to the grid, or will first show a confirmation dialog, according to the value of ListGrid.expansionEditorShowSaveDialog.
		 * Flags: RW, Group: expansionField */
		showExpansionEditorSaveButton: boolean /* Boolean */;

		/** Should this listGrid display a filter row. If true, this ListGrid will be drawn with a single editable row, (separate from the body) with a filter button. Values entered into this row are used as filter criteria to filter this List's data on enter-keypress or filter button click. ListGrid.autoFetchTextMatchStyle determines the textMatchStyle for the request passed to ListGrid.fetchData. The default FormItem.operator','search operator for an item in the filterEditor can be set via ListGridField.filterOperator. When field.filterOperator has been set calls to retrieve the criteria from the grid return AdvancedCriteria. See also ListGrid.allowFilterOperators for a UI that allows end users to change the search operator on the fly Note that if ListGrid.filterData or ListGrid.fetchData is called directly while the filter editor is showing, the filter editor values will be updated to reflect the new set of criteria. If you wish to retain the user entered filter criteria and modify a subset of field values programmatically, this can be achieved by copying the existing set of criteria and adding other changes - something like this: var newCriteria = myListGrid.getFilterEditorCriteria(); isc.DataSource.combineCriteria(newCriteria, { field1:"new value1", field2:"new value2" }); myListGrid.setCriteria(newCriteria); In this example code we're using ListGrid.getFilterEditorCriteria rather than ListGrid.getCriteria - this ensures that if the user has typed a new value into the filter editor, but not yet clicked the filter button, we pick up the value the user entered. This sample code uses DataSource.combineCriteria to combine the existing filterEditorCriteria with some new custom criteria. This technique is applicable to both simple and advanced criteria. If you call filterData() and pass in criteria for dataSource fields that are not present in the ListGrid, these criteria will continue to be applied along with the user-visible criteria. filterEditor and advanced criteria: If a developer calls filterData() on a ListGrid and passes in AdvancedCriteria, expected behavior of the filter editor becomes ambiguous, since AdvancedCriteria has far more complex filter expression support than the ordinary filterEditor can represent. Default behavior for AdvancedCriteria will combine the AdvancedCriteria with the values in the filter editor as follows: If the top level criteria has operator of type "and": Each field in the top level criteria array for which a 'canFilter' true field is shown in the listGrid will show up if the specified operator matches the default filter behavior (based on the ListGrid.autoFetchTextMatchStyle). If the user enters values in the filter editor, these will be combined with the existing AdvancedCriteria by either replacing or adding field level criteria at the top level. If the top level criteria is a single field-criteria: If the field shows up in the listGrid and is canFilter:true, it will be displayed to the user (if the operator matches the default filter behavior for the field). If the user enters new filter criteria in the filterEditor, they will be combined with this existing criterion via a top level "and" operator, or if the user modifies the field for which the criterion already existed, it will be replaced. Otherwise, if there are multiple top level criteria combined with an "or" operator, these will not be shown in the filter editor. Any filter parameters the user enters will be added to the existing criteria via an additional top level "and" operator, meaning the user will essentially filter a subset of the existing criteria 
		 * Flags: IRW, Group: filterEditor */
		showFilterEditor: boolean;

		/** Should this ListGrid show a summary row beneath the last record of the grid. This summary row will contain per-field summary information. See ListGridField.showGridSummary and ListGrid.getGridSummaryFunction for details on how the summary value to be displayed for each column will be calculated. Note that the ListGrid.summaryRow','summaryRow autoChild will be created to actually display the summary row.
		 * Flags: IRW */
		showGridSummary: boolean /* Boolean */;

		/** If this listGrid supports ListGrid.canGroupBy','grouping, setting this property will cause the grid to render an extra row at the end of each group when grouped, containing summary information for the fields. Summary information will be calculated by the ListGridField.getGroupSummary method if specified, otherwise via the specified ListGridField.summaryFunction.
		 * Flags: IRW */
		showGroupSummary: boolean /* Boolean */;

		/** If this grid is ListGrid.groupBy','grouped, and ListGrid.showGroupSummary is true, setting this property causes field summary values for each group to be displayed directly in the group header node, rather than showing up at the bottom of each expanded group. Note that this means the group header node will be showing multiple field values rather than the default display of a single cell spanning all columns containing the group title. Developers may specify an explicit ListGrid.groupTitleField, or rely on the automatically generated ListGrid.showGroupTitleColumn','groupTitleColumn to have group titles be visible as well as the summary values. Also note that multi-line group summaries are not supported when showing the group summary in the group header. If multiple ListGridField.summaryFunction','field summary functions are defined for some field only the first will be displayed when this property is set to true.
		 * Flags: IRW, Group: grouping */
		showGroupSummaryInHeader: boolean /* Boolean */;

		/** If this grid is ListGrid.groupBy','grouped and ListGrid.showGroupSummaryInHeader is true, instead of group header nodes showing up with a single cell value spanning the full set of columns, summaries for each field will show up in the appropriate columns of the header node. In this case there are 2 options for where the group title will show up. Developers may specify an existing field to put the title values into via ListGrid.groupTitleField. If no groupTitleField is specified, this property may be set to true which causes a groupTitleColumn to be automatically generated. Each group header will show the group title in this column (records within the group will not show a value for this column). The column appears in the leftmost position within the grid (unless ListGrid.showRowNumbers is true, in which case this column shows up in the second-leftmost position), and by default will auto-fit to its data. To customize this field, developers may modify ListGrid.groupTitleColumnProperties or ListGrid.groupTitleColumnDefaults at the class level.
		 * Flags: IR */
		showGroupTitleColumn: boolean /* Boolean */;

		/** If this is ListGrid.groupBy','grouped and has frozenFields','frozen fields, should the group title show in the frozen or unfrozen body? Setting this property to false will cause the group title to show in the unfrozen body in this case, meaning it will appear to the right of the frozen fields, and scroll horizontally as the user scrolls the unfrozen fields. This can be useful for grids where there isn't enough available space to show the group title text in the frozen body. Note that if ListGrid.groupTitleField is explicitly set, or ListGrid.showGroupSummaryInHeader is true, this property has no effect. In this case rather than the group title showing in a single cell spanning multiple other fields, it will be rendered into a specific column.
		 * Flags: IRWA */
		showGroupTitleInFrozenBody: boolean;

		/** Should we show the header for this ListGrid?
		 * Flags: IRW, Group: gridHeader */
		showHeader: boolean /* Boolean */;

		/** Whether to show a context menu on the header with standard items for showing and hiding fields. Not supported for CubeGrid.
		 * Flags: IR, Group: gridHeader */
		showHeaderContextMenu: boolean /* Boolean */;

		/** If set to true and ListGrid.showHeaderContextMenu','showHeaderContextMenu is true, the ListGrid.headerMenuButton will be displayed when the user rolls over the header buttons in this grid. Not supported for CubeGrid.
		 * Flags: IR, Group: headerMenuButton */
		showHeaderMenuButton: boolean /* Boolean */;

		/** Should the header show a drop-shadow? Shadow will be applied to the header, or for a grid with frozen columns, the header layout. Header shadow will only be displayed if Canvas.useCSSShadow','css shadows are being used.
		 * Flags: IRW */
		showHeaderShadow: boolean /* Boolean */;

		/** If this grid has specified ListGrid.headerSpans','headerSpans, should field titles be prefixed with the titles of the headerSpans in which they are contained when using the FormulaBuilder or SummaryBuilder.
		 * Flags: IRW */
		showHeaderSpanTitlesInFormulaBuilder: boolean /* Boolean */;

		/** If this grid has specified ListGrid.headerSpans, should field titles be prefixed with the titles of the headerSpans in which they are contained when using the DataBoundComponent.editHilites','hilite editor.
		 * Flags: IRW */
		showHeaderSpanTitlesInHiliteEditor: boolean /* Boolean */;

		/** If this grid has specified ListGrid.headerSpans','headerSpans, should field titles be prefixed with the titles of the headerSpans in which they are contained when using the MultiSortDialog','multi-sort editor.
		 * Flags: IRW */
		showHeaderSpanTitlesInSortEditor: boolean /* Boolean */;

		/** Determines whether hiliting for any field in this grid is shown in a group summary. This setting affects all fields of the grid. To suppress hilites for a specific field see ListGridField.showHilitesInGroupSummary. Hiliting in summary fields (columns) can be enabled by setting ListGrid.includeHilitesInSummaryFields','includeHiliteInSummaryField to true.
		 * Flags: IRW */
		showHilitesInGroupSummary: boolean;

		/** If true, and canHover is also true, when the user hovers over a cell, hover text will pop up next to the mouse. The contents of the hover is determined by ListGrid.cellHoverHTML.
		 * Flags: IRW, Group: hovers */
		showHover: boolean /* Boolean */;

		/** When set to true and canHover is also true, shows a widget hovering at the mouse point. A number of builtin modes are provided - see HoverMode. Also supported at the ListGridField.showHoverComponents','field-level.
		 * Flags: IRWA, Group: hoverComponents */
		showHoverComponents: boolean /* Boolean */;

		/** Should partially selected parents (in a Tree data set) be shown with special icon? This has an impact in grouped grids where ListGrid.canSelectGroups is true. The partial icon will show up for the group header node when a group is partially selected.
		 * Flags: IRW */
		showPartialSelection: boolean /* Boolean */;

		/** When enabled, ListGrid.createRecordComponent will be called when saved rows are being rendered, and any returned component will be displayed embedded within the row or cell. recordComponents are not created for newly added rows which have not yet been saved. See the unsavedRecords','Handling Unsaved Records overview for more information. Depending on the ListGrid.showRecordComponentsByCell setting, createRecordComponent() will be called either once per row, or once for every cell. Depending on ListGrid.recordComponentPosition, components can either be placed underneath normal record or cell content ("expand" setting) or placed so that they overlap normal cell content ("within" setting). For the "within" setting, the default is to fill the row or cell, but the component can specify percent size or even use Canvas.snapTo','snapTo-positioning to place itself within the row or cell. The "expand" setting is incompatible with ListGrid.canFreezeFields','frozen columns unless all recordComponents are the same height and they are present in every row, in which case the fixed height of all recordComponents can be set via ListGrid.recordComponentHeight to re-enable frozen fields. Using recordComponents potentially means creating one component for every visible grid row or cell and so can impact performance. Before using this subsystem: consider using ListGridField.valueIcons (possibly with a specified ListGridField.valueIconClick handler) for icons based on field values which may be displayed alone in the cell or alongside standard content (see ListGridField.showValueIconOnly); for clickable icons representing actions that can be taken on a record, also consider using ListGridFieldType','a field of type "icon", or multiple such fields for controls that only need to appear on rollover, consider ListGrid.showRollOverCanvas','rollOver controls if you are trying to customize the editor for a field, you can provide a custom control via ListGridField.editorType, and FormItem.icons are a common way to add clickable buttons. You can also ListGrid.getEditorType','provide different controls per record. These options are usually better that using recordComponents as custom editors, since you won't have to manage issues like making the recordComponent appear only when editing, having changes affect editing','editValues, triggering saves and handling validation errors, etc. See RecordComponentPoolingMode for an overview of how best to optimize use of recordComponents for different data sets. Regardless of the pooling mode, you can explicitly refresh record components via ListGrid.invalidateRecordComponents and ListGrid.refreshRecordComponent. Interaction with ListGrid.autoFitFieldWidths','column auto-fit: per-cell record components are not taken into account when determining the size for column auto fit. The default ListGrid.getDefaultFieldWidth implementation looks at cell content only. We typically recommend that, for fields showing record-components, ListGridField.autoFitWidth and ListGridField.canAutoFitWidth be disabled, or if the record components are of a predictable size, a ListGridField.defaultWidth be specified. This is particularly pertinent where ListGrid.recordComponentPosition is set to "within", in which case cells' content is often empty or completely covered by record-components.
		 * Flags: IRWA */
		showRecordComponents: boolean;

		/** If true, shows ListGrid.showRecordComponents','recordComponents in cells, rather than just in records.
		 * Flags: IRWA */
		showRecordComponentsByCell: boolean;

		/** Should we show different styling for the cell the mouse is over? If true, the cell style will have the suffix "Over" appended. Can be overridden on a per-record basis via ListGridRecord.showRollOver.
		 * Flags: IRW, Group: appearance */
		showRollOver: boolean /* Boolean */;

		/** When enabled, when the mouse moves over a row or cell (depending on ListGrid.useCellRollOvers), an arbitrary Canvas can be shown layered on top of the row or cell (the ListGrid.rollOverCanvas), layered underneath the row or cell (the ListGrid.rollUnderCanvas), or both. This can be used to dynamically show controls or informational displays only on rollover. For example, controls to delete a row might appear only on rollover so they do not clutter the static display, or a "rollUnder" Canvas could be used to display additional information that can appear behind normal cell values (like displaying percent complete via as a bar of color that appears behind text values). Canvas.snapTo','snapTo positioning can be used to place the rollOver/rollUnderCanvas. With useCellRollOvers, positioning is relative to the cell, for row-level rollOver, position is relative to the portion of the row that is scrolled into view (this implies a row-level rollOver/UnderCanvas can never be placed horizontally scrolled out of view, but this is possible for a cell-level rollOver). snapTo positioning makes it easy to do something like place a button at the right edge of the grid, next to the scrollbar: just set snapTo:"R" on the rollOverCanvas. The rollOver/rollUnder Canvas can be a single static component (the same for all cells/rows) configured via the AutoChild system, or can instead be provided dynamically by implementing ListGrid.getRollOverCanvas and/or ListGrid.getRollUnderCanvas. The rollOver/rollUnder canvas will be automatically added to the grid's ListGrid.body','body as an ListGrid.addEmbeddedComponent','embedded component. For grids with ListGridField.frozen','frozen fields, the behavior is as follows: If ListGrid.useCellRollOvers is false (the default), embedded components will be added to both the body and the frozen body Otherwise the component will be added to whichever body contains the cell the user is currently over The rollOver/rollUnder canvas added to the frozen body will be created by calling the ListGrid.getFrozenRollOverCanvas or ListGrid.getFrozenRollUnderCanvas methods. The default implementation for these methods matches their equivalents for non-frozen rollOver / rollUnder canvases - it will use the autoChild subsystem to create a canvas from the ListGrid.rollOverCanvas autoChild configuration. showRollOverCanvas has no effect if ListGrid.showRollOver is false. See also ListGrid.showSelectedRollOverCanvas.
		 * Flags: IRWA, Group: rowEffects */
		showRollOverCanvas: boolean /* Boolean */;

		/** If roll overs are enabled, should the ListGrid.rollUnderCanvas','rollUnderCanvas be displayed? Use of the showRollUnderCanvas is enabled if ListGrid.showRollOver','showRollOver is true, and either ListGrid.showRollOverCanvas','showRollOverCanvas is true and showRollUnderCanvas is unset, or showRollUnderCanvas is explicitly set to true. See also ListGrid.showSelectedRollUnderCanvas.
		 * Flags: IRWA */
		showRollUnderCanvas: boolean /* Boolean */;

		/** When set to true, shows an additional field at the beginning of the field-list (respecting RTL) that displays the current rowNum for each record.
		 * Flags: IRWA, Group: rowNumberField */
		showRowNumbers: boolean;

		/** This setting causes the ListGrid.rollOverCanvas','roll over canvas to be displayed when the user rolls over selected records in the grid (but not when rolling over other records). This can be useful to display a "Selected Over" appearance which can't be easily achieved via standard cell styling.
		 * Flags: IRWA, Group: rowEffects */
		showSelectedRollOverCanvas: boolean /* Boolean */;

		/** This setting causes the ListGrid.rollUnderCanvas','roll under canvas to be displayed when the user rolls over selected records in the grid (but not when rolling over other records). This can be useful to display a "Selected Over" appearance which can't be easily achieved via standard cell styling. As with ListGrid.showRollUnderCanvas, if this property is unset, but the related ListGrid.showSelectedRollOverCanvas property is true, both the the roll under and roll under canvases will be displayed as the user rolls over selected records.
		 * Flags: IRWA, Group: rowEffects */
		showSelectedRollUnderCanvas: boolean /* Boolean */;

		/** Should the "Selected" style be applied to selected records?
		 * Flags: IRW */
		showSelectedStyle: boolean /* Boolean */;

		/** If ListGrid.selectionType','selectionType is set to "single", setting this property to true means selection will be displayed to the user with the ListGrid.selectionCanvas','selectionCanvas and/or ListGrid.selectionUnderCanvas','selectionUnderCanvas rather than with CSS styling. If showSelectionCanvas is set to true, then the selectionUnderCanvas will automatically be enabled unless ListGrid.showSelectionUnderCanvas','showSelectionUnderCanvas is set to false. NOTE: It is recommended to use the selectionUnderCanvas rather than the selectionCanvas if possible because the selectionCanvas is stacked on top of the selected record and this may interfere with event handling in rare cases. If no interactive components are shown in the selectionCanvas and it simply provides custom styling, then the selectionUnderCanvas should be used instead. With ListGrid.canFreezeFields','frozen fields, the selectionCanvas is displayed only over the non-frozen fields of the selected row.
		 * Flags: IRWA, Group: rowEffects */
		showSelectionCanvas: boolean /* Boolean */;

		/** If ListGrid.selectionType','selectionType is set to "single", and either ListGrid.showSelectionCanvas','showSelectionCanvas is true and showSelectionUnderCanvas is unset, or showSelectionUnderCanvas is explicitly set to true, then selection will be displayed to the user with the ListGrid.selectionCanvas','selectionCanvas and/or ListGrid.selectionUnderCanvas','selectionUnderCanvas rather than with CSS styling. Setting showSelectionUnderCanvas to false will disable the use of the selectionUnderCanvas. With ListGrid.canFreezeFields','frozen fields, the selectionUnderCanvas is displayed only behind the non-frozen fields of the selected row.
		 * Flags: IRWA, Group: rowEffects */
		showSelectionUnderCanvas: boolean /* Boolean */;

		/** Indicates whether a sorting arrow should appear for the listGrid, and its location. See SortArrow for details. Clicking the sort arrow reverses the direction of sorting for the current sort column (if any), or sorts the listGrid by its first sortable column. The arrow image on the button indicates the current direction of sorting. If undefined, the sort arrow will show up in the sorted field, and the corner sort button will be displayed if a vertical scrollbar is being displayed
		 * Flags: IRW, Group: sorting */
		showSortArrow: SortArrow;

		/** When multiple fields are sorted, set this to false to hide the sort-numeral displayed by default after the sort-arrows in the header-buttons of sorted fields.
		 * Flags: IRWA */
		showSortNumerals: boolean;

		/** When ListGrid.headerSpans are in use, whether to show a hierarchical column picker that includes both headerSpans and normal headers, with normal headers indented under headerSpans similarly to how a TreeGrid displays a Tree. If showTreeColumnPicker is false, no column picker will be shown on the headerSpan itself, and the column picker for a clicked on a normal field header will include only normal fields.
		 * Flags: IR, Group: headerSpan */
		showTreeColumnPicker: boolean /* Boolean */;

		/** If this list grid is showing any ListGridField.frozen','frozen fields, and a horizontal scrollbar is visible at the bottom of the liquid columns, should an equivalent scrollbar gap be left visible below the frozen columns? Note that if set to true any backgroundColor or border applied to the ListGrid will show up below the bottom row of the frozen column(s).
		 * Flags: IRWA, Group: frozenFields */
		shrinkForFreeze: boolean /* Boolean */;

		/** If record[this.singleCellValueProperty] is set for some record, the record will be displayed as a single cell spanning every column in the grid, with contents set to the value of record[this.singleCellValueProperty].
		 * Flags: IRW */
		singleCellValueProperty: string;

		/** Where do 'skin' images (those provided with the class) live?
		 * Flags: IRWA, Group: appearance */
		skinImgDir: string /* URL */;

		/** Image to show when sorting ascending. See ImgProperties for format.
		 * Flags: IRWA, Group: appearance */
		sortAscendingImage: ImgProperties;

		/** For any fields of FieldType','type "binary", should sorting be performed against the fileName of the value for the field? For SmartClient server backed dataSources, this is applied to the record automatically as described in the binaryFields overview. If set to false, binary fields will be sorted against the record value for the field in question. Client-side sorting does not support this, so developers who actually want to support a sort against the binary itself would typically set ResultSet.useClientSorting to false on the ListGrid.dataProperties block for this grid. Note that this setting will have no effect if DataSourceField.sortByField is specified
		 * Flags: IRW, Group: sorting */
		sortBinaryByFileName: boolean;

		/** If set, whenever grouping is performed by an end user or by a programmatic call to ListGrid.groupBy, data is implicitly sorted by all of the grouped columns, in the order they were passed to groupBy. Any user-configured sorting is applied after sorting by grouped columns. Sorting by grouped fields will be in ascending or descending order according to whether the grid is currently sorted (by any field) in ascending or descending order, defaulting to ascending if the grid is not sorted. Implicit sorting by group can be forced to be always ascending or always descending by setting ListGrid.groupSortDirection. The sorting is "implicit" in the sense that the sorting is not shown in the ListGrid headers, and not shown in the MultiSortDialog if enabled. An end user cannot currently remove the implicit sorting themselves (except by removing the grouping), though it is possible to override it by providing an explicit sort on the group's column. Clicking on the grouped field's header reveals the usual sort indicators with all the same semantics. The correct way to remove implicit sorting programmatically is to call ListGrid.setSortByGroupFirst','setSortByGroupFirst(false). Programmatic calls to ListGrid.getSort will not include the implicit sort in the list of return sort specifiers, and calls to ListGrid.setSort will implicitly add the sorting by grouped columns before the specified sort. Note that directly calling ResultSet.getSort() will include the implicit sort information.
		 * Flags: IRW, Group: sorting */
		sortByGroupFirst: boolean /* Boolean */;

		/** Image to show when sorting descending. See ImgProperties for format.
		 * Flags: IRWA, Group: appearance */
		sortDescendingImage: ImgProperties;

		/** Sorting direction of this ListGrid. If specified when the ListGrid is initialized, this property will be the default sorting direction for the ListGrid.sortField. May be overridden by specifying ListGridField.sortDirection. After initialization, this property will be updated on ListGrid.sort or ListGrid.setSort to reflect the current sort direction of the grid. When this grid is sorted by multiple fields, the grid's sortDirection reflects the sort direction of the primary sort field.
		 * Flags: IRW, Group: sorting */
		sortDirection: SortDirection;

		/** If this grid has specified ListGrid.headerSpans','headerSpans, and ListGrid.showHeaderSpanTitlesInSortEditor','showHeaderSpanTitlesInSortEditor is true, this string will be inserted between the headerSpan title(s) and the field title in the field chooser grid on the MultiSortDialog','multi-sort editor
		 * Flags: IRW, Group: i18nMessages */
		sortEditorSpanTitleSeparator: string /* String */;

		/** The title for the corner sort button. The title will only Class.changeDefaults','ListGrid.changeDefaults() rather than replacing with an entirely new object.
		 * Flags: IR, Group: i18nMessages */
		sorterButtonTitle: string;

		/** Widget class for the corner sort button, if showing. This button displays the current sort direction of the primary sort field (either the only sorted field or the first in a ListGrid.canMultiSort','multi-sort grid) and reverses the direction of that field when clicked. For consistent appearance, this is usually set to match ListGrid.headerButtonConstructor
		 * Flags: IR, Group: gridHeader */
		sorterConstructor: Class;

		/** Defaults to apply to the corner sort button. To modify this object, use Class.changeDefaults','ListGrid.changeDefaults() rather than replacing with an entirely new object.
		 * Flags: IRA, Group: gridHeader */
		sorterDefaults: any /* object */;

		/** Properties to apply to the sorter button. Overrides defaults applied via ListGrid.sorterDefaults.
		 * Flags: IRA, Group: gridHeader */
		sorterProperties: ButtonProps /* Button Properties */;

		/** Specifies the field by which this grid should be initially sorted. Can be set to either a ListGridField.name','field name or the index of the field in the fields Array. ListGrids also support being initialized with multiple-field sort via ListGrid.initialSort. If initialSort is specified, it will be used in preference to this property. To sort the grid after it has been initialized, use ListGrid.sort or ListGrid.setSort. Details about the current sort of a live grid can be retrieved by calling ListGrid.getSortField or ListGrid.getSort
		 * Flags: IR, Group: sorting */
		sortField: string | number /* String | int */;

		/** If we're showing a ListGrid.showHeaderContextMenu','headerContextMenu for this grid, this attribute will be shown as the menu item title to sort a field in ascending order.
		 * Flags: IRW, Group: i18nMessages */
		sortFieldAscendingText: string;

		/** If we're showing a ListGrid.showHeaderContextMenu','headerContextMenu for this grid, this attribute will be shown as the menu item title to sort a field in descending order.
		 * Flags: IRW, Group: i18nMessages */
		sortFieldDescendingText: string;

		/** When multiple fields are sorted, the Style to apply to the numeral that appears after the sort-arrows in the header-buttons of sorted fields.
		 * Flags: IRWA */
		sortNumeralStyle: string /* CSSStyleName */;

		/** Initial sort state for the grid. ListGrid.viewState can be used to initialize all view properties of the grid. When doing so, sortState is not needed because viewState includes it as well. If both are provided, sortState has priority for sort state. To retrieve current state call ListGrid.getSortState','getSortState. 
		 * Flags: IRW, Group: viewState */
		sortState: string /* ListGridSortState */;

		/** The menu displayed when a cell is right clicked on.
		 * Flags: R, Group: gridHeader */
		spanContextMenu:  Layout /* AutoChild Layout */;

		/** If this is an editable listGrid, this property determines how failure to save due to validation errors should be displayed to the user. If this property is true, when validation errors occur the errors will be displayed to the user in an alert, and focus will be returned to the first cell to fail validation. If false, the cells that failed validation will be silently styled with the editFailedBaseStyle. Note: stopOnErrors being set to true implies that 'waitForSave' is also true. We will not dismiss the editor until save has completed if stopOnErrors is true.
		 * Flags: IRWA, Group: editing */
		stopOnErrors: boolean /* Boolean */;

		/** Default CSS class for the ListGrid as a whole.
		 * Flags: IRW, Group: appearance */
		styleName: string /* CSSStyleName */;

		/** Automatically generated ListGrid for displaying grid summary information (see ListGrid.showGridSummary). This component is an AutoChild and as such may be customized via listGrid.summaryRowProperties and listGrid.summaryRowDefaults
		 * Flags: RA */
		summaryRow:  ListGrid /* AutoChild ListGrid */;

		/** If ListGrid.showGridSummary is true, and a ListGrid.summaryRowDataSource is specified this property may be used to specify fetch criteria to apply when retrieving summary data to show in the summary row. If unset, and any filter criteria have been specified for the grid, they will be used.
		 * Flags: IRWA */
		summaryRowCriteria: Criteria;

		/** If ListGrid.showGridSummary is true, by default summary values are calculated on the client based on the current data-set for the grid (see ListGrid.getGridSummary and ListGrid.getGridSummaryFunction). In some cases however it may make sense to calculate summary values on the server and retrieve them via a dataSource fetch. If set, this property specifies a dataSource to fetch against for the summary row. The dataSource should return a single record with summary data for each field for which summary data should be shown. Note that specifying this property completely bypasses the standard client-side grid summary calculation logic. The fetch may be further customized via ListGrid.summaryRowCriteria and ListGrid.summaryRowFetchRequestProperties
		 * Flags: IRA */
		summaryRowDataSource: DataSource;

		/** If ListGrid.showGridSummary is true, and a ListGrid.summaryRowDataSource is specified this property may be used to customize the fetch request used when retrieving summary data to show in the summary row. An example use case might be specifying a DSRequest.operationId to perform a custom fetch operation which retrieved only summary values based on criteria.
		 * Flags: IRWA */
		summaryRowFetchRequestProperties: DSRequestProps /* DSRequest Properties */;

		/** Default height for the ListGrid.summaryRow','summary row autoChild. Note that this height is a minimum - the summary row has ListGrid.autoFitData set to "vertical" so if multiple rows are visible in the grid summary, the summaryRow component will expand to accommodate them.
		 * Flags: IR */
		summaryRowHeight: number /* int */;

		/** ListGrid.baseStyle for the ListGrid.summaryRow
		 * Flags: IRWA */
		summaryRowStyle: string /* CSSStyleName */;

		/** "Tall" baseStyle for this listGrid. Only applies if ListGrid.baseStyle is set to null. If baseStyle is unset, this property will be used as a base cell style unless the grid is showing fixed height rows with a specified cellHeight that matches ListGrid.normalCellHeight, in which case ListGrid.normalBaseStyle will be used. Note that in Internet Explorer if ListGrid.fastCellUpdates is true, tallBaseStyle will also be used even if the cellHeight matches the specified normalCellHeight for the grid. See cellStyleSuffixes for details on how stateful suffixes are combined with the base style to generate stateful cell styles.
		 * Flags: IR */
		tallBaseStyle: string /* CSSStyleName */;

		/** Display format to use for fields specified as type 'time'. May also be specified at the field level via ListGridField.timeFormatter. If unset, time fields will be formatted based on the system wide Time.shortDisplayFormat. If this field is editable, the timeFormatter will also be passed to the editor created to edit any time type fields as TimeItem.timeFormatter
		 * Flags: IRW, Group: appearance */
		timeFormatter: TimeDisplayFormat;

		/** Best field to use for a user-visible title for an individual record from this grid. If ListGrid.dataSource is non null, this property may be specified on the dataSource instead. If not explicitly set, titleField looks for fields named "title", "name", and "id" in that order. If a field exists with one of those names, it becomes the titleField. If not, then the first field is designated as the titleField.
		 * Flags: IRW */
		titleField: string;

		/** While scrolling an incrementally rendered grid, using the inertial scrolling, time in milliseconds to wait before redrawing, after the last touchScroll by the user. If not specified ListGrid.scrollRedrawDelay will be used as a default for both drag scrolling and touch scrolling. Note that if specified, this value will typically be larger than ListGrid.scrollRedrawDelay. See also GridRenderer.instantScrollTrackRedraw for cases where this delay is skipped.
		 * Flags: IRW, Group: performance */
		touchScrollRedrawDelay: number /* Integer */;

		/** Default image to use for the dragTracker when things are dragged within or out of this list. See ImgProperties for format.
		 * Flags: IRWA, Group: dragTracker */
		trackerImage: ImgProperties;

		/** If we're showing a ListGrid.showHeaderContextMenu','headerContextMenu for this grid and ListGrid.canFreezeFields','this.canFreezeFields is true, this string will be shown as the title for the menu item to unfreeze a currently frozen field. This is a dynamic string - text within &#36;{...} will be evaluated as JS code when the message is displayed, with title available as a variable containing the field title. Default value returns "Unfreeze " + the field's summary title.
		 * Flags: IRWA, Group: i18nMessages */
		unfreezeFieldText: string /* HTMLString */;

		/** If we're showing a ListGrid.showHeaderContextMenu','headerContextMenu for this grid, and ListGrid.isGrouped','this.isGrouped is true, this attribute will be shown as the title for the menu item to ungroup the grid.
		 * Flags: IRW, Group: i18nMessages */
		ungroupText: string;

		/** When ListGrid.canRemoveRecords is enabled, this icon will be shown in the auto generated field fro removing records if the record has been marked as removed via ListGrid.markRecordRemoved. At this point, clicking on the icon will unmark the record as removed.
		 * Flags: IR */
		unremoveIcon: string /* SCImgURL */;

		/** When ListGrid.headerSpans','headerSpans are in use, this property sets the default vertical alignment for for fields which do not have a headerSpan.
		 * Flags: IR, Group: headerSpan */
		unspannedHeaderVAlign: string /* vAlign */;

		/** If set to true, an advanced field picker based on the FieldPicker will be shown instead of the column picker submenu if there are more fields in the grid than ListGrid.advancedFieldPickerThreshold. When there are large numbers of available fields, the FieldPicker-based interface is more usable for both defining visible fields and defining field order.
		 * Flags: IR */
		useAdvancedFieldPicker: boolean /* Boolean */;

		/** If true, the set of fields given by the "default binding" (see DataBoundComponent.fields) is used, with any fields specified in component.fields acting as overrides that can suppress or modify the display of individual fields, without having to list the entire set of fields that should be shown. If component.fields contains fields that are not found in the DataSource, they will be shown after the most recently referred to DataSource field. If the new fields appear first, they will be shown first. validationFieldBinding', 'This example shows a mixture of component fields and DataSource fields, and how they interact for validation. This setting may be cleared if a FieldPicker is used to edit the component's field order.
		 * Flags: IRW, Group: databinding */
		useAllDataSourceFields: boolean;

		/** Are rollovers cell-level or row-level?
		 * Flags: IRW */
		useCellRollOvers: boolean /* Boolean */;

		/** Enables copy/paste shortcuts, provided ListGrid.canSelectCells is true The default setting of true means that the value of ListGrid.canSelectCells determines whether copy/paste shortcuts are enabled. Setting this property to false disables said shortcuts unconditionally. Copying is done via copying to a SmartClient-wide "clipboard" - not the OS-level clipboard, which is inaccessible on some browsers - via the methods ListGrid.getSelectedCellData and ListGrid.applyCellData. To copy data to and from applications outside of the browser, use the technique shown in the gridToExcel', 'Grid to Excel and excelToGrid', 'Excel to Grid samples. The following shortcuts are available: CTRL + D: copy cell values from top row of selected cells down to all rows CTRL + R: copy cell values from left column of selected cells right to all columns CTRL + C: copy selected cell values into shared clipboard CTRL + V: paste from shared clipboard into current selection
		 * Flags: IRW */
		useCopyPasteShortcuts: boolean /* Boolean */;

		/** If ListGrid.saveLocally is specified, but this grid is bound to a DataSource which includes remote field validators, by default edits will be saved synchronously and these validators will not be executed. Set this property to true to ensure these remote validators are called when saving edits in saveLocally mode. Note that since these remote validators need to run on the server, saving with this property set is asynchronous, even though the data that ultimately gets updated is already present on the client.
		 * Flags: IRWA, Group: databinding */
		useRemoteValidators: boolean;

		/** Enables various styling behaviors that potentially make sense when ListGrid.getRowSpan has been overridden to introduce spanning cells, and spanning is largest on the left and smaller as cells go to the right. Specifically: computes ListGrid.alternateRecordStyles','banded styling based on the span of the cell in the left-most column enables ListGrid.canSelectCells','cell-level selection, including ListGrid.useCellRollOvers','cell-level rollover styling enables row-span-sensitive cell selection. See also RowSpanSelectionMode for available behaviors Because this setting enables ListGrid.canSelectCells, it is incompatible with any APIs that expect a record-oriented data model. Because this setting only makes sense when row spanning decreases from the first column to the last, it has unspecified behavior with ListGrid.canReorderFields.
		 * Flags: IR */
		useRowSpanStyling: boolean;

		/** Whether client-side validation checks should be performed when the user moves between cells in the current edit row. If unset, defaults to ListGrid.editByCell. Note that validation always occurs when a row is to be saved, so setting ListGrid.saveByCell:true forces validation on cell transitions. To completely disable automatic validation, set ListGrid.neverValidate:true.
		 * Flags: IRW, Group: gridValidation */
		validateByCell: boolean;

		/** If true, validation will be performed on each edited cell when each editor's "change" handler is fired.
		 * Flags: IRW, Group: gridValidation */
		validateOnChange: boolean;

		/** Height for value icons for this listGrid. Overrides ListGrid.valueIconSize. Can be overridden at the field level
		 * Flags: IRW, Group: imageColumns */
		valueIconHeight: number;

		/** How much padding should there be on the left of valueIcons by default Can be overridden at the field level
		 * Flags: IRW, Group: imageColumns */
		valueIconLeftPadding: number;

		/** How much padding should there be on the right of valueIcons by default
		 * Flags: IRW, Group: imageColumns */
		valueIconRightPadding: number;

		/** Default width and height of value icons for this ListGrid. Can be overridden at the listGrid level via explicit ListGrid.valueIconWidth and ListGrid.valueIconHeight, or at the field level via ListGridField.valueIconSize, ListGridField.valueIconWidth and {ListGridField.valueIconHeight}
		 * Flags: IRW, Group: imageColumns */
		valueIconSize: number;

		/** Width for value icons for this listGrid. Overrides ListGrid.valueIconSize. Can be overridden at the field level
		 * Flags: IRW, Group: imageColumns */
		valueIconWidth: number;

		/** Initial ListGridViewState','view state for the grid. Since view state contains field state it is not necessary to set ListGrid.fieldState','fieldState when also setting viewState. If both are provided, fieldState has priority for field state. To retrieve current state call ListGrid.getViewState','getViewState. 
		 * Flags: IRW, Group: viewState */
		viewState: string /* String */;

		/** When incremental rendering is switched on and there are variable record heights, the virtual scrolling mechanism manages the differences in scroll height calculations due to the unknown sizes of un-rendered rows to make the scrollbar and viewport appear correctly. When the virtualScrolling system is active, the last scroll position scrolls the last record to the top of the viewport, leaving blank space underneath. This is a necessary and unavoidable consequence of mapping the position of the scrollbar thumb to an unknown amount of remaining space without being able to know the total scrollable area in advance (since record heights vary). virtualScrolling is switched on automatically when ListGrid.fixedRecordHeights is false and also when using the ListGrid.showRecordComponents','recordComponents subsystem, as recordComponents expand the rows that contain them. This flag should be manually enabled when calling ListGrid.addEmbeddedComponent if embedded components can cause record sizes to expand beyond specified cellHeight. virtualScrolling is also automatically enabled when ListGrid.canExpandRecords is true to handle the fact that expanded rows may render at variable heights.
		 * Flags: IRA */
		virtualScrolling: boolean;

		/** If this is an editable listGrid, this property determines whether the user will be able to dismiss the edit form, or navigate to another cell while the save is in process (before the asynchronous server response returns).
		 * Flags: IRWA, Group: editing */
		waitForSave: boolean /* Boolean */;

		/** If ListGrid.canRemoveRecords is true, when the user clicks the remove icon for some record, should we show a warning message (defined as ListGrid.warnOnRemovalMessage) and allow the user to cancel removal?
		 * Flags: IRW */
		warnOnRemoval: boolean /* Boolean */;

		/** Warning message to show the user on a click on the 'remove' icon if ListGrid.canRemoveRecords is true and ListGrid.warnOnRemoval is true.
		 * Flags: IRW, Group: i18nMessages */
		warnOnRemovalMessage: string;

		/** If a field has ListGridField.displayField specified and has no ListGridField.optionDataSource, this field will display the value from the displayField of each record by default (for more on this behavior see ListGridField.optionDataSource). If such a field is editable, changing the edit value for the field on some record, without updating the edit value for the associated display field on the same record would mean the user would continue to see the unchanged display field value. Developers can resolve this situation by programmatically setting an edit value for the display field as well as the data field, or avoid it by specifying an optionDataSource and ensuring ListGrid.autoFetchDisplayMap is true, or setting an explicit valueMap for the field. By default, when the edit value on a field with a specified displayField and no optionDataSource is set, we log a warning to notify the developer. This warning may be disabled by setting warnOnUnmappedValueFieldChange to false. Note: There are actually a couple of cases in which the system will automatically derive a new display-field value and apply it to the record: If the edit value was changed by a user actually editing the record (rather than a programmatic call to setEditValue()), and the edit-item had a valueMap or optionDataSource set, we automatically pick up the display value from that item and store it as an edit-value for the displayField of the record If the listGrid has a loaded record in its data set whose valueField value matches the edit value for the valueField, we automatically apply the displayField value from that record as an edit value for the displayField on the newly edited record. In either case, the display value for the record is updated automatically (and the warning would not be logged).
		 * Flags: IRWA */
		warnOnUnmappedValueFieldChange: boolean /* Boolean */;

		/** Should content within cells be allowed to wrap? Even if content is allowed to wrap, if ListGrid.fixedRecordHeights is set, the content will be clipped off at the cell boundary. Either set a larger, fixed ListGrid.cellHeight to reveal more content, or set ListGrid.fixedRecordHeights to false to allow auto-sizing.
		 * Flags: IRWA */
		wrapCells: boolean /* Boolean */;

		/** If HeaderSpan.wrap is not explicitly set, should fields wrap? If autofitting, see the docs on that property for the details of how the minimum width for a field is determined.
		 * Flags: IR */
		wrapHeaderSpanTitles: boolean /* Boolean */;

		/** If ListGridField.wrap is not explicitly set, should fields wrap? If autofitting, see the docs on that property for the details of how the minimum width for a field is determined.
		 * Flags: IR */
		wrapHeaderTitles: boolean /* Boolean */;


		/* Instance Method Overrides */

		/** 
		 * Called when a cell receives a contextclick event.
		 * @param {ListGridRecord} record - cell record as returned by getCellRecord
		 * @param {number} rowNum - row number for the cell
		 * @param {number} colNum - column number of the cell
		 */
		cellContextClick?(record:ListGridRecord, rowNum:number, colNum:number): boolean; 

		/** 
		 * Clear the current criteria used to filter data.
		 * @param {DSCallback} callback - callback to invoke on completion
		 * @param {DSRequest} requestProperties - additional properties to set on the DSRequest that will be issued
		 */
		clearCriteria?(callback?:DSCallback, requestProperties?:DSRequest): void; 

		/** 
		 * Retrieves data from the DataSource that matches the specified criteria. When fetchData() is first called, if data has not already been provided via ListGrid.setData','setData(), this method will create a ResultSet, which will be configured based on component settings such as DataBoundComponent.fetchOperation and DataBoundComponent.dataPageSize, as well as the general purpose ListGrid.dataProperties. The created ResultSet will automatically send a DSRequest to retrieve data from ListGrid.dataSource','listGrid.dataSource, and from then on will automatically manage paging through large datasets, as well as performing filtering and sorting operations inside the browser when possible - see the ResultSet docs for details. NOTE: do not use both DataBoundComponent.autoFetchData','autoFetchData:true and a call to fetchData() - this may result in two DSRequests to fetch data. Use either DataBoundComponent.autoFetchData','autoFetchData and Criteria or a manual call to fetchData() passing criteria. Whether a ResultSet was automatically created or provided via ListGrid.setData','setData(), subsequent calls to fetchData() will simply call ResultSet.setCriteria. Changes to criteria may or may not result in a DSRequest to the server due to ResultSet.useClientFiltering','client-side filtering. You can call DataBoundComponent.willFetchData','willFetchData(criteria) to determine if new criteria will result in a server fetch. If you need to force data to be re-fetched, you can call ListGrid.invalidateCache','invalidateCache() and new data will automatically be fetched from the server using the current criteria and sort direction. NOTE: when using invalidateCache() there is no need to also call fetchData() and in fact this could produce unexpected results. This method takes an optional callback parameter (set to a DSCallback) to fire when the fetch completes. Note that this callback will not fire if no server fetch is performed. In this case the data is updated synchronously, so as soon as this method completes you can interact with the new data. If necessary, you can use DataBoundComponent.willFetchData','willFetchData() to determine whether or not a server fetch will occur when fetchData() is called with new criteria. In addition to the callback parameter for this method, developers can use ListGrid.dataArrived','dataArrived() to be notified every time data is loaded. By default, this method assumes a TextMatchStyle of "exact"; that can be overridden by supplying a different value in the requestProperties parameter. See DataBoundComponent.willFetchData;
		 * @param {Criteria} criteria - Search criteria. If a DynamicForm is passed in as this argument instead of a raw criteria object, will be derived by calling DynamicForm.getValuesAsCriteria
		 * @param {DSCallback} callback - callback to invoke when a fetch is complete. Fires only if server contact was required
		 * @param {DSRequest} requestProperties - additional properties to set on the DSRequest that will be issued
		 */
		fetchData?(criteria?:Criteria, callback?:DSCallback, requestProperties?:DSRequest): void; 

		/** 
		 * Return CSS text for styling this cell, which will be applied in addition to the CSS class for the cell, as overrides. "CSS text" means semicolon-separated style settings, suitable for inclusion in a CSS stylesheet or in a STYLE attribute of an HTML element. 
		 * @param {ListGridRecord} record - cell record as returned by getCellRecord
		 * @param {number} rowNum - row number for the cell
		 * @param {number} colNum - column number of the cell
		 */
		getCellCSSText?(record:ListGridRecord, rowNum:number, colNum:number): string; 

		/** 
		 * Retrieves a copy of the current criteria for this component (may be null). Note: if ListGrid.showFilterEditor is true, the criteria returned by this method may not match the values currently displayed in the filter editor, since the user may have entered values which have not yet been applied to our data. ListGrid.getFilterEditorCriteria may be used to retrieve the current criteria displayed in the filterEditor.
		 */
		getCriteria?(): Criteria; 

		/** 
		 * Given a column number or field name, return the field definition of a field which is visible in the grid. To retrieve the definition of any field, including hidden ones, use ListGrid.getFieldByName','getFieldByName(). When using DataBoundComponent.fields','DataBinding, the field definition may be a mix of information derived from ListGrid.fields and ListGrid.dataSource.
		 * @param {number} colNum - number or id of the field.
		 */
		getField?(colNum:number | string /* int | ID */): ListGridField; 

		/** 
		 * Given a column number or field id, return the field name of a field.
		 * @param {number} colNum - number or id of the field.
		 */
		getFieldName?(colNum:number | string /* number or id */): string; 

		/** 
		 * Return the pointer to a particular record by record number. Synonym for ListGrid.getCellRecord.
		 * @param {number} recordNum - row index of record to return.
		 */
		getRecord?(recordNum:number): ListGridRecord; 

		/** 
		 * Returns all selected records in this grid. <strong>NOTE:</strong> Records in the returned array should be treated as read-only and not modified.
		 * @param {boolean} excludePartialSelections - When true, partially selected records will not be returned. Otherwise, both fully and partially selected records are returned.
		 */
		getSelectedRecords?(excludePartialSelections?:boolean): Array<ListGridRecord> /* Array of ListGridRecord */; 

		/** 
		 * Returns all selected records in this grid. If this grid is ListGrid.isGrouped','grouped, group header nodes will not be included in the returned array. Developers can make use of ListGrid.getGroupTreeSelection to get the selection including the selected group header nodes. <strong>NOTE:</strong> Records in the returned array should be treated as read-only and not modified.
		 * @param {boolean} excludePartialSelections - When true, partially selected records will not be returned. Otherwise, both fully and partially selected records are returned.
		 */
		getSelection?(excludePartialSelections?:boolean /* Boolean */): Array<ListGridRecord> /* Array of ListGridRecord */; 

		/** 
		 * Returns a snapshot of the current view state of this ListGrid. This includes the field, sort, hilite, group, and selected state of the grid, returned as a string representation of a ListGridViewState object. This string can be passed to ListGrid.setViewState to reset this grid's view state to the current state (assuming the same data / fields are present in the grid).
		 */
		getViewState?(): string /* ListGridViewState */; 

		/** 
		 * Marks the widget as "dirty" so that it will be added to a queue for redraw. Redraw of dirty components is handled by a looping timer and will after a very short delay (typically less than 100ms). In most cases it is recommended that developers use markForRedraw() instead of calling Canvas.redraw directly. Since this method queues the redraw, multiple calls to markForRedraw() within a single thread of execution will only lead to a single DOM manipulation which greatly improves application performance.
		 * @param {string} reason - reason for performing the redraw
		 */
		markForRedraw?(reason?:string): void; 

		/** 
		 * Executed when the listGrid receives a 'click' event on an enabled, non-separator record. The default implementation does nothing -- override to perform some action when any record or field is clicked. A record event handler can be specified either as a function to execute, or as a string of script to evaluate. If the handler is defined as a string of script, all the parameters below will be available as variables for use in the script. To do something specific if a particular field is clicked, add a recordClick method or string of script to that field (same parameters) when you're setting up the list. Notes: This will not be called if the click is below the last item of the list. This method is called from the default implementation of ListGrid.rowClick, so if that method is overridden this method may not be fired.
		 * @param {ListGrid} viewer - the listGrid that contains the click event
		 * @param {ListGridRecord} record - the record that was clicked on
		 * @param {number} recordNum - number of the record clicked on in the current set of displayed records (starts with 0)
		 * @param {ListGridField} field - the field that was clicked on (field definition)
		 * @param {number} fieldNum - number of the field clicked on in the listGrid.fields array
		 * @param {any} value - value of the cell (after valueMap, etc. applied)
		 * @param {any} rawValue - raw value of the cell (before valueMap, etc applied)
		 */
		recordClick?(viewer:ListGrid, record:ListGridRecord, recordNum:number, field:ListGridField, fieldNum:number, value:any, rawValue:any): boolean; 

		/** 
		 * Remove a record from this ListGrid. If this grid is bound to a DataSource, it will perform a DataSource "remove" operation to remove records from this component's DataSource. Otherwise the data will be removed from the grid's ListGrid.data','data object. To make changes to the local data object even when a DataSource is present, use ListGrid.saveLocally.
		 * @param {any} data - listGrid record, or primary key values of record to delete.
		 * @param {DSCallback} callback - method to call on operation completion. Note that if this is method does not trigger a dataSource remove operation, the callback will still be fired when the data has been removed, but the dsResponse parameter will be null.
		 * @param {DSRequestProps} requestProperties - additional properties to set on any DSRequest that will be issued
		 */
		removeData?(data:any /* Record */, callback?:DSCallback, requestProperties?:DSRequestProps /* DSRequest Properties */): void; 

		/** 
		 * Select/deselect a Record passed in explicitly, or by index. Note that this method selects records unconditionally, allowing multiple selected records, even when ListGrid.selectionType is "single". To enforce mutually-exclusive record-selection, use ListGrid.selectSingleRecord.
		 * @param {any} record - record (or row number) to select
		 * @param {boolean} newState - new selection state (if null, defaults to true)
		 */
		selectRecord?(record:any | number /* Record | number */, newState?:boolean): void; 

		/** 
		 * Sets this component's filter criteria. Default implementation calls this.data.setCriteria(). Note: if ListGrid.showFilterEditor is true, the ListGrid.setFilterEditorCriteria method may be used to update the values displayed in the filter editor without effecting the data object.
		 * @param {Criteria} param0 - new criteria to show
		 */
		setCriteria?(param0:Criteria | AdvancedCriteria /* Criteria or AdvancedCriteria */): void; 

		/** 
		 * Setter for the ListGrid.showFilterEditor property. Allows the filter editor to be shown or hidden at runtime.
		 * @param {boolean} value - true if the filter editor should be shown, false if it should be hidden
		 */
		setShowFilterEditor?(value:boolean): void; 

		/** 
		 * Reset this grid's view state to match the ListGridViewState object passed in. Used to restore previous state retrieved from the grid by a call to ListGrid.getViewState.
		 * @param {string} viewState - Object describing the desired view state for the grid
		 */
		setViewState?(viewState:string /* ListGridViewState */): void; 

		/** 
		 * Start editing a new row, after the last pre-existing record in the current set of data. This new row will be saved via the "add" dataSourceOperations','DataSource\n operation. See the editing','Grid Editing overview and also the unsavedRecords','Editing Unsaved Records overview for context about how unsaved records behave. You can optionally pass newValues which are the initial values for the newly added record. See also ListGridField.defaultValue as a means of setting default values every time the user begins editing a new record, for instance, by pressing downArrow on the last normal record in the grid when ListGrid.listEndEditAction is "next". If editing is already underway elsewhere in the grid, startEditingNew() behaves just like ListGrid.startEditing.
		 * @param {any} newValues - Optional initial set of properties for the new record
		 * @param {boolean} suppressFocus - Whether to suppress the default behavior of moving focus to the newly shown editor.
		 */
		startEditingNew?(newValues?:any | any /* Map | Record */, suppressFocus?:boolean /* Boolean */): void; 

		/** 
		 * Perform a DataSource "update" operation to update existing records in this component's DataSource.
		 * @param {any} updatedRecord - updated record
		 * @param {DSCallback} callback - method to call on operation completion
		 * @param {DSRequestProps} requestProperties - additional properties to set on the DSRequest that will be issued
		 */
		updateData?(updatedRecord:any /* Record */, callback?:DSCallback, requestProperties?:DSRequestProps /* DSRequest Properties */): void; 

	} // ListGrid

	export interface ListGridStatic<T, P> extends VLayoutStatic<T, P> {
	} // ListGridStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a Mail Props argument.
	 * This is derived from the methods in the Mail class and it's parents and their properties marked with the I flag.
	 */
	export interface MailProps  {
		/** Comma-separated list of "BCC" recipients. Like all other String properties of Mail, you can use Velocity substitution variables in this property. If you specify a "Bcc:" line in the body of your email, recipient addresses will be parsed and this property will be ignored.
		 * Flags: IR, Group: mail */
		bcc?: string /* String */; // Flags=IR
		/** Comma-separated list of "CC" recipients. Like all other String properties of Mail, you can use Velocity substitution variables in this property. If you specify a "Cc:" line in the body of your email, recipient addresses will be parsed and this property will be ignored.
		 * Flags: IR, Group: mail */
		cc?: string /* String */; // Flags=IR
		/** Used to override the content-type header applied to the email. Primarily used to send HTML emails rather than plain text ones (use "text/html" to do this).
		 * Flags: IR, Group: mail */
		contentType?: string /* String */; // Flags=IR
		/** Used to override the character encoding we apply to the email body. If you do not set this property, it is derived from the server_properties','server.properties setting mail.system.default.encoding, which is set to "UTF-8" by default. This setting should be appropriate for most use cases.
		 * Flags: IR, Group: mail */
		encoding?: string /* String */; // Flags=IR
		/** The email address the message will appear to come from. Like all other String properties of Mail, you can use Velocity substitution variables in this property. If you specify a "From:" line in the body of your email, the from address will be parsed and this property will be ignored. Ordinarily, this property (or the parsed equivalent in the email body) is mandatory for all emails. However, if you specify the property mail.system.mail.smtp.from in server.properties, it will become the default "from" address, and this property becomes optional.
		 * Flags: IR, Group: mail */
		from?: string /* String */; // Flags=IR
		/** Allows you to specify an alternative source of substitution values for the templating process (by default, the data record(s) returned by the DataSource operation are used). If set, this VelocityExpression should evaluate to a Java Map object, or a Java List containing only Maps. For example, assuming you had suitable context stored in a Map that is held in the current session as attribute "foo", the following would cause the mail templating system to look in there for values when running substitution: messageData="$session.foo" 
		 * Flags: IRA, Group: mail */
		messageData?: string /* VelocityExpression */; // Flags=IRA
		/** The text that will form the body of the mail message. Like all other String properties of Mail, you can use Velocity substitution variables in this property. You must specify either this property or Mail.templateFile','templateFile, but clearly it makes no sense to specify them both.
		 * Flags: IR, Group: mail */
		messageTemplate?: string /* String */; // Flags=IR
		/** By default, multiple mail messages are sent if the dsResponse contains multiple records. Set this property to false to prevent this behavior.
		 * Flags: IR, Group: mail */
		multiple?: boolean; // Flags=IR
		/** An email address to indicate as the reply-to address on the message. Like all other String properties of Mail, you can use Velocity substitution variables in this property.
		 * Flags: IR, Group: mail */
		replyTo?: string /* String */; // Flags=IR
		/** The string to appear in the subject line of the message. Like all other String properties of Mail, you can use Velocity substitution variables in this property. If you specify a "Subject:" line in the body of your email, the subject will be parsed and this property will be ignored.
		 * Flags: IR, Group: mail */
		subject?: string /* String */; // Flags=IR
		/** Qualified name of the file containing the message template, relative to webroot. Like all the other String properties of Mail, you can use Velocity substitution variables in this property. The content itself (ie, the contents of the file named in this property) can also contain Velocity substitutions, of course. You must specify either this property or Mail.messageTemplate','messageTemplate, but clearly it makes no sense to specify them both.
		 * Flags: IR, Group: mail */
		templateFile?: string /* URL */; // Flags=IR
		/** Comma-separated list of recipients. Like all other String properties of Mail, you can use Velocity substitution variables in this property. If you specify a "To:" line in the body of your email, recipient addresses will be parsed and this property will be ignored.
		 * Flags: IR, Group: mail */
		to?: string /* String */; // Flags=IR
	} // MailProps


	/**
	 * A Mail object describes an email that will be sent automatically by the SmartClient Server as part of a normal DataSource operation. Mail definitions are part of an OperationBinding, and they can only be specified in a DataSource's XML definition. Despite the declarative nature of mail definitions, templating support via Velocity makes it very flexible; it is very easy to include values from records just fetched from permanent storage by this operation, for example. See velocitySupport for an overview of SmartClient Server's pervasive support for templated declarative operations using Velocity. The default context for the message is the dsResponse.data; that is, $foo in the message refers to the field "foo" in the DataSource response (the equivalent of calling dsResponse.getFieldValue("foo") in Java). You also have access to the normal Velocity variables described in the overview linked to above. If multiple records appear in the dsResponse, one message will be sent per record in the response unless "multiple" is set to false. This allows a set of recipients to be selected by a "fetch" operationBinding and messages sent to each. This also means that if no data is selected by a fetch or affected by an update, no mail is sent. If you have the transactionChaining','Transaction Chaining feature (available in Power and better versions), all of the variables normally accessible in other Velocity contexts are available in the message template as well, for example: $responseData.last('order').orderId You can provide the body of the email directly in the Mail.messageTemplate','messageTemplate tag, or you can provide a filename in the Mail.templateFile','templateFile attribute, which tells SmartClient to use the contents of that file as the body of the email. If you provide neither of these, your email will have no body; if you provide both, SmartClient will ignore the file and just use the content directly provided. Mail server configuration The mail server to use for sending emails is configured in the server_properties','server.properties file. The following values can be provided: mail.system.mail.smtp.host: The name of the SMTP server to use; defaults to "localhost" mail.system.mail.smtp.port: What port is the MTA listening on; defaults to 25 mail.system.mail.smtp.auth: Whether this server requires authentication; defaults to false mail.system.mail.smtp.user: SMTP user, if authentication is on; no default mail.system.mail.smtp.password: Password, if authentication is on; no default Note that we will also pass any other properties that start mail.system through to the underlying Javamail Session object, so you can use Javamail features that aren't explicitly exposed by SmartClient's mail support. For example, many cloud-based SMTP providers require that you issue a STARTTLS command before authenticating; you can achieve this by adding the following line to server_properties','server.properties: mail.system.mail.smtp.starttls.enable: true 
	 */
	export interface Mail  {
		/** Comma-separated list of "BCC" recipients. Like all other String properties of Mail, you can use Velocity substitution variables in this property. If you specify a "Bcc:" line in the body of your email, recipient addresses will be parsed and this property will be ignored.
		 * Flags: IR, Group: mail */
		bcc: string /* String */;

		/** Comma-separated list of "CC" recipients. Like all other String properties of Mail, you can use Velocity substitution variables in this property. If you specify a "Cc:" line in the body of your email, recipient addresses will be parsed and this property will be ignored.
		 * Flags: IR, Group: mail */
		cc: string /* String */;

		/** Used to override the content-type header applied to the email. Primarily used to send HTML emails rather than plain text ones (use "text/html" to do this).
		 * Flags: IR, Group: mail */
		contentType: string /* String */;

		/** Used to override the character encoding we apply to the email body. If you do not set this property, it is derived from the server_properties','server.properties setting mail.system.default.encoding, which is set to "UTF-8" by default. This setting should be appropriate for most use cases.
		 * Flags: IR, Group: mail */
		encoding: string /* String */;

		/** The email address the message will appear to come from. Like all other String properties of Mail, you can use Velocity substitution variables in this property. If you specify a "From:" line in the body of your email, the from address will be parsed and this property will be ignored. Ordinarily, this property (or the parsed equivalent in the email body) is mandatory for all emails. However, if you specify the property mail.system.mail.smtp.from in server.properties, it will become the default "from" address, and this property becomes optional.
		 * Flags: IR, Group: mail */
		from: string /* String */;

		/** Allows you to specify an alternative source of substitution values for the templating process (by default, the data record(s) returned by the DataSource operation are used). If set, this VelocityExpression should evaluate to a Java Map object, or a Java List containing only Maps. For example, assuming you had suitable context stored in a Map that is held in the current session as attribute "foo", the following would cause the mail templating system to look in there for values when running substitution: messageData="$session.foo" 
		 * Flags: IRA, Group: mail */
		messageData: string /* VelocityExpression */;

		/** The text that will form the body of the mail message. Like all other String properties of Mail, you can use Velocity substitution variables in this property. You must specify either this property or Mail.templateFile','templateFile, but clearly it makes no sense to specify them both.
		 * Flags: IR, Group: mail */
		messageTemplate: string /* String */;

		/** By default, multiple mail messages are sent if the dsResponse contains multiple records. Set this property to false to prevent this behavior.
		 * Flags: IR, Group: mail */
		multiple: boolean;

		/** An email address to indicate as the reply-to address on the message. Like all other String properties of Mail, you can use Velocity substitution variables in this property.
		 * Flags: IR, Group: mail */
		replyTo: string /* String */;

		/** The string to appear in the subject line of the message. Like all other String properties of Mail, you can use Velocity substitution variables in this property. If you specify a "Subject:" line in the body of your email, the subject will be parsed and this property will be ignored.
		 * Flags: IR, Group: mail */
		subject: string /* String */;

		/** Qualified name of the file containing the message template, relative to webroot. Like all the other String properties of Mail, you can use Velocity substitution variables in this property. The content itself (ie, the contents of the file named in this property) can also contain Velocity substitutions, of course. You must specify either this property or Mail.messageTemplate','messageTemplate, but clearly it makes no sense to specify them both.
		 * Flags: IR, Group: mail */
		templateFile: string /* URL */;

		/** Comma-separated list of recipients. Like all other String properties of Mail, you can use Velocity substitution variables in this property. If you specify a "To:" line in the body of your email, recipient addresses will be parsed and this property will be ignored.
		 * Flags: IR, Group: mail */
		to: string /* String */;

	} // Mail

	export interface MailStatic<T, P> extends ClassStatic<T, P> {
	} // MailStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a Menu Props argument.
	 * This is derived from the methods in the Menu class and it's parents and their properties marked with the I flag.
	 */
	export interface MenuProps extends ListGridProps {
		/** Explicitly disable alternateRecordStyles at the menu level by default so setting to true for all ListGrids will not impact menus' appearance.
		 * Flags: IRW */
		alternateRecordStyles?: boolean /* Boolean */; // Flags=IRW
		/** When false, when a menu item is chosen (via mouse click or keyboard), the menu is not automatically hidden, staying in place for further interactivity
		 * Flags: IRW */
		autoDismiss?: boolean /* Boolean */; // Flags=IRW
		/** When false, when a user clicks outside the menu, or hits the Escape key, this menu will not be automatically hidden, staying in place for further interactivity.
		 * Flags: IRW */
		autoDismissOnBlur?: boolean /* Boolean */; // Flags=IRW
		/** Menus will not draw on initialization, until they're explicitly show()n
		 * Flags: IRWA */
		autoDraw?: boolean /* Boolean */; // Flags=IRWA
		/** This DataBoundComponent attribute is non-functional in Menus, where fetches are always automatic.
		 * Flags: IR, Group: databinding */
		autoFetchData?: boolean; // Flags=IR
		/** CSS style for a normal cell
		 * Flags: IRW */
		baseStyle?: string /* CSSStyleName */; // Flags=IRW
		/** CSS style used for the body of this menu when there is no icon field. When there is an icon field, then Menu.iconBodyStyleName','iconBodyStyleName, if set, will override this setting. If applying a background-color to the body via a CSS style applied using this property, be sure to set ListGrid.bodyBackgroundColor','bodyBackgroundColor to null.
		 * Flags: IRW, Group: appearance */
		bodyStyleName?: string /* CSSStyleName */; // Flags=IRW
		/** Title for the "Done" button shown when the NavigationBar is present.
		 * Flags: IR, Group: i18nMessages */
		cancelButtonTitle?: string /* HTMLString */; // Flags=IR
		/** If true, clicking or pressing Enter on a menu item that has a submenu will select that item (with standard behavior of hiding the menus, calling click handlers, etc) instead of showing the submenu.
		 * Flags: IRW, Group: selection */
		canSelectParentItems?: boolean; // Flags=IRW
		/** When true any generated submenus will inherit Menu.autoDismiss from this menu.
		 * Flags: IRW */
		cascadeAutoDismiss?: boolean /* Boolean */; // Flags=IRW
		/** The height of each item in the menu, in pixels.
		 * Flags: IRW, Group: sizing */
		cellHeight?: number; // Flags=IRW
		/** Default image to display for disabled checkmarked items. See ImgProperties for format. Valid src, width and height must be specified.
		 * Flags: IR */
		checkmarkDisabledImage?: ImgProperties /* Img Properties */; // Flags=IR
		/** Default image to display for checkmarked items. See ImgProperties for format. Valid src, width and height must be specified.
		 * Flags: IR */
		checkmarkImage?: ImgProperties /* Img Properties */; // Flags=IR
		/** An array of menuItem objects, specifying the menu items this menu should show. Data may also be set to a Tree in which case a hierarchy of menus and submenus will automatically be generated to match the tree structure. See also Menu.dataSource for dynamically fetching menuItems and submenus from a hierarchical DataSource.
		 * Flags: IRW, Group: data */
		data?: Array<any> /* Array of MenuItem | Array[] of Record | Tree | RecordList */; // Flags=IRW
		/** Optional DataSource to fetch menuItems and submenus from, instead of using Menu.items. Data is tree-based in menus, so the provided DataSource should be set up for hierarchical fetching - see the treeDataBinding','Tree Data Binding overview. Note that, although Menu is a subclass of ListGrid, some APIs, like ListGrid.setCriteria','setCriteria and ListGrid.autoFetchData','autoFetchData are not supported in menus. If a dataSource is supplied, it is automatically fetched against as required, without the need for autoFetchData. To apply criteria to the fetches made in this way, see Menu.initialCriteria','initialCriteria. Moreover, fetchData() is also an example of a ListGrid API that doesn't apply to menu, and, as was done for setCriteria() and other APIs like setCriteria().
		 * Flags: IR */
		dataSource?: DataSource; // Flags=IR
		/** The default menu width.
		 * Flags: IRW, Group: sizing */
		defaultWidth?: number /* int */; // Flags=IRW
		/** Message to show when a menu is shown with no items.
		 * Flags: IRWA, Group: i18nMessages */
		emptyMessage?: string /* HTMLString */; // Flags=IRWA
		/** When using a Tree or hierarchical DataSource as the menu's data, submenus are automatically generated from child nodes. fetchSubmenus can be set to false to disable this for the whole menu, or can be set false on a per-item basis via MenuItem.fetchSubmenus.
		 * Flags: IR */
		fetchSubmenus?: boolean /* Boolean */; // Flags=IR
		/** Array of columns to show for this menu. Standard menu fields may be included by specifying MenuFieldID','MenuFieldIDs directly. Additional custom fields may be specified as ListGridField objects. If this property is unset, default behavior will show the MenuFieldID','standard set of fields, with the exception of any that have been suppressed via Menu.showIcons, Menu.showKeys and Menu.showSubmenus
		 * Flags: IRWA */
		fields?: Array<ListGridField> /* Array of MenuFieldID | Array of ListGridField */; // Flags=IRWA
		/** If set, alternative body style for the menu used when there is no icon field and the Menu.placement settings indicate the menu will be filling a portion of the screen or a panel. Generally this alternative style should not have rounded or excessively large edges. If unset, then Menu.bodyStyleName is used instead. When there is an icon field, Menu.iconFillSpaceStyleName, if set, overrides this setting.
		 * Flags: IR, Group: appearance */
		fillSpaceStyleName?: string /* CSSStyleName */; // Flags=IR
		/** If set, the CSS style used for the body of this menu when there <em>is</em> an icon field. In RTL mode, the iconBodyStyleName is suffixed with "RTL", which allows skins to apply different styles in LTR and RTL modes. Note: Any skin which uses iconBodyStyleName should add "RTL" styles as well, even if identical to LTR styles. Otherwise, menus may lose their styling in RTL mode.
		 * Flags: IR, Group: appearance */
		iconBodyStyleName?: string /* CSSStyleName */; // Flags=IR
		/** Default properties for the automatically generated icon column. Default object includes properties to set width and to show icon for this column. To modify the behavior or appearance of this column, developers may set Menu.iconFieldProperties at the instance level, or override this object at the class level. If overriding this object, we recommend using Class.changeDefaults rather than replacing this object entirely. See Menu.showIcons for an overview of the icon column.
		 * Flags: IR */
		iconFieldDefaults?: ListGridField /* ListGridField properties */; // Flags=IR
		/** Custom properties for the automatically generated icon column. See Menu.showIcons for an overview of the icon column.
		 * Flags: IR */
		iconFieldProperties?: ListGridField /* ListGridField properties */; // Flags=IR
		/** If set, alternative body style for the menu used when there is an icon field and the Menu.placement settings indicate the menu will be filling a portion of the screen or a panel. Generally this alternative style should not have rounded or excessively large edges. In RTL mode, the iconFillSpaceStyleName is suffixed with "RTL", which allows skins to apply different styles in LTR and RTL modes. If unset, then Menu.iconBodyStyleName is used instead. Note: Like iconBodyStyleName, any skin which uses iconFillSpaceStyleName should add "RTL" styles as well, even if identical to LTR styles. Otherwise, menus may lose their styling in RTL mode.
		 * Flags: IR, Group: appearance */
		iconFillSpaceStyleName?: string /* CSSStyleName */; // Flags=IR
		/** The default height applied to custom icons in this menu. This is used whenever item.iconHeight is not specified.
		 * Flags: IRW */
		iconHeight?: number; // Flags=IRW
		/** The default width applied to custom icons in this menu. This is used whenever item.iconWidth is not specified.
		 * Flags: IRW */
		iconWidth?: number; // Flags=IRW
		/** Criteria to be used when fetching items for this Menu. Note that ListGrid.setCriteria','setCriteria is not supported in Menus.
		 * Flags: IR, Group: databinding */
		initialCriteria?: Criteria; // Flags=IR
		/** Synonym for Menu.data
		 * Flags: IRW, Group: data */
		items?: Array<MenuItem> /* Array of MenuItem */; // Flags=IRW
		/** Default properties for the automatically generated key column. Default object includes properties to set width and to show key for this column. To modify the behavior or appearance of this column, developers may set Menu.keyFieldProperties at the instance level, or override this object at the class level. If overriding this object, we recommend using Class.changeDefaults rather than replacing this object entirely. See Menu.showKeys for an overview of the key column.
		 * Flags: IR */
		keyFieldDefaults?: ListGridField /* ListGridField properties */; // Flags=IR
		/** Custom properties for the automatically generated key column. See Menu.showKeys for an overview of the key column.
		 * Flags: IR */
		keyFieldProperties?: ListGridField /* ListGridField properties */; // Flags=IR
		/** For a menu that has a MenuButton generated for it automatically (for example when included in a MenuBar, the width that the MenuButton should have. If unset, the MenuButton will be as wide as menu.width.
		 * Flags: IR */
		menuButtonWidth?: number /* int */; // Flags=IR
		/** Navigation bar shown when Menu.placement setting indicates that the menu should be shown filling a portion of the screen or a panel.
		 * Flags: IR */
		navigationBar?:  NavigationBar /* AutoChild NavigationBar */; // Flags=IR
		/** When the Menu.placement setting indicates that the menu should be shown filling a portion of the screen or a panel, navStack is a container element created to hold the NavigationBar and any submenus that are shown by the menu.
		 * Flags: IR */
		navStack?:  Canvas /* AutoChild Canvas */; // Flags=IR
		/** Where should the menu be placed on the screen? Default is to use PanelPlacement "fillScreen" if Browser.isHandset. In any non-handset device, placement is unset, so the menu defaults to normal placement (near the originating MenuButton, or the mouse for a context menu, or according to left/top/width/height for a manually created Menu). When using any placement setting that fills a portion of the screen or a panel, submenus are displayed by sliding them into place on top of the currently active menu, and a NavigationBar','menu.navigationBar is used to manage navigation to the main menu (and provide dismissal, via a Menu.cancelButtonTitle','cancel button.
		 * Flags: IR */
		placement?: PanelPlacement; // Flags=IR
		/** When this menu is shown how should it animate into view? By default the menu will just show at the specified size/position. Options for animated show effects are "fade" to fade from transparent to visible, "slide" to slide the menu into view, or "wipe" to have the menu grow into view, revealing its content as it grows. Can be overridden by passing the 'animationEffect' parameter to 'menu.show()'
		 * Flags: IRWA */
		showAnimationEffect?: string; // Flags=IRWA
		/** showEdges dynamically defaults to false when the Menu.placement setting indicates the Menu will be filling a portion of the screen or a panel.
		 * Flags: IR */
		showEdges?: boolean /* Boolean */; // Flags=IR
		/** A boolean, indicating whether the checkmark/custom icon column should be displayed.
		 * Flags: IRW */
		showIcons?: boolean /* Boolean */; // Flags=IRW
		/** A boolean, indicating whether the shortcut key column should be displayed. If showKeys is not set, the menu will show the key column only if one of its items specifies a keys property. If showKeys is false, the keys will not be displayed, but will still function.
		 * Flags: IRW */
		showKeys?: boolean /* Boolean */; // Flags=IRW
		/** Whether to show a drop shadow for this Canvas. Developers should be aware that the drop shadow is drawn outside the specified width and height of the widget meaning a widget with shadows takes up a little more space than it otherwise would. A full screen canvas with showShadow set to true as this would be likely to cause browser scrollbars to appear - developers can handle this by either setting this property to false on full-screen widgets, or by setting overflow to "hidden" on the &lt;body&gt; element browser-level scrolling is never intended to occur. showShadow dynamically defaults to false when the Menu.placement setting indicates the Menu will be filling a portion of the screen or a panel.
		 * Flags: IR */
		showShadow?: boolean /* Boolean */; // Flags=IR
		/** A boolean, indicating whether the submenu indicator column should be displayed. If showSubmenus is not set, the menu will show the indicator column only if one of its items specifies a submenu property. If showSubmenus is false, the submenu arrows will not be displayed, but submenus will still appear on rollover.
		 * Flags: IRW */
		showSubmenus?: boolean /* Boolean */; // Flags=IRW
		/** When using a Tree or hierarchical DataSource as the menu's data, optional subclass of Menu that should be used when generating submenus.
		 * Flags: IR */
		submenuConstructor?: string /* SCClassName */; // Flags=IR
		/** Should submenus show up on our left or right. Can validly be set to "left" or "right". If unset, submenus show up on the right by default in Left-to-right text mode, or on the left in Right-to-left text mode (see Page.isRTL).
		 * Flags: IRW */
		submenuDirection?: string; // Flags=IRW
		/** Default image to use for the submenu indicator when item is disabled. Valid src, width and height must be specified. See ImgProperties for format. If Menu.submenuDirection is set to "left", the image src will have the suffix "_left" appended to it.
		 * Flags: IR */
		submenuDisabledImage?: ImgProperties /* Img Properties */; // Flags=IR
		/** Default properties for the automatically generated submenu column. Default object includes properties to set width, align and to show submenu icon for this column. To modify the behavior or appearance of this column, developers may set Menu.submenuFieldProperties at the instance level, or override this object at the class level. If overriding this object, we recommend using Class.changeDefaults rather than replacing this object entirely. See Menu.showSubmenus for an overview of the submenu column.
		 * Flags: IR */
		submenuFieldDefaults?: ListGridField /* ListGridField properties */; // Flags=IR
		/** Custom properties for the automatically generated submenu column. See Menu.showSubmenus for an overview of the submenu column.
		 * Flags: IR */
		submenuFieldProperties?: ListGridField /* ListGridField properties */; // Flags=IR
		/** Default image to use for the submenu indicator. Valid src, width and height must be specified. See ImgProperties for format. If Menu.submenuDirection is set to "left", the image src will have the suffix "_left" appended to it.
		 * Flags: IR */
		submenuImage?: ImgProperties /* Img Properties */; // Flags=IR
		/** Optional target canvas for this menu. Available as a parameter to dynamic menuItem configuration methods such as MenuItem.checkIf. Whenever a Menu is shown as a contextMenu by a widget due to Canvas.contextMenu being set, menu.target is automatically set to the widget that showed the contextMenu. If this item has any MenuItem.submenu','submenus the target will be propagated down to these child menus.
		 * Flags: IRW */
		target?: Canvas; // Flags=IRW
		/** Default properties for the automatically generated title column. Default object includes properties to set width and to show title for this column. To modify the behavior or appearance of this column, developers may set Menu.titleFieldProperties at the instance level, or override this object at the class level. If overriding this object, we recommend using Class.changeDefaults rather than replacing this object entirely.
		 * Flags: IR */
		titleFieldDefaults?: ListGridField /* ListGridField properties */; // Flags=IR
		/** Custom properties for the automatically generated title column.
		 * Flags: IR */
		titleFieldProperties?: ListGridField /* ListGridField properties */; // Flags=IR
		/** A boolean indicating whether this menu should use shortcut keys. Set useKeys to false in a menu's initialization block to explicitly disable shortcut keys.
		 * Flags: IRW */
		useKeys?: boolean /* Boolean */; // Flags=IRW

		/* Method Overrides */

		/** 
		 * This DataBoundComponent method does not apply to Menu.
		 * @param {Criteria} criteria - Search criteria. If a DynamicForm is passed in as this argument instead of a raw criteria object, will be derived by calling DynamicForm.getValuesAsCriteria
		 * @param {DSCallback} callback - callback to invoke when a fetch is complete. Fires only if server contact was required
		 * @param {DSRequest} requestProperties - additional properties to set on the DSRequest that will be issued
		 */
		fetchData?(criteria?:Criteria, callback?:DSCallback, requestProperties?:DSRequest): void; 

		/** 
		 * Get a particular MenuItem by index. If passed a MenuItem, returns it.
		 * @param {number} item - index of the MenuItem
		 */
		getItem?(item:number /* int */): MenuItem; 

		/** 
		 * This DataBoundComponent method is not supported - use Menu.initialCriteria','initialCriteria to apply criteria to the fetches made by menus.
		 * @param {Criteria} criteria - new criteria to show
		 */
		setCriteria?(criteria:Criteria | AdvancedCriteria /* Criteria or AdvancedCriteria */): void; 

	} // MenuProps


	/**
	 * The Menu widget class implements interactive menu widgets, with optional icons, submenus, and shortcut keys. A Menu is initialized with a set of MenuItems specified as Menu.items, each of which represents one row in the menu's display and specifies the action to take when that menu item is selected. Each MenuItem can have a MenuItem.title','title, MenuItem.icon','icon, MenuItem.keys','shortcut keys, optional MenuItem.submenu and various other settings. Alternatively, a MenuItem can contain an arbitrary widget via MenuItem.embeddedComponent. To create a context menu for a component, provide a Menu instance for the Canvas.contextMenu property. Note that some components like ListGrid have more specific properties because they have distinct regions or because they have a default set of context menu actions available (for example: ListGrid.headerContextMenu and related APIs). If you want a button that pops up a menu when clicked, or a bar of such buttons, see the MenuButton and MenuBar classes. To create a pop-up panel interface that looks nothing like a Menu (but still dismisses automatically on an outside click), use Canvas.showClickMask to arrange for automatic dismissal, and the Canvas.showNextTo utility method to place the component near whatever triggered it, while automatically staying on-screen. 
	 */
	export interface Menu extends ListGrid {
		/** Explicitly disable alternateRecordStyles at the menu level by default so setting to true for all ListGrids will not impact menus' appearance.
		 * Flags: IRW */
		alternateRecordStyles: boolean /* Boolean */;

		/** When false, when a menu item is chosen (via mouse click or keyboard), the menu is not automatically hidden, staying in place for further interactivity
		 * Flags: IRW */
		autoDismiss: boolean /* Boolean */;

		/** When false, when a user clicks outside the menu, or hits the Escape key, this menu will not be automatically hidden, staying in place for further interactivity.
		 * Flags: IRW */
		autoDismissOnBlur: boolean /* Boolean */;

		/** Menus will not draw on initialization, until they're explicitly show()n
		 * Flags: IRWA */
		autoDraw: boolean /* Boolean */;

		/** This DataBoundComponent attribute is non-functional in Menus, where fetches are always automatic.
		 * Flags: IR, Group: databinding */
		autoFetchData: boolean;

		/** CSS style for a normal cell
		 * Flags: IRW */
		baseStyle: string /* CSSStyleName */;

		/** CSS style used for the body of this menu when there is no icon field. When there is an icon field, then Menu.iconBodyStyleName','iconBodyStyleName, if set, will override this setting. If applying a background-color to the body via a CSS style applied using this property, be sure to set ListGrid.bodyBackgroundColor','bodyBackgroundColor to null.
		 * Flags: IRW, Group: appearance */
		bodyStyleName: string /* CSSStyleName */;

		/** Title for the "Done" button shown when the NavigationBar is present.
		 * Flags: IR, Group: i18nMessages */
		cancelButtonTitle: string /* HTMLString */;

		/** If true, clicking or pressing Enter on a menu item that has a submenu will select that item (with standard behavior of hiding the menus, calling click handlers, etc) instead of showing the submenu.
		 * Flags: IRW, Group: selection */
		canSelectParentItems: boolean;

		/** When true any generated submenus will inherit Menu.autoDismiss from this menu.
		 * Flags: IRW */
		cascadeAutoDismiss: boolean /* Boolean */;

		/** The height of each item in the menu, in pixels.
		 * Flags: IRW, Group: sizing */
		cellHeight: number;

		/** Default image to display for disabled checkmarked items. See ImgProperties for format. Valid src, width and height must be specified.
		 * Flags: IR */
		checkmarkDisabledImage: ImgProperties /* Img Properties */;

		/** Default image to display for checkmarked items. See ImgProperties for format. Valid src, width and height must be specified.
		 * Flags: IR */
		checkmarkImage: ImgProperties /* Img Properties */;

		/** An array of menuItem objects, specifying the menu items this menu should show. Data may also be set to a Tree in which case a hierarchy of menus and submenus will automatically be generated to match the tree structure. See also Menu.dataSource for dynamically fetching menuItems and submenus from a hierarchical DataSource.
		 * Flags: IRW, Group: data */
		data: Array<any> /* Array of MenuItem | Array[] of Record | Tree | RecordList */;

		/** Optional DataSource to fetch menuItems and submenus from, instead of using Menu.items. Data is tree-based in menus, so the provided DataSource should be set up for hierarchical fetching - see the treeDataBinding','Tree Data Binding overview. Note that, although Menu is a subclass of ListGrid, some APIs, like ListGrid.setCriteria','setCriteria and ListGrid.autoFetchData','autoFetchData are not supported in menus. If a dataSource is supplied, it is automatically fetched against as required, without the need for autoFetchData. To apply criteria to the fetches made in this way, see Menu.initialCriteria','initialCriteria. Moreover, fetchData() is also an example of a ListGrid API that doesn't apply to menu, and, as was done for setCriteria() and other APIs like setCriteria().
		 * Flags: IR */
		dataSource: DataSource;

		/** The default menu width.
		 * Flags: IRW, Group: sizing */
		defaultWidth: number /* int */;

		/** Message to show when a menu is shown with no items.
		 * Flags: IRWA, Group: i18nMessages */
		emptyMessage: string /* HTMLString */;

		/** When using a Tree or hierarchical DataSource as the menu's data, submenus are automatically generated from child nodes. fetchSubmenus can be set to false to disable this for the whole menu, or can be set false on a per-item basis via MenuItem.fetchSubmenus.
		 * Flags: IR */
		fetchSubmenus: boolean /* Boolean */;

		/** Array of columns to show for this menu. Standard menu fields may be included by specifying MenuFieldID','MenuFieldIDs directly. Additional custom fields may be specified as ListGridField objects. If this property is unset, default behavior will show the MenuFieldID','standard set of fields, with the exception of any that have been suppressed via Menu.showIcons, Menu.showKeys and Menu.showSubmenus
		 * Flags: IRWA */
		fields: Array<ListGridField> /* Array of MenuFieldID | Array of ListGridField */;

		/** If set, alternative body style for the menu used when there is no icon field and the Menu.placement settings indicate the menu will be filling a portion of the screen or a panel. Generally this alternative style should not have rounded or excessively large edges. If unset, then Menu.bodyStyleName is used instead. When there is an icon field, Menu.iconFillSpaceStyleName, if set, overrides this setting.
		 * Flags: IR, Group: appearance */
		fillSpaceStyleName: string /* CSSStyleName */;

		/** If set, the CSS style used for the body of this menu when there <em>is</em> an icon field. In RTL mode, the iconBodyStyleName is suffixed with "RTL", which allows skins to apply different styles in LTR and RTL modes. Note: Any skin which uses iconBodyStyleName should add "RTL" styles as well, even if identical to LTR styles. Otherwise, menus may lose their styling in RTL mode.
		 * Flags: IR, Group: appearance */
		iconBodyStyleName: string /* CSSStyleName */;

		/** Default properties for the automatically generated icon column. Default object includes properties to set width and to show icon for this column. To modify the behavior or appearance of this column, developers may set Menu.iconFieldProperties at the instance level, or override this object at the class level. If overriding this object, we recommend using Class.changeDefaults rather than replacing this object entirely. See Menu.showIcons for an overview of the icon column.
		 * Flags: IR */
		iconFieldDefaults: ListGridField /* ListGridField properties */;

		/** Custom properties for the automatically generated icon column. See Menu.showIcons for an overview of the icon column.
		 * Flags: IR */
		iconFieldProperties: ListGridField /* ListGridField properties */;

		/** If set, alternative body style for the menu used when there is an icon field and the Menu.placement settings indicate the menu will be filling a portion of the screen or a panel. Generally this alternative style should not have rounded or excessively large edges. In RTL mode, the iconFillSpaceStyleName is suffixed with "RTL", which allows skins to apply different styles in LTR and RTL modes. If unset, then Menu.iconBodyStyleName is used instead. Note: Like iconBodyStyleName, any skin which uses iconFillSpaceStyleName should add "RTL" styles as well, even if identical to LTR styles. Otherwise, menus may lose their styling in RTL mode.
		 * Flags: IR, Group: appearance */
		iconFillSpaceStyleName: string /* CSSStyleName */;

		/** The default height applied to custom icons in this menu. This is used whenever item.iconHeight is not specified.
		 * Flags: IRW */
		iconHeight: number;

		/** The default width applied to custom icons in this menu. This is used whenever item.iconWidth is not specified.
		 * Flags: IRW */
		iconWidth: number;

		/** Criteria to be used when fetching items for this Menu. Note that ListGrid.setCriteria','setCriteria is not supported in Menus.
		 * Flags: IR, Group: databinding */
		initialCriteria: Criteria;

		/** Synonym for Menu.data
		 * Flags: IRW, Group: data */
		items: Array<MenuItem> /* Array of MenuItem */;

		/** Default properties for the automatically generated key column. Default object includes properties to set width and to show key for this column. To modify the behavior or appearance of this column, developers may set Menu.keyFieldProperties at the instance level, or override this object at the class level. If overriding this object, we recommend using Class.changeDefaults rather than replacing this object entirely. See Menu.showKeys for an overview of the key column.
		 * Flags: IR */
		keyFieldDefaults: ListGridField /* ListGridField properties */;

		/** Custom properties for the automatically generated key column. See Menu.showKeys for an overview of the key column.
		 * Flags: IR */
		keyFieldProperties: ListGridField /* ListGridField properties */;

		/** For a menu that has a MenuButton generated for it automatically (for example when included in a MenuBar, the width that the MenuButton should have. If unset, the MenuButton will be as wide as menu.width.
		 * Flags: IR */
		menuButtonWidth: number /* int */;

		/** Navigation bar shown when Menu.placement setting indicates that the menu should be shown filling a portion of the screen or a panel.
		 * Flags: IR */
		navigationBar:  NavigationBar /* AutoChild NavigationBar */;

		/** When the Menu.placement setting indicates that the menu should be shown filling a portion of the screen or a panel, navStack is a container element created to hold the NavigationBar and any submenus that are shown by the menu.
		 * Flags: IR */
		navStack:  Canvas /* AutoChild Canvas */;

		/** Where should the menu be placed on the screen? Default is to use PanelPlacement "fillScreen" if Browser.isHandset. In any non-handset device, placement is unset, so the menu defaults to normal placement (near the originating MenuButton, or the mouse for a context menu, or according to left/top/width/height for a manually created Menu). When using any placement setting that fills a portion of the screen or a panel, submenus are displayed by sliding them into place on top of the currently active menu, and a NavigationBar','menu.navigationBar is used to manage navigation to the main menu (and provide dismissal, via a Menu.cancelButtonTitle','cancel button.
		 * Flags: IR */
		placement: PanelPlacement;

		/** When this menu is shown how should it animate into view? By default the menu will just show at the specified size/position. Options for animated show effects are "fade" to fade from transparent to visible, "slide" to slide the menu into view, or "wipe" to have the menu grow into view, revealing its content as it grows. Can be overridden by passing the 'animationEffect' parameter to 'menu.show()'
		 * Flags: IRWA */
		showAnimationEffect: string;

		/** showEdges dynamically defaults to false when the Menu.placement setting indicates the Menu will be filling a portion of the screen or a panel.
		 * Flags: IR */
		showEdges: boolean /* Boolean */;

		/** A boolean, indicating whether the checkmark/custom icon column should be displayed.
		 * Flags: IRW */
		showIcons: boolean /* Boolean */;

		/** A boolean, indicating whether the shortcut key column should be displayed. If showKeys is not set, the menu will show the key column only if one of its items specifies a keys property. If showKeys is false, the keys will not be displayed, but will still function.
		 * Flags: IRW */
		showKeys: boolean /* Boolean */;

		/** Whether to show a drop shadow for this Canvas. Developers should be aware that the drop shadow is drawn outside the specified width and height of the widget meaning a widget with shadows takes up a little more space than it otherwise would. A full screen canvas with showShadow set to true as this would be likely to cause browser scrollbars to appear - developers can handle this by either setting this property to false on full-screen widgets, or by setting overflow to "hidden" on the &lt;body&gt; element browser-level scrolling is never intended to occur. showShadow dynamically defaults to false when the Menu.placement setting indicates the Menu will be filling a portion of the screen or a panel.
		 * Flags: IR */
		showShadow: boolean /* Boolean */;

		/** A boolean, indicating whether the submenu indicator column should be displayed. If showSubmenus is not set, the menu will show the indicator column only if one of its items specifies a submenu property. If showSubmenus is false, the submenu arrows will not be displayed, but submenus will still appear on rollover.
		 * Flags: IRW */
		showSubmenus: boolean /* Boolean */;

		/** When using a Tree or hierarchical DataSource as the menu's data, optional subclass of Menu that should be used when generating submenus.
		 * Flags: IR */
		submenuConstructor: string /* SCClassName */;

		/** Should submenus show up on our left or right. Can validly be set to "left" or "right". If unset, submenus show up on the right by default in Left-to-right text mode, or on the left in Right-to-left text mode (see Page.isRTL).
		 * Flags: IRW */
		submenuDirection: string;

		/** Default image to use for the submenu indicator when item is disabled. Valid src, width and height must be specified. See ImgProperties for format. If Menu.submenuDirection is set to "left", the image src will have the suffix "_left" appended to it.
		 * Flags: IR */
		submenuDisabledImage: ImgProperties /* Img Properties */;

		/** Default properties for the automatically generated submenu column. Default object includes properties to set width, align and to show submenu icon for this column. To modify the behavior or appearance of this column, developers may set Menu.submenuFieldProperties at the instance level, or override this object at the class level. If overriding this object, we recommend using Class.changeDefaults rather than replacing this object entirely. See Menu.showSubmenus for an overview of the submenu column.
		 * Flags: IR */
		submenuFieldDefaults: ListGridField /* ListGridField properties */;

		/** Custom properties for the automatically generated submenu column. See Menu.showSubmenus for an overview of the submenu column.
		 * Flags: IR */
		submenuFieldProperties: ListGridField /* ListGridField properties */;

		/** Default image to use for the submenu indicator. Valid src, width and height must be specified. See ImgProperties for format. If Menu.submenuDirection is set to "left", the image src will have the suffix "_left" appended to it.
		 * Flags: IR */
		submenuImage: ImgProperties /* Img Properties */;

		/** Optional target canvas for this menu. Available as a parameter to dynamic menuItem configuration methods such as MenuItem.checkIf. Whenever a Menu is shown as a contextMenu by a widget due to Canvas.contextMenu being set, menu.target is automatically set to the widget that showed the contextMenu. If this item has any MenuItem.submenu','submenus the target will be propagated down to these child menus.
		 * Flags: IRW */
		target: Canvas;

		/** Default properties for the automatically generated title column. Default object includes properties to set width and to show title for this column. To modify the behavior or appearance of this column, developers may set Menu.titleFieldProperties at the instance level, or override this object at the class level. If overriding this object, we recommend using Class.changeDefaults rather than replacing this object entirely.
		 * Flags: IR */
		titleFieldDefaults: ListGridField /* ListGridField properties */;

		/** Custom properties for the automatically generated title column.
		 * Flags: IR */
		titleFieldProperties: ListGridField /* ListGridField properties */;

		/** A boolean indicating whether this menu should use shortcut keys. Set useKeys to false in a menu's initialization block to explicitly disable shortcut keys.
		 * Flags: IRW */
		useKeys: boolean /* Boolean */;


		/* Instance Method Overrides */

		/** 
		 * This DataBoundComponent method does not apply to Menu.
		 * @param {Criteria} criteria - Search criteria. If a DynamicForm is passed in as this argument instead of a raw criteria object, will be derived by calling DynamicForm.getValuesAsCriteria
		 * @param {DSCallback} callback - callback to invoke when a fetch is complete. Fires only if server contact was required
		 * @param {DSRequest} requestProperties - additional properties to set on the DSRequest that will be issued
		 */
		fetchData?(criteria?:Criteria, callback?:DSCallback, requestProperties?:DSRequest): void; 

		/** 
		 * Get a particular MenuItem by index. If passed a MenuItem, returns it.
		 * @param {number} item - index of the MenuItem
		 */
		getItem?(item:number /* int */): MenuItem; 

		/** 
		 * This DataBoundComponent method is not supported - use Menu.initialCriteria','initialCriteria to apply criteria to the fetches made by menus.
		 * @param {Criteria} criteria - new criteria to show
		 */
		setCriteria?(criteria:Criteria | AdvancedCriteria /* Criteria or AdvancedCriteria */): void; 

	} // Menu

	export interface MenuStatic<T, P> extends ListGridStatic<T, P> {

	/* Methods */

	} // MenuStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a MiniNavControl Props argument.
	 * This is derived from the methods in the MiniNavControl class and it's parents and their properties marked with the I flag.
	 */
	export interface MiniNavControlProps extends StretchImgButtonProps {
		/** Image used for the down arrowhead.
		 * Flags: IR */
		downButtonSrc?: string /* SCImgURL */; // Flags=IR
		skinImgDir?: string /* URL */; // Flags=IR
		/** Image used for the up arrowhead.
		 * Flags: IR */
		upButtonSrc?: string /* SCImgURL */; // Flags=IR

		/* Method Overrides */

	} // MiniNavControlProps


	/**
	 * Compact control for up/down navigation that roughly looks like an up arrowhead next to a down arrowhead. 
	 */
	export interface MiniNavControl extends StretchImgButton {
		/** Image used for the down arrowhead.
		 * Flags: IR */
		downButtonSrc: string /* SCImgURL */;

		skinImgDir: string /* URL */;

		/** Image used for the up arrowhead.
		 * Flags: IR */
		upButtonSrc: string /* SCImgURL */;


		/* Instance Method Overrides */

	} // MiniNavControl

	export interface MiniNavControlStatic<T, P> extends StretchImgButtonStatic<T, P> {
	} // MiniNavControlStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a MultiSortDialog Props argument.
	 * This is derived from the methods in the MultiSortDialog class and it's parents and their properties marked with the I flag.
	 */
	export interface MultiSortDialogProps  {
		/** The title-text to appear on the addLevelButton. Note, this is a passthrough property which, when set, is passed through to the MultiSortPanel','MultiSortPanel contained in this dialog. You only need to consider the properties on the MultiSortPanel for i18n.
		 * Flags: IR, Group: i18nMessages */
		addLevelButtonTitle?: string /* String */; // Flags=IR
		/** The title-text to appear on the applyButton
		 * Flags: IR, Group: i18nMessages */
		applyButtonTitle?: string /* String */; // Flags=IR
		/** The title-text to appear in the "direction" field's SelectItem for an "ascending" sort Note, this is a passthrough property which, when set, is passed through to the MultiSortPanel','MultiSortPanel contained in this dialog. You only need to consider the properties on the MultiSortPanel for i18n.
		 * Flags: IR, Group: i18nMessages */
		ascendingTitle?: string /* String */; // Flags=IR
		/** The title-text to appear on the cancelButton
		 * Flags: IR, Group: i18nMessages */
		cancelButtonTitle?: string /* String */; // Flags=IR
		/** The title-text to appear on the copyLevelButton Note, this is a passthrough property which, when set, is passed through to the MultiSortPanel','MultiSortPanel contained in this dialog. You only need to consider the properties on the MultiSortPanel for i18n.
		 * Flags: IR, Group: i18nMessages */
		copyLevelButtonTitle?: string /* String */; // Flags=IR
		/** The title-text to appear on the deleteLevelButton Note, this is a passthrough property which, when set, is passed through to the MultiSortPanel','MultiSortPanel contained in this dialog. You only need to consider the properties on the MultiSortPanel for i18n.
		 * Flags: IR, Group: i18nMessages */
		deleteLevelButtonTitle?: string /* String */; // Flags=IR
		/** The title-text to appear in the "direction" field's SelectItem for a "descending" sort Note, this is a passthrough property which, when set, is passed through to the MultiSortPanel','MultiSortPanel contained in this dialog. You only need to consider the properties on the MultiSortPanel for i18n.
		 * Flags: IR, Group: i18nMessages */
		descendingTitle?: string /* String */; // Flags=IR
		/** The title-text to appear in the header of the "direction" field. Note, this is a passthrough property which, when set, is passed through to the MultiSortPanel','MultiSortPanel contained in this dialog. You only need to consider the properties on the MultiSortPanel for i18n.
		 * Flags: IR, Group: i18nMessages */
		directionFieldTitle?: string /* String */; // Flags=IR
		/** The list of fields which the user can choose to sort by.
		 * Flags: IR */
		fields?: Array<DataSourceField> /* Array of DataSourceField */; // Flags=IR
		/** The title-text to appear in the first column for the first sort-level. Note, this is a passthrough property which, when set, is passed through to the MultiSortPanel','MultiSortPanel contained in this dialog. You only need to consider the properties on the MultiSortPanel for i18n.
		 * Flags: IR, Group: i18nMessages */
		firstSortLevelTitle?: string /* String */; // Flags=IR
		/** The initial sort configuration to show in the MultiSortPanel.optionsGrid','optionsGrid. Note, this is a passthrough property which, when set, is passed through to the MultiSortPanel','MultiSortPanel contained in this dialog.
		 * Flags: IR */
		initialSort?: Array<SortSpecifier> /* Array of SortSpecifier */; // Flags=IR
		/** This is a dynamic string - text within &#36;{...} will be evaluated as JS code when the message is displayed. Default value returns Columns may only be used once: [some field's title] is used multiple times Note, this is a passthrough property which, when set, is passed through to the MultiSortPanel','MultiSortPanel contained in this dialog. You only need to consider the properties on the MultiSortPanel for i18n.
		 * Flags: IR, Group: i18nMessages */
		invalidListPrompt?: string /* HTMLString */; // Flags=IR
		/** The hover-prompt for the Level Down button.
		 * Flags: IR, Group: i18nMessages */
		levelDownButtonTitle?: string /* String */; // Flags=IR
		/** The hover-prompt for the Level Up button.
		 * Flags: IR, Group: i18nMessages */
		levelUpButtonTitle?: string /* String */; // Flags=IR
		/** The maximum number of levels of sorting that can be applied. Since each sort-property or field-name can be used only once in a given multi-sort operation, if no maxLevels value or a value larger than the total number of available properties is specified, it will default to the total number of available properties. Note, this is a passthrough property which, when set, is passed through to the MultiSortPanel','MultiSortPanel contained in this dialog.
		 * Flags: IR */
		maxLevels?: number; // Flags=IR
		/** Automatically generated ListGrid allowing the user to configure a set of SortSpecifiers. This component is an AutoChild and as such may be customized via multiSortPanel.optionsGridProperties and multiSortPanel.optionsGridDefaults.
		 * Flags: IR */
		optionsGrid?:  ListGrid /* AutoChild ListGrid */; // Flags=IR
		/** The title-text to appear in the first column for all sort-levels other than the first. Note, this is a passthrough property which, when set, is passed through to the MultiSortPanel','MultiSortPanel contained in this dialog. You only need to consider the properties on the MultiSortPanel for i18n.
		 * Flags: IR, Group: i18nMessages */
		otherSortLevelTitle?: string /* String */; // Flags=IR
		/** The title-text to appear in the header of the "property" field. Note, this is a passthrough property which, when set, is passed through to the MultiSortPanel','MultiSortPanel contained in this dialog. You only need to consider the properties on the MultiSortPanel for i18n.
		 * Flags: IR, Group: i18nMessages */
		propertyFieldTitle?: string /* String */; // Flags=IR
		/** The title-text to appear in this Dialog's Header-bar.
		 * Flags: IR, Group: i18nMessages */
		title?: string /* String */; // Flags=IR

		/* Method Overrides */

	} // MultiSortDialogProps


	/**
	 * A dialog that allows the user to set up complex sorting arrangements by defining a group of SortSpecifiers. Each SortSpecifier applies to a single property and direction - so, for instance, in a grid with two columns, year and monthNumber, you could sort first by year in descending order and then by monthNumber in ascending order. This would producing a grid sorted by year from largest (most recent) to smallest (least recent) and, within each year, by monthNumber from smallest (January) to largest (December). See MultiSortDialog.askForSort, DataBoundComponent.askForSort 
	 */
	export interface MultiSortDialog  {
		/** Automatically generated IButton providing a mechanism for adding new levels to the sort configuration. This component is an AutoChild and as such may be customized via multiSortPanel.addLevelButtonProperties and multiSortPanel.addLevelButtonDefaults.
		 * Flags: RA */
		addLevelButton:  IButton /* AutoChild IButton */;

		/** The title-text to appear on the addLevelButton. Note, this is a passthrough property which, when set, is passed through to the MultiSortPanel','MultiSortPanel contained in this dialog. You only need to consider the properties on the MultiSortPanel for i18n.
		 * Flags: IR, Group: i18nMessages */
		addLevelButtonTitle: string /* String */;

		/** Automatically generated IButton providing the mechanism for accepting the current sort configuration. Fires the passed callback with a single parameter, sortLevels, representing the current sort configuration as an array of SortSpecifiers. This component is an AutoChild and as such may be customized via multiSortDialog.applyButtonProperties and multiSortDialog.applyButtonDefaults.
		 * Flags: RA */
		applyButton:  IButton /* AutoChild IButton */;

		/** The title-text to appear on the applyButton
		 * Flags: IR, Group: i18nMessages */
		applyButtonTitle: string /* String */;

		/** The title-text to appear in the "direction" field's SelectItem for an "ascending" sort Note, this is a passthrough property which, when set, is passed through to the MultiSortPanel','MultiSortPanel contained in this dialog. You only need to consider the properties on the MultiSortPanel for i18n.
		 * Flags: IR, Group: i18nMessages */
		ascendingTitle: string /* String */;

		/** Automatically generated IButton providing the mechanism for closing this Dialog without accepting the current sort configuration. The passed callback is fired with a single null parameter, indicating that the operation was cancelled. This component is an AutoChild and as such may be customized via multiSortDialog.cancelButtonProperties and multiSortDialog.cancelButtonDefaults.
		 * Flags: RA */
		cancelButton:  IButton /* AutoChild IButton */;

		/** The title-text to appear on the cancelButton
		 * Flags: IR, Group: i18nMessages */
		cancelButtonTitle: string /* String */;

		/** Automatically generated IButton providing a mechanism for duplicating levels in the sort configuration. This component is an AutoChild and as such may be customized via multiSortPanel.copyLevelButtonProperties and multiSortPanel.copyLevelButtonDefaults.
		 * Flags: RA */
		copyLevelButton:  IButton /* AutoChild IButton */;

		/** The title-text to appear on the copyLevelButton Note, this is a passthrough property which, when set, is passed through to the MultiSortPanel','MultiSortPanel contained in this dialog. You only need to consider the properties on the MultiSortPanel for i18n.
		 * Flags: IR, Group: i18nMessages */
		copyLevelButtonTitle: string /* String */;

		/** Automatically generated IButton providing a mechanism for deleting levels from the sort configuration. This component is an AutoChild and as such may be customized via multiSortPanel.deleteLevelButtonProperties and multiSortPanel.deleteLevelButtonDefaults.
		 * Flags: RA */
		deleteLevelButton:  IButton /* AutoChild IButton */;

		/** The title-text to appear on the deleteLevelButton Note, this is a passthrough property which, when set, is passed through to the MultiSortPanel','MultiSortPanel contained in this dialog. You only need to consider the properties on the MultiSortPanel for i18n.
		 * Flags: IR, Group: i18nMessages */
		deleteLevelButtonTitle: string /* String */;

		/** The title-text to appear in the "direction" field's SelectItem for a "descending" sort Note, this is a passthrough property which, when set, is passed through to the MultiSortPanel','MultiSortPanel contained in this dialog. You only need to consider the properties on the MultiSortPanel for i18n.
		 * Flags: IR, Group: i18nMessages */
		descendingTitle: string /* String */;

		/** The title-text to appear in the header of the "direction" field. Note, this is a passthrough property which, when set, is passed through to the MultiSortPanel','MultiSortPanel contained in this dialog. You only need to consider the properties on the MultiSortPanel for i18n.
		 * Flags: IR, Group: i18nMessages */
		directionFieldTitle: string /* String */;

		/** The list of fields which the user can choose to sort by.
		 * Flags: IR */
		fields: Array<DataSourceField> /* Array of DataSourceField */;

		/** The title-text to appear in the first column for the first sort-level. Note, this is a passthrough property which, when set, is passed through to the MultiSortPanel','MultiSortPanel contained in this dialog. You only need to consider the properties on the MultiSortPanel for i18n.
		 * Flags: IR, Group: i18nMessages */
		firstSortLevelTitle: string /* String */;

		/** The initial sort configuration to show in the MultiSortPanel.optionsGrid','optionsGrid. Note, this is a passthrough property which, when set, is passed through to the MultiSortPanel','MultiSortPanel contained in this dialog.
		 * Flags: IR */
		initialSort: Array<SortSpecifier> /* Array of SortSpecifier */;

		/** This is a dynamic string - text within &#36;{...} will be evaluated as JS code when the message is displayed. Default value returns Columns may only be used once: [some field's title] is used multiple times Note, this is a passthrough property which, when set, is passed through to the MultiSortPanel','MultiSortPanel contained in this dialog. You only need to consider the properties on the MultiSortPanel for i18n.
		 * Flags: IR, Group: i18nMessages */
		invalidListPrompt: string /* HTMLString */;

		/** Automatically generated ImgButton providing a mechanism for moving existing sort-levels down in the sort configuration. This component is an AutoChild and as such may be customized via multiSortPanel.levelDownButtonProperties and multiSortPanel.levelDownButtonDefaults.
		 * Flags: RA */
		levelDownButton:  ImgButton /* AutoChild ImgButton */;

		/** The hover-prompt for the Level Down button.
		 * Flags: IR, Group: i18nMessages */
		levelDownButtonTitle: string /* String */;

		/** Automatically generated ImgButton providing a mechanism for moving existing sort-levels up in the sort configuration. This component is an AutoChild and as such may be customized via multiSortPanel.levelUpButtonProperties and multiSortPanel.levelUpButtonDefaults.
		 * Flags: RA */
		levelUpButton:  ImgButton /* AutoChild ImgButton */;

		/** The hover-prompt for the Level Up button.
		 * Flags: IR, Group: i18nMessages */
		levelUpButtonTitle: string /* String */;

		/** The maximum number of levels of sorting that can be applied. Since each sort-property or field-name can be used only once in a given multi-sort operation, if no maxLevels value or a value larger than the total number of available properties is specified, it will default to the total number of available properties. Note, this is a passthrough property which, when set, is passed through to the MultiSortPanel','MultiSortPanel contained in this dialog.
		 * Flags: IR */
		maxLevels: number;

		/** Automatically generated MultiSortPanel displayed within this component.
		 * Flags: R */
		multiSortPanel:  MultiSortPanel /* AutoChild MultiSortPanel */;

		/** Automatically generated ListGrid allowing the user to configure a set of SortSpecifiers. This component is an AutoChild and as such may be customized via multiSortPanel.optionsGridProperties and multiSortPanel.optionsGridDefaults.
		 * Flags: IR */
		optionsGrid:  ListGrid /* AutoChild ListGrid */;

		/** The title-text to appear in the first column for all sort-levels other than the first. Note, this is a passthrough property which, when set, is passed through to the MultiSortPanel','MultiSortPanel contained in this dialog. You only need to consider the properties on the MultiSortPanel for i18n.
		 * Flags: IR, Group: i18nMessages */
		otherSortLevelTitle: string /* String */;

		/** The title-text to appear in the header of the "property" field. Note, this is a passthrough property which, when set, is passed through to the MultiSortPanel','MultiSortPanel contained in this dialog. You only need to consider the properties on the MultiSortPanel for i18n.
		 * Flags: IR, Group: i18nMessages */
		propertyFieldTitle: string /* String */;

		/** The title-text to appear in this Dialog's Header-bar.
		 * Flags: IR, Group: i18nMessages */
		title: string /* String */;


		/* Instance Method Overrides */

	} // MultiSortDialog

	export interface MultiSortDialogStatic<T, P> extends ClassStatic<T, P> {

	/* Methods */

	} // MultiSortDialogStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a MultiSortPanel Props argument.
	 * This is derived from the methods in the MultiSortPanel class and it's parents and their properties marked with the I flag.
	 */
	export interface MultiSortPanelProps  {
		/** The title-text to appear on the addLevelButton
		 * Flags: IR, Group: i18nMessages */
		addLevelButtonTitle?: string /* String */; // Flags=IR
		/** The title-text to appear in the "direction" field's SelectItem for an "ascending" sort
		 * Flags: IR, Group: i18nMessages */
		ascendingTitle?: string /* String */; // Flags=IR
		/** The title-text to appear on the copyLevelButton
		 * Flags: IR, Group: i18nMessages */
		copyLevelButtonTitle?: string /* String */; // Flags=IR
		/** The title-text to appear on the deleteLevelButton
		 * Flags: IR, Group: i18nMessages */
		deleteLevelButtonTitle?: string /* String */; // Flags=IR
		/** The title-text to appear in the "direction" field's SelectItem for a "descending" sort
		 * Flags: IR, Group: i18nMessages */
		descendingTitle?: string /* String */; // Flags=IR
		/** The title-text to appear in the header of the "direction" field.
		 * Flags: IR, Group: i18nMessages */
		directionFieldTitle?: string /* String */; // Flags=IR
		/** The list of fields which the user can choose to sort by.
		 * Flags: IR */
		fields?: Array<DataSourceField> /* Array of DataSourceField */; // Flags=IR
		/** The title-text to appear in the first column for the first sort-level.
		 * Flags: IR, Group: i18nMessages */
		firstSortLevelTitle?: string /* String */; // Flags=IR
		/** The initial sort configuration to show in the MultiSortPanel.optionsGrid','optionsGrid.
		 * Flags: IR */
		initialSort?: Array<SortSpecifier> /* Array of SortSpecifier */; // Flags=IR
		/** This is a dynamic string - text within &#36;{...} will be evaluated as JS code when the message is displayed. Default value returns Columns may only be used once: [some field's title] is used multiple times 
		 * Flags: IR, Group: i18nMessages */
		invalidListPrompt?: string /* HTMLString */; // Flags=IR
		/** The hover-prompt for the Level Down button.
		 * Flags: IR, Group: i18nMessages */
		levelDownButtonTitle?: string /* String */; // Flags=IR
		/** The hover-prompt for the Level Up button.
		 * Flags: IR, Group: i18nMessages */
		levelUpButtonTitle?: string /* String */; // Flags=IR
		/** The maximum number of levels of sorting that can be applied. Since each sort-property or field-name can be used only once in a given multi-sort operation, if no maxLevels value or a value larger than the total number of available properties is specified, it will default to the total number of available properties.
		 * Flags: IR */
		maxLevels?: number; // Flags=IR
		/** Automatically generated ListGrid allowing the user to configure a set of SortSpecifiers. This component is an AutoChild and as such may be customized via multiSortPanel.optionsGridProperties and multiSortPanel.optionsGridDefaults.
		 * Flags: IR */
		optionsGrid?:  ListGrid /* AutoChild ListGrid */; // Flags=IR
		/** The title-text to appear in the first column for all sort-levels other than the first.
		 * Flags: IR, Group: i18nMessages */
		otherSortLevelTitle?: string /* String */; // Flags=IR
		/** The title-text to appear in the header of the "property" field.
		 * Flags: IR, Group: i18nMessages */
		propertyFieldTitle?: string /* String */; // Flags=IR

		/* Method Overrides */

	} // MultiSortPanelProps


	/**
	 * A widget that allows the user to set up complex sorting arrangements by defining a group of SortSpecifiers. Each SortSpecifier applies to a single property and direction - so, for instance, in a grid with two columns, year and monthNumber, you could sort first by year in descending order and then by monthNumber in ascending order. This would producing a grid sorted by year from largest (most recent) to smallest (least recent) and, within each year, by monthNumber from smallest (January) to largest (December). 
	 */
	export interface MultiSortPanel  {
		/** Automatically generated IButton providing a mechanism for adding new levels to the sort configuration. This component is an AutoChild and as such may be customized via multiSortPanel.addLevelButtonProperties and multiSortPanel.addLevelButtonDefaults.
		 * Flags: RA */
		addLevelButton:  IButton /* AutoChild IButton */;

		/** The title-text to appear on the addLevelButton
		 * Flags: IR, Group: i18nMessages */
		addLevelButtonTitle: string /* String */;

		/** The title-text to appear in the "direction" field's SelectItem for an "ascending" sort
		 * Flags: IR, Group: i18nMessages */
		ascendingTitle: string /* String */;

		/** Automatically generated IButton providing a mechanism for duplicating levels in the sort configuration. This component is an AutoChild and as such may be customized via multiSortPanel.copyLevelButtonProperties and multiSortPanel.copyLevelButtonDefaults.
		 * Flags: RA */
		copyLevelButton:  IButton /* AutoChild IButton */;

		/** The title-text to appear on the copyLevelButton
		 * Flags: IR, Group: i18nMessages */
		copyLevelButtonTitle: string /* String */;

		/** Automatically generated IButton providing a mechanism for deleting levels from the sort configuration. This component is an AutoChild and as such may be customized via multiSortPanel.deleteLevelButtonProperties and multiSortPanel.deleteLevelButtonDefaults.
		 * Flags: RA */
		deleteLevelButton:  IButton /* AutoChild IButton */;

		/** The title-text to appear on the deleteLevelButton
		 * Flags: IR, Group: i18nMessages */
		deleteLevelButtonTitle: string /* String */;

		/** The title-text to appear in the "direction" field's SelectItem for a "descending" sort
		 * Flags: IR, Group: i18nMessages */
		descendingTitle: string /* String */;

		/** The title-text to appear in the header of the "direction" field.
		 * Flags: IR, Group: i18nMessages */
		directionFieldTitle: string /* String */;

		/** The list of fields which the user can choose to sort by.
		 * Flags: IR */
		fields: Array<DataSourceField> /* Array of DataSourceField */;

		/** The title-text to appear in the first column for the first sort-level.
		 * Flags: IR, Group: i18nMessages */
		firstSortLevelTitle: string /* String */;

		/** The initial sort configuration to show in the MultiSortPanel.optionsGrid','optionsGrid.
		 * Flags: IR */
		initialSort: Array<SortSpecifier> /* Array of SortSpecifier */;

		/** This is a dynamic string - text within &#36;{...} will be evaluated as JS code when the message is displayed. Default value returns Columns may only be used once: [some field's title] is used multiple times 
		 * Flags: IR, Group: i18nMessages */
		invalidListPrompt: string /* HTMLString */;

		/** Automatically generated ImgButton providing a mechanism for moving existing sort-levels down in the sort configuration. This component is an AutoChild and as such may be customized via multiSortPanel.levelDownButtonProperties and multiSortPanel.levelDownButtonDefaults.
		 * Flags: RA */
		levelDownButton:  ImgButton /* AutoChild ImgButton */;

		/** The hover-prompt for the Level Down button.
		 * Flags: IR, Group: i18nMessages */
		levelDownButtonTitle: string /* String */;

		/** Automatically generated ImgButton providing a mechanism for moving existing sort-levels up in the sort configuration. This component is an AutoChild and as such may be customized via multiSortPanel.levelUpButtonProperties and multiSortPanel.levelUpButtonDefaults.
		 * Flags: RA */
		levelUpButton:  ImgButton /* AutoChild ImgButton */;

		/** The hover-prompt for the Level Up button.
		 * Flags: IR, Group: i18nMessages */
		levelUpButtonTitle: string /* String */;

		/** The maximum number of levels of sorting that can be applied. Since each sort-property or field-name can be used only once in a given multi-sort operation, if no maxLevels value or a value larger than the total number of available properties is specified, it will default to the total number of available properties.
		 * Flags: IR */
		maxLevels: number;

		/** Automatically generated ListGrid allowing the user to configure a set of SortSpecifiers. This component is an AutoChild and as such may be customized via multiSortPanel.optionsGridProperties and multiSortPanel.optionsGridDefaults.
		 * Flags: IR */
		optionsGrid:  ListGrid /* AutoChild ListGrid */;

		/** The title-text to appear in the first column for all sort-levels other than the first.
		 * Flags: IR, Group: i18nMessages */
		otherSortLevelTitle: string /* String */;

		/** The title-text to appear in the header of the "property" field.
		 * Flags: IR, Group: i18nMessages */
		propertyFieldTitle: string /* String */;


		/* Instance Method Overrides */

	} // MultiSortPanel

	export interface MultiSortPanelStatic<T, P> extends ClassStatic<T, P> {
	} // MultiSortPanelStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a NavigationBar Props argument.
	 * This is derived from the methods in the NavigationBar class and it's parents and their properties marked with the I flag.
	 */
	export interface NavigationBarProps extends HLayoutProps {
		/** If set, the left button title will never be omitted in an attempt to fit the full title. See the documentation of NavigationBar.title for details.
		 * Flags: IRW */
		alwaysShowLeftButtonTitle?: boolean; // Flags=IRW
		/** Whether to animate a change of the view state via NavigationBar.setViewState. Enabling animation of state changes does have a performance impact because more components need to be created by the NavigationBar to implement the animated transitions. It is therefore recommended to leave animateStateChanges at its default value of false unless NavigationBar.setViewState might be called on this NavigationBar instance and animation is desired. Note also that when animation is enabled, certain AutoChild defaults and properties may be used to create other AutoChildren that are internal to the animation implementation. This generally does not cause an issue unless certain non-UI event handlers are added to the defaults and/or properties (e.g. Canvas.visibilityChanged, Canvas.resized). For those types of handlers, a check should be added to make sure that the handler is running for the expected component.
		 * Flags: IRA */
		animateStateChanges?: boolean; // Flags=IRA
		/** An arbitrary component that will be placed where the NavigationBar.miniNavControl','miniNavControl AutoChild would normally be placed (see NavigationBar.miniNavAlign','miniNavAlign).
		 * Flags: IRW */
		customNavControl?: Canvas; // Flags=IRW
		/** The button displayed to the left of the title in this NavigationBar. By default this will be a NavigationButton with NavigationButton.direction','direction set to "back". The following autoChildUsage','passthroughs apply: NavigationBar.leftButtonTitle','leftButtonTitle for Button.title NavigationBar.leftButtonIcon','leftButtonIcon for Button.icon 
		 * Flags: IR */
		leftButton?:  NavigationButton /* AutoChild NavigationButton */; // Flags=IR
		/** Button.icon','Icon for the NavigationBar.leftButton','leftButton.
		 * Flags: IRW */
		leftButtonIcon?: string /* SCImgURL */; // Flags=IRW
		/** Button.title','Title for the NavigationBar.leftButton','leftButton.
		 * Flags: IRW */
		leftButtonTitle?: string /* HTMLString */; // Flags=IRW
		/** Maximum amount in pixels that the title will be placed off center in an effort to avoid clipping it - see NavigationBar.title','title.
		 * Flags: IR */
		maxCenterOffset?: number /* int */; // Flags=IR
		/** Placement of MiniNavControl, if present: "right" alignment places the miniNav on the far right "center" alignment places the miniNav in the center, or to the right of the title if the title is present "left" alignment will place the miniNav on the left, or to the right of the NavigationBar.leftButton if its present. 
		 * Flags: IR */
		miniNavAlign?: Alignment; // Flags=IR
		/** AutoChild of type MiniNavControl. Not shown by default (see NavigationBar.showMiniNavControl','showMiniNavControl). Also, if a NavigationBar.customNavControl','customNavControl is provided, then the customNavControl is used instead of an automatically created miniNavControl.
		 * Flags: IR */
		miniNavControl?:  MiniNavControl /* AutoChild MiniNavControl */; // Flags=IR
		/** The button displayed to the right of the title in this NavigationBar. By default this will be a NavigationButton with NavigationButton.direction','direction set to "forward". The following autoChildUsage','passthroughs apply: NavigationBar.rightButtonTitle','rightButtonTitle for Button.title NavigationBar.rightButtonIcon','rightButtonIcon for Button.icon 
		 * Flags: IR */
		rightButton?:  NavigationButton /* AutoChild NavigationButton */; // Flags=IR
		/** Button.icon','Icon for the NavigationBar.rightButton','rightButton.
		 * Flags: IRW */
		rightButtonIcon?: string /* SCImgURL */; // Flags=IRW
		/** Button.title','Title for the NavigationBar.rightButton','rightButton.
		 * Flags: IRW */
		rightButtonTitle?: string /* HTMLString */; // Flags=IRW
		/** Short title to display for the left button title if there is not enough room to show the title for the navigation bar. Setting to null or an empty string ("") will avoid a shortened title ever being used. See NavigationBar.title for a full description.
		 * Flags: IRW */
		shortLeftButtonTitle?: string /* HTMLString */; // Flags=IRW
		/** If set to false, then the NavigationBar.leftButton','leftButton is not shown.
		 * Flags: IRW */
		showLeftButton?: boolean /* Boolean */; // Flags=IRW
		/** If set to false, then the NavigationBar.miniNavControl','miniNavControl is not shown.
		 * Flags: IR */
		showMiniNavControl?: boolean; // Flags=IR
		/** If set to false, then the NavigationBar.rightButton','rightButton is not shown.
		 * Flags: IRW */
		showRightButton?: boolean /* Boolean */; // Flags=IRW
		/** The title to display in the center of this navigation bar. If there is not enough room for the title with the current titles of the NavigationBar.leftButton','left and NavigationBar.rightButton','right buttons, space will be used as follows: if the title can be fully visible without clipping if it is placed slightly off-center, it will be placed off-center, up to a maximum of NavigationBar.maxCenterOffset','maxCenterOffset pixels if that's not enough space, if a NavigationBar.shortLeftButtonTitle','shortLeftButtonTitle is provided, it will be used in lieu of the normal left button title if that's still not enough space, the title of the left button will be hidden, leaving only the icon. This will be skipped if either NavigationBar.alwaysShowLeftButtonTitle','alwaysShowLeftButtonTitle has been set or the button has no icon, which would leave the space blank. if that's still not enough space, the title text will be clipped, showing an ellipsis (where browser support allows this) 
		 * Flags: IRW */
		title?: string /* HTMLString */; // Flags=IRW
		/** The AutoChild label used to display the NavigationBar.title','title in this NavigationBar.
		 * Flags: IR */
		titleLabel?:  Label /* AutoChild Label */; // Flags=IR

		/* Method Overrides */

		/** 
		 * Sets multiple state attributes of this NavigationBar at once. If this NavigationBar was created with NavigationBar.animateStateChanges','animateStateChanges set to true, then the change-over to the new state attributes will be animated if the direction is either "forward" or "back". 
		 * @param {NavigationBarViewState} viewState - the new view state.
		 * @param {NavigationDirection} direction - an optional direction for animation. If not specified or set to "none" then the state change will not be animated. The direction should be "forward" for operations that reveal new content and "back" for operations that reveal previously-displayed content.
		 */
		setViewState?(viewState:NavigationBarViewState, direction?:NavigationDirection): void; 

	} // NavigationBarProps


	/**
	 * Navigation control implemented as a horizontal layout showing back and forward controls and a title. 
	 */
	export interface NavigationBar extends HLayout {
		/** If set, the left button title will never be omitted in an attempt to fit the full title. See the documentation of NavigationBar.title for details.
		 * Flags: IRW */
		alwaysShowLeftButtonTitle: boolean;

		/** Whether to animate a change of the view state via NavigationBar.setViewState. Enabling animation of state changes does have a performance impact because more components need to be created by the NavigationBar to implement the animated transitions. It is therefore recommended to leave animateStateChanges at its default value of false unless NavigationBar.setViewState might be called on this NavigationBar instance and animation is desired. Note also that when animation is enabled, certain AutoChild defaults and properties may be used to create other AutoChildren that are internal to the animation implementation. This generally does not cause an issue unless certain non-UI event handlers are added to the defaults and/or properties (e.g. Canvas.visibilityChanged, Canvas.resized). For those types of handlers, a check should be added to make sure that the handler is running for the expected component.
		 * Flags: IRA */
		animateStateChanges: boolean;

		/** An arbitrary component that will be placed where the NavigationBar.miniNavControl','miniNavControl AutoChild would normally be placed (see NavigationBar.miniNavAlign','miniNavAlign).
		 * Flags: IRW */
		customNavControl: Canvas;

		/** The button displayed to the left of the title in this NavigationBar. By default this will be a NavigationButton with NavigationButton.direction','direction set to "back". The following autoChildUsage','passthroughs apply: NavigationBar.leftButtonTitle','leftButtonTitle for Button.title NavigationBar.leftButtonIcon','leftButtonIcon for Button.icon 
		 * Flags: IR */
		leftButton:  NavigationButton /* AutoChild NavigationButton */;

		/** Button.icon','Icon for the NavigationBar.leftButton','leftButton.
		 * Flags: IRW */
		leftButtonIcon: string /* SCImgURL */;

		/** Button.title','Title for the NavigationBar.leftButton','leftButton.
		 * Flags: IRW */
		leftButtonTitle: string /* HTMLString */;

		/** Maximum amount in pixels that the title will be placed off center in an effort to avoid clipping it - see NavigationBar.title','title.
		 * Flags: IR */
		maxCenterOffset: number /* int */;

		/** Placement of MiniNavControl, if present: "right" alignment places the miniNav on the far right "center" alignment places the miniNav in the center, or to the right of the title if the title is present "left" alignment will place the miniNav on the left, or to the right of the NavigationBar.leftButton if its present. 
		 * Flags: IR */
		miniNavAlign: Alignment;

		/** AutoChild of type MiniNavControl. Not shown by default (see NavigationBar.showMiniNavControl','showMiniNavControl). Also, if a NavigationBar.customNavControl','customNavControl is provided, then the customNavControl is used instead of an automatically created miniNavControl.
		 * Flags: IR */
		miniNavControl:  MiniNavControl /* AutoChild MiniNavControl */;

		/** The button displayed to the right of the title in this NavigationBar. By default this will be a NavigationButton with NavigationButton.direction','direction set to "forward". The following autoChildUsage','passthroughs apply: NavigationBar.rightButtonTitle','rightButtonTitle for Button.title NavigationBar.rightButtonIcon','rightButtonIcon for Button.icon 
		 * Flags: IR */
		rightButton:  NavigationButton /* AutoChild NavigationButton */;

		/** Button.icon','Icon for the NavigationBar.rightButton','rightButton.
		 * Flags: IRW */
		rightButtonIcon: string /* SCImgURL */;

		/** Button.title','Title for the NavigationBar.rightButton','rightButton.
		 * Flags: IRW */
		rightButtonTitle: string /* HTMLString */;

		/** Short title to display for the left button title if there is not enough room to show the title for the navigation bar. Setting to null or an empty string ("") will avoid a shortened title ever being used. See NavigationBar.title for a full description.
		 * Flags: IRW */
		shortLeftButtonTitle: string /* HTMLString */;

		/** If set to false, then the NavigationBar.leftButton','leftButton is not shown.
		 * Flags: IRW */
		showLeftButton: boolean /* Boolean */;

		/** If set to false, then the NavigationBar.miniNavControl','miniNavControl is not shown.
		 * Flags: IR */
		showMiniNavControl: boolean;

		/** If set to false, then the NavigationBar.rightButton','rightButton is not shown.
		 * Flags: IRW */
		showRightButton: boolean /* Boolean */;

		/** The title to display in the center of this navigation bar. If there is not enough room for the title with the current titles of the NavigationBar.leftButton','left and NavigationBar.rightButton','right buttons, space will be used as follows: if the title can be fully visible without clipping if it is placed slightly off-center, it will be placed off-center, up to a maximum of NavigationBar.maxCenterOffset','maxCenterOffset pixels if that's not enough space, if a NavigationBar.shortLeftButtonTitle','shortLeftButtonTitle is provided, it will be used in lieu of the normal left button title if that's still not enough space, the title of the left button will be hidden, leaving only the icon. This will be skipped if either NavigationBar.alwaysShowLeftButtonTitle','alwaysShowLeftButtonTitle has been set or the button has no icon, which would leave the space blank. if that's still not enough space, the title text will be clipped, showing an ellipsis (where browser support allows this) 
		 * Flags: IRW */
		title: string /* HTMLString */;

		/** The AutoChild label used to display the NavigationBar.title','title in this NavigationBar.
		 * Flags: IR */
		titleLabel:  Label /* AutoChild Label */;


		/* Instance Method Overrides */

		/** 
		 * Sets multiple state attributes of this NavigationBar at once. If this NavigationBar was created with NavigationBar.animateStateChanges','animateStateChanges set to true, then the change-over to the new state attributes will be animated if the direction is either "forward" or "back". 
		 * @param {NavigationBarViewState} viewState - the new view state.
		 * @param {NavigationDirection} direction - an optional direction for animation. If not specified or set to "none" then the state change will not be animated. The direction should be "forward" for operations that reveal new content and "back" for operations that reveal previously-displayed content.
		 */
		setViewState?(viewState:NavigationBarViewState, direction?:NavigationDirection): void; 

	} // NavigationBar

	export interface NavigationBarStatic<T, P> extends HLayoutStatic<T, P> {
	} // NavigationBarStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a NavigationButton Props argument.
	 * This is derived from the methods in the NavigationButton class and it's parents and their properties marked with the I flag.
	 */
	export interface NavigationButtonProps extends ButtonProps {
		/** Base style for navigation buttons where Direction is set to "back"
		 * Flags: IRW */
		backBaseStyle?: string /* CSSStyleName */; // Flags=IRW
		/** Default baseStyle for navigation buttons. Note that the special NavigationButton.backBaseStyle and NavigationButton.forwardBaseStyle are applied if NavigationButton.direction is set.
		 * Flags: IRW */
		baseStyle?: string /* CSSStyleName */; // Flags=IRW
		/** Navigation direction for this button. If set to "forward" or "back" the special NavigationButton.forwardBaseStyle or NavigationButton.backBaseStyle will be applied.
		 * Flags: IRW */
		direction?: NavigationDirection; // Flags=IRW
		/** Base style for navigation buttons where Direction is set to "forward"
		 * Flags: IRW */
		forwardBaseStyle?: string /* CSSStyleName */; // Flags=IRW
	} // NavigationButtonProps


	/**
	 * Specially styled Button subclass used by the NavigationBar class. 
	 */
	export interface NavigationButton extends Button {
		/** Base style for navigation buttons where Direction is set to "back"
		 * Flags: IRW */
		backBaseStyle: string /* CSSStyleName */;

		/** Default baseStyle for navigation buttons. Note that the special NavigationButton.backBaseStyle and NavigationButton.forwardBaseStyle are applied if NavigationButton.direction is set.
		 * Flags: IRW */
		baseStyle: string /* CSSStyleName */;

		/** Navigation direction for this button. If set to "forward" or "back" the special NavigationButton.forwardBaseStyle or NavigationButton.backBaseStyle will be applied.
		 * Flags: IRW */
		direction: NavigationDirection;

		/** Base style for navigation buttons where Direction is set to "forward"
		 * Flags: IRW */
		forwardBaseStyle: string /* CSSStyleName */;

	} // NavigationButton

	export interface NavigationButtonStatic<T, P> extends ButtonStatic<T, P> {
	} // NavigationButtonStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a OperationBinding Props argument.
	 * This is derived from the methods in the OperationBinding class and it's parents and their properties marked with the I flag.
	 */
	export interface OperationBindingProps  {
		/** This property indicates whether this operation supports AdvancedCriteria. This setting overrides DataSource.allowAdvancedCriteria for this operation only. See DataSource.supportsAdvancedCriteria for further information. NOTE: If you specify this property in a DataSource descriptor (.ds.xml file), it is enforced on the server. This means that if you run a request containing AdvancedCriteria against an OperationBinding that advertises itself as allowAdvancedCriteria:false, it will be rejected.
		 * Flags: IRWA */
		allowAdvancedCriteria?: boolean; // Flags=IRWA
		/** Ordinarily, "update" and "remove" operations are only allowed for DataSources that have a DataSourceField.primaryKey','primaryKey, and all primary key values are present in the request. This is because an update of a DataSource with no primary key, or an update request that has missing primary key values, cannot be guaranteed to affect only one record. Setting this property on an operationBinding circumvents this restriction for that operation only. Warning: Be aware that this is a potentially dangerous setting and should be used with care. With this flag set, you have no guarantee that an update will not change or remove every row in a table. Also, running allowMultiUpdate operations directly from the client is not straightforward because it requires the ability to specify criteria and values separately in the request, which is not currently supported. This can be worked around in various ways, but really allowMultiUpdate is primarily intended for server-side operations. Therefore, the recommended pattern is to use a DataSource.performCustomOperation','custom operation from the client to invoke a DMI on the server which performs the multi-update operation via a second, server-side DSRequest.
		 * Flags: IR */
		allowMultiUpdate?: boolean; // Flags=IR
		/** If true, causes requests against this operation to automatically start or join a transaction. if false, causes requests against this operation to be committed individually. If null, falls back to DataSource.autoJoinTransactions. See DataSource.autoJoinTransactions for further details of SmartClient's automatic transaction control.
		 * Flags: IR */
		autoJoinTransactions?: boolean; // Flags=IR
		/** A per-operationBinding setting for beanClassName, otherwise also settable at the top-level DataSource configuration.
		 * Flags: IR, Group: clientDataIntegration */
		beanClassName?: string /* String */; // Flags=IR
		/** For an operationBinding of OperationBinding.operationType','operationType "add" or "update", this property is the OperationBinding.operationId','operationId of a "fetch" operationBinding to use for cache synchronization purposes (ie, to fetch the row most recently added or changed). This property, along with OperationBinding.useForCacheSync','useForCacheSync and OperationBinding.canSyncCache','canSyncCache is provided so that you can use custom database operations without sacrificing the benefits of SmartClient's automatic cache synchronization. This property is only applicable to DataSources of type "sql".
		 * Flags: IR, Group: customQuerying */
		cacheSyncOperation?: string /* String */; // Flags=IR
		/** Applies only to dataFormat: "json". Specifies the name of the query parameter that tells your JSON service what function to call as part of the response for this operation. Typically set once for the DataSource as a whole via DataSource.callbackParam.
		 * Flags: IR, Group: clientDataIntegration */
		callbackParam?: string /* String */; // Flags=IR
		/** For an operation of type "add" or "update", a SQLDataSource will normally obtain data to return to the client by performing the "cacheSyncOperation": a SELECT statement that retrieves the modified record by primary key. This accommodates sequence columns, columns with default values, database triggers and other database features that may modify data after insertion or update. Certain major SQL customizations can prevent the SQLDataSource from authoritatively determining the primary key used in the SQL statement, such that re-selecting the saved record may fail. By default, when canSyncCache has not been explicitly set, in the following cases it is assumed that the normal cacheSyncOperation cannot be used: &lt;customSQL&gt; has been used to define an entirely custom query a custom &lt;whereClause&gt; has been defined for an "update" or "remove" operation a custom &lt;valuesClause&gt; has been defined for an "add" operation If any of these cases apply or if canSyncCache has been set false, the server will skip the cacheSyncOperation and return a DSResponse where DSResponse.invalidateCache has been set to true to notify client-side components that they may need to refresh their entire cache. Alternatively, if the default re-selection behavior will not work but a customized SQL query would work, you can define that SQL operation as another operationBinding and use OperationBinding.cacheSyncOperation to declare that it should be used. Setting cacheSyncOperation implicitly sets canCacheSync to true. This property is only applicable to DataSources of type "sql".
		 * Flags: IR, Group: customQuerying */
		canSyncCache?: boolean /* Boolean */; // Flags=IR
		/** Indicates that field-level declarative security rules are waived for rows that were created by the current user, as described in the discussion of DataSource.creatorOverrides','dataSource.creatorOverrides. This setting overrides dataSource.creatorOverrides, for this operation only.
		 * Flags: IR, Group: fieldLevelAuth */
		creatorOverrides?: boolean; // Flags=IR
		/** Elements of this feature are only available with Power or better licenses. See <a href=http://smartclient.com/product>smartclient.com/product</a> for details. A list of DSRequestModifiers that will be used to modify the criteria of each DSRequest that uses this operationBinding. Note that the criteria elements are applied to DSRequest criteria as follows: Simple criteria: The field and value are just applied as an extra key/value pair in the criteria map, as long as the DSRequestModifier.operator','operator attribute is left unset, or is set to "equals". For any other setting of operator, the criteria is first converted to the equivalent AdvancedCriteria and then processed as described below AdvancedCriteria: If the topmost operator is "and", we add the new criterion as an additional criterion directly in the existing list. Otherwise, we create a new top-level AdvancedCriteria with an operator of "and". This is then set to have two elements in its criteria: the previous top-level criteria and the new criterion. The effect of this is to apply any criteria specifed here as additional constraints on top of what the user has specified, and of course, the user is unable to affect this. Thus, this is a suitable and convenient place to enforce rules such as "Users can only ever see their own records". Below is an example of the XML as it should be defined in your ds.xml, datasource definitions. &lt;operationBindings&gt; &lt;operationBinding operationType="fetch" operationId="..."&gt; &lt;criteria fieldName="USER_ROLE" value="ADMIN" operator="equals" /&gt; &lt;/operationBinding&gt; &lt;/operationBindings&gt;
		 * Flags: IR, Group: transactionChaining */
		criteria?: Array<DSRequestModifier> /* Array of DSRequestModifier */; // Flags=IR
		/** Indicates that the listed fields should be included in the default OperationBinding.whereClause','whereClause generated for this operationBinding, even if they are marked DataSourceField.customSQL','customSQL="true". You can specify this property as a comma-separated list (eg, "foo, bar, baz") or by just repeating the &lt;customCriteriaFields&gt; tag multiple times with one field each. This property is only applicable to DataSources of DataSource.serverType','"sql".
		 * Flags: IR, Group: customQuerying */
		customCriteriaFields?: string | Array<any> /* String or Array */; // Flags=IR
		/** Indicates that the listed fields should be included in the default OperationBinding.selectClause','selectClause and OperationBinding.selectClause','whereClause generated for this operationBinding, even if they are marked DataSourceField.customSQL','customSQL="true". If you need to apply different sets of overrides for the selectClause and the whereClause, use OperationBinding.customValueFields','customValueFields and/or OperationBinding.customCriteriaFields','customCriteriaFields instead. If you specify both customFields and customCriteriaFields or customValueFields, the more specific variant wins. If you specify both customFields and OperationBinding.excludeCriteriaFields','excludeCriteriaFields, customFields wins (this is another use case when you may wish to use customValueFields instead) You can specify this property as a comma-separated list (eg, "foo, bar, baz") or by just repeating the &lt;customFields&gt; tag multiple times with one field each. This property is only applicable to DataSources of DataSource.serverType','"sql".
		 * Flags: IR, Group: customQuerying */
		customFields?: string | Array<any> /* String or Array */; // Flags=IR
		/** This feature is available with Power or better licenses only. See <a href=http://smartclient.com/product>smartclient.com/product</a> for details. For a dataSource of DataSource.serverType','serverType "hibernate", this property can be specified on an operationBinding to indicate that the server should run user-specified HQL (Hibernate Query Language), rather than the Hibernate criteria query or saveOrUpdate call it would normally generate to satisfy a dataSource operation via Hibernate. Note that inserting new records via HQL is often impractical, due to intentional restrictions in the language (it is only possible to perform an insert expressed in terms of a SELECT; the "VALUES" construct commonly used when inserting new rows singly is not supported). If you are intending to use customHQL, we recommend that you avoid doing so for OperationBindings with OperationBinding.operationType','operationType "add", unless you have a special requirement such as a bulk insert; if you need custom queries to perform inserts on "hibernate" dataSources, we recommend you use OperationBinding.customSQL','customSQL, which is valid for "hibernate" DataSources as well as "sql" dataSources. For other operations on "hibernate" dataSources, however, HQL has the advantage of being more portable across different database engines than is plain SQL. Note that using customHQL affects paging implementation. If you use it, full data set is fetched from Hibernate and records that aren't in the requested range are dropped at the server side.
		 * Flags: IR, Group: customQuerying */
		customHQL?: string /* String */; // Flags=IR
		/** This feature is available with Power or better licenses only. See <a href=http://smartclient.com/product>smartclient.com/product</a> for details. For a dataSource of DataSource.serverType','serverType "jpa", this property can be specified on an operationBinding to indicate that the server should run user-specified JQL (Java Persistence Query Language). Note that inserting new records via JQL is often impractical, due to intentional restrictions in the language (it is only possible to perform an insert expressed in terms of a SELECT; the "VALUES" construct commonly used when inserting new rows singly is not supported). If you are intending to use customJQL, we recommend that you avoid doing so for OperationBindings with OperationBinding.operationType','operationType "add", unless you have a special requirement such as a bulk insert; if you need custom queries to perform inserts on "jpa" dataSources, we recommend you use OperationBinding.customSQL','customSQL, which is valid for "jpa" DataSources as well as "sql" dataSources. For other operations on "jpa" dataSources, however, JQL has the advantage of being more portable across different database engines than is plain SQL. Note that using customJQL affects paging implementation. If you use it, full data set is fetched from JPA and records that aren't in the requested range are dropped at the server side.
		 * Flags: IR, Group: customQuerying */
		customJQL?: string /* String */; // Flags=IR
		/** This feature is available with Power or better licenses only. See <a href=http://smartclient.com/product>smartclient.com/product</a> for details. For a dataSource of DataSource.serverType','serverType "sql" or "hibernate", this property can be specified on an operationBinding to indicate that the server should run user-specified SQL, rather than the query it would normally generate to satisfy a dataSource operation. This property allows you to provide a fully-customized query; an alternative is to provide custom "pieces" to the query generator, via properties such as OperationBinding.whereClause','whereClause and OperationBinding.valuesClause','valuesClause. See the customQuerying for more details. For a dataSource of type "sql", the SmartClient server generates a number of useful DefaultQueryClause','query "pieces", and makes them available to your custom SQL code via the Velocity templating language (note that this is not available for "hibernate" dataSources). We also make the template variables $criteria and $values available, to give you direct access to the supplied criteria, and to the new field values for update and add operations. These variables are available to both "sql" and "hibernate" dataSources. Note that you should use this feature with care. In particular, writing customSQL code that makes use of a particular database engine's features or syntax will make your application less portable. See customQuerying for an overview of writing custom queries and clauses. <h3>Examples</h3> An example using the SmartClient-supplied query pieces. This custom query will give exactly the same result as the SmartClient-generated query: &lt;operationBinding operationId="customFetch" operationType="fetch"&gt; &nbsp;&nbsp;&lt;customSQL&gt; &nbsp;&nbsp;&nbsp;&nbsp;SELECT $defaultSelectClause FROM $defaultTableClause WHERE $defaultWhereClause ORDER BY $defaultOrderClause &nbsp;&nbsp;&lt;/customSQL&gt; &lt;/operationBinding&gt; An example using the SmartClient-supplied $criteria template variable: &lt;operationBinding operationId="customFetch" operationType="fetch"&gt; &nbsp;&nbsp;&lt;customSQL&gt; &nbsp;&nbsp;&nbsp;&nbsp;SELECT foo, bar, baz FROM MyTable WHERE bar &gt; $criteria.someValue &nbsp;&nbsp;&lt;/customSQL&gt; &lt;/operationBinding&gt; An update example: &lt;operationBinding operationId="myUpdateOp" operationType="update"&gt; &nbsp;&nbsp;&lt;customSQL&gt; &nbsp;&nbsp;&nbsp;&nbsp;UPDATE $defaultTableClause SET $defaultValuesClause WHERE bar &lt;= $criteria.someValue &nbsp;&nbsp;&lt;/customSQL&gt; &lt;/operationBinding&gt; 
		 * Flags: IR, Group: customQuerying */
		customSQL?: string /* String */; // Flags=IR
		/** Indicates that the listed fields should be included in the default OperationBinding.selectClause','selectClause generated for this operationBinding, even if they are marked DataSourceField.customSQL','customSQL="true". You can specify this property as a comma-separated list (eg, "foo, bar, baz") or by just repeating the &lt;customValueFields&gt; tag multiple times with one field each. This property is only applicable to DataSources of DataSource.serverType','"sql".
		 * Flags: IR, Group: customQuerying */
		customValueFields?: string | Array<any> /* String or Array */; // Flags=IR
		/** Format for response data for this operation. Typically set once for the DataSource as a whole via DataSource.dataFormat.
		 * Flags: IR, Group: clientDataIntegration */
		dataFormat?: DSDataFormat; // Flags=IR
		/** Controls the format in which inputs are sent to the dataURL. When a DataSource operation such as fetchData() is invoked on this DataSource or a component bound to this DataSource, the data passed to the operation, if any, will be sent to the dataURL. The dataProtocol property controls the format in which the data is sent: SOAP message, HTTP GET or POST of parameters, etc. The dataProtocol property need not be set for a DataSource with a WebService ( DataSource.serviceNamespace is set), in this case, SOAP messaging is used by default. Developers may completely bypass the SmartClient comm system by setting dataProtocol to "clientCustom". In this case SmartClient will not attempt to send any data to the server after calling DataSource.transformRequest. Instead the developer is expected to implement transformRequest() such that it performs the necessary data action outside of SmartClient, and then calls DataSource.processResponse, passing in the DSRequest.requestId and an appropriate set of DSResponse properties to indicate the result of the action. NOTE: when OperationBinding.dataFormat is "iscServer", dataProtocol is not consulted. Instead, SmartClient uses a proprietary wire format to communicate with the SmartClient server, and the server-side DSRequest and DSResponse objects should be used to access request data and form responses.
		 * Flags: IR, Group: clientDataIntegration */
		dataProtocol?: DSProtocol; // Flags=IR
		/** Transport to use for this operation. Defaults to DataSource.dataTransport, which in turn defaults to RPCManager.defaultTransport. This would typically only be set to enable "scriptInclude" transport for contacting DataSource.dataFormat','JSON web services hosted on servers other than the origin server. When using the "scriptInclude" transport, be sure to set DataSource.callbackParam or OperationBinding.callbackParam to match the name of the query parameter name expected by your JSON service provider.
		 * Flags: IR, Group: clientDataIntegration */
		dataTransport?: RPCTransport; // Flags=IR
		/** URL to contact to fulfill DSRequests for this operationBinding. dataURL is typically set as DataSource.dataURL rather than on each individual operationBinding. dataURL can be omitted for a DataSource using a Web Service (DataSource.serviceNamespace is set).
		 * Flags: IR, Group: clientDataIntegration */
		dataURL?: string /* URL */; // Flags=IR
		/** HTTP parameters that should be submitted with every DSRequest. Useful for authenticated services that require a sessionId with every request. Can be set for all operations of a given DataSource as DataSource.defaultParams.
		 * Flags: IRA, Group: clientDataIntegration */
		defaultParams?: any /* Object */; // Flags=IRA
		/** Indicates that the listed fields should be excluded from the default OperationBinding.whereClause','whereClause generated for this operationBinding. This enables you to use these fields in a customQuerying','custom query while still allowing the $defaultWhereClause to be generated for all other fields. For example, you might take a particular field and apply it in the WHERE clause of a subquery. You can specify this property as a comma-separated list (eg, "foo, bar, baz") or by just repeating the &lt;customCriteriaFields&gt; tag multiple times with one field each. Note that if a field is included in both excludeCriteriaFields and OperationBinding.customCriteriaFields','customCriteriaFields, customCriteriaFields wins. This property is only applicable to DataSources of DataSource.serverType','"sql".
		 * Flags: IR, Group: customQuerying */
		excludeCriteriaFields?: string | Array<any> /* String or Array */; // Flags=IR
		/** The format in which the data should be exported. Default is "csv". See ExportFormat for more information.
		 * Flags: IR */
		exportAs?: ExportFormat; // Flags=IR
		/** The list of field-names to export. If provided, the field-list in the exported output is limited and sorted as per the list. If exportFields is not provided, the exported output includes all visible fields from the DataSource (field.hidden=false), sorted in the order they're defined.
		 * Flags: IR */
		exportFields?: Array<any> /* Array */; // Flags=IR
		/** The name of the file to save the exported data into.
		 * Flags: IR */
		exportFilename?: string /* String */; // Flags=IR
		/** When set, causes the results of the DataSource Operation to be exported to a file, whose name and format are indicated by OperationBinding.exportFilename and OperationBinding.exportAs respectively. When no exportFilename is provided, the default is Results and the default value of exportAs is csv. Once the Operation completes, DSRequest.exportDisplay specifies whether the exported data will be downloaded to the file-system or displayed in a new window. The default value of exportDisplay is "download" which displays the Save As dialog. See ExportDisplay for more information. The export field-list can also be configured, see DSRequest.exportFields. You can also configure the style of line-breaks to use when generating the output. See LineBreakStyle for more information. As well as setting this and other properties on the OperationBinding, Exports can be initiated in two other ways. You can set properties on the dsRequest by passing requestProperties into DataSource.exportData. Note that this method does not support exporting to JSON format (see <a href="http://forums.smartclient.com/showthread.php?t=235">this post</a> for more detail). Additionally, custom server code may set export-related properties on the DSResponse. Format Examples XML format &lt;List&gt; &lt;Object&gt; &lt;id&gt;10101&lt;/id&gt; &lt;displayName&gt;Record 10101&lt;/displayName&gt; &lt;/Object&gt; &lt;/List&gt; JSON Format [ { id: 10101, displayName: "Record 10101" } ] CSV Format id,displayName 10101,"Record 10101" 
		 * Flags: IR */
		exportResults?: boolean; // Flags=IR
		/** List of fields to group by when using serverSummaries','server-side summarization. Valid only for an operation of type "fetch". See the serverSummaries','Server Summaries overview for details and examples of usage.
		 * Flags: IR, Group: serverSummaries */
		groupBy?: Array<string> /* Array of String */; // Flags=IR
		/** This feature is available with Power or better licenses only. See <a href=http://smartclient.com/product>smartclient.com/product</a> for details. For a dataSource of DataSource.serverType','serverType "sql", this property can be specified on an operationBinding to provide the server with a bespoke GROUP BY clause to use when constructing the SQL query to perform this operation. The property should be a comma-separated list of column names and/or expressions, forming a valid GROUP BY clause in the syntax of the underlying database. The server will insert the text of this property immediately after the "GROUP BY" token. Note that specifying this property enables you to use aggregate functions (such as COUNT and SUM) in your OperationBinding.selectClause','selectClause. Also note that care is required when using groupClause to ensure that the selectClause contains the fields you are grouping by. Failure to do this correctly will result in a runtime SQL error. This property is only applicable to operationBindings of OperationBinding.operationType','operationType "fetch". See the documentation for OperationBinding.customSQL for usage examples
		 * Flags: IR, Group: customQuerying */
		groupClause?: string /* String */; // Flags=IR
		/** Value to use for the OperationBinding.ownerIdField','ownerIdField if no one has authenticated. Overrides the same setting at the DataSource.guestUserId','DataSource level.
		 * Flags: IR */
		guestUserId?: string; // Flags=IR
		/** If set, every invocation of this operationBinding will invalidate the local cache, forcing a server visit to refresh the data.
		 * Flags: IR */
		invalidateCache?: boolean; // Flags=IR
		/** The style of line-breaks to use in the exported output. See LineBreakStyle for more information.
		 * Flags: IR */
		lineBreakStyle?: string /* String */; // Flags=IR
		/** Definition of an email message that will be sent as an after-effect of selecting or updating data. Note that if a fixed number of different messages need to be sent, multiple &lt;mail&gt; tags may be specified. For example, one mail could be sent to an admin address, and a different message to every member of a user group.
		 * Flags: IR, Group: mail */
		mail?: Mail; // Flags=IR
		/** You can explicitly declare the arguments to be passed to OperationBinding.serverMethod using this attribute. This isn't required - in the absence of methodArguments, the DMI implementation will still automatically pass a stock set of arguments to your method (see the overview in ServerObject), but specifying arguments gives you the ability to call pre-existing methods without adding SmartClient-specific code. The format for specifying methodArguments is as a comma separated list of VTL (Velocity Template Language) expressions. See the <a href='http://jakarta.apache.org/velocity/docs/vtl-reference-guide.html' target='_blank'>VTL Reference</a> and <a href='http://jakarta.apache.org/velocity/docs/user-guide.html' target='_blank'>Velocity User Guide</a> for an overview of how to use VTL. The Velocity context is pre-populated with the following variables - you can pass these verbatim as arguments, or call methods on these objects and pass the resulting values: dsRequest: instance of the current DSRequest request: the current HttpServletRequest response: the current HttpServletResponse rpcManager: the instance of RPCManager for this request dataSource: a DataSource instance for this request So, for example, if you had a method signature like the following: public DSResponse fetch(SupplyItem criteria, long startRow, long endRow) You can invoke it by specifying methodArguments as follows: methodArguments="$dsRequest.criteria, $dsRequest.startRow, $dsRequest.endRow" Without methodArguments, there would be no way for you to specify startRow/endRow as arguments. You could, of course, simply declare the method to take a DSRequest object and call getStartRow()/getEndRow() in the body of the method.
		 * Flags: IR */
		methodArguments?: string; // Flags=IR
		/** This feature is available with Power or better licenses only. See <a href=http://smartclient.com/product>smartclient.com/product</a> for details. For a dataSource of DataSource.serverType','serverType "jpa" or "hibernate", this property can be specified on an operationBinding to indicate that the server should execute a named query which has already been defined on an entity. &#64;Entity &#64;Table (name="Countries") &#64;NamedQuery(name = "Country.withPopulationLessThan", query = "SELECT country FROM Country country WHERE country.population &lt; :population") public class Country { ... } &lt;operationBindings&gt; &lt;operationBinding operationType="custom" operationId="withPopulationLessThan" namedQuery="Country.withPopulationLessThan"/&gt; &lt;/operationBindings&gt; Substitution values can be used in order to build more dynamic named queries. When calling DataSource.performCustomOperation the values are passed in using the data argument. Note that value substitution for named queries is slightly different to other custom queries. Because of the way the persistence API works the JQL query written in the &#64;NamedQuery annotation can only contain basic parameter names such as "population". Therefore the value substitution becomes a simple name based mapping. <h3>Examples</h3> Using Simple Criteria<br /> <br /> An example using a simple criteria for the above defined Country entity. In this case the named query parameter ":population" will be swapped out for the value of the criteria objects "population" field. var criteria = { population: 596000 }; countryDataSource.performCustomOperation("withPopulationLessThan", criteria); Using Advanced Criteria<br /> <br /> If an advanced criteria is detected, access to all "fieldName" variables and their values will be provided but still using simple name based mapping. In the below case only the deep-first occurrence of the "population" fieldName will available. The operator is effectively ignored. var criteria = { _constructor: "AdvancedCriteria", operator:"or", criteria:[ { fieldName:"population", operator:"lessThan", value: 12000 }, { fieldName:"name", operator:"equals", value: "Sweden" }, { _constructor: "AdvancedCriteria", operator:"and", criteria:[ { fieldName:"population", operator:"lessThan", value: 0 } ] } ] }; countryDataSource.performCustomOperation("withPopulationLessThan", criteria); Note<br /> Using namedQuery affects paging implementation. If you use it, full data set is fetched from JPA and records that aren't in the requested range are dropped at the server side.
		 * Flags: IR, Group: customQuerying */
		namedQuery?: string /* String */; // Flags=IR
		/** Optional operationId if this DataSource supports two or more variants of one of the basic DataSource operations, for instance, a "fetch" that uses full text search and a "fetch" that accepts per-field search criteria. See DSRequest.operationId for usage.
		 * Flags: IR, Group: clientDataIntegration */
		operationId?: string /* String */; // Flags=IR
		/** Which operationType this operationBinding is for. This property is only settable on an operationBinding, not a DataSource as a whole.
		 * Flags: IR, Group: clientDataIntegration */
		operationType?: DSOperationType; // Flags=IR
		/** This feature is available with Power or better licenses only. See <a href=http://smartclient.com/product>smartclient.com/product</a> for details. For a dataSource of DataSource.serverType','serverType "sql", this property can be specified on an operationBinding to provide the server with a bespoke ORDER BY clause to use when constructing the SQL query to perform this operation. The property should be a comma-separated list of column names and/or expressions, forming a valid ORDER BY clause in the syntax of the underlying database. The server will insert the text of this property immediately after the "ORDER BY" token. This property is only applicable to operationBindings of OperationBinding.operationType','operationType "fetch". See the documentation for OperationBinding.customSQL for usage examples
		 * Flags: IR, Group: customQuerying */
		orderClause?: string /* String */; // Flags=IR
		/** Specifies, for this operationBinding only, the list of field names that should be returned to the client. Typically this will be a subset of the DataSource.fields, but note that this is not a requirement; outputs can include fields that are not defined in the DataSource's field list. In this case, the server will return extra fields even if DataSource.dropExtraFields is true. You specify this property as a string containing a comma-separated list of field names (eg, "foo, bar, baz")
		 * Flags: IR */
		outputs?: string /* String */; // Flags=IR
		/** Requires that the currently authenticated user match the contents of this field, for client-initiated requests (i.e., where DSRequest.isClientRequest() returns true on the server). When a new row is added by a client-initiated DSRequest, the ownerIdField will be automatically populated with the currently authenticated user (clobbering any value supplied by the client). Client-initiated attempts to update the ownerIdField will also be prevented. If you wish to set the ownerIdField to a different value via an "add" or "update" operation, you can do so in server-side DMI code (possibly consulting DSRequest.getClientSuppliedValues() to get the value that was clobbered). For client-initiated "fetch", "update" or "remove" operations, the server will modify client-supplied criteria so that only rows whose ownerIdField matches the currently authenticated user can be read, updated or deleted. Overrides the same setting at the DataSource.ownerIdField','DataSource level. If ownerIdField is specified, DataSource.requiresAuthentication','requiresAuthentication will default to true. If requiresAuthentication is explicitly set to false, then unauthenticated users will be able to see all records. To avoid this, you can use DataSource.guestUserId','guestUserId to specify a default user to apply when no one has authenticated.
		 * Flags: IR */
		ownerIdField?: string; // Flags=IR
		/** Configures DataSource.preventHTTPCaching on a per-operationType basis.
		 * Flags: IR */
		preventHTTPCaching?: boolean; // Flags=IR
		/** Sets DataSource.progressiveLoading','progressive loading mode for this particular operation, overriding the DataSource-level setting. Note that this setting applies only to fetch operations - it has no effect if specified on any other kind of operation.
		 * Flags: IRW, Group: progressiveLoading */
		progressiveLoading?: boolean; // Flags=IRW
		/** Ordinarily, "update" and "remove" operations are only allowed if all primary key values are present in the request. This is because an update request that has missing primary key values cannot be guaranteed to affect only one record. Setting this property on an operationBinding circumvents this restriction for that operation only. Note, this property differs from OperationBinding.allowMultiUpdate','allowMultiUpdate in its intent: allowMultiUpdate tells the framework that this operation deliberately affects multiple records; providesMissingKeys tells the framework that this operation will only affect one record, and will ensure this by providing values for missing keys during its operation. Unlike allowMultiUpdate, setting this flag does not cause component caches to be ListGrid.invalidateCache','invalidated Providing values for missing keys can be done in various ways: Operations that specify &lt;OperationBinding.customSQL','customSQL&gt; or &lt;OperationBinding.whereClause','whereClause&gt; can provide missing key values from session storage or elsewhere in the provided record Operations that specify &lt;serverScript','script&gt; can provide arbitrary code to manipulate the record in whatever way they like before executing the underlying built-in functionality Operations can specify &lt;OperationBinding.criteria','criteria&gt; to provide missing keys A request can contain DSRequest.fieldValueExpressions','fieldValueExpressions, which can be used to provide values for missing keys Note, you can also use a regular dmiOverview','DMI to arbitrarily manipulate the record sent from the client, including providing values for any missing keys. If you do this, you do not need to specify providesMissingKeys because the request is not validated for the presence of key values until after the DMI has run. Warning: Be aware that this is a potentially dangerous setting and should be used with care. With this flag set, the framework cannot guarantee that an update will not change or remove every row in a table: it becomes your code's responsibility to ensure that all PK values are provided to the operation by the time it actually needs them.
		 * Flags: IR */
		providesMissingKeys?: boolean; // Flags=IR
		/** Specifies, for this specific operationBinding, whether to qualify column names with table names in any SQL we generate. Overrides the DataSource.qualifyColumnNames property. Only applicable to dataSources of DataSource.serverType','serverType "sql".
		 * Flags: IR */
		qualifyColumnNames?: boolean; // Flags=IR
		/** For an XML DataSource, tagName of the elements to be used as records. This is a simple alternative to OperationBinding.recordXPath when the elements to be used as records all share a tagName. When a DataSource has a WebService, recordName can also be set to the name of any complexType declared within the WebService's WSDL file.
		 * Flags: IR, Group: clientDataIntegration */
		recordName?: string /* String */; // Flags=IR
		/** For an XML or JSON DataSource, XPath expression used to retrieve the objects that will become DataSource records. For example, an "ItemSearch" web service might return a "Results" structure containing metadata along with the set of Items that one might want to display in a grid. An XPath expression like "/Results/Items" could be used to retrieve just the Items, which would then become DataSource records. For a JSON web service, the recordXPath is applied to the returned JSON data via XMLTools.selectObjects. Only limited XPath syntax is allowed; see XMLTools.selectObjects','selectObjects() for details. For processing XML results, see OperationBinding.xmlNamespaces for information on the namespaces that are available in this XPath expression. If you are contacting a WSDL web service, note that OperationBinding.recordName is an alternative way to specify which records should be selected by their tagName or type, and this is usually simpler. To learn about XPath, try the following search: <a href="http://www.google.com/search?q=xpath+tutorial" target="_blank" >http://www.google.com/search?q=xpath+tutorial</a>
		 * Flags: IR, Group: clientDataIntegration */
		recordXPath?: string /* XPathExpression */; // Flags=IR
		/** Additional properties to pass through to the DSRequest created for this operation. Note that these will be cumulative with and will override on a per-property basis any properties set via DataSource.requestProperties. These properties are applied before DataSource.transformRequest is called.
		 * Flags: IR, Group: clientDataIntegration */
		requestProperties?: DSRequestProps /* DSRequest Properties */; // Flags=IR
		/** Indicates that the specified VelocityExpression must be true for a user to access this operationBinding. As with OperationBinding.requiresRole, if there an operationBinding that is the default operationBinding for the operationType, its requires expression is assumed to apply to all other operationBindings of the same type unless they explicitly set requires="" DataSource.requires, if specified, applies before operationBinding.requires is evaluated. In this case, both requires expressions must be true for the request to be accepted.
		 * Flags: IR, Group: auth */
		requires?: string /* VelocityExpression */; // Flags=IR
		/** Whether a user must be authenticated in order to access this operation. For details of what is meant by "authenticated", see DataSource.requiresAuthentication. To protect access to an entire operationType (eg, all "fetch" operations), declare an operationBinding with requiresAuthentication="true", OperationBinding.operationType set to the operationType to be protected, but no OperationBinding.operationId. This will then prevent access to the "fetch" operationType unless another OperationBinding declares requiresAuthentication="false" with a specific OperationBinding.operationId','operationId.
		 * Flags: IR, Group: auth */
		requiresAuthentication?: boolean; // Flags=IR
		/** Comma-separated list of user roles that are allowed to invoke the operation described by this operationBinding. If the current user has any of the roles listed, they can invoke the operation. Also note that authentication.superuserRole can be specified in the server_properties','server.properties file. If set this denotes a "super user" role - any user with that role will have access to all operations, regardless of the "requiresRole" settings for the operation. Whether the current user has a given role is determined by calling the standard Java servlets method httpServletRequest.isUserInRole(), hence works with both simple J2EE security (realms and form-based authentication) and JAAS (Java Authentication & Authorization Service). If you wish to use a role-based security scheme that does not make use of the servlet API's standards, SmartClient Server also implements the setAuthenticated and setUserRoles methods on RPCManager. You can use this API to tell SmartClient that all the requests in the queue currently being processed are associated with a user who has the roles you supply; in this case, SmartClient will not attempt to resolve the user's roles via httpServletRequest.isUserInRole(). When taking this approach, the rpcManager.setUserRoles() method should be called on the server for each transaction received from the client. We recommend doing this by overriding the special IDACall servlet and checking server side state to determine the current user's roles, calling the API, and then calling handleDSRequest() or handleRPCRequest() directly to handle the request(s) passed in. Here's an example of this approach which assumes the current user's roles has been set directly on the HttpSession object as a comma-separated-string attribute "roles": public class SecureIDACall extends IDACall { public void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { HttpSession session = request.getSession(); Object roles = session == null ? null : session.getAttribute("roles"); if (roles != null) { try { RequestContext context = RequestContext.instance(this, request, response); RPCManager rpc = new RPCManager(request, response); rpc.setAuthenticated(true); rpc.setUserRoles((String) roles); // call processRPCTransaction() to iterate through all RPCRequests and // DSRequests and execute them processRPCTransaction(rpc, context); } catch (Throwable e) { handleError(response, e); } } else { super.processRequest(request, response); } } } If there is an operationBinding declared for a given operationType which does not have an OperationBinding.operationId, that is, it is the default operationBinding for the type, then any other operationBinding of the same type is assumed to have the same setting for requiresRole as the default operationBinding for the operationType. For example, given these declarations: &lt;operationBinding operationType="fetch" requiresRole="manager"&gt; ... settings ... &lt;/operationBinding&gt; &lt;operationBinding operationType="fetch" operationId="fetchWithExtraFields"&gt; ... settings ... &lt;/operationBinding&gt; The second operationBinding requires the "manager" role even though there is no explicit requiresRole declaration. To prevent the "manager" role being required by the second operationBinding, add requireRole="". Note that if DataSource.requiresRole is set, all operations on the DataSource require the roles set for the DataSource as a whole, even if they declare individual requiresRole attributes. This property is valid only for a server-side DataSource when using the SmartClient Server. <h3>Special rules for cache sync</h3> After successfull "add" or "update" operation cache sync request is performed, which is using "fetch" operation of the same datasource. It may happen that user is allowed to add records, but is not allowed to fetch them, for example: &lt;operationBinding operationType="fetch" requiresRole="admin"&gt; ... settings ... &lt;/operationBinding&gt; &lt;operationBinding operationType="add"&gt; ... settings ... &lt;/operationBinding&gt; User without "admin" role will be able to successfully add record, but the cache sync operation will fail due to security violation. In this case the record will be saved to database, but the added record will not be fetched from database, instead just DSRequest.oldValues','old values overlaid with submitted values will be returned. So, any changes made to the new record during request execution, including generated values for primary key fields of "sequence" type, will not be returned to the client. However, if "add" or "update" operation explicitly declares OperationBinding.cacheSyncOperation, cache sync request will be executed even if the user does not meet the security checks for the operationBinding. Note that field-level security still will be respected and disallowed fields will be excluded from returned data.
		 * Flags: IR, Group: auth */
		requiresRole?: string /* String */; // Flags=IR
		/** Optional schema describing how to extract DataSource records from the XML elements selected. Once a set of XML elements have been selected via recordXPath or recordName, those elements are normally transformed to JavaScript objects using the fields of the DataSource that owns the operationBinding. A responseDataSchema can be specified instead if the XML differs in some way between different DataSource operations, such that different values for DataSourceField.valueXPath','field.valueXPath may be necessary to extract the same DataSource record from slightly different XML structures.
		 * Flags: IRA, Group: clientDataIntegration */
		responseDataSchema?: DataSource; // Flags=IRA
		/** Scriptlet to be executed prior to the DataSource operation which is configured by this operationBinding. This setting overrides any DataSource.script','script specified at the DataSource level for this operation. Scriptlets are used similarly to DMIs configured via OperationBinding.serverObject - they can add business logic by modifying the DSRequest before it's executed, modifying the default DSResponse, or taking other, unrelated actions. Scriptlets are used similarly to DMIs configured via DataSource.serverObject or OperationBinding.serverObject - they can add business logic by modifying the DSRequest before it's executed, modifying the default DSResponse, or taking other, unrelated actions. For example: &lt;operationBindings&gt; &lt;operationBinding operationType="add"&gt; &lt;script language="groovy"&gt; ... Groovy code ... &lt;/script&gt; &lt;/operationBinding&gt; &lt;/operationBindings&gt; Scriptlets can be written in any language supported by the "JSR 223" standard, including Java itself. See the dmiOverview','DMI Script Overview for rules on how to return data, add additional imports, and other settings. The following variables are available for DMI scriptlets: dataSource: the current DataSource dsRequest: the current DSRequest criteria: shortcut to DSRequest.getCriteria() (a Map) values: shortcut to DSRequest.getValues() (a Map) oldValues: shortcut to DSRequest.getOldValues() (a Map) sqlConnection: SQLDataSource only: the current SQLConnection object. If using DataSource.autoJoinTransactions','automatic transactions are enabled, this SQLConnection is in the context of the current transaction. beanFactory: the spring BeanFactory (when applicable) cdiBeanManager: the CDI BeanManager (when applicable) Scriptlets also have access to a set of contextual variables related to the Servlets API, as follows: servletRequest: the current ServletRequest session: the current HttpSession rpcManager: the current RPCManager servletResponse: the current ServletResponse (advanced use only) servletContext: the current ServletContext(advanced use only) As with DMI in general, be aware that if you write scriptlets that depend upon these variables, you preclude your DataSource from being used in the widest possible variety of circumstances. For example, adding a scriptlet that relies on the HttpSession prevents your DataSource from being used in a command-line process. Note that if a dataSource configuration has both a &lt;script&gt; block and a specified OperationBinding.serverObject','serverObject for some operation, the script block will be executed, and the serverObject ignored.
		 * Flags: IR */
		script?: string /* String */; // Flags=IR
		/** This feature is available with Power or better licenses only. See <a href=http://smartclient.com/product>smartclient.com/product</a> for details. For a dataSource of DataSource.serverType','serverType "sql", this property can be specified on an operationBinding to provide the server with a bespoke SELECT clause to use when constructing the SQL query to perform this operation. The property should be a comma-separated list of column names and/or expressions, and you can refer to any scalar function supported by the underlying database. The server will insert the text of this property immediately after the "SELECT" token. Note that if you also specify a OperationBinding.groupClause','groupClause, you can use aggregate functions such as SUM and COUNT in the selectClause. This property is only applicable to operationBindings of OperationBinding.operationType','operationType "fetch". See the documentation for OperationBinding.customSQL for usage examples
		 * Flags: IR, Group: customQuerying */
		selectClause?: string /* String */; // Flags=IR
		/** The name of the method to invoke on the ServerObject for this operationBinding. NOTE: If you have a DataSource.serverObject','DataSource-level ServerObject and wish to override this operation so that it simply calls a different method on the same server object, it is sufficient to specify just this property on the operationBinding: there is no need to redefine the serverObject at the operationBinding level.
		 * Flags: IR */
		serverMethod?: string; // Flags=IR
		/** Optional ServerObject declaration that specifies the ServerObject configuration for this operationBinding. In the absence of a serverObject specification here, the one specified on the DataSource itself is used by default, if present (DataSource.serverObject). If neither is present, then Direct Method Invocation will not be enabled for this operationBinding. Note that if a dataSource configuration has both a OperationBinding.script','&lt;script&gt; block and a specified serverObject for some operation, the script block will be executed, and the serverObject ignored.
		 * Flags: IR */
		serverObject?: ServerObject; // Flags=IR
		/** Setting skipAudit to true indicates that DataSource.audit','auditing must be skipped for this operationBinding. Note, that this setting can be overrided by server-side API DSRequest.setSkipAudit().
		 * Flags: IR */
		skipAudit?: boolean; // Flags=IR
		/** A SQLDataSource will normally issue two queries for a "fetch" operation when paging is enabled: one to determine the total rows available (the "row count query"), and one to fetch the specific range of rows requested. Setting skipRowCount="true" will avoid the "row count query", but as a consequence DSResponse.totalRows will be set to match the requested DSRequest.endRow since the totalRows is unknown. You can avoid this by using a OperationBinding.sqlPaging','paging strategy of "jdbcScroll" or "dropAtServer", but be aware that these paging strategies can introduce significant delays when used with potentially large datasets (in fact, "dropAtServer" is almost guaranteed to do so if used with datasets of more than 1000 or so rows) As an alternative, consider enabling DataSource.progressiveLoading','progressive loading, which avoids doing a query for row counts, but will still allow the user to load more results using the scrollbar if viewing results in a ListGrid.
		 * Flags: IR */
		skipRowCount?: boolean; // Flags=IR
		/** For a DataSource contacting a DataSource.serviceNamespace','WSDL web service, setting this flag means the DataSource doesn't actually attempt to contact the server but generates a sample response instead, based on the XML Schema of the response message embedded in the WSDL. The spoofed response will include all complexType elements and will fill in appropriate values by type for all simpleType elements, although the spoofed data will not conform to all xs:restriction declarations (eg xs:pattern). Note that if your WSDL does not fully describe the response format (some WSDL services just have a placeholder &lt;xs:any&gt; element), SmartClient can only produce a partial response. To use a hand-generated sample response, just save an XML file to disk and use the OperationBinding.dataURL setting to point to it.
		 * Flags: IR, Group: clientDataIntegration */
		spoofResponses?: boolean; // Flags=IR
		/** The paging strategy to use for this specific OperationBinding. If this property is not set, we fall back to the DataSource.sqlPaging value, and the defaults described in the documentation for that property.
		 * Flags: IRW */
		sqlPaging?: SQLPagingStrategy; // Flags=IRW
		/** For dataSources of DataSource.serverType','serverType "sql" and "hibernate" only, this property determines whether "custom" operations have their custom SQL or HQL sent to the underlying database via a JDBC executeQuery() or a JDBC executeUpdate(). The default value of null means the same as "query", so you only need to use this property when your custom SQL or HQL updates data.
		 * Flags: IR, Group: customQuerying */
		sqlType?: SQLType; // Flags=IR
		/** If explicitly set true or false, forces the use of a "hint" in the SQL we generate for paged queries on or off as appropriate. If not set, defaults to the DataSource.sqlUsePagingHint value. Note this property is only applicable to DataSource.serverType','SQL DataSources, only when a DataSource.sqlPaging','paging strategy of "sqlLimit" is in force, and it only has an effect for those specific database products where we employ a native hint in the generated SQL in an attempt to improve performance.
		 * Flags: IR, Group: sqlPaging */
		sqlUsePagingHint?: boolean; // Flags=IR
		/** A mapping from field names to SummaryFunction','summary functions to be applied to each field. Valid only for an operation of type "fetch". See the serverSummaries','Server Summaries overview for examples of usage.
		 * Flags: IR, Group: serverSummaries */
		summaryFunctions?: any /* Object */; // Flags=IR
		/** This feature is available with Power or better licenses only. See <a href=http://smartclient.com/product>smartclient.com/product</a> for details. For a dataSource of DataSource.serverType','serverType "sql", this property can be specified on an operationBinding to provide the server with a bespoke table clause to use when constructing the SQL query to perform this operation. The property should be a comma-separated list of tables and views, and you can use any special language constructs supported by the underlying database. The server will insert the text of this property immediately after the "FROM" token. See the documentation for OperationBinding.customSQL for usage examples
		 * Flags: IR, Group: customQuerying */
		tableClause?: string /* String */; // Flags=IR
		/** If set to "false", transformation of values for DataSourceField.multiple','multiple:true fields, normally controlled by DataSourceField.multipleStorage, is instead disabled for this OperationBinding.
		 * Flags: IR, Group: multipleField */
		transformMultipleFields?: boolean; // Flags=IR
		/** Setting useFlatFields on an operationBinding is equivalent to setting DSRequest.useFlatFields on all DataSource requests with the same OperationBinding.operationType as this operationBinding. Typical usage is to combine operationBinding.useFlatFields with DataBoundComponent.useFlatFields','searchForm.useFlatFields, with the SearchForm bound to the WebService.getInputDS','input message of the web service operation set as OperationBinding.wsOperation. This allows gratuitous nesting to be consistently bypassed in both the user presentation and in the actual XML messaging. Note that useFlatFields is not generally recommended for use with input messages where multiple simple type fields exist with the same name, however if used in this way, the first field to use a given name wins. "first" means the first field encountered in a depth first search. "wins" means only the first field will be available in data binding, and only the first field will be populated in the generated XML message.
		 * Flags: IR, Group: clientDataIntegration */
		useFlatFields?: boolean; // Flags=IR
		/** For an operationBinding of OperationBinding.operationType','operationType "fetch" which specifies no OperationBinding.operationId','operationId, this property determines whether the operationBinding should be used for cache synchronization purposes (ie, to retrieve the record most recently added or changed). This property has no effect on an operationBinding that specifies an operationId - see OperationBinding.cacheSyncOperation. In order to work correctly with SmartClient's cache synchronization system, an operationBinding marked useForCacheSync should have the following properties: Able to complete its retrieval using no context other than the values of the primary key fields declared in the dataSource (these will be provided in the $criteria object passed to the operation) Returns the entire record, including any values that may require joins to other tables or other complexities This property is only applicable to DataSources of type "sql".
		 * Flags: IR, Group: customQuerying */
		useForCacheSync?: boolean; // Flags=IR
		/** Whether to use the RPCManager.sendProxied','HttpProxy servlet to send requests described by this operationBinding. If unset, automatically detects whether using the HttpProxy is necessary based on the same-origin policy. Valid only with OperationBinding.dataProtocol settings other than ISCServer.
		 * Flags: IR, Group: clientDataIntegration */
		useHttpProxy?: boolean; // Flags=IR
		/** Sets or clears the useSpringTransaction flag for this specific operation. See DataSource.useSpringTransaction for details of the Spring transaction integration feature
		 * Flags: IR */
		useSpringTransaction?: boolean; // Flags=IR
		/** Whether to use the subselect technique (see DataSource.useSubselectForRowCount for details) to derive a rowcount query for this operation. If this property is not set, we fall back to the useSubselectForRowCount setting on the DataSource, and the defaults described in the documentation for that property.
		 * Flags: IRW */
		useSubselectForRowCount?: boolean; // Flags=IRW
		/** Elements of this feature are only available with Power or better licenses. See <a href=http://smartclient.com/product>smartclient.com/product</a> for details. A list of DSRequestModifiers that will be used to modify the values object of each DSRequest that uses this operationBinding. See this example: queuedAdd. Below example of the xml as it should be defined in ds.xml: &lt;operationBinding operationType="add"&gt; &lt;values fieldName="orderID" value="$responseData.last('queuedAdd_order','add').orderID" /&gt; &lt;/operationBinding&gt;
		 * Flags: IR, Group: transactionChaining */
		values?: Array<DSRequestModifier> /* Array of DSRequestModifier */; // Flags=IR
		/** This feature is available with Power or better licenses only. See <a href=http://smartclient.com/product>smartclient.com/product</a> for details. For a dataSource of DataSource.serverType','serverType "sql", this property can be specified on an operationBinding to provide the server with a bespoke set of values to add or update, for use when constructing the SQL query to perform this operation. The property should be one of the following, depending on the OperationBinding.operationType','operationType: For "add" operations, the syntax that would be valid for an INSERT INTO query: a comma-separated list of column names enclosed in parentheses, followed by a comma-separated list of new values, enclosed in parentheses and preceded by the token "VALUES". For example: &lt;valuesClause&gt;(name, age) VALUES("Jane Doe", 48)&lt;/valuesClause&gt; For "update" operations, the syntax that would be valid for an UPDATE query: a comma-separated list of expressions equating a column name to its new value. For example: &lt;valuesClause&gt;name="Jane Doe", age=48&lt;/valuesClause&gt; You may find the SmartClient-provided $values variable of particular use with this property. See the documentation for OperationBinding.customSQL for usage examples
		 * Flags: IR, Group: customQuerying */
		valuesClause?: string /* String */; // Flags=IR
		/** This feature is available with Power or better licenses only. See <a href=http://smartclient.com/product>smartclient.com/product</a> for details. For a dataSource of DataSource.serverType','serverType "sql", this property can be specified on an operationBinding to provide the server with a bespoke WHERE clause to use when constructing the SQL query to perform this operation. The property should be a valid expression in the syntax of the underlying database. The server will insert the text of this property immediately after the "WHERE" token. You may find the SmartClient-provided $criteria variable of particular use with this property. See the documentation for OperationBinding.customSQL for usage examples
		 * Flags: IR, Group: customQuerying */
		whereClause?: string /* String */; // Flags=IR
		/** Name of the web service operation that will be invoked in order to execute this DataSource operation. Valid only for a DataSource that has a WebService (DataSource.serviceNamespace is set). Otherwise, use OperationBinding.dataURL. Setting wsOperation means that DSRequest.data will be serialized as the request message for the specified web service operation, with namespacing and soap encoding handled automatically. See DataSource.transformRequest for how to customize what data is sent to the server.
		 * Flags: IR, Group: clientDataIntegration */
		wsOperation?: string /* String */; // Flags=IR
		/** Optional object declaring namespace prefixes for use in OperationBinding.recordXPath and DataSourceField.valueXPath XPath expressions. xmlNamespaces should be specified as a mapping from namespace prefix to namespace URI, for example: xmlNamespaces : { az : "http://webservices.amazon.com/AWSECommerceService/2005-03-23" } By default, all namespaces declared on the document element (outermost element of the response) are made available with the prefix used in the document itself. Then, for non-WSDL-described XML results, if there is a default namespace on the document element, it is made available with the special prefix "default". For results of WSDL-described operations, the prefix "service" means the service namespace, that is, the "targetNamespace" on the &lt;definitions&gt; element from the WSDL file. The prefix "schema" means the namespace of the outermost element in the output message for the current operation. "default" will be the schema namespace if there is one, otherwise the service namespace. For basic information on XML Namespaces and their use in XPath, try the following search: <a href="http://www.google.com/search?q=XPath+xml+namespaces" target="_blank" >http://www.google.com/search?q=XPath+xml+namespaces</a>
		 * Flags: IR, Group: clientDataIntegration */
		xmlNamespaces?: any /* Object */; // Flags=IR
	} // OperationBindingProps


	/**
	 * An operationBinding tells a DataSource how to execute one of the basic DS operations: fetch, add, update, remove. See DataSource.operationBindings. 
	 */
	export interface OperationBinding  {
		/** This property indicates whether this operation supports AdvancedCriteria. This setting overrides DataSource.allowAdvancedCriteria for this operation only. See DataSource.supportsAdvancedCriteria for further information. NOTE: If you specify this property in a DataSource descriptor (.ds.xml file), it is enforced on the server. This means that if you run a request containing AdvancedCriteria against an OperationBinding that advertises itself as allowAdvancedCriteria:false, it will be rejected.
		 * Flags: IRWA */
		allowAdvancedCriteria: boolean;

		/** Ordinarily, "update" and "remove" operations are only allowed for DataSources that have a DataSourceField.primaryKey','primaryKey, and all primary key values are present in the request. This is because an update of a DataSource with no primary key, or an update request that has missing primary key values, cannot be guaranteed to affect only one record. Setting this property on an operationBinding circumvents this restriction for that operation only. Warning: Be aware that this is a potentially dangerous setting and should be used with care. With this flag set, you have no guarantee that an update will not change or remove every row in a table. Also, running allowMultiUpdate operations directly from the client is not straightforward because it requires the ability to specify criteria and values separately in the request, which is not currently supported. This can be worked around in various ways, but really allowMultiUpdate is primarily intended for server-side operations. Therefore, the recommended pattern is to use a DataSource.performCustomOperation','custom operation from the client to invoke a DMI on the server which performs the multi-update operation via a second, server-side DSRequest.
		 * Flags: IR */
		allowMultiUpdate: boolean;

		/** If true, causes requests against this operation to automatically start or join a transaction. if false, causes requests against this operation to be committed individually. If null, falls back to DataSource.autoJoinTransactions. See DataSource.autoJoinTransactions for further details of SmartClient's automatic transaction control.
		 * Flags: IR */
		autoJoinTransactions: boolean;

		/** A per-operationBinding setting for beanClassName, otherwise also settable at the top-level DataSource configuration.
		 * Flags: IR, Group: clientDataIntegration */
		beanClassName: string /* String */;

		/** For an operationBinding of OperationBinding.operationType','operationType "add" or "update", this property is the OperationBinding.operationId','operationId of a "fetch" operationBinding to use for cache synchronization purposes (ie, to fetch the row most recently added or changed). This property, along with OperationBinding.useForCacheSync','useForCacheSync and OperationBinding.canSyncCache','canSyncCache is provided so that you can use custom database operations without sacrificing the benefits of SmartClient's automatic cache synchronization. This property is only applicable to DataSources of type "sql".
		 * Flags: IR, Group: customQuerying */
		cacheSyncOperation: string /* String */;

		/** Applies only to dataFormat: "json". Specifies the name of the query parameter that tells your JSON service what function to call as part of the response for this operation. Typically set once for the DataSource as a whole via DataSource.callbackParam.
		 * Flags: IR, Group: clientDataIntegration */
		callbackParam: string /* String */;

		/** For an operation of type "add" or "update", a SQLDataSource will normally obtain data to return to the client by performing the "cacheSyncOperation": a SELECT statement that retrieves the modified record by primary key. This accommodates sequence columns, columns with default values, database triggers and other database features that may modify data after insertion or update. Certain major SQL customizations can prevent the SQLDataSource from authoritatively determining the primary key used in the SQL statement, such that re-selecting the saved record may fail. By default, when canSyncCache has not been explicitly set, in the following cases it is assumed that the normal cacheSyncOperation cannot be used: &lt;customSQL&gt; has been used to define an entirely custom query a custom &lt;whereClause&gt; has been defined for an "update" or "remove" operation a custom &lt;valuesClause&gt; has been defined for an "add" operation If any of these cases apply or if canSyncCache has been set false, the server will skip the cacheSyncOperation and return a DSResponse where DSResponse.invalidateCache has been set to true to notify client-side components that they may need to refresh their entire cache. Alternatively, if the default re-selection behavior will not work but a customized SQL query would work, you can define that SQL operation as another operationBinding and use OperationBinding.cacheSyncOperation to declare that it should be used. Setting cacheSyncOperation implicitly sets canCacheSync to true. This property is only applicable to DataSources of type "sql".
		 * Flags: IR, Group: customQuerying */
		canSyncCache: boolean /* Boolean */;

		/** Indicates that field-level declarative security rules are waived for rows that were created by the current user, as described in the discussion of DataSource.creatorOverrides','dataSource.creatorOverrides. This setting overrides dataSource.creatorOverrides, for this operation only.
		 * Flags: IR, Group: fieldLevelAuth */
		creatorOverrides: boolean;

		/** Elements of this feature are only available with Power or better licenses. See <a href=http://smartclient.com/product>smartclient.com/product</a> for details. A list of DSRequestModifiers that will be used to modify the criteria of each DSRequest that uses this operationBinding. Note that the criteria elements are applied to DSRequest criteria as follows: Simple criteria: The field and value are just applied as an extra key/value pair in the criteria map, as long as the DSRequestModifier.operator','operator attribute is left unset, or is set to "equals". For any other setting of operator, the criteria is first converted to the equivalent AdvancedCriteria and then processed as described below AdvancedCriteria: If the topmost operator is "and", we add the new criterion as an additional criterion directly in the existing list. Otherwise, we create a new top-level AdvancedCriteria with an operator of "and". This is then set to have two elements in its criteria: the previous top-level criteria and the new criterion. The effect of this is to apply any criteria specifed here as additional constraints on top of what the user has specified, and of course, the user is unable to affect this. Thus, this is a suitable and convenient place to enforce rules such as "Users can only ever see their own records". Below is an example of the XML as it should be defined in your ds.xml, datasource definitions. &lt;operationBindings&gt; &lt;operationBinding operationType="fetch" operationId="..."&gt; &lt;criteria fieldName="USER_ROLE" value="ADMIN" operator="equals" /&gt; &lt;/operationBinding&gt; &lt;/operationBindings&gt;
		 * Flags: IR, Group: transactionChaining */
		criteria: Array<DSRequestModifier> /* Array of DSRequestModifier */;

		/** Indicates that the listed fields should be included in the default OperationBinding.whereClause','whereClause generated for this operationBinding, even if they are marked DataSourceField.customSQL','customSQL="true". You can specify this property as a comma-separated list (eg, "foo, bar, baz") or by just repeating the &lt;customCriteriaFields&gt; tag multiple times with one field each. This property is only applicable to DataSources of DataSource.serverType','"sql".
		 * Flags: IR, Group: customQuerying */
		customCriteriaFields: string | Array<any> /* String or Array */;

		/** Indicates that the listed fields should be included in the default OperationBinding.selectClause','selectClause and OperationBinding.selectClause','whereClause generated for this operationBinding, even if they are marked DataSourceField.customSQL','customSQL="true". If you need to apply different sets of overrides for the selectClause and the whereClause, use OperationBinding.customValueFields','customValueFields and/or OperationBinding.customCriteriaFields','customCriteriaFields instead. If you specify both customFields and customCriteriaFields or customValueFields, the more specific variant wins. If you specify both customFields and OperationBinding.excludeCriteriaFields','excludeCriteriaFields, customFields wins (this is another use case when you may wish to use customValueFields instead) You can specify this property as a comma-separated list (eg, "foo, bar, baz") or by just repeating the &lt;customFields&gt; tag multiple times with one field each. This property is only applicable to DataSources of DataSource.serverType','"sql".
		 * Flags: IR, Group: customQuerying */
		customFields: string | Array<any> /* String or Array */;

		/** This feature is available with Power or better licenses only. See <a href=http://smartclient.com/product>smartclient.com/product</a> for details. For a dataSource of DataSource.serverType','serverType "hibernate", this property can be specified on an operationBinding to indicate that the server should run user-specified HQL (Hibernate Query Language), rather than the Hibernate criteria query or saveOrUpdate call it would normally generate to satisfy a dataSource operation via Hibernate. Note that inserting new records via HQL is often impractical, due to intentional restrictions in the language (it is only possible to perform an insert expressed in terms of a SELECT; the "VALUES" construct commonly used when inserting new rows singly is not supported). If you are intending to use customHQL, we recommend that you avoid doing so for OperationBindings with OperationBinding.operationType','operationType "add", unless you have a special requirement such as a bulk insert; if you need custom queries to perform inserts on "hibernate" dataSources, we recommend you use OperationBinding.customSQL','customSQL, which is valid for "hibernate" DataSources as well as "sql" dataSources. For other operations on "hibernate" dataSources, however, HQL has the advantage of being more portable across different database engines than is plain SQL. Note that using customHQL affects paging implementation. If you use it, full data set is fetched from Hibernate and records that aren't in the requested range are dropped at the server side.
		 * Flags: IR, Group: customQuerying */
		customHQL: string /* String */;

		/** This feature is available with Power or better licenses only. See <a href=http://smartclient.com/product>smartclient.com/product</a> for details. For a dataSource of DataSource.serverType','serverType "jpa", this property can be specified on an operationBinding to indicate that the server should run user-specified JQL (Java Persistence Query Language). Note that inserting new records via JQL is often impractical, due to intentional restrictions in the language (it is only possible to perform an insert expressed in terms of a SELECT; the "VALUES" construct commonly used when inserting new rows singly is not supported). If you are intending to use customJQL, we recommend that you avoid doing so for OperationBindings with OperationBinding.operationType','operationType "add", unless you have a special requirement such as a bulk insert; if you need custom queries to perform inserts on "jpa" dataSources, we recommend you use OperationBinding.customSQL','customSQL, which is valid for "jpa" DataSources as well as "sql" dataSources. For other operations on "jpa" dataSources, however, JQL has the advantage of being more portable across different database engines than is plain SQL. Note that using customJQL affects paging implementation. If you use it, full data set is fetched from JPA and records that aren't in the requested range are dropped at the server side.
		 * Flags: IR, Group: customQuerying */
		customJQL: string /* String */;

		/** This feature is available with Power or better licenses only. See <a href=http://smartclient.com/product>smartclient.com/product</a> for details. For a dataSource of DataSource.serverType','serverType "sql" or "hibernate", this property can be specified on an operationBinding to indicate that the server should run user-specified SQL, rather than the query it would normally generate to satisfy a dataSource operation. This property allows you to provide a fully-customized query; an alternative is to provide custom "pieces" to the query generator, via properties such as OperationBinding.whereClause','whereClause and OperationBinding.valuesClause','valuesClause. See the customQuerying for more details. For a dataSource of type "sql", the SmartClient server generates a number of useful DefaultQueryClause','query "pieces", and makes them available to your custom SQL code via the Velocity templating language (note that this is not available for "hibernate" dataSources). We also make the template variables $criteria and $values available, to give you direct access to the supplied criteria, and to the new field values for update and add operations. These variables are available to both "sql" and "hibernate" dataSources. Note that you should use this feature with care. In particular, writing customSQL code that makes use of a particular database engine's features or syntax will make your application less portable. See customQuerying for an overview of writing custom queries and clauses. <h3>Examples</h3> An example using the SmartClient-supplied query pieces. This custom query will give exactly the same result as the SmartClient-generated query: &lt;operationBinding operationId="customFetch" operationType="fetch"&gt; &nbsp;&nbsp;&lt;customSQL&gt; &nbsp;&nbsp;&nbsp;&nbsp;SELECT $defaultSelectClause FROM $defaultTableClause WHERE $defaultWhereClause ORDER BY $defaultOrderClause &nbsp;&nbsp;&lt;/customSQL&gt; &lt;/operationBinding&gt; An example using the SmartClient-supplied $criteria template variable: &lt;operationBinding operationId="customFetch" operationType="fetch"&gt; &nbsp;&nbsp;&lt;customSQL&gt; &nbsp;&nbsp;&nbsp;&nbsp;SELECT foo, bar, baz FROM MyTable WHERE bar &gt; $criteria.someValue &nbsp;&nbsp;&lt;/customSQL&gt; &lt;/operationBinding&gt; An update example: &lt;operationBinding operationId="myUpdateOp" operationType="update"&gt; &nbsp;&nbsp;&lt;customSQL&gt; &nbsp;&nbsp;&nbsp;&nbsp;UPDATE $defaultTableClause SET $defaultValuesClause WHERE bar &lt;= $criteria.someValue &nbsp;&nbsp;&lt;/customSQL&gt; &lt;/operationBinding&gt; 
		 * Flags: IR, Group: customQuerying */
		customSQL: string /* String */;

		/** Indicates that the listed fields should be included in the default OperationBinding.selectClause','selectClause generated for this operationBinding, even if they are marked DataSourceField.customSQL','customSQL="true". You can specify this property as a comma-separated list (eg, "foo, bar, baz") or by just repeating the &lt;customValueFields&gt; tag multiple times with one field each. This property is only applicable to DataSources of DataSource.serverType','"sql".
		 * Flags: IR, Group: customQuerying */
		customValueFields: string | Array<any> /* String or Array */;

		/** Format for response data for this operation. Typically set once for the DataSource as a whole via DataSource.dataFormat.
		 * Flags: IR, Group: clientDataIntegration */
		dataFormat: DSDataFormat;

		/** Controls the format in which inputs are sent to the dataURL. When a DataSource operation such as fetchData() is invoked on this DataSource or a component bound to this DataSource, the data passed to the operation, if any, will be sent to the dataURL. The dataProtocol property controls the format in which the data is sent: SOAP message, HTTP GET or POST of parameters, etc. The dataProtocol property need not be set for a DataSource with a WebService ( DataSource.serviceNamespace is set), in this case, SOAP messaging is used by default. Developers may completely bypass the SmartClient comm system by setting dataProtocol to "clientCustom". In this case SmartClient will not attempt to send any data to the server after calling DataSource.transformRequest. Instead the developer is expected to implement transformRequest() such that it performs the necessary data action outside of SmartClient, and then calls DataSource.processResponse, passing in the DSRequest.requestId and an appropriate set of DSResponse properties to indicate the result of the action. NOTE: when OperationBinding.dataFormat is "iscServer", dataProtocol is not consulted. Instead, SmartClient uses a proprietary wire format to communicate with the SmartClient server, and the server-side DSRequest and DSResponse objects should be used to access request data and form responses.
		 * Flags: IR, Group: clientDataIntegration */
		dataProtocol: DSProtocol;

		/** Transport to use for this operation. Defaults to DataSource.dataTransport, which in turn defaults to RPCManager.defaultTransport. This would typically only be set to enable "scriptInclude" transport for contacting DataSource.dataFormat','JSON web services hosted on servers other than the origin server. When using the "scriptInclude" transport, be sure to set DataSource.callbackParam or OperationBinding.callbackParam to match the name of the query parameter name expected by your JSON service provider.
		 * Flags: IR, Group: clientDataIntegration */
		dataTransport: RPCTransport;

		/** URL to contact to fulfill DSRequests for this operationBinding. dataURL is typically set as DataSource.dataURL rather than on each individual operationBinding. dataURL can be omitted for a DataSource using a Web Service (DataSource.serviceNamespace is set).
		 * Flags: IR, Group: clientDataIntegration */
		dataURL: string /* URL */;

		/** HTTP parameters that should be submitted with every DSRequest. Useful for authenticated services that require a sessionId with every request. Can be set for all operations of a given DataSource as DataSource.defaultParams.
		 * Flags: IRA, Group: clientDataIntegration */
		defaultParams: any /* Object */;

		/** Indicates that the listed fields should be excluded from the default OperationBinding.whereClause','whereClause generated for this operationBinding. This enables you to use these fields in a customQuerying','custom query while still allowing the $defaultWhereClause to be generated for all other fields. For example, you might take a particular field and apply it in the WHERE clause of a subquery. You can specify this property as a comma-separated list (eg, "foo, bar, baz") or by just repeating the &lt;customCriteriaFields&gt; tag multiple times with one field each. Note that if a field is included in both excludeCriteriaFields and OperationBinding.customCriteriaFields','customCriteriaFields, customCriteriaFields wins. This property is only applicable to DataSources of DataSource.serverType','"sql".
		 * Flags: IR, Group: customQuerying */
		excludeCriteriaFields: string | Array<any> /* String or Array */;

		/** The format in which the data should be exported. Default is "csv". See ExportFormat for more information.
		 * Flags: IR */
		exportAs: ExportFormat;

		/** The list of field-names to export. If provided, the field-list in the exported output is limited and sorted as per the list. If exportFields is not provided, the exported output includes all visible fields from the DataSource (field.hidden=false), sorted in the order they're defined.
		 * Flags: IR */
		exportFields: Array<any> /* Array */;

		/** The name of the file to save the exported data into.
		 * Flags: IR */
		exportFilename: string /* String */;

		/** When set, causes the results of the DataSource Operation to be exported to a file, whose name and format are indicated by OperationBinding.exportFilename and OperationBinding.exportAs respectively. When no exportFilename is provided, the default is Results and the default value of exportAs is csv. Once the Operation completes, DSRequest.exportDisplay specifies whether the exported data will be downloaded to the file-system or displayed in a new window. The default value of exportDisplay is "download" which displays the Save As dialog. See ExportDisplay for more information. The export field-list can also be configured, see DSRequest.exportFields. You can also configure the style of line-breaks to use when generating the output. See LineBreakStyle for more information. As well as setting this and other properties on the OperationBinding, Exports can be initiated in two other ways. You can set properties on the dsRequest by passing requestProperties into DataSource.exportData. Note that this method does not support exporting to JSON format (see <a href="http://forums.smartclient.com/showthread.php?t=235">this post</a> for more detail). Additionally, custom server code may set export-related properties on the DSResponse. Format Examples XML format &lt;List&gt; &lt;Object&gt; &lt;id&gt;10101&lt;/id&gt; &lt;displayName&gt;Record 10101&lt;/displayName&gt; &lt;/Object&gt; &lt;/List&gt; JSON Format [ { id: 10101, displayName: "Record 10101" } ] CSV Format id,displayName 10101,"Record 10101" 
		 * Flags: IR */
		exportResults: boolean;

		/** List of fields to group by when using serverSummaries','server-side summarization. Valid only for an operation of type "fetch". See the serverSummaries','Server Summaries overview for details and examples of usage.
		 * Flags: IR, Group: serverSummaries */
		groupBy: Array<string> /* Array of String */;

		/** This feature is available with Power or better licenses only. See <a href=http://smartclient.com/product>smartclient.com/product</a> for details. For a dataSource of DataSource.serverType','serverType "sql", this property can be specified on an operationBinding to provide the server with a bespoke GROUP BY clause to use when constructing the SQL query to perform this operation. The property should be a comma-separated list of column names and/or expressions, forming a valid GROUP BY clause in the syntax of the underlying database. The server will insert the text of this property immediately after the "GROUP BY" token. Note that specifying this property enables you to use aggregate functions (such as COUNT and SUM) in your OperationBinding.selectClause','selectClause. Also note that care is required when using groupClause to ensure that the selectClause contains the fields you are grouping by. Failure to do this correctly will result in a runtime SQL error. This property is only applicable to operationBindings of OperationBinding.operationType','operationType "fetch". See the documentation for OperationBinding.customSQL for usage examples
		 * Flags: IR, Group: customQuerying */
		groupClause: string /* String */;

		/** Value to use for the OperationBinding.ownerIdField','ownerIdField if no one has authenticated. Overrides the same setting at the DataSource.guestUserId','DataSource level.
		 * Flags: IR */
		guestUserId: string;

		/** If set, every invocation of this operationBinding will invalidate the local cache, forcing a server visit to refresh the data.
		 * Flags: IR */
		invalidateCache: boolean;

		/** The style of line-breaks to use in the exported output. See LineBreakStyle for more information.
		 * Flags: IR */
		lineBreakStyle: string /* String */;

		/** Definition of an email message that will be sent as an after-effect of selecting or updating data. Note that if a fixed number of different messages need to be sent, multiple &lt;mail&gt; tags may be specified. For example, one mail could be sent to an admin address, and a different message to every member of a user group.
		 * Flags: IR, Group: mail */
		mail: Mail;

		/** You can explicitly declare the arguments to be passed to OperationBinding.serverMethod using this attribute. This isn't required - in the absence of methodArguments, the DMI implementation will still automatically pass a stock set of arguments to your method (see the overview in ServerObject), but specifying arguments gives you the ability to call pre-existing methods without adding SmartClient-specific code. The format for specifying methodArguments is as a comma separated list of VTL (Velocity Template Language) expressions. See the <a href='http://jakarta.apache.org/velocity/docs/vtl-reference-guide.html' target='_blank'>VTL Reference</a> and <a href='http://jakarta.apache.org/velocity/docs/user-guide.html' target='_blank'>Velocity User Guide</a> for an overview of how to use VTL. The Velocity context is pre-populated with the following variables - you can pass these verbatim as arguments, or call methods on these objects and pass the resulting values: dsRequest: instance of the current DSRequest request: the current HttpServletRequest response: the current HttpServletResponse rpcManager: the instance of RPCManager for this request dataSource: a DataSource instance for this request So, for example, if you had a method signature like the following: public DSResponse fetch(SupplyItem criteria, long startRow, long endRow) You can invoke it by specifying methodArguments as follows: methodArguments="$dsRequest.criteria, $dsRequest.startRow, $dsRequest.endRow" Without methodArguments, there would be no way for you to specify startRow/endRow as arguments. You could, of course, simply declare the method to take a DSRequest object and call getStartRow()/getEndRow() in the body of the method.
		 * Flags: IR */
		methodArguments: string;

		/** This feature is available with Power or better licenses only. See <a href=http://smartclient.com/product>smartclient.com/product</a> for details. For a dataSource of DataSource.serverType','serverType "jpa" or "hibernate", this property can be specified on an operationBinding to indicate that the server should execute a named query which has already been defined on an entity. &#64;Entity &#64;Table (name="Countries") &#64;NamedQuery(name = "Country.withPopulationLessThan", query = "SELECT country FROM Country country WHERE country.population &lt; :population") public class Country { ... } &lt;operationBindings&gt; &lt;operationBinding operationType="custom" operationId="withPopulationLessThan" namedQuery="Country.withPopulationLessThan"/&gt; &lt;/operationBindings&gt; Substitution values can be used in order to build more dynamic named queries. When calling DataSource.performCustomOperation the values are passed in using the data argument. Note that value substitution for named queries is slightly different to other custom queries. Because of the way the persistence API works the JQL query written in the &#64;NamedQuery annotation can only contain basic parameter names such as "population". Therefore the value substitution becomes a simple name based mapping. <h3>Examples</h3> Using Simple Criteria<br /> <br /> An example using a simple criteria for the above defined Country entity. In this case the named query parameter ":population" will be swapped out for the value of the criteria objects "population" field. var criteria = { population: 596000 }; countryDataSource.performCustomOperation("withPopulationLessThan", criteria); Using Advanced Criteria<br /> <br /> If an advanced criteria is detected, access to all "fieldName" variables and their values will be provided but still using simple name based mapping. In the below case only the deep-first occurrence of the "population" fieldName will available. The operator is effectively ignored. var criteria = { _constructor: "AdvancedCriteria", operator:"or", criteria:[ { fieldName:"population", operator:"lessThan", value: 12000 }, { fieldName:"name", operator:"equals", value: "Sweden" }, { _constructor: "AdvancedCriteria", operator:"and", criteria:[ { fieldName:"population", operator:"lessThan", value: 0 } ] } ] }; countryDataSource.performCustomOperation("withPopulationLessThan", criteria); Note<br /> Using namedQuery affects paging implementation. If you use it, full data set is fetched from JPA and records that aren't in the requested range are dropped at the server side.
		 * Flags: IR, Group: customQuerying */
		namedQuery: string /* String */;

		/** Optional operationId if this DataSource supports two or more variants of one of the basic DataSource operations, for instance, a "fetch" that uses full text search and a "fetch" that accepts per-field search criteria. See DSRequest.operationId for usage.
		 * Flags: IR, Group: clientDataIntegration */
		operationId: string /* String */;

		/** Which operationType this operationBinding is for. This property is only settable on an operationBinding, not a DataSource as a whole.
		 * Flags: IR, Group: clientDataIntegration */
		operationType: DSOperationType;

		/** This feature is available with Power or better licenses only. See <a href=http://smartclient.com/product>smartclient.com/product</a> for details. For a dataSource of DataSource.serverType','serverType "sql", this property can be specified on an operationBinding to provide the server with a bespoke ORDER BY clause to use when constructing the SQL query to perform this operation. The property should be a comma-separated list of column names and/or expressions, forming a valid ORDER BY clause in the syntax of the underlying database. The server will insert the text of this property immediately after the "ORDER BY" token. This property is only applicable to operationBindings of OperationBinding.operationType','operationType "fetch". See the documentation for OperationBinding.customSQL for usage examples
		 * Flags: IR, Group: customQuerying */
		orderClause: string /* String */;

		/** Specifies, for this operationBinding only, the list of field names that should be returned to the client. Typically this will be a subset of the DataSource.fields, but note that this is not a requirement; outputs can include fields that are not defined in the DataSource's field list. In this case, the server will return extra fields even if DataSource.dropExtraFields is true. You specify this property as a string containing a comma-separated list of field names (eg, "foo, bar, baz")
		 * Flags: IR */
		outputs: string /* String */;

		/** Requires that the currently authenticated user match the contents of this field, for client-initiated requests (i.e., where DSRequest.isClientRequest() returns true on the server). When a new row is added by a client-initiated DSRequest, the ownerIdField will be automatically populated with the currently authenticated user (clobbering any value supplied by the client). Client-initiated attempts to update the ownerIdField will also be prevented. If you wish to set the ownerIdField to a different value via an "add" or "update" operation, you can do so in server-side DMI code (possibly consulting DSRequest.getClientSuppliedValues() to get the value that was clobbered). For client-initiated "fetch", "update" or "remove" operations, the server will modify client-supplied criteria so that only rows whose ownerIdField matches the currently authenticated user can be read, updated or deleted. Overrides the same setting at the DataSource.ownerIdField','DataSource level. If ownerIdField is specified, DataSource.requiresAuthentication','requiresAuthentication will default to true. If requiresAuthentication is explicitly set to false, then unauthenticated users will be able to see all records. To avoid this, you can use DataSource.guestUserId','guestUserId to specify a default user to apply when no one has authenticated.
		 * Flags: IR */
		ownerIdField: string;

		/** Configures DataSource.preventHTTPCaching on a per-operationType basis.
		 * Flags: IR */
		preventHTTPCaching: boolean;

		/** Sets DataSource.progressiveLoading','progressive loading mode for this particular operation, overriding the DataSource-level setting. Note that this setting applies only to fetch operations - it has no effect if specified on any other kind of operation.
		 * Flags: IRW, Group: progressiveLoading */
		progressiveLoading: boolean;

		/** Ordinarily, "update" and "remove" operations are only allowed if all primary key values are present in the request. This is because an update request that has missing primary key values cannot be guaranteed to affect only one record. Setting this property on an operationBinding circumvents this restriction for that operation only. Note, this property differs from OperationBinding.allowMultiUpdate','allowMultiUpdate in its intent: allowMultiUpdate tells the framework that this operation deliberately affects multiple records; providesMissingKeys tells the framework that this operation will only affect one record, and will ensure this by providing values for missing keys during its operation. Unlike allowMultiUpdate, setting this flag does not cause component caches to be ListGrid.invalidateCache','invalidated Providing values for missing keys can be done in various ways: Operations that specify &lt;OperationBinding.customSQL','customSQL&gt; or &lt;OperationBinding.whereClause','whereClause&gt; can provide missing key values from session storage or elsewhere in the provided record Operations that specify &lt;serverScript','script&gt; can provide arbitrary code to manipulate the record in whatever way they like before executing the underlying built-in functionality Operations can specify &lt;OperationBinding.criteria','criteria&gt; to provide missing keys A request can contain DSRequest.fieldValueExpressions','fieldValueExpressions, which can be used to provide values for missing keys Note, you can also use a regular dmiOverview','DMI to arbitrarily manipulate the record sent from the client, including providing values for any missing keys. If you do this, you do not need to specify providesMissingKeys because the request is not validated for the presence of key values until after the DMI has run. Warning: Be aware that this is a potentially dangerous setting and should be used with care. With this flag set, the framework cannot guarantee that an update will not change or remove every row in a table: it becomes your code's responsibility to ensure that all PK values are provided to the operation by the time it actually needs them.
		 * Flags: IR */
		providesMissingKeys: boolean;

		/** Specifies, for this specific operationBinding, whether to qualify column names with table names in any SQL we generate. Overrides the DataSource.qualifyColumnNames property. Only applicable to dataSources of DataSource.serverType','serverType "sql".
		 * Flags: IR */
		qualifyColumnNames: boolean;

		/** For an XML DataSource, tagName of the elements to be used as records. This is a simple alternative to OperationBinding.recordXPath when the elements to be used as records all share a tagName. When a DataSource has a WebService, recordName can also be set to the name of any complexType declared within the WebService's WSDL file.
		 * Flags: IR, Group: clientDataIntegration */
		recordName: string /* String */;

		/** For an XML or JSON DataSource, XPath expression used to retrieve the objects that will become DataSource records. For example, an "ItemSearch" web service might return a "Results" structure containing metadata along with the set of Items that one might want to display in a grid. An XPath expression like "/Results/Items" could be used to retrieve just the Items, which would then become DataSource records. For a JSON web service, the recordXPath is applied to the returned JSON data via XMLTools.selectObjects. Only limited XPath syntax is allowed; see XMLTools.selectObjects','selectObjects() for details. For processing XML results, see OperationBinding.xmlNamespaces for information on the namespaces that are available in this XPath expression. If you are contacting a WSDL web service, note that OperationBinding.recordName is an alternative way to specify which records should be selected by their tagName or type, and this is usually simpler. To learn about XPath, try the following search: <a href="http://www.google.com/search?q=xpath+tutorial" target="_blank" >http://www.google.com/search?q=xpath+tutorial</a>
		 * Flags: IR, Group: clientDataIntegration */
		recordXPath: string /* XPathExpression */;

		/** Additional properties to pass through to the DSRequest created for this operation. Note that these will be cumulative with and will override on a per-property basis any properties set via DataSource.requestProperties. These properties are applied before DataSource.transformRequest is called.
		 * Flags: IR, Group: clientDataIntegration */
		requestProperties: DSRequestProps /* DSRequest Properties */;

		/** Indicates that the specified VelocityExpression must be true for a user to access this operationBinding. As with OperationBinding.requiresRole, if there an operationBinding that is the default operationBinding for the operationType, its requires expression is assumed to apply to all other operationBindings of the same type unless they explicitly set requires="" DataSource.requires, if specified, applies before operationBinding.requires is evaluated. In this case, both requires expressions must be true for the request to be accepted.
		 * Flags: IR, Group: auth */
		requires: string /* VelocityExpression */;

		/** Whether a user must be authenticated in order to access this operation. For details of what is meant by "authenticated", see DataSource.requiresAuthentication. To protect access to an entire operationType (eg, all "fetch" operations), declare an operationBinding with requiresAuthentication="true", OperationBinding.operationType set to the operationType to be protected, but no OperationBinding.operationId. This will then prevent access to the "fetch" operationType unless another OperationBinding declares requiresAuthentication="false" with a specific OperationBinding.operationId','operationId.
		 * Flags: IR, Group: auth */
		requiresAuthentication: boolean;

		/** Comma-separated list of user roles that are allowed to invoke the operation described by this operationBinding. If the current user has any of the roles listed, they can invoke the operation. Also note that authentication.superuserRole can be specified in the server_properties','server.properties file. If set this denotes a "super user" role - any user with that role will have access to all operations, regardless of the "requiresRole" settings for the operation. Whether the current user has a given role is determined by calling the standard Java servlets method httpServletRequest.isUserInRole(), hence works with both simple J2EE security (realms and form-based authentication) and JAAS (Java Authentication & Authorization Service). If you wish to use a role-based security scheme that does not make use of the servlet API's standards, SmartClient Server also implements the setAuthenticated and setUserRoles methods on RPCManager. You can use this API to tell SmartClient that all the requests in the queue currently being processed are associated with a user who has the roles you supply; in this case, SmartClient will not attempt to resolve the user's roles via httpServletRequest.isUserInRole(). When taking this approach, the rpcManager.setUserRoles() method should be called on the server for each transaction received from the client. We recommend doing this by overriding the special IDACall servlet and checking server side state to determine the current user's roles, calling the API, and then calling handleDSRequest() or handleRPCRequest() directly to handle the request(s) passed in. Here's an example of this approach which assumes the current user's roles has been set directly on the HttpSession object as a comma-separated-string attribute "roles": public class SecureIDACall extends IDACall { public void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { HttpSession session = request.getSession(); Object roles = session == null ? null : session.getAttribute("roles"); if (roles != null) { try { RequestContext context = RequestContext.instance(this, request, response); RPCManager rpc = new RPCManager(request, response); rpc.setAuthenticated(true); rpc.setUserRoles((String) roles); // call processRPCTransaction() to iterate through all RPCRequests and // DSRequests and execute them processRPCTransaction(rpc, context); } catch (Throwable e) { handleError(response, e); } } else { super.processRequest(request, response); } } } If there is an operationBinding declared for a given operationType which does not have an OperationBinding.operationId, that is, it is the default operationBinding for the type, then any other operationBinding of the same type is assumed to have the same setting for requiresRole as the default operationBinding for the operationType. For example, given these declarations: &lt;operationBinding operationType="fetch" requiresRole="manager"&gt; ... settings ... &lt;/operationBinding&gt; &lt;operationBinding operationType="fetch" operationId="fetchWithExtraFields"&gt; ... settings ... &lt;/operationBinding&gt; The second operationBinding requires the "manager" role even though there is no explicit requiresRole declaration. To prevent the "manager" role being required by the second operationBinding, add requireRole="". Note that if DataSource.requiresRole is set, all operations on the DataSource require the roles set for the DataSource as a whole, even if they declare individual requiresRole attributes. This property is valid only for a server-side DataSource when using the SmartClient Server. <h3>Special rules for cache sync</h3> After successfull "add" or "update" operation cache sync request is performed, which is using "fetch" operation of the same datasource. It may happen that user is allowed to add records, but is not allowed to fetch them, for example: &lt;operationBinding operationType="fetch" requiresRole="admin"&gt; ... settings ... &lt;/operationBinding&gt; &lt;operationBinding operationType="add"&gt; ... settings ... &lt;/operationBinding&gt; User without "admin" role will be able to successfully add record, but the cache sync operation will fail due to security violation. In this case the record will be saved to database, but the added record will not be fetched from database, instead just DSRequest.oldValues','old values overlaid with submitted values will be returned. So, any changes made to the new record during request execution, including generated values for primary key fields of "sequence" type, will not be returned to the client. However, if "add" or "update" operation explicitly declares OperationBinding.cacheSyncOperation, cache sync request will be executed even if the user does not meet the security checks for the operationBinding. Note that field-level security still will be respected and disallowed fields will be excluded from returned data.
		 * Flags: IR, Group: auth */
		requiresRole: string /* String */;

		/** Optional schema describing how to extract DataSource records from the XML elements selected. Once a set of XML elements have been selected via recordXPath or recordName, those elements are normally transformed to JavaScript objects using the fields of the DataSource that owns the operationBinding. A responseDataSchema can be specified instead if the XML differs in some way between different DataSource operations, such that different values for DataSourceField.valueXPath','field.valueXPath may be necessary to extract the same DataSource record from slightly different XML structures.
		 * Flags: IRA, Group: clientDataIntegration */
		responseDataSchema: DataSource;

		/** Scriptlet to be executed prior to the DataSource operation which is configured by this operationBinding. This setting overrides any DataSource.script','script specified at the DataSource level for this operation. Scriptlets are used similarly to DMIs configured via OperationBinding.serverObject - they can add business logic by modifying the DSRequest before it's executed, modifying the default DSResponse, or taking other, unrelated actions. Scriptlets are used similarly to DMIs configured via DataSource.serverObject or OperationBinding.serverObject - they can add business logic by modifying the DSRequest before it's executed, modifying the default DSResponse, or taking other, unrelated actions. For example: &lt;operationBindings&gt; &lt;operationBinding operationType="add"&gt; &lt;script language="groovy"&gt; ... Groovy code ... &lt;/script&gt; &lt;/operationBinding&gt; &lt;/operationBindings&gt; Scriptlets can be written in any language supported by the "JSR 223" standard, including Java itself. See the dmiOverview','DMI Script Overview for rules on how to return data, add additional imports, and other settings. The following variables are available for DMI scriptlets: dataSource: the current DataSource dsRequest: the current DSRequest criteria: shortcut to DSRequest.getCriteria() (a Map) values: shortcut to DSRequest.getValues() (a Map) oldValues: shortcut to DSRequest.getOldValues() (a Map) sqlConnection: SQLDataSource only: the current SQLConnection object. If using DataSource.autoJoinTransactions','automatic transactions are enabled, this SQLConnection is in the context of the current transaction. beanFactory: the spring BeanFactory (when applicable) cdiBeanManager: the CDI BeanManager (when applicable) Scriptlets also have access to a set of contextual variables related to the Servlets API, as follows: servletRequest: the current ServletRequest session: the current HttpSession rpcManager: the current RPCManager servletResponse: the current ServletResponse (advanced use only) servletContext: the current ServletContext(advanced use only) As with DMI in general, be aware that if you write scriptlets that depend upon these variables, you preclude your DataSource from being used in the widest possible variety of circumstances. For example, adding a scriptlet that relies on the HttpSession prevents your DataSource from being used in a command-line process. Note that if a dataSource configuration has both a &lt;script&gt; block and a specified OperationBinding.serverObject','serverObject for some operation, the script block will be executed, and the serverObject ignored.
		 * Flags: IR */
		script: string /* String */;

		/** This feature is available with Power or better licenses only. See <a href=http://smartclient.com/product>smartclient.com/product</a> for details. For a dataSource of DataSource.serverType','serverType "sql", this property can be specified on an operationBinding to provide the server with a bespoke SELECT clause to use when constructing the SQL query to perform this operation. The property should be a comma-separated list of column names and/or expressions, and you can refer to any scalar function supported by the underlying database. The server will insert the text of this property immediately after the "SELECT" token. Note that if you also specify a OperationBinding.groupClause','groupClause, you can use aggregate functions such as SUM and COUNT in the selectClause. This property is only applicable to operationBindings of OperationBinding.operationType','operationType "fetch". See the documentation for OperationBinding.customSQL for usage examples
		 * Flags: IR, Group: customQuerying */
		selectClause: string /* String */;

		/** The name of the method to invoke on the ServerObject for this operationBinding. NOTE: If you have a DataSource.serverObject','DataSource-level ServerObject and wish to override this operation so that it simply calls a different method on the same server object, it is sufficient to specify just this property on the operationBinding: there is no need to redefine the serverObject at the operationBinding level.
		 * Flags: IR */
		serverMethod: string;

		/** Optional ServerObject declaration that specifies the ServerObject configuration for this operationBinding. In the absence of a serverObject specification here, the one specified on the DataSource itself is used by default, if present (DataSource.serverObject). If neither is present, then Direct Method Invocation will not be enabled for this operationBinding. Note that if a dataSource configuration has both a OperationBinding.script','&lt;script&gt; block and a specified serverObject for some operation, the script block will be executed, and the serverObject ignored.
		 * Flags: IR */
		serverObject: ServerObject;

		/** Setting skipAudit to true indicates that DataSource.audit','auditing must be skipped for this operationBinding. Note, that this setting can be overrided by server-side API DSRequest.setSkipAudit().
		 * Flags: IR */
		skipAudit: boolean;

		/** A SQLDataSource will normally issue two queries for a "fetch" operation when paging is enabled: one to determine the total rows available (the "row count query"), and one to fetch the specific range of rows requested. Setting skipRowCount="true" will avoid the "row count query", but as a consequence DSResponse.totalRows will be set to match the requested DSRequest.endRow since the totalRows is unknown. You can avoid this by using a OperationBinding.sqlPaging','paging strategy of "jdbcScroll" or "dropAtServer", but be aware that these paging strategies can introduce significant delays when used with potentially large datasets (in fact, "dropAtServer" is almost guaranteed to do so if used with datasets of more than 1000 or so rows) As an alternative, consider enabling DataSource.progressiveLoading','progressive loading, which avoids doing a query for row counts, but will still allow the user to load more results using the scrollbar if viewing results in a ListGrid.
		 * Flags: IR */
		skipRowCount: boolean;

		/** For a DataSource contacting a DataSource.serviceNamespace','WSDL web service, setting this flag means the DataSource doesn't actually attempt to contact the server but generates a sample response instead, based on the XML Schema of the response message embedded in the WSDL. The spoofed response will include all complexType elements and will fill in appropriate values by type for all simpleType elements, although the spoofed data will not conform to all xs:restriction declarations (eg xs:pattern). Note that if your WSDL does not fully describe the response format (some WSDL services just have a placeholder &lt;xs:any&gt; element), SmartClient can only produce a partial response. To use a hand-generated sample response, just save an XML file to disk and use the OperationBinding.dataURL setting to point to it.
		 * Flags: IR, Group: clientDataIntegration */
		spoofResponses: boolean;

		/** The paging strategy to use for this specific OperationBinding. If this property is not set, we fall back to the DataSource.sqlPaging value, and the defaults described in the documentation for that property.
		 * Flags: IRW */
		sqlPaging: SQLPagingStrategy;

		/** For dataSources of DataSource.serverType','serverType "sql" and "hibernate" only, this property determines whether "custom" operations have their custom SQL or HQL sent to the underlying database via a JDBC executeQuery() or a JDBC executeUpdate(). The default value of null means the same as "query", so you only need to use this property when your custom SQL or HQL updates data.
		 * Flags: IR, Group: customQuerying */
		sqlType: SQLType;

		/** If explicitly set true or false, forces the use of a "hint" in the SQL we generate for paged queries on or off as appropriate. If not set, defaults to the DataSource.sqlUsePagingHint value. Note this property is only applicable to DataSource.serverType','SQL DataSources, only when a DataSource.sqlPaging','paging strategy of "sqlLimit" is in force, and it only has an effect for those specific database products where we employ a native hint in the generated SQL in an attempt to improve performance.
		 * Flags: IR, Group: sqlPaging */
		sqlUsePagingHint: boolean;

		/** A mapping from field names to SummaryFunction','summary functions to be applied to each field. Valid only for an operation of type "fetch". See the serverSummaries','Server Summaries overview for examples of usage.
		 * Flags: IR, Group: serverSummaries */
		summaryFunctions: any /* Object */;

		/** This feature is available with Power or better licenses only. See <a href=http://smartclient.com/product>smartclient.com/product</a> for details. For a dataSource of DataSource.serverType','serverType "sql", this property can be specified on an operationBinding to provide the server with a bespoke table clause to use when constructing the SQL query to perform this operation. The property should be a comma-separated list of tables and views, and you can use any special language constructs supported by the underlying database. The server will insert the text of this property immediately after the "FROM" token. See the documentation for OperationBinding.customSQL for usage examples
		 * Flags: IR, Group: customQuerying */
		tableClause: string /* String */;

		/** If set to "false", transformation of values for DataSourceField.multiple','multiple:true fields, normally controlled by DataSourceField.multipleStorage, is instead disabled for this OperationBinding.
		 * Flags: IR, Group: multipleField */
		transformMultipleFields: boolean;

		/** Setting useFlatFields on an operationBinding is equivalent to setting DSRequest.useFlatFields on all DataSource requests with the same OperationBinding.operationType as this operationBinding. Typical usage is to combine operationBinding.useFlatFields with DataBoundComponent.useFlatFields','searchForm.useFlatFields, with the SearchForm bound to the WebService.getInputDS','input message of the web service operation set as OperationBinding.wsOperation. This allows gratuitous nesting to be consistently bypassed in both the user presentation and in the actual XML messaging. Note that useFlatFields is not generally recommended for use with input messages where multiple simple type fields exist with the same name, however if used in this way, the first field to use a given name wins. "first" means the first field encountered in a depth first search. "wins" means only the first field will be available in data binding, and only the first field will be populated in the generated XML message.
		 * Flags: IR, Group: clientDataIntegration */
		useFlatFields: boolean;

		/** For an operationBinding of OperationBinding.operationType','operationType "fetch" which specifies no OperationBinding.operationId','operationId, this property determines whether the operationBinding should be used for cache synchronization purposes (ie, to retrieve the record most recently added or changed). This property has no effect on an operationBinding that specifies an operationId - see OperationBinding.cacheSyncOperation. In order to work correctly with SmartClient's cache synchronization system, an operationBinding marked useForCacheSync should have the following properties: Able to complete its retrieval using no context other than the values of the primary key fields declared in the dataSource (these will be provided in the $criteria object passed to the operation) Returns the entire record, including any values that may require joins to other tables or other complexities This property is only applicable to DataSources of type "sql".
		 * Flags: IR, Group: customQuerying */
		useForCacheSync: boolean;

		/** Whether to use the RPCManager.sendProxied','HttpProxy servlet to send requests described by this operationBinding. If unset, automatically detects whether using the HttpProxy is necessary based on the same-origin policy. Valid only with OperationBinding.dataProtocol settings other than ISCServer.
		 * Flags: IR, Group: clientDataIntegration */
		useHttpProxy: boolean;

		/** Sets or clears the useSpringTransaction flag for this specific operation. See DataSource.useSpringTransaction for details of the Spring transaction integration feature
		 * Flags: IR */
		useSpringTransaction: boolean;

		/** Whether to use the subselect technique (see DataSource.useSubselectForRowCount for details) to derive a rowcount query for this operation. If this property is not set, we fall back to the useSubselectForRowCount setting on the DataSource, and the defaults described in the documentation for that property.
		 * Flags: IRW */
		useSubselectForRowCount: boolean;

		/** Elements of this feature are only available with Power or better licenses. See <a href=http://smartclient.com/product>smartclient.com/product</a> for details. A list of DSRequestModifiers that will be used to modify the values object of each DSRequest that uses this operationBinding. See this example: queuedAdd. Below example of the xml as it should be defined in ds.xml: &lt;operationBinding operationType="add"&gt; &lt;values fieldName="orderID" value="$responseData.last('queuedAdd_order','add').orderID" /&gt; &lt;/operationBinding&gt;
		 * Flags: IR, Group: transactionChaining */
		values: Array<DSRequestModifier> /* Array of DSRequestModifier */;

		/** This feature is available with Power or better licenses only. See <a href=http://smartclient.com/product>smartclient.com/product</a> for details. For a dataSource of DataSource.serverType','serverType "sql", this property can be specified on an operationBinding to provide the server with a bespoke set of values to add or update, for use when constructing the SQL query to perform this operation. The property should be one of the following, depending on the OperationBinding.operationType','operationType: For "add" operations, the syntax that would be valid for an INSERT INTO query: a comma-separated list of column names enclosed in parentheses, followed by a comma-separated list of new values, enclosed in parentheses and preceded by the token "VALUES". For example: &lt;valuesClause&gt;(name, age) VALUES("Jane Doe", 48)&lt;/valuesClause&gt; For "update" operations, the syntax that would be valid for an UPDATE query: a comma-separated list of expressions equating a column name to its new value. For example: &lt;valuesClause&gt;name="Jane Doe", age=48&lt;/valuesClause&gt; You may find the SmartClient-provided $values variable of particular use with this property. See the documentation for OperationBinding.customSQL for usage examples
		 * Flags: IR, Group: customQuerying */
		valuesClause: string /* String */;

		/** This feature is available with Power or better licenses only. See <a href=http://smartclient.com/product>smartclient.com/product</a> for details. For a dataSource of DataSource.serverType','serverType "sql", this property can be specified on an operationBinding to provide the server with a bespoke WHERE clause to use when constructing the SQL query to perform this operation. The property should be a valid expression in the syntax of the underlying database. The server will insert the text of this property immediately after the "WHERE" token. You may find the SmartClient-provided $criteria variable of particular use with this property. See the documentation for OperationBinding.customSQL for usage examples
		 * Flags: IR, Group: customQuerying */
		whereClause: string /* String */;

		/** Name of the web service operation that will be invoked in order to execute this DataSource operation. Valid only for a DataSource that has a WebService (DataSource.serviceNamespace is set). Otherwise, use OperationBinding.dataURL. Setting wsOperation means that DSRequest.data will be serialized as the request message for the specified web service operation, with namespacing and soap encoding handled automatically. See DataSource.transformRequest for how to customize what data is sent to the server.
		 * Flags: IR, Group: clientDataIntegration */
		wsOperation: string /* String */;

		/** Optional object declaring namespace prefixes for use in OperationBinding.recordXPath and DataSourceField.valueXPath XPath expressions. xmlNamespaces should be specified as a mapping from namespace prefix to namespace URI, for example: xmlNamespaces : { az : "http://webservices.amazon.com/AWSECommerceService/2005-03-23" } By default, all namespaces declared on the document element (outermost element of the response) are made available with the prefix used in the document itself. Then, for non-WSDL-described XML results, if there is a default namespace on the document element, it is made available with the special prefix "default". For results of WSDL-described operations, the prefix "service" means the service namespace, that is, the "targetNamespace" on the &lt;definitions&gt; element from the WSDL file. The prefix "schema" means the namespace of the outermost element in the output message for the current operation. "default" will be the schema namespace if there is one, otherwise the service namespace. For basic information on XML Namespaces and their use in XPath, try the following search: <a href="http://www.google.com/search?q=XPath+xml+namespaces" target="_blank" >http://www.google.com/search?q=XPath+xml+namespaces</a>
		 * Flags: IR, Group: clientDataIntegration */
		xmlNamespaces: any /* Object */;

	} // OperationBinding

	export interface OperationBindingStatic<T, P> extends ClassStatic<T, P> {
	} // OperationBindingStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a Page Props argument.
	 * This is derived from the methods in the Page class and it's parents and their properties marked with the I flag.
	 */
	export interface PageProps  {
	} // PageProps


	/**
	 * Provides information about the page you're loaded in. We define "page" here to be roughly equivalent to the browser window or frame the libraries have been loaded in. 
	 */
	export interface Page  {
	} // Page

	export interface PageStatic<T, P> extends ClassStatic<T, P> {

	/* Methods */

		/** 
		 * Specify the directory for app-specific images. This becomes the default location where any SmartClient component will load images from unless the special "[SKIN]" prefix is used to indicate that an image is part of a skin. Default is "[APP]images/"
		 * @param {string} URL - New imgDir URL.
		 */
		setAppImgDir(URL?:string): void; 

	} // PageStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a ProcessElement Props argument.
	 * This is derived from the methods in the ProcessElement class and it's parents and their properties marked with the I flag.
	 */
	export interface ProcessElementProps  {
		/** Optional ID for this process element, allowing it to be referred to from DecisionGateway','Gateways, or as the Process.startElement. See ProcessSequence and Process to understand when this is required or can be omitted. Unlike Canvas.ID a processElement's is a not a globally unique variable, it need only by unique within it's process. When assigned an ID, a processElement can be retrieve via Process.getElement.
		 * Flags: IR */
		ID?: string /* String */; // Flags=IR
		/** Next Process.sequences','sequence or Process.elements','element to execute after this one completes. nextElement does not need to be specified on most elements if you use Process.sequences','sequences. Note that if there is both a sequence and a normal element with the same name in the current Process, the sequence will be used.
		 * Flags: IR */
		nextElement?: string /* String */; // Flags=IR
	} // ProcessElementProps


	/**
	 * A ProcessElement is an abstract superclass for elements involved in a Process, such as a Task or XORGateway. 
	 */
	export interface ProcessElement  {
		/** Optional ID for this process element, allowing it to be referred to from DecisionGateway','Gateways, or as the Process.startElement. See ProcessSequence and Process to understand when this is required or can be omitted. Unlike Canvas.ID a processElement's is a not a globally unique variable, it need only by unique within it's process. When assigned an ID, a processElement can be retrieve via Process.getElement.
		 * Flags: IR */
		ID: string /* String */;

		/** Next Process.sequences','sequence or Process.elements','element to execute after this one completes. nextElement does not need to be specified on most elements if you use Process.sequences','sequences. Note that if there is both a sequence and a normal element with the same name in the current Process, the sequence will be used.
		 * Flags: IR */
		nextElement: string /* String */;

	} // ProcessElement

	export interface ProcessElementStatic<T, P> extends ClassStatic<T, P> {
	} // ProcessElementStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a RecordEditor Props argument.
	 * This is derived from the methods in the RecordEditor class and it's parents and their properties marked with the I flag.
	 */
	export interface RecordEditorProps  {
		/** Properties to apply to the automatically generated RecordEditor.actionButton. Note that for a recordEditor being used as a ListGrid.filterEditor, the ListGrid.filterButtonProperties can be used to specify actionButton properties directly at the grid level.
		 * Flags: IRA */
		actionButtonProperties?: ButtonProps /* Button Properties */; // Flags=IRA
		/** Button.baseStyle','baseStyle for the RecordEditor.actionButton
		 * Flags: IR */
		actionButtonStyle?: string /* CSSStyleName */; // Flags=IR
		/** GridRenderer.baseStyle','base cell style for this listGrid. If this property is unset, base style may be derived from ListGrid.normalBaseStyle or ListGrid.tallBaseStyle as described in ListGrid.getBaseStyle. See cellStyleSuffixes for details on how stateful suffixes are combined with the base style to generate stateful cell styles.
		 * Flags: IR, Group: appearance */
		baseStyle?: string /* CSSStyleName */; // Flags=IR
		/** Button.icon','Icon to show on the RecordEditor.actionButton if this component is being used as a ListGrid.filterEditor. Note that this SCImgURL will be resolved using the RecordEditor.skinImgDir defined for the RecordEditor.
		 * Flags: IR */
		filterImg?: string /* SCImgURL */; // Flags=IR
		/** Where do 'skin' images (those provided with the class) live?
		 * Flags: IR */
		skinImgDir?: string /* URL */; // Flags=IR

		/* Method Overrides */

	} // RecordEditorProps


	/**
	 * Component for editing a single record. RecordEditors are implemented as a subclass of ListGrid, showing no header and a single row always drawn in the editable state, allowing the user to modify the values at any time. The RecordEditor.actionButton is automatically shown as a way for the user to act upon the edited values. The RecordEditor class exists as a helper class for ListGrids, used to provide an interface for editing criteria when ListGrid.showFilterEditor','filterEditor is set to true. 
	 */
	export interface RecordEditor  {
		/** Automatically created Button auto-child shown at the edge of the recordEditor. For a recordEditor acting as a ListGrid.filterEditor, this button will show the RecordEditor.filterImg as an Button.icon by default. Clicking this button will call RecordEditor.performAction on the editor. May be customized using the standard AutoChild pattern, by overriding RecordEditor.actionButtonProperties.
		 * Flags: R */
		actionButton: Button  /* Button AutoChild */;

		/** Properties to apply to the automatically generated RecordEditor.actionButton. Note that for a recordEditor being used as a ListGrid.filterEditor, the ListGrid.filterButtonProperties can be used to specify actionButton properties directly at the grid level.
		 * Flags: IRA */
		actionButtonProperties: ButtonProps /* Button Properties */;

		/** Button.baseStyle','baseStyle for the RecordEditor.actionButton
		 * Flags: IR */
		actionButtonStyle: string /* CSSStyleName */;

		/** GridRenderer.baseStyle','base cell style for this listGrid. If this property is unset, base style may be derived from ListGrid.normalBaseStyle or ListGrid.tallBaseStyle as described in ListGrid.getBaseStyle. See cellStyleSuffixes for details on how stateful suffixes are combined with the base style to generate stateful cell styles.
		 * Flags: IR, Group: appearance */
		baseStyle: string /* CSSStyleName */;

		/** Button.icon','Icon to show on the RecordEditor.actionButton if this component is being used as a ListGrid.filterEditor. Note that this SCImgURL will be resolved using the RecordEditor.skinImgDir defined for the RecordEditor.
		 * Flags: IR */
		filterImg: string /* SCImgURL */;

		/** Where do 'skin' images (those provided with the class) live?
		 * Flags: IR */
		skinImgDir: string /* URL */;


		/* Instance Method Overrides */

	} // RecordEditor

	export interface RecordEditorStatic<T, P> extends ClassStatic<T, P> {
	} // RecordEditorStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a RestDataSource Props argument.
	 * This is derived from the methods in the RestDataSource class and it's parents and their properties marked with the I flag.
	 */
	export interface RestDataSourceProps extends DataSourceProps {
		/** Custom DataSource.dataURL','dataURL for DSRequest','DSRequests with DSRequest.operationType','operationType "add". See RestDataSource.dataURL to configure a single URL for all requests, which is required to support RPCManager.startQueue.
		 * Flags: IR */
		addDataURL?: string /* String */; // Flags=IR
		/** Expected format for server responses. RestDataSources handle "json" and "xml" format responses by default. See class overview documentation for examples of responses in each format.
		 * Flags: IR */
		dataFormat?: DSDataFormat; // Flags=IR
		/** Rather than setting DataSource.dataProtocol, to control the format in which inputs are sent to the dataURL, you must specify a replacement OperationBinding and specify OperationBinding.dataProtocol on that operationBinding. This is because RestDataSource specifies default operationBindings for all operationTypes - see RestDataSource.operationBindings.
		 * Flags: IR, Group: clientDataIntegration */
		dataProtocol?: DSProtocol; // Flags=IR
		/** Default URL to contact to fulfill all DSRequests. RestDataSources also allow per-operationType dataURLs to be set via RestDataSource.fetchDataURL RestDataSource.addDataURL RestDataSource.updateDataURL RestDataSource.removeDataURL NOTE:: when using RPCManager.startQueue','queuing with RestDataSource, an HTTP request containing mixed DSRequest.operationType','operationTypes (such as a mixture of "add", "update" and "remove" operations resulting from ListGrid.autoSaveEdits','Grid Mass Editing) can only go to one URL, so you should not set distinct URLs for each operationType; doing so will break queuing of mixed operationTypes: multiple requests will be sent to distinct URLs, and a warning logged.
		 * Flags: IR */
		dataURL?: string /* String */; // Flags=IR
		/** If set, disables RPCManager.startQueue','request queuing for this RestDataSource.
		 * Flags: IRW */
		disableQueuing?: boolean /* Boolean */; // Flags=IRW
		/** Custom DataSource.dataURL','dataURL for DSRequest','DSRequests with DSRequest.operationType','operationType "fetch". Use RestDataSource.dataURL to configure a single URL for all requests, which is required to support RPCManager.startQueue.
		 * Flags: IR */
		fetchDataURL?: string /* String */; // Flags=IR
		/** Allows you to specify an arbitrary prefix string to apply to all json format responses sent from the server to this application. The client will expect to find this prefix on any JSON response received for this DataSource, and will strip it off before evaluating the response text. The default prefix is "&lt;SCRIPT&gt;//'\"]]&gt;&gt;isc_JSONResponseStart&gt;&gt;". The inclusion of such a prefix ensures your code is not directly executable outside of your application, as a preventative measure against <a href='http://www.google.com/search?q=javascript+hijacking'>javascript hijacking</a>. You can switch off JSON wrapping altogether by setting both this and RestDataSource.jsonSuffix to empty strings. If you are using SmartClient Server's RESTHandler servlet, see the server-side Javadocs for details of how to change the way JSON wrapping works on the server side.
		 * Flags: IRW */
		jsonPrefix?: string /* String */; // Flags=IRW
		/** recordXPath mapping to the data node of json returned by the server. Applies if this.dataFormat is set to "json" The default value will pick up data from a response structured as follows: {response: {status:0, data:[ {field1:"value", field2:"value"}, {field1:"value", field2:"value"} ] } 
		 * Flags: IR */
		jsonRecordXPath?: string; // Flags=IR
		/** Allows you to specify an arbitrary suffix string to apply to all json format responses sent from the server to this application. The client will expect to find this suffix on any JSON response received for this DataSource, and will strip it off before evaluating the response text. The default suffix is "//isc_JSONResponseEnd".
		 * Flags: IRW */
		jsonSuffix?: string /* String */; // Flags=IRW
		/** If RestDataSource.sendMetaData is true, this attribute is used to specify the prefix to apply to 'meta data' properties when assembling parameters to send to the server. Applies to operations where OperationBinding.dataProtocol is set to "getParams" or "postParams" only.
		 * Flags: IR */
		metaDataPrefix?: string; // Flags=IR
		/** RestDataSource OperationBindings set to specify default dataProtocol per operationType. Default databindings are: operationBindings : [ {operationType:"fetch", dataProtocol:"getParams"}, {operationType:"add", dataProtocol:"postParams"}, {operationType:"remove", dataProtocol:"postParams"}, {operationType:"update", dataProtocol:"postParams"} ], If you are integrating with a RestDataSource','REST server that requires the more obscure RPCRequest.httpMethods of "PUT", "DELETE" or "HEAD", you can specify these httpMethod settings via OperationBinding.requestProperties. dataProtocol settings that mention "GET" or "POST" are compatible with these additional HTTP methods as well. Typical DataSource.operationBindings','operationBindings for a REST server that uses "PUT" and "DELETE" are as follows: operationBindings:[ {operationType:"fetch", dataProtocol:"getParams"}, {operationType:"add", dataProtocol:"postParams"}, {operationType:"remove", dataProtocol:"getParams", requestProperties:{httpMethod:"DELETE"}}, {operationType:"update", dataProtocol:"postParams", requestProperties:{httpMethod:"PUT"}} ], Note that dataProtocol:"postMessage" is always used when RPCManager.startQueue','queuing is used to send multiple DSRequests to the server as a single HttpRequest. See RestDataSource docs, "queuing support". We also recommend that you use the "postMessage" protocol whenever you are intending to use AdvancedCriteria with RestDataSource - this is discussed in the section "Server inbound data format" in the RestDataSource','RestDataSource overview. 
		 * Flags: IR */
		operationBindings?: Array<OperationBinding> /* Array of OperationBinding */; // Flags=IR
		/** When using dataFormat:"json" and dataProtocol:"postMessage" should we use the JSONEncoder.prettyPrint feature to enable indented, highly readable JSON messages. True by default because the bandwidth involved is generally negligible and the benefits for troubleshooting are key.
		 * Flags: IR */
		prettyPrintJSON?: boolean /* Boolean */; // Flags=IR
		/** For RestDataSources, by default, either the RestDataSource.xmlRecordXPath or RestDataSource.jsonRecordXPath is used based on the RestDataSource.dataFormat setting. Note that you can also apply record xpath binding via OperationBinding.recordXPath.
		 * Flags: IRW */
		recordXPath?: string; // Flags=IRW
		/** Custom DataSource.dataURL','dataURL for DSRequest','DSRequests with DSRequest.operationType','operationType "remove". See RestDataSource.dataURL to configure a single URL for all requests, which is required to support RPCManager.startQueue.
		 * Flags: IR */
		removeDataURL?: string /* String */; // Flags=IR
		/** Should operation meta data be included when assembling parameters to send to the server? If true, meta data parameters will be prefixed with the RestDataSource.metaDataPrefix. Applies to operations where OperationBinding.dataProtocol is set to "getParams" or "postParams" only.
		 * Flags: IR */
		sendMetaData?: boolean /* Boolean */; // Flags=IR
		/** Custom DataSource.dataURL','dataURL for DSRequest','DSRequests with DSRequest.operationType','operationType "update". See RestDataSource.dataURL to configure a single URL for all requests, which is required to support RPCManager.startQueue.
		 * Flags: IR */
		updateDataURL?: string /* String */; // Flags=IR
		/** When RestDataSource.dataFormat is "xml", xmlNamespaces configures the set of namespace prefixes that are added to the document element of the XML message sent to the server. Format is the same as DataSource.xmlNamespaces. By default, the "xsi" prefix is bound to "http://www.w3.org/2001/XMLSchema-instance" in order to allow explicit null values in Records to be sent for DataSourceField.nillable','fields declared nillable. Set to null to avoid any prefixes being added.
		 * Flags: IR */
		xmlNamespaces?: any /* Object */; // Flags=IR
		/** recordXPath mapping to the data node of XML returned by the server. Applies if this.dataFormat is set to "xml". The default value will pick up data from a response structured as follows: &lt;response&gt; &lt;status&gt;0&lt;/status&gt; &lt;data&gt; &lt;record&gt; &lt;field1&gt;value&lt;/field1&gt; &lt;field2&gt;value&lt;/field2&gt; &lt;/record&gt; &lt;record&gt; &lt;field1&gt;value&lt;/field1&gt; &lt;field2&gt;value&lt;/field2&gt; &lt;/record&gt; &lt;/data&gt; &lt;/response&gt; 
		 * Flags: IR */
		xmlRecordXPath?: string; // Flags=IR

		/* Method Overrides */

	} // RestDataSourceProps


	/**
	 * The RestDataSource implements the 4 core DataSource operations using a simple protocol of XML or JSON requests and responses sent over HTTP, which can be easily fulfilled by any HTTP server technology. RestDataSource is named for the <a href='http://www.google.com/search?hl=en&q=REST+HTTP' target='_blank'>REST</a> (REpresentational State Transfer) pattern, which in brief says that simple messages passed over HTTP is a sufficient protocol for many web applications, without the need for further protocols such as WSDL or SOAP. A RestDataSource is used just like a normal DataSource. RestDataSources are pre-configured, using the general-purpose databinding facilities of DataSources, to expect a particular format for responses and to send requests in a specific format. These request and response formats represent Isomorphic's recommended best practices for binding SmartClient to backends which do not already support a similar, pre-existing request and response format and where the SmartClient Java Server cannot be used. If you have a pre-existing REST or WSDL service which is difficult to change, consider adapting SmartClient to the existing service instead, by starting with a normal DataSource and using the clientDataIntegration','client-side data integration facilities to create a mapping between SmartClient's DSRequest and DSResponse objects and the message formats of your existing services. NOTE: do not begin this process by creating or subclassing RestDataSource; for a pre-existing service which is unrelated to the protocol documented for RestDataSource, start by configuring or subclassing DataSource instead. RestDataSource is typically used with PHP, Ruby, Python, Perl or custom server technologies, and represents an alternative to installing the SmartClient Server in a Java technology stack, or using wsdlBinding','WSDL-based binding with .NET or other WSDL-capable technologies. Note that SmartClient Server also provides built-in support for the REST protocol via its RESTHandler servlet; this is primarily to allow non-SmartClient clients to make use of DataSource operations. If you particularly wished to do so, you could use RestDataSource to make a SmartClient app talk to the SmartClient Server using REST rather than the proprietary wire format normally used when communicating with SmartClient Server (this is how we are able to write automated tests for the RESTHandler servlet). However, doing this provides no benefit, imposes a number of inconveniences, and makes a handful of server-based features less useful (DataSourceField.viewRequiresAuthentication','field-level declarative security, for example), so we strongly recommend that you do <em>not</em> do this; it is only mentioned here for completeness while we are discussing REST. The request and response formats used by the RestDataSource allow for many of the available features of SmartClient's databinding system to be used, including data paging, searching & sorting, DSRequest.oldValues','long transactions, ResultSet','automatic cache sync, relogin','relogin and RPCManager.startQueue','queuing. However, advanced features such as upload','uploading / binary fields and ListGrid.exportData','export aren't available with RestDataSource and need to be re-implemented as needed. Most, though not all, iscServer','server-based features are still available when using RestDataSource, as long as you are also using the RESTHandler servlet that is part of SmartClient Server. However, as noted above, this approach is not recommended; if you are using Isomorphic technology both client- and server-side, it makes more sense to use the proprietary wire format. RestDataSource and binary data Binary data in a response provided to a RestDataSource must be delivered as valid XML or JSON Strings. Once delivered to the browser as Strings, there is no way to trigger the browser's "Save As" dialog to download the data, and in most cases no way to trigger other helper applications that might be launched to handle binary data (such as Excel or a PDF viewer). Hence for binary it usually makes sense to make a direct request via RPCManager.sendRequest() with downloadResult:true, separate from RestDataSource. If you are using the SmartClient Server included in Pro, Power end Enterprise to handle your REST requests server-side, there is transparent support for conversion between Java InputStreams representing binary data, and Strings containing that binary data encoded using the <a href=http://en.wikipedia.org/wiki/Base64>Base64 algorithm</a>. Thus, on the server, the binary data is in its raw binary form, with transparent conversion to or from Base64 for messages to or from the REST client. <span style="font-weight:bold;font-size:16px;">Examples</span> XML formatted responses: RestDataSource expects a response like the following in response to a "fetch" request: &lt;response&gt; &lt;status&gt;0&lt;/status&gt; &lt;startRow&gt;0&lt;/startRow&gt; &lt;endRow&gt;76&lt;/endRow&gt; &lt;totalRows&gt;546&lt;/totalRows&gt; &lt;data&gt; &lt;record&gt; &lt;field1&gt;value&lt;/field1&gt; &lt;field2&gt;value&lt;/field2&gt; &lt;/record&gt; &lt;record&gt; &lt;field1&gt;value&lt;/field1&gt; &lt;field2&gt;value&lt;/field2&gt; &lt;/record&gt; ... 76 total records ... &lt;/data&gt; &lt;/response&gt; The &lt;status&gt; element indicates whether the fetch operation was successful (see statusCodes). The &lt;data&gt; element contains a list of record nodes, each of which represents a record returned by the server. The optional &lt;startRow&gt;, &lt;endRow&gt; and &lt;totalRows&gt; elements are needed only if data paging is in use, and populate the DSResponse.startRow','startRow, DSResponse.endRow','endRow and DSResponse.totalRows','totalRows properties of the DSResponse. Note: for a more compact format, simple field values may be specified on record nodes directly as attributes - in this case a record element might be structured like this: &lt;record field1="value" field2="value" /&gt; Note that a RestDataSource will bypass browser caching of all responses by default. See DataSource.preventHTTPCaching. Successful "add" or "update" request responses are similar in format - in this case the data element would be expected to contain a single record object containing the details of the record, as saved on the server. The response from a "remove" operation would again include status and data elements, but in this case, only the primary key field value(s) of the removed record would be expected to be present under the data element. If a validation failure occurred on the server, the response would have status set to RPCResponse.STATUS_VALIDATION_ERROR [-4], and any validation errors could be included as per-field sub-elements of an "errors" element. For a validation error, the response is not expected to contain any &lt;data&gt; element. A response showing a validation error might look like this: &lt;response&gt; &lt;status&gt;-4&lt;/status&gt; &lt;errors&gt; &lt;field1&gt; &lt;errorMessage&gt;A validation error occurred for this field&lt;/errorMessage&gt; &lt;/field1&gt; &lt;/errors&gt; &lt;/response&gt; An unrecoverable error, such as an unexpected server failure, can be flagged by setting &lt;status&gt; to -1 and setting &lt;data&gt; to an error message. In this case the &lt;errors&gt; element is not used (it's specific to validation errors). An unrecoverable error causes all response processing to be skipped and RPCManager.handleError to be invoked, which by default will show the provided error message as an alert using isc.warn. JSON formatted responses: JSON format responses are expected to contain the same data / meta-data as XMLresponses, encapsulated in a simple object with a "response" attribute. The response to a "fetch" request would therefore have this format: { "response": { "status": 0, "startRow": 0, "endRow": 76, "totalRows": 546, "data": [ {"field1": "value", "field2": "value"}, {"field1": "value", "field2": "value"}, ... 76 total records ... ] } } The structure successful for "add", "update" and "remove" responses would be similar, though the data array would be expected to contain only a single object, representing the values as saved. This allows the server to return values such as an auto-generated sequence primaryKey, a last modified timestamp, or similar server-generated field values. For a remove, only the value for the primaryKey field[s] would be required. For a validation error, the status attribute would be set to RPCResponse.STATUS_VALIDATION_ERROR [-4], and errors would be specified in the errors attribute of the response. For example: { "response": { "status": -4, "errors": { "field1": {"errorMessage": "A validation error on field1"}, "field2": {"errorMessage": "A validation error on field2"} } } } An array of errors may also be returned for a single field, like this: { "response": { "status": -4, "errors": { "field1": [ {"errorMessage": "First error on field1"}, {"errorMessage": "Second error on field1"} ] } } } As with the XML format above, an unrecoverable error is indicated by setting the status attribute to -1 and the data property to the error message. Server inbound data formats The format of data sent to the server is determined by the OperationBinding.dataProtocol specified for the operation. Request data is sent as parameters if the format is specified as "getParams" or "postParams". In this case, the parameters sent to the server will consist of the DSRequest's data, and any parameters explicitly specified on the DSRequest object (as RPCRequest.params. If RestDataSource.sendMetaData is true, the DSRequest meta data properties will also be present as parameters, prefixed with RestDataSource.metaDataPrefix. Example URL constructed with the metaDataPrefix set to "_" (the default): &nbsp;&nbsp;&nbsp;[dataURL]?field1=value1&_operationType=fetch&_startRow=0&_endRow=50&_sortBy=-field2&_dataSource=dsName In this case the server would be able to separate the request's data from the meta data via the "_" prefix. If data is sent to the server via the "postMessage" dataProtocol, the data will be serialized as an XML or JSON message according to the dataFormat setting. Both XML and JSON messages will contain request metadata such as startRow and endRow, and will appear exactly as though the subset of the DSRequest that is meaningful to the server had been passed to DataSource.xmlSerialize or JSON.encode respectively. An example of an XML message might look like this: &lt;request&gt; &lt;data&gt; &lt;countryCode&gt;US&lt;/countryCode&gt; &lt;countryName&gt;Edited Value&lt;/countryName&gt; &lt;capital&gt;Edited Value&lt;/capital&gt; &lt;continent&gt;Edited Value&lt;/continent&gt; &lt;/data&gt; &lt;dataSource&gt;countryDS&lt;/dataSource&gt; &lt;operationType&gt;update&lt;/operationType&gt; &lt/request&gt; An example of an XML message for a fetch operation passing simple criteria: &lt;request&gt; &lt;data&gt; &lt;continent&gt;North America&lt;/continent&gt; &lt;/data&gt; &lt;dataSource&gt;countryDS&lt;/dataSource&gt; &lt;operationType&gt;fetch&lt;/operationType&gt; &lt;startRow&gt;0&lt;/startRow&gt; &lt;endRow&gt;75&lt;/endRow&gt; &lt;componentId&gt;worldGrid&lt;/componentId&gt; &lt;textMatchStyle&gt;exact&lt;/textMatchStyle&gt; &lt/request&gt; And an example of an XML message for a fetch operation passing AdvancedCriteria: &lt;request&gt; &lt;data&gt; &lt;_constructor&gt;AdvancedCriteria&lt;/_constructor&gt; &lt;operator&gt;or&lt;/operator&gt; &lt;criteria&gt; &lt;criterion&gt; &lt;fieldName&gt;continent&lt;/fieldName&gt; &lt;operator&gt;equals&lt;/operator&gt; &lt;value&gt;North America&lt;/value&gt; &lt;/criterion&gt; &lt;criterion&gt; &lt;operator&gt;and&lt;/operator&gt; &lt;criteria&gt; &lt;criterion&gt; &lt;fieldName&gt;continent&lt;/fieldName&gt; &lt;operator&gt;equals&lt;/operator&gt; &lt;value&gt;Europe&lt;/value&gt; &lt;/criterion&gt; &lt;criterion&gt; &lt;fieldName&gt;population&lt;/fieldName&gt; &lt;operator&gt;greaterThan&lt;/operator&gt; &lt;value&gt;50000000&lt;/value&gt; &lt;/criterion&gt; &lt;/criteria&gt; &lt;/criterion&gt; &lt;/criteria&gt; &lt;/data&gt; &lt;dataSource&gt;countryDS&lt;/dataSource&gt; &lt;operationType&gt;fetch&lt;/operationType&gt; &lt;startRow&gt;0&lt;/startRow&gt; &lt;endRow&gt;75&lt;/endRow&gt; &lt;componentId&gt;worldGrid&lt;/componentId&gt; &lt/request&gt; An example of an XML message for a fetch operation when using serverSummaries','server-side summaries: &lt;request&gt; &lt;data&gt;&lt;/data&gt; &lt;dataSource&gt;countryDS&lt;/dataSource&gt; &lt;operationType&gt;fetch&lt;/operationType&gt; &lt;summaryFunctions&gt; &lt;pk&gt;count&lt;/pk&gt; &lt;/summaryFunctions&gt; &lt;groupBy&gt;member_g8&lt;/groupBy&gt; &lt/request&gt; JSON messages are just the plain JSON form of the structures shown in the above XML examples. The advanced criteria XML example above but in JSON form: { data: { _constructor: "AdvancedCriteria", operator: "or", criteria: [ { fieldName: "continent", operator: "equals", value: "North America }, { operator: "and", criteria: [ { fieldName: "continent", operator: "equals", value: "Europe" }, { fieldName: "population", operator: "greaterThan", value: 50000000 } ] } ] } dataSource: "countryDS", operationType: "fetch", startRow: 0, endRow: 75, componentId: "worldGrid" } The RestDataSource.operationBindings','default OperationBindings for a RestDataSource specify dataProtocol as "getParams" for the fetch operation, and "postParams" for update, add and remove operations. Note that most webservers impose a limit on the maximum size of GET requests (specifically, on the size of the request URL + HTTP headers). Using dataProtocol:"getParams" for "fetch" operations that involve complex AdvancedCriteria will result in a JSON serialization of the AdvancedCriteria in the request URL, and when combined with large cookies this can easily overflow the default limits on certain webservers (see <a href='http://stackoverflow.com/questions/686217/maximum-on-http-header-values' target='_blank'>http://stackoverflow.com/questions/686217/maximum-on-http-header-values</a>). For this reason, we recommend that you use the "postMessage" protocol whenever you are intending to use AdvancedCriteria with RestDataSource. Date, time and datetime values Date, time and datetime values must be communicated using XML Schema format, as in the following examples: &nbsp;&nbsp;&lt;dateField&gt;2007-04-22&lt;/dateField&gt; &nbsp;&nbsp;&lt;timeField&gt;11:07:13&lt;/timeField&gt; &nbsp;&nbsp;&lt;dateTimeField&gt;2007-04-22T11:07:13&lt;/dateTimeField&gt; &nbsp;&nbsp;&lt;dateTimeField&gt;2007-04-22T11:07:13.582&lt;/dateTimeField&gt; And the equivalent in JSON: &nbsp;&nbsp;dateField: "2007-04-22" &nbsp;&nbsp;timeField: "11:07:13" &nbsp;&nbsp;dateTimeField: "2007-04-22T11:07:13" &nbsp;&nbsp;dateTimeField: "2007-04-22T11:07:13.582" Both RestDataSource on the client-side and the RESTHandler servlet on the server side automatically handle encoding and decoding temporal values using these formats. Both also handle datetime formats including or excluding milliseconds automatically. When encoding, both honor the DataSource.trimMilliseconds setting on the DataSource, falling back to the server.properties setting rest.trimMilliseconds; when decoding, both detect whether or not to try to parse milliseconds based on the string they receive. Fields of type "date" and "time" are considered to hold logical date and time values, as discussed in the dateFormatAndStorage','date and time handling article, and are not affected by timezones. Fields of type "datetime" will be converted to UTC on the client side by RestDataSource, and will be sent back down to the client as UTC by the server-side RESTHandler. We recommend that your own REST client and/or server code do the same thing (ie, transmit all datetime values in both directions as UTC). Note that the examples given above give no timezone information, and will be treated by the SmartClient Server as UTC values. If you wish to work with datetime values in a particular timezone, use a format like this: &nbsp;&nbsp;&lt;dateField&gt;2007-04-22T11:07:13-0800&lt;/dateField&gt; &nbsp;&nbsp;&lt;dateField&gt;2012-11-19T22:12:04+0100&lt;/dateField&gt; And the equivalent in JSON: &nbsp;&nbsp;dateTimeField: "2007-04-22T11:07:13-0800" &nbsp;&nbsp;dateTimeField: "2012-11-19T22:12:04+0100" NOTE: Although we refer above to XML Schema format, the format used for specifying timezone offset is slightly different from XML Schema - as shown in the above examples, you specify "+HHMM" or "-HHMM", as opposed to the XML Schema format which requires a ":" character between the hours and minutes. The reason for this difference is simply that the Java SimpleDateFormat class imposes it. RestDataSource queuing support RestDataSource supports RPCManager.startQueue','queuing of DSRequests. This allows you to send multiple requests to the server in a single HTTP turnaround, thus minimizing network traffic and allowing the server to treat multiple requests as a single transaction, if the server is able to do so (in Power Edition and above, the SmartClient Server transparently supports grouping multiple REST requests in a queue into a single database transaction when using one of the built-in DataSource types). Note that you can disable queuing support with the RestDataSource.disableQueuing flag. If you want to use queuing with RestDataSource, you must use the "postMessage" dataProtocol with either XML or JSON dataFormat. Message format is similar to the non-queued examples shown earlier: it is simply extended to cope with the idea of multiple DSRequests encapsulated in the message. An example of the XML message sent from RestDataSource to the server for two update requests combined into a queue, using XML dataFormat: &lt;transaction&gt; &lt;operations&gt; &lt;request&gt; &lt;data&gt; &lt;pk&gt;1&lt;/pk&gt; &lt;countryName&gt;Edited Value&lt;/countryName&gt; &lt;capital&gt;Edited Value&lt;/capital&gt; &lt;continent&gt;Edited Value&lt;/continent&gt; &lt;/data&gt; &lt;dataSource&gt;countryDS&lt;/dataSource&gt; &lt;operationType&gt;update&lt;/operationType&gt; &lt/request&gt; &lt;request&gt; &lt;data&gt; &lt;pk&gt;2&lt;/pk&gt; &lt;capital&gt;Edited Value&lt;/capital&gt; &lt;population&gt;123456&lt;/population&gt; &lt;/data&gt; &lt;dataSource&gt;countryDS&lt;/dataSource&gt; &lt;operationType&gt;update&lt;/operationType&gt; &lt/request&gt; &lt;/operations&gt; &lt;transaction&gt; And the same message in JSON format: { transaction: { operations: [{ dataSource:"countryDS", operationType:"update", data: { pk: 1 countryName: "Edited Value", capital: "Edited Value", continent: "Edited Value" } }, { dataSource:"countryDS", operationType:"update", data: { pk: 2, capital: "Edited Value", popuilation: 123456 } }] } } RestDataSource expects the response to a queue of requests to be a queue of responses in the same order as the original requests. Again, the message format is very similar to the unqueued REST format, it just has an outer container construct. Note also that the individual DSResponses in a queued response have an extra property, DSResponse.queueStatus','queueStatus. This allows each individual response to determine whether the queue as a whole succeeded. For example, if the first update succeeded but the second failed validation, the first response would have a status of 0, but a queueStatus of -1, while the second response would have both properties set to -1. The update queue example given above would expect a response like this (in XML): &lt;responses&gt; &lt;response&gt; &lt;status&gt;0&lt;/status&gt; &lt;queueStatus&gt;0&lt;/queueStatus&gt; &lt;data&gt; &lt;record&gt; &lt;countryName&gt;Edited Value&lt;/countryName&gt; &lt;gdp&gt;1700.0&lt;/gdp&gt; &lt;continent&gt;Edited Value&lt;/continent&gt; &lt;capital&gt;Edited Value&lt;/capital&gt; &lt;pk&gt;1&lt;/pk&gt; &lt;/record&gt; &lt;/data&gt; &lt;/response&gt; &lt;response&gt; &lt;status&gt;0&lt;/status&gt; &lt;queueStatus&gt;0&lt;/queueStatus&gt; &lt;data&gt; &lt;record&gt; &lt;countryName&gt;United States&lt;/countryName&gt; &lt;gdp&gt;7247700.0&lt;/gdp&gt; &lt;continent&gt;North America&lt;/continent&gt; &lt;independence&gt;1776-07-04&lt;/independence&gt; &lt;capital&gt;Washington DC&lt;/capital&gt; &lt;pk&gt;2&lt;/pk&gt; &lt;population&gt;123456&lt;/population&gt; &lt;/record&gt; &lt;/data&gt; &lt;/response&gt; &lt;/responses&gt; And in JSON: [ { "response": { "queueStatus": 0, "status": 0, "data": [{ "countryName": "Edited Value", "gdp": 1700.0, "continent": "Edited Value", "capital": "Edited Value", "pk": 1 }] } }, { "response": { "queueStatus": 0, "status": 0, "data": [{ "countryName": "United States", "gdp": 7247700.0, "continent": "North America", "independence": "1776-07-04", "capital": "Washington DC", "pk": 2, "population": 123456 }] } } ] Hierarchical (Tree) data: To create a hierarchical DataSource, in the DataSource's fields array, a field must be specified as the parent id field - the field which will contain a pointer to the id of each node's parent. This can be achieved by setting the DataSourceField.foreignKey and the DataSourceField.rootValue attributes on the field definition. For example: RestDataSource.create({ ID:"supplyItem", fields : [ {name:"itemId", type:"sequence", primaryKey:true}, {name:"parentId", type:"integer", foreignKey:"supplyItem.itemId", rootValue:0}, ... ] }); Tree Data is then treated on the server as a flat list of records linked by parent id. Tree data is typically displayed using a dataBound TreeGrid component. TreeGrids automatically create a ResultTree data object, which requests data directly from the DataSource. ResultTrees load data on demand, only requesting currently visible (open) nodes from the server. This is handled by including a specified value for the parent id field in the request criteria. To implement a standard load-on-demand tree RestDataSource back end, you should therefore simply return the set of nodes that match the criteria passed in. For example, if your DataSource was defined as the "supplyItem" code snippet above, a fetch request for all children of a node with itemId set to 12 would have "parentId" set to 12 in the request criteria. A valid response would then contain all the records that matched this criteria. For example: &lt;response&gt; &lt;status&gt;0&lt;/status&gt; &lt;data&gt; &lt;record&gt; &lt;itemId&gt;15&lt;/itemId&gt; &lt;parentId&gt;12&lt;/parentId&gt; &lt;/record&gt; &lt;record&gt; &lt;itemId&gt;16&lt;/itemId&gt; &lt;parentId&gt;12&lt;/parentId&gt; &lt;/record&gt; &lt;/data&gt; &lt;/response&gt; The structure of responses for Add, Update and Delete type requests will be the same regardless of whether the data is hierarchical. However you should be aware that the underlying data storage may need to be managed slightly differently in some cases. Specifically, Add and Update operations may change the structure of the tree by returning a new parent id field value for the modified node. Depending on how your data is stored you may need to include special back-end logic to handle this. Also, if a user deletes a folder within a databound tree, any children of that folder will also be dropped from the tree, and can be removed from the back-end data storage. Note: For a general overview of binding components to Tree structured data, see treeDataBinding','Tree Databinding. 
	 */
	export interface RestDataSource extends DataSource {
		/** Custom DataSource.dataURL','dataURL for DSRequest','DSRequests with DSRequest.operationType','operationType "add". See RestDataSource.dataURL to configure a single URL for all requests, which is required to support RPCManager.startQueue.
		 * Flags: IR */
		addDataURL: string /* String */;

		/** Expected format for server responses. RestDataSources handle "json" and "xml" format responses by default. See class overview documentation for examples of responses in each format.
		 * Flags: IR */
		dataFormat: DSDataFormat;

		/** Rather than setting DataSource.dataProtocol, to control the format in which inputs are sent to the dataURL, you must specify a replacement OperationBinding and specify OperationBinding.dataProtocol on that operationBinding. This is because RestDataSource specifies default operationBindings for all operationTypes - see RestDataSource.operationBindings.
		 * Flags: IR, Group: clientDataIntegration */
		dataProtocol: DSProtocol;

		/** Default URL to contact to fulfill all DSRequests. RestDataSources also allow per-operationType dataURLs to be set via RestDataSource.fetchDataURL RestDataSource.addDataURL RestDataSource.updateDataURL RestDataSource.removeDataURL NOTE:: when using RPCManager.startQueue','queuing with RestDataSource, an HTTP request containing mixed DSRequest.operationType','operationTypes (such as a mixture of "add", "update" and "remove" operations resulting from ListGrid.autoSaveEdits','Grid Mass Editing) can only go to one URL, so you should not set distinct URLs for each operationType; doing so will break queuing of mixed operationTypes: multiple requests will be sent to distinct URLs, and a warning logged.
		 * Flags: IR */
		dataURL: string /* String */;

		/** If set, disables RPCManager.startQueue','request queuing for this RestDataSource.
		 * Flags: IRW */
		disableQueuing: boolean /* Boolean */;

		/** Custom DataSource.dataURL','dataURL for DSRequest','DSRequests with DSRequest.operationType','operationType "fetch". Use RestDataSource.dataURL to configure a single URL for all requests, which is required to support RPCManager.startQueue.
		 * Flags: IR */
		fetchDataURL: string /* String */;

		/** Allows you to specify an arbitrary prefix string to apply to all json format responses sent from the server to this application. The client will expect to find this prefix on any JSON response received for this DataSource, and will strip it off before evaluating the response text. The default prefix is "&lt;SCRIPT&gt;//'\"]]&gt;&gt;isc_JSONResponseStart&gt;&gt;". The inclusion of such a prefix ensures your code is not directly executable outside of your application, as a preventative measure against <a href='http://www.google.com/search?q=javascript+hijacking'>javascript hijacking</a>. You can switch off JSON wrapping altogether by setting both this and RestDataSource.jsonSuffix to empty strings. If you are using SmartClient Server's RESTHandler servlet, see the server-side Javadocs for details of how to change the way JSON wrapping works on the server side.
		 * Flags: IRW */
		jsonPrefix: string /* String */;

		/** recordXPath mapping to the data node of json returned by the server. Applies if this.dataFormat is set to "json" The default value will pick up data from a response structured as follows: {response: {status:0, data:[ {field1:"value", field2:"value"}, {field1:"value", field2:"value"} ] } 
		 * Flags: IR */
		jsonRecordXPath: string;

		/** Allows you to specify an arbitrary suffix string to apply to all json format responses sent from the server to this application. The client will expect to find this suffix on any JSON response received for this DataSource, and will strip it off before evaluating the response text. The default suffix is "//isc_JSONResponseEnd".
		 * Flags: IRW */
		jsonSuffix: string /* String */;

		/** If RestDataSource.sendMetaData is true, this attribute is used to specify the prefix to apply to 'meta data' properties when assembling parameters to send to the server. Applies to operations where OperationBinding.dataProtocol is set to "getParams" or "postParams" only.
		 * Flags: IR */
		metaDataPrefix: string;

		/** RestDataSource OperationBindings set to specify default dataProtocol per operationType. Default databindings are: operationBindings : [ {operationType:"fetch", dataProtocol:"getParams"}, {operationType:"add", dataProtocol:"postParams"}, {operationType:"remove", dataProtocol:"postParams"}, {operationType:"update", dataProtocol:"postParams"} ], If you are integrating with a RestDataSource','REST server that requires the more obscure RPCRequest.httpMethods of "PUT", "DELETE" or "HEAD", you can specify these httpMethod settings via OperationBinding.requestProperties. dataProtocol settings that mention "GET" or "POST" are compatible with these additional HTTP methods as well. Typical DataSource.operationBindings','operationBindings for a REST server that uses "PUT" and "DELETE" are as follows: operationBindings:[ {operationType:"fetch", dataProtocol:"getParams"}, {operationType:"add", dataProtocol:"postParams"}, {operationType:"remove", dataProtocol:"getParams", requestProperties:{httpMethod:"DELETE"}}, {operationType:"update", dataProtocol:"postParams", requestProperties:{httpMethod:"PUT"}} ], Note that dataProtocol:"postMessage" is always used when RPCManager.startQueue','queuing is used to send multiple DSRequests to the server as a single HttpRequest. See RestDataSource docs, "queuing support". We also recommend that you use the "postMessage" protocol whenever you are intending to use AdvancedCriteria with RestDataSource - this is discussed in the section "Server inbound data format" in the RestDataSource','RestDataSource overview. 
		 * Flags: IR */
		operationBindings: Array<OperationBinding> /* Array of OperationBinding */;

		/** When using dataFormat:"json" and dataProtocol:"postMessage" should we use the JSONEncoder.prettyPrint feature to enable indented, highly readable JSON messages. True by default because the bandwidth involved is generally negligible and the benefits for troubleshooting are key.
		 * Flags: IR */
		prettyPrintJSON: boolean /* Boolean */;

		/** For RestDataSources, by default, either the RestDataSource.xmlRecordXPath or RestDataSource.jsonRecordXPath is used based on the RestDataSource.dataFormat setting. Note that you can also apply record xpath binding via OperationBinding.recordXPath.
		 * Flags: IRW */
		recordXPath: string;

		/** Custom DataSource.dataURL','dataURL for DSRequest','DSRequests with DSRequest.operationType','operationType "remove". See RestDataSource.dataURL to configure a single URL for all requests, which is required to support RPCManager.startQueue.
		 * Flags: IR */
		removeDataURL: string /* String */;

		/** Should operation meta data be included when assembling parameters to send to the server? If true, meta data parameters will be prefixed with the RestDataSource.metaDataPrefix. Applies to operations where OperationBinding.dataProtocol is set to "getParams" or "postParams" only.
		 * Flags: IR */
		sendMetaData: boolean /* Boolean */;

		/** Custom DataSource.dataURL','dataURL for DSRequest','DSRequests with DSRequest.operationType','operationType "update". See RestDataSource.dataURL to configure a single URL for all requests, which is required to support RPCManager.startQueue.
		 * Flags: IR */
		updateDataURL: string /* String */;

		/** When RestDataSource.dataFormat is "xml", xmlNamespaces configures the set of namespace prefixes that are added to the document element of the XML message sent to the server. Format is the same as DataSource.xmlNamespaces. By default, the "xsi" prefix is bound to "http://www.w3.org/2001/XMLSchema-instance" in order to allow explicit null values in Records to be sent for DataSourceField.nillable','fields declared nillable. Set to null to avoid any prefixes being added.
		 * Flags: IR */
		xmlNamespaces: any /* Object */;

		/** recordXPath mapping to the data node of XML returned by the server. Applies if this.dataFormat is set to "xml". The default value will pick up data from a response structured as follows: &lt;response&gt; &lt;status&gt;0&lt;/status&gt; &lt;data&gt; &lt;record&gt; &lt;field1&gt;value&lt;/field1&gt; &lt;field2&gt;value&lt;/field2&gt; &lt;/record&gt; &lt;record&gt; &lt;field1&gt;value&lt;/field1&gt; &lt;field2&gt;value&lt;/field2&gt; &lt;/record&gt; &lt;/data&gt; &lt;/response&gt; 
		 * Flags: IR */
		xmlRecordXPath: string;


		/* Instance Method Overrides */

	} // RestDataSource

	export interface RestDataSourceStatic<T, P> extends DataSourceStatic<T, P> {
	} // RestDataSourceStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a ResultSet Props argument.
	 * This is derived from the methods in the ResultSet class and it's parents and their properties marked with the I flag.
	 */
	export interface ResultSetProps  {
		/** If the complete set of records for a resultSet is available when the resultSet is created, it can be made available to the resultSet via this property at initialization time. This data will then be considered cached meaning sorting and filtering can occur on the client (no need for server fetch). This cached data can be dropped via a call to ResultSet.invalidateCache. See also ResultSet.initialData and ResultSet.initialLength as an alternative approach for initializing a ResultSet with a partial cache, such that data paging will occur as uncached rows are requested.
		 * Flags: IRA, Group: fetching */
		allRows?: Array<any> /* Array of Record */; // Flags=IRA
		/** If true, records requested only for visible area.
		 * Flags: IRA */
		alwaysRequestVisibleRows?: boolean; // Flags=IRA
		/** Filter criteria used whenever records are retrieved. Use ResultSet.setCriteria to change the criteria after initialization.
		 * Flags: IRW */
		criteria?: Criteria; // Flags=IRW
		/** Decides under what conditions the cache should be dropped when the Criteria changes.
		 * Flags: IRWA */
		criteriaPolicy?: CriteriaPolicy; // Flags=IRWA
		/** What DataSource is this resultSet associated with?
		 * Flags: IR, Group: databinding */
		dataSource?: DataSource; // Flags=IR
		/** By default when the data of this ResultSet's dataSource is modified, the ResultSet will be updated to display these changes. Set this flag to true to disable this behavior.
		 * Flags: IRA, Group: cacheSync */
		disableCacheSync?: boolean; // Flags=IRA
		/** Whether to discard all cached rows when a modification operation (add, update, remove) occurs on the ResultSet's DataSource. A ResultSet that has a complete cache for the current filter criteria can potentially incorporate a newly created or updated row based on the data that the server returns when a modification operation completes. However this is not always possible for ResultSets that show some types of joins, or when the server cannot easily return update data. In this case set dropCacheOnUpdate to cause the cache to be discarded when an update occurs. dropCacheOnUpdate can be set either directly on a ResultSet, or on a DataSource in order to affect all ResultSets on that DataSource.
		 * Flags: IRA, Group: cacheSync */
		dropCacheOnUpdate?: boolean; // Flags=IRA
		/** Delay in milliseconds before fetching rows. When a get() or getRange() call asked for rows that haven't been loaded, the ResultSet will wait before actually triggering the request. If, during the delay, more get() or getRange() calls are made for missing rows, the final fetch to the server will reflect the most recently requested rows. The intent of this delay is to avoid triggering many unnecessary fetches during drag-scrolling and similar user interactions.
		 * Flags: IRWA, Group: fetching */
		fetchDelay?: number /* integer */; // Flags=IRWA
		/** Mode of fetching records from the server. If unset, will default to "local" if ResultSet.allRows is specified, otherwise "paged".
		 * Flags: IRA, Group: fetching */
		fetchMode?: FetchMode; // Flags=IRA
		/** DSRequest.operationId','operationId this component should use when performing fetch operations.
		 * Flags: IR, Group: operations */
		fetchOperation?: string /* String */; // Flags=IR
		/** Criteria that are never shown to or edited by the user and are cumulative with any criteria provided via DataBoundComponent.initialCriteria, ResultSet.setCriteria etc.
		 * Flags: IRW */
		implicitCriteria?: Criteria; // Flags=IRW
		/** Initial set of data for the ResultSet. This data will be treated exactly as though it were the data returned from the ResultSet's first server fetch. By default, initialData will be considered a complete response (all rows that match the Criteria which the ResultSet was initialized with). Set ResultSet.initialLength to treat initialData as a partial response, equivalent to receiving a DSResponse with startRow:0, endRow:initialData.length and totalRows:initialLength. Normal data paging will then occur if data is requested for row indices not filled via initialData. initialData may be provided as a "sparse" array, that is, slots may be left null indicating rows that have not been loaded. In this way you can create a ResultSet that is missing rows at the beginning of the dataset, but has loaded rows toward the end, so that you can create a component that is scrolled to a particular position of a dataset without loading rows at the beginning.
		 * Flags: IA, Group: fetching */
		initialData?: Array<any> /* Array of Record */; // Flags=IA
		/** Initial value of the data set length. To create a ResultSet with it's cache partly filled, see ResultSet.initialData.
		 * Flags: IA, Group: fetching */
		initialLength?: number /* integer */; // Flags=IA
		/** By default when a row is returned by the server, the current ResultSet.setCriteria','filter\n criteria are applied to it, and it may disappear from the cache. Set this flag to true to disable this behavior.
		 * Flags: IRA, Group: cacheSync */
		neverDropUpdatedRows?: boolean; // Flags=IRA
		/** Sets DataSource.progressiveLoading','progressive loading mode for this ResultSet. Any DSRequests issued by this ResultSet will copy this setting onto the request, overriding the OperationBinding- and DataSource-level settings. This setting is applied automatically by DataBoundComponents that have their own explicit setting for DataBoundComponent.progressiveLoading','progressiveLoading
		 * Flags: IRW, Group: progressiveLoading */
		progressiveLoading?: boolean; // Flags=IRW
		/** Allows to set a DSRequest properties to this ResulSet.
		 * Flags: IR */
		requestProperties?: DSRequestProps /* DSRequest Properties */; // Flags=IR
		/** How many rows to retrieve at once. Applicable only with fetchMode: "paged". When a paged ResultSet is asked for rows that have not yet been loaded, it will fetch adjacent rows that are likely to be required soon, in batches of this size.
		 * Flags: IRWA, Group: fetching */
		resultSize?: number /* integer */; // Flags=IRWA
		/** Initial sort specifiers for a ResultSet. Use ResultSet.setSort and ResultSet.getSort to sort the data after initialization rather than attempting to read or modify this property directly. Note: if ResultSet.initialData was specified, the data is assumed to already be sorted to match this sort configuration.
		 * Flags: IA, Group: fetching */
		sortSpecifiers?: Array<SortSpecifier> /* Array of SortSpecifier */; // Flags=IA
		/** When a successful Add, Update or Remove type operation fires on this ResultSet's dataSource, if DSResponse.data is unset, should we integrate the submitted data values (from the request) into our data-set? This attribute will be passed to DataSource.getUpdatedData as the useDataFromRequest parameter.
		 * Flags: IRA, Group: cacheSync */
		updateCacheFromRequest?: boolean; // Flags=IRA
		/** If set to true, updated and added rows will be integrated into the client-side cache even if paging is enabled and cache is partial. If updatePartialCache is false, the cache will be invalidated and new data fetched. If updatePartialCache is enabled and an "add" or "update" operation succeeds with a partial cache: updated rows will remain in their current position. No attempt will be made to sort them into a new position even if the sort field was updated. newly added rows will be added at either the end (first preference) or beginning of the dataset if that part of the dataset is cached and was most recently requested. If not, the new row is added at the end of the most recently requested contiguously cached range. The cache will then be dropped the next time rows are fetched, to prevent problems with inconsistent row numbering between the server and client, which could otherwise lead to duplicate rows or rows being skipped entirely.
		 * Flags: IRA, Group: cacheSync */
		updatePartialCache?: boolean; // Flags=IRA
		/** Whether to filter data locally when all DataSource records have been loaded (that is, criteria is blank and cache is complete). This may need to be disabled if client-side filtering differs from server-side filtering in a way that affects functionality or is surprising. This setting is distinct from fetchMode:"local", which explicitly loads all available DataSource records up front and always performs all filtering on the client. See ResultSet.applyFilter for default filtering behavior. NOTE: even with useClientFiltering false, client-side filtering will be used during cache sync to determine if an updated or added row matches the current criteria. To avoid relying on client-side filtering in this case, either: - avoid returning update data when the updated row doesn't match the current filter - set dropCacheOnUpdate
		 * Flags: IRWA */
		useClientFiltering?: boolean; // Flags=IRWA
		/** Whether to sort data locally when all records matching the current criteria have been cached. This may need to be disabled if client-side sort order differs from server-side sort order in a way that affects functionality or is surprising.
		 * Flags: IRWA */
		useClientSorting?: boolean; // Flags=IRWA

		/* Method Overrides */

		/** 
		 * Get the current criteria for this ResultSet.
		 */
		getCriteria?(): Criteria; 

		/** 
		 * Set the filter criteria to use when fetching rows. Depending on the result of ResultSet.compareCriteria and settings for ResultSet.useClientFiltering / FetchMode, setting criteria may cause a trip to the server to get a new set of rows, or may simply cause already-fetched rows to be re-filtered according to the new Criteria. In either case, the dataset length available from ResultSet.getLength may change and rows will appear at different indices. The filter criteria can be changed while server fetches for data matching the old criteria are still outstanding. If this is the case, the ResultSet will make sure that any records received matching the old criteria are not added to the cache for the new criteria. Any callbacks for responses to the outstanding requests are fired as normal, and the responses' DSResponse.totalRows','totalRows counts are kept (as they are still potentially meaningful to components using the ResultSet), but the response data is cleared so that it won't be used inadvertently as data matching the new criteria. Note: for simple Criteria, any field values in the criteria explicitly specified as null will be passed to the server. By default the server then returns only records whose value is null for that field. This differs from certain higher level methods such as ListGrid.fetchData which prune null criteria fields before performing a fetch operation.
		 * @param {Criteria} newCriteria - the filter criteria
		 */
		setCriteria?(newCriteria:Criteria): boolean; 

	} // ResultSetProps


	/**
	 * ResultSets are an implementation of the List interface that automatically fetches DataSource records when items are requested from the List. ResultSets provide robust, customizable, high-performance cache management for ListGrids and other built-in SmartClient components, and can be used as cache managers by custom components. ResultSets manage data paging, that is, loading records in batches as the user navigates the data set. A ResultSet will switch to using client-side sorting and filtering when possible to improve responsiveness and reduce server load. ResultSets also participate in automatic cache synchronization, observing operations on DataSources and automatically updating their caches. Creation A ResultSet can be passed to any component that expects a List, and the List APIs can be called directly on the ResultSet as long as the caller is able to deal with asynchronous loading; see ResultSet.getRange. Generally ResultSets do not need to be created directly, but are created by DataBound components as an automatic consequence of calling dataBoundComponentMethods','DataBound Component Methods. For example, the ListGrid.fetchData causes ListGrid.data to become an automatically created ResultSet object. Automatically created ResultSets can be customized via properties on ListGrids such as ListGrid.dataPageSize and ListGrid.dataProperties. All ResultSets for a given DataSource may also be customized via setting DataSource.resultSetClass to the name of a ResultSet isc.defineClass','subclass in which Class.addProperties','defaults have been changed. A ResultSet defaults to using data paging, setting DSRequest.startRow and DSRequest.endRow in issued dsRequests. Server code may always return more rows than the ResultSet requests and the ResultSet will correctly integrate those rows based on DSResponse.startRow/DSResponse.endRow','endRow. Hence the server can always avoid paging mode by simply returning all matching rows. A ResultSet can be created directly with just the ID of a DataSource: isc.ResultSet.create({ dataSource : "dataSourceID" }) Directly created ResultSets are typically used by custom components, or as a means of managing datasets that will be used by several components. When created directly rather than via a dataBoundComponent, a newly created ResultSet will not issue it's first "fetch" DSRequest until data is accessed (for example, via ResultSet.get','get()). Paging and total dataset length When using data paging, the server communicates the total number of records that match the current search criteria by setting DSResponse.totalRows. The ResultSet will then return this number from ResultSet.getLength','getLength(), and ListGrids and other components will show a scrollbar that allows the user to jump to the end of the dataset directly. However, the ResultSet does not require that the server calculate the true length of the dataset, which can be costly for an extremely large, searchable dataset. Instead, the server may simply advertise a totalRows value that is one page larger than the last row loaded. This results in a UI sometimes called "progressive loading", where the user may load more rows by scrolling past the end of the currently loaded rows, but is not allowed to skip to the end of the dataset. No client-side settings are required to enable this mode - it is entirely server-driven. However, it is usually coupled with ListGrid.canSort','disabling sorting, since server-side sorting would also force the server to traverse the entire dataset. Note also the DataSource.progressiveLoading','progressiveLoading flag, which can be applied at a DataSource, operation, request, component or ResultSet level; if you are using the built-in server-side DataSource implementations with Pro or better, this tells SmartClient Server to use its pre-built progressive loading mode for that DataSource, operation, request, component or ResultSet. Client-side Sorting and Filtering If a ResultSet obtains a full cache for the current set of filter criteria, it will automatically switch to client-side sorting, and will also use client-side filtering if the filter criteria are later changed but appear to be more restrictive than the criteria in use when the ResultSet obtained a full cache. The ResultSet.useClientSorting','useClientSorting and ResultSet.useClientFiltering','useClientFiltering flags can be used to disable client-side sorting and filtering respectively if these behaviors don't match server-based sorting and filtering. However, because client-side sorting and filtering radically improve responsiveness and reduce server load, it is better to customize the ResultSet so that it can match server-side sorting and filtering behaviors. Sorting behavior is primarily customized via the "sort normalizer" passed to ResultSet.sortByProperty, either via direct calls on a standalone ResultSet, or via ListGridField.sortNormalizer for a ListGrid-managed ResultSet. By default, client-side filtering interprets the Criteria','criteria passed to ResultSet.setCriteria','setCriteria() as a set of field values that records must match (similarly to the built-in SQL/Hibernate connectors built into the SmartClient Server). Custom client-side filtering logic can be implemented by overriding ResultSet.applyFilter','applyFilter(). Overriding ResultSet.compareCriteria','compareCriteria() allows you to control when the ResultSet uses client-side vs server-side filtering, and the ResultSet has two default ResultSet.criteriaPolicy','criteria policies built-in. Modifying ResultSets Records cannot be directly added or removed from a ResultSet via List APIs such as List.removeAt','removeAt(), since this would break the consistency of server and client row numbering needed for data paging, and also create some issues with automatic cache synchronization. Use DataSource.addData/DataSource.removeData','removeData() to add/remove rows from the DataSource, and the ResultSet will reflect the changes automatically. Alternatively, the DataSource.updateCaches method may be called to only update local caches of the DataSource in question, without generating any server traffic. To create a locally modifiable cache of Records from a DataSource, you can use DataSource.fetchData to retrieve a List of Records which can be modified directly, or you can create a client-only DataSource from the retrieved data to share a modifiable cache between several DataBoundComponents. Updates and Automatic Cache Synchronization Once a ResultSet has retrieved data or has been initialized with data, the ResultSet will observe any successful "update", "add" or "remove" dsRequests against their DataSource, regardless of the component that initiated them. A ResultSet with a full cache for the current filter criteria will integrate updates into the cache automatically. Updated rows that no longer match the current filter criteria will be removed automatically. To prevent this, you can set ResultSet.neverDropUpdatedRows. Added rows will similarly be added to the cache only if they match current filter criteria. Note that the client-side filtering described above is also used to determine whether updated or added rows should be in the cache. If any aspect of automated cache update is ever incorrect, ResultSet.dropCacheOnUpdate','dropCacheOnUpdate can be set for the ResultSet or DSResponse.invalidateCache can be set for an individual dsResponse. If automatic cache synchronization isn't working, troubleshoot the problem using the steps suggested <a href='http://forums.smartclient.com/showthread.php?t=8159#aGrid' target='_blank'>in the FAQ</a>. Regarding OperationBinding.operationId','operationIds and how they affect caching, take into account that cache sync is based on the fetch used - any add or update operation uses a fetch to retrieve updated data, and the operationId of that fetch can be set via OperationBinding.cacheSyncOperation','cacheSyncOperation. If the operationId of the cache is different from the operationId of the cache update data, it won't be used to update the cache, since the fields included and other aspects of the data are allowed to be different across different operationIds. This allows to maintain distinct caches on a per component basis, so when two components are using separate operationIds they are assumed to have distinct caches, because updates performed with one operationId will not affect the cache obtained via another operationId. Also, take into account that operationId must be unique per DataSource, across all operationTypes for that DataSource. Data Paging with partial cache When in paging mode with a partial cache, a ResultSet relies on server side sorting, setting DSRequest.sortBy to the current sort field and direction. In order for the cache to remain coherent, row numbering must continue to agree between server and client as new fetches are issued, otherwise, duplicate rows or missing rows may occur. If concurrent modifications by other users are allowed, generally the server should set DSResponse.invalidateCache to clear the cache when concurrent modification is detected. In paging mode with a partial cache, any successful "update" or "add" operation may cause client and server row numbering to become out of sync. This happens because the update may affect the sort order, and client and server cannot be guaranteed to match for sets of records that have equivalent values for the sort field. For this reason, after an "add" or "update" operation with a partial cache, the ResultSet will automatically mark cache for invalidation the next time a fetch operation is performed. Alternatively, if ResultSet.updatePartialCache is set to false, the ResultSet will simply invalidate cache immediately in this circumstance. 
	 */
	export interface ResultSet  {
		/** If the complete set of records for a resultSet is available when the resultSet is created, it can be made available to the resultSet via this property at initialization time. This data will then be considered cached meaning sorting and filtering can occur on the client (no need for server fetch). This cached data can be dropped via a call to ResultSet.invalidateCache. See also ResultSet.initialData and ResultSet.initialLength as an alternative approach for initializing a ResultSet with a partial cache, such that data paging will occur as uncached rows are requested.
		 * Flags: IRA, Group: fetching */
		allRows: Array<any> /* Array of Record */;

		/** If true, records requested only for visible area.
		 * Flags: IRA */
		alwaysRequestVisibleRows: boolean;

		/** Filter criteria used whenever records are retrieved. Use ResultSet.setCriteria to change the criteria after initialization.
		 * Flags: IRW */
		criteria: Criteria;

		/** Decides under what conditions the cache should be dropped when the Criteria changes.
		 * Flags: IRWA */
		criteriaPolicy: CriteriaPolicy;

		/** What DataSource is this resultSet associated with?
		 * Flags: IR, Group: databinding */
		dataSource: DataSource;

		/** By default when the data of this ResultSet's dataSource is modified, the ResultSet will be updated to display these changes. Set this flag to true to disable this behavior.
		 * Flags: IRA, Group: cacheSync */
		disableCacheSync: boolean;

		/** Whether to discard all cached rows when a modification operation (add, update, remove) occurs on the ResultSet's DataSource. A ResultSet that has a complete cache for the current filter criteria can potentially incorporate a newly created or updated row based on the data that the server returns when a modification operation completes. However this is not always possible for ResultSets that show some types of joins, or when the server cannot easily return update data. In this case set dropCacheOnUpdate to cause the cache to be discarded when an update occurs. dropCacheOnUpdate can be set either directly on a ResultSet, or on a DataSource in order to affect all ResultSets on that DataSource.
		 * Flags: IRA, Group: cacheSync */
		dropCacheOnUpdate: boolean;

		/** Delay in milliseconds before fetching rows. When a get() or getRange() call asked for rows that haven't been loaded, the ResultSet will wait before actually triggering the request. If, during the delay, more get() or getRange() calls are made for missing rows, the final fetch to the server will reflect the most recently requested rows. The intent of this delay is to avoid triggering many unnecessary fetches during drag-scrolling and similar user interactions.
		 * Flags: IRWA, Group: fetching */
		fetchDelay: number /* integer */;

		/** Mode of fetching records from the server. If unset, will default to "local" if ResultSet.allRows is specified, otherwise "paged".
		 * Flags: IRA, Group: fetching */
		fetchMode: FetchMode;

		/** DSRequest.operationId','operationId this component should use when performing fetch operations.
		 * Flags: IR, Group: operations */
		fetchOperation: string /* String */;

		/** Criteria that are never shown to or edited by the user and are cumulative with any criteria provided via DataBoundComponent.initialCriteria, ResultSet.setCriteria etc.
		 * Flags: IRW */
		implicitCriteria: Criteria;

		/** Initial set of data for the ResultSet. This data will be treated exactly as though it were the data returned from the ResultSet's first server fetch. By default, initialData will be considered a complete response (all rows that match the Criteria which the ResultSet was initialized with). Set ResultSet.initialLength to treat initialData as a partial response, equivalent to receiving a DSResponse with startRow:0, endRow:initialData.length and totalRows:initialLength. Normal data paging will then occur if data is requested for row indices not filled via initialData. initialData may be provided as a "sparse" array, that is, slots may be left null indicating rows that have not been loaded. In this way you can create a ResultSet that is missing rows at the beginning of the dataset, but has loaded rows toward the end, so that you can create a component that is scrolled to a particular position of a dataset without loading rows at the beginning.
		 * Flags: IA, Group: fetching */
		initialData: Array<any> /* Array of Record */;

		/** Initial value of the data set length. To create a ResultSet with it's cache partly filled, see ResultSet.initialData.
		 * Flags: IA, Group: fetching */
		initialLength: number /* integer */;

		/** By default when a row is returned by the server, the current ResultSet.setCriteria','filter\n criteria are applied to it, and it may disappear from the cache. Set this flag to true to disable this behavior.
		 * Flags: IRA, Group: cacheSync */
		neverDropUpdatedRows: boolean;

		/** Sets DataSource.progressiveLoading','progressive loading mode for this ResultSet. Any DSRequests issued by this ResultSet will copy this setting onto the request, overriding the OperationBinding- and DataSource-level settings. This setting is applied automatically by DataBoundComponents that have their own explicit setting for DataBoundComponent.progressiveLoading','progressiveLoading
		 * Flags: IRW, Group: progressiveLoading */
		progressiveLoading: boolean;

		/** Allows to set a DSRequest properties to this ResulSet.
		 * Flags: IR */
		requestProperties: DSRequestProps /* DSRequest Properties */;

		/** How many rows to retrieve at once. Applicable only with fetchMode: "paged". When a paged ResultSet is asked for rows that have not yet been loaded, it will fetch adjacent rows that are likely to be required soon, in batches of this size.
		 * Flags: IRWA, Group: fetching */
		resultSize: number /* integer */;

		/** Initial sort specifiers for a ResultSet. Use ResultSet.setSort and ResultSet.getSort to sort the data after initialization rather than attempting to read or modify this property directly. Note: if ResultSet.initialData was specified, the data is assumed to already be sorted to match this sort configuration.
		 * Flags: IA, Group: fetching */
		sortSpecifiers: Array<SortSpecifier> /* Array of SortSpecifier */;

		/** When a successful Add, Update or Remove type operation fires on this ResultSet's dataSource, if DSResponse.data is unset, should we integrate the submitted data values (from the request) into our data-set? This attribute will be passed to DataSource.getUpdatedData as the useDataFromRequest parameter.
		 * Flags: IRA, Group: cacheSync */
		updateCacheFromRequest: boolean;

		/** If set to true, updated and added rows will be integrated into the client-side cache even if paging is enabled and cache is partial. If updatePartialCache is false, the cache will be invalidated and new data fetched. If updatePartialCache is enabled and an "add" or "update" operation succeeds with a partial cache: updated rows will remain in their current position. No attempt will be made to sort them into a new position even if the sort field was updated. newly added rows will be added at either the end (first preference) or beginning of the dataset if that part of the dataset is cached and was most recently requested. If not, the new row is added at the end of the most recently requested contiguously cached range. The cache will then be dropped the next time rows are fetched, to prevent problems with inconsistent row numbering between the server and client, which could otherwise lead to duplicate rows or rows being skipped entirely.
		 * Flags: IRA, Group: cacheSync */
		updatePartialCache: boolean;

		/** Whether to filter data locally when all DataSource records have been loaded (that is, criteria is blank and cache is complete). This may need to be disabled if client-side filtering differs from server-side filtering in a way that affects functionality or is surprising. This setting is distinct from fetchMode:"local", which explicitly loads all available DataSource records up front and always performs all filtering on the client. See ResultSet.applyFilter for default filtering behavior. NOTE: even with useClientFiltering false, client-side filtering will be used during cache sync to determine if an updated or added row matches the current criteria. To avoid relying on client-side filtering in this case, either: - avoid returning update data when the updated row doesn't match the current filter - set dropCacheOnUpdate
		 * Flags: IRWA */
		useClientFiltering: boolean;

		/** Whether to sort data locally when all records matching the current criteria have been cached. This may need to be disabled if client-side sort order differs from server-side sort order in a way that affects functionality or is surprising.
		 * Flags: IRWA */
		useClientSorting: boolean;


		/* Instance Method Overrides */

		/** 
		 * Get the current criteria for this ResultSet.
		 */
		getCriteria?(): Criteria; 

		/** 
		 * Set the filter criteria to use when fetching rows. Depending on the result of ResultSet.compareCriteria and settings for ResultSet.useClientFiltering / FetchMode, setting criteria may cause a trip to the server to get a new set of rows, or may simply cause already-fetched rows to be re-filtered according to the new Criteria. In either case, the dataset length available from ResultSet.getLength may change and rows will appear at different indices. The filter criteria can be changed while server fetches for data matching the old criteria are still outstanding. If this is the case, the ResultSet will make sure that any records received matching the old criteria are not added to the cache for the new criteria. Any callbacks for responses to the outstanding requests are fired as normal, and the responses' DSResponse.totalRows','totalRows counts are kept (as they are still potentially meaningful to components using the ResultSet), but the response data is cleared so that it won't be used inadvertently as data matching the new criteria. Note: for simple Criteria, any field values in the criteria explicitly specified as null will be passed to the server. By default the server then returns only records whose value is null for that field. This differs from certain higher level methods such as ListGrid.fetchData which prune null criteria fields before performing a fetch operation.
		 * @param {Criteria} newCriteria - the filter criteria
		 */
		setCriteria?(newCriteria:Criteria): boolean; 

	} // ResultSet

	export interface ResultSetStatic<T, P> extends ClassStatic<T, P> {

	/* Methods */

	} // ResultSetStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a ResultTree Props argument.
	 * This is derived from the methods in the ResultTree class and it's parents and their properties marked with the I flag.
	 */
	export interface ResultTreeProps  {
		/** Controls what happens to the ResultTree.getOpenState','"open state" - the set of nodes opened or closed by the end user after tree data is loaded - when an entirely new tree of nodes is loaded from the server, as a consequence of calling ResultTree.invalidateCache or of changing criteria such that the current cache of nodes is dropped.
		 * Flags: IRW */
		autoPreserveOpenState?: PreserveOpenState; // Flags=IRW
		/** When using FetchMode','fetchMode:"paged" and providing multiple levels of the tree in one DSResponse, this property specifies the default value assumed for the ResultTree.canReturnOpenSubfoldersProperty when no value for that property is provided for a node.
		 * Flags: IR */
		canReturnOpenFolders?: boolean; // Flags=IR
		/** When using FetchMode','fetchMode:"paged" and providing multiple levels of the tree in one DSResponse, canReturnOpenSubfoldersProperty may be set on any folder to indicate whether child folders might be returned by the server already open. If the property is set to false on a folder then subfolders of that folder are never allowed to be returned already open. This enables the paging mechanism to be more efficient in the amount of data that it requests from the server. For example, setting the canReturnOpenSubfoldersProperty value to false on a node is appropriate if the server-side code determines that the the node's children consist of entirely leaf nodes.
		 * Flags: IR */
		canReturnOpenSubfoldersProperty?: string /* String */; // Flags=IR
		/** When using FetchMode','fetchMode:"paged" and providing multiple levels of the tree in one DSResponse, childCountProperty must be set for any folders that include only a partial list of children. For a deeper discussion see the Paging large sets of children section of the treeDataBinding overview.
		 * Flags: IR */
		childCountProperty?: string /* String */; // Flags=IR
		/** The filter criteria to use when fetching rows. For usage see ResultTree.setCriteria.
		 * Flags: IRW */
		criteria?: Criteria; // Flags=IRW
		/** Optional initial data for the tree. If the ResultTree.fetchMode','fetchMode is "basic" or "local" then the format of this data is exactly the same Tree.parentIdField','parentId-linked list of tree nodes as documented on Tree.data (when the modelType is set to "parent"). If the fetchMode is "paged" then the format is extended to allow the ResultTree.childCountProperty','childCountProperty to be set on folder nodes. Providing an initial set of nodes in this way does not affect the behavior of the ResultTree in its loading of unloaded folders. An equivalent result is achieved if the first fetch from the server returns this same data. If fetchMode is "paged" then you may make folder-by-folder choices as to whether to use paging for the childen of each folder. If you would like to use paging in a folder then you may include a partial list of that folder's children with the data, provided that you set the childCountProperty to the total number of children. Otherwise you will need to include either all children of the folder or none of the children. Open folders without any children provided will cause immediate, new fetches for the children, as usual. Because the initial data is treated exactly as though it were returned from the tree's first server fetch, the order of the initial data must match the initial sort order of the TreeGrid displaying the data or, if no such sort is specified, the native storage order on the server. For example, consider initial data containing n records having the parentId "X", meaning they are all in the same folder. These n records are the records at indices 0 through (n - 1) that are stored on the server under the parent node. If the childCountProperty set on the parent node indicates that there are m > n total rows under the parent node then the records at indices n to (m - 1) will be fetched from the server as the user scrolls the additional rows into view.
		 * Flags: IRA, Group: treeDataBinding */
		data?: any /* List of TreeNode */; // Flags=IRA
		/** What DataSource is this resultTree associated with?
		 * Flags: IR, Group: databinding */
		dataSource?: DataSource | string /* DataSource or ID */; // Flags=IR
		/** Controls whether nodes are assumed to be folders or leaves by default. Nodes that have children or have the Tree.isFolderProperty','isFolderProperty set to true will always be considered folders. Other nodes will be considered folders or leaves by default according to this setting. If defaultIsFolder is unset, the ResultTree will automatically set it to match the value of ResultTree.loadDataOnDemand. This means that, when using folder-by-folder load on demand (loadDataOnDemand:true), by default a newly loaded node will be considered to be a folder that has not loaded its children yet. When not using folder-by-folder load on demand, by default a newly loaded node is considered a leaf. If you set defaultIsFolder:true explicitly, by default a newly loaded node is considered to be a folder with no children. See Tree.isFolder for details on how to explicitly mark nodes as folders or leaves.
		 * Flags: IR */
		defaultIsFolder?: boolean; // Flags=IR
		/** This attribute governs how to handle cache-synch when a new node is added to this dataSource with no explicit parentId. If set to true, when a new node is added to this dataSource via DataSource.addData, with no explicit parentId, the node will be added as a child of the root node of this result tree. Otherwise it will be ignored. Similar logic applies to DataSource.updateData','updated nodes - if this property is true and the parentId of an updated node is cleared, it will be moved to become a child of root, otherwise it will be dropped from the tree.
		 * Flags: IRWA */
		defaultNewNodesToRoot?: boolean /* Boolean */; // Flags=IRWA
		/** By default when the data of this ResultTree's dataSource is modified, the ResultTree will be updated to display these changes. Set this flag to true to disable this behavior.
		 * Flags: IRA, Group: cacheSync */
		disableCacheSync?: boolean /* Boolean */; // Flags=IRA
		/** When data is loaded from the server, should nodes with an explicit value for the Tree.parentIdField which doesn't map to a valid parent node be dropped? If set to false, for TreeGrid.loadDataOnDemand:false trees, parentless nodes will be added as children of the root node - for TreeGrid.loadDataOnDemand:true, they will be added as children of the folder currently requesting children. This effectively allows nodes to be loaded into the current (or root) folder without needing an explicit Tree.parentIdField','parentIdField value that matches the folder's ID or rootValue for the resultTree. Note: For loadDataOnDemand:false trees, if this property is unset at init time, it will default to true if an explicit ResultTree.rootNode has been specified. This ensures that if the data tree retrieved from the server includes ancestors of the desired root-node we don't display them. Otherwise this property always defaults to false.
		 * Flags: IRA */
		discardParentlessNodes?: boolean; // Flags=IRA
		/** Mode of fetching records from server. fetchMode:"local" implies that local filtering will always be performed. See ResultTree.keepParentsOnFilter for additional filtering details. fetchMode:"basic" or "paged" implies that if search criteria change, the entire tree will be discarded and re-fetched from the server. When retrieving the replacement tree data, the default behavior will be to preserve the ResultTree.getOpenState','openState for any nodes that the server returns which were previously opened by the user. Note that this implies that if ResultTree.loadDataOnDemand is enabled and the server returns only root-level nodes, open state will be preserved only for root-level nodes, and children of open root-level nodes will be immediately fetched from the server if they are not included in the server's initial response. fetchMode:"paged" enables paging for nodes that have very large numbers of children. Whenever the children of a folder are loaded, the resultTree will set DSRequest.startRow and DSRequest.endRow','endRow when requesting children from the DataSource, and will manage loading of further children on demand, similar to how a ResultSet manages paging for lists. For a deeper discussion see the Paging large sets of children section of the treeDataBinding overview.
		 * Flags: IR, Group: treeDataBinding */
		fetchMode?: FetchMode; // Flags=IR
		/** Criteria that are never shown to or edited by the user and are cumulative with any criteria provided via DataBoundComponent.initialCriteria, ResultTree.setCriteria etc.
		 * Flags: IRW */
		implicitCriteria?: Criteria; // Flags=IRW
		/** If set, tree-based filtering is performed such that parent nodes are kept as long as they have children that match the filter criteria, even if the parents themselves do not match the filter criteria. If not set, filtering will exclude parent nodes not matching the criteria and all nodes below it in the tree. When keepParentsOnFilter is enabled for paged ResultTrees, server-side filtering is required. When enabled for non-paged trees, FetchMode','fetchMode:"local" is automatically enabled so that all filtering behavior shifts to the client-side and full criteria are no longer sent to the server. Instead, server fetches will always load all nodes, or with ResultTree.loadDataOnDemand:true, will always load all nodes under a given parent. This means that the server does not need to implement special tree filtering logic. Optionally, ResultTree.serverFilterFields can be set to a list of field names that will be sent to the server whenever they are present in the criteria.
		 * Flags: IR, Group: treeDataBinding */
		keepParentsOnFilter?: boolean; // Flags=IR
		/** Does this resultTree load data incrementally as folders within the tree are opened, or is it all loaded in a single request?
		 * Flags: IR */
		loadDataOnDemand?: boolean /* Boolean */; // Flags=IR
		/** Selects the model used to construct the tree representation. See TreeModelType for the available options and their implications. If the "parent" modelType is used, you can provide the initial parent-linked data set to the tree via the Tree.data attribute. If the "children" modelType is used, you can provide the initial tree structure to the Tree via the Tree.root attribute.
		 * Flags: IRWA */
		modelType?: TreeModelType; // Flags=IRWA
		/** Sets DataSource.progressiveLoading','progressive loading mode for this ResultTree. The ResultTree will copy this setting onto the DSRequests that it issues, overriding the OperationBinding- and DataSource-level settings, in cases where the use of progressive loading does not affect the correctness of the tree's paging algorithm. This setting is applied automatically by DataBoundComponents that have their own explicit setting for DataBoundComponent.progressiveLoading','progressiveLoading. Note: This property only has an effect for FetchMode','fetchMode:"paged" ResultTrees.
		 * Flags: IRW, Group: progressiveLoading */
		progressiveLoading?: boolean; // Flags=IRW
		/** How many tree nodes to retrieve at once from each large set of children in the tree. Applicable only with fetchMode: "paged". When a paged ResultTree is asked for rows that have not yet been loaded, it will fetch adjacent rows that are likely to be required soon, in batches of this size.
		 * Flags: IRA, Group: treeDataBinding */
		resultSize?: number /* integer */; // Flags=IRA
		/** This attribute may be used to specify a root value for the parentIdField of this resultTree. This overrides the default DataSourceField.rootValue for this tree, allowing a component to navigate a tree starting at a specific node. May be overridden via TreeGrid.treeRootValue for ResultTrees generated by a TreeGrid component.
		 * Flags: IR */
		rootNode?: any; // Flags=IR
		/** When ResultTree.keepParentsOnFilter is enabled for FetchMode','fetchMode:"local" ResultTrees, this property lists field names that will be sent to the server if they are present in the criteria.
		 * Flags: IR */
		serverFilterFields?: Array<string> /* Array of String */; // Flags=IR
		/** When a successful Add, Update or Remove type operation fires on this ResultTree's dataSource, if DSResponse.data is unset, should we integrate the submitted data values (from the request) into our data-set?
		 * Flags: IRA, Group: cacheSync */
		updateCacheFromRequest?: boolean /* Boolean */; // Flags=IRA

		/* Method Overrides */

		/** 
		 * Set the filter criteria to use when fetching rows. Depending on the result of ResultTree.compareCriteria and setting for ResultTree.fetchMode, setting criteria may cause a trip to the server to get a new set of nodes, or may simply cause already-fetched nodes to be re-filtered according to the new criteria. For a basic overview on when server fetches are generally performed, see ResultTree.fetchMode. However, this is not the final determination of when server fetches occur. Criteria can be split into local criteria and server criteria by specifying ResultTree.serverFilterFields. Thus, even when using fetchMode:"local" a new server fetch will occur if the server criteria changes. For details on how the criteria is split, see DataSource.splitCriteria. Note: if criteria is being split to retrieve server criteria portion and the criteria is an AdvancedCriteria, the criteria must consist of a single "and" operator and one or more simple criteria below it. No other logical operators may be used. In other words, the AdvancedCriteria provided must be exactly representable by a simple criteria.
		 * @param {Criteria} newCriteria - the filter criteria
		 */
		setCriteria?(newCriteria:Criteria): void; 

	} // ResultTreeProps


	/**
	 * ResultTrees are an implementation of the Tree API, used to handle hierarchical data, whose nodes are DataSource records which are retrieved from a server. Modifying ResultTrees ResultTree nodes cannot be directly added or removed from a ResultTree.fetchMode','paged ResultTree via Tree APIs such as Tree.add or Tree.remove, since such trees are considered to be read-only by virtue of containing ResultSets, which are read-only data structures. Even in other FetchModes, calling such APIs will only update the local cache of the ResultTree, rather than triggering any server traffict to update the DataSource. Use DataSource.addData/DataSource.removeData','removeData() to add/remove rows from the DataSource, and the ResultTree will reflect the changes automatically. Alternatively, the DataSource.updateCaches method may be called to only update local caches of the DataSource in question, without generating any server traffic. To create a locally modifiable cache of records from a DataSource, you can use DataSource.fetchData to retrieve a List of records which can be modified directly, or you can create a client-only DataSource from the retrieved data to share a modifiable cache between several DataBoundComponents. 
	 */
	export interface ResultTree  {
		/** Controls what happens to the ResultTree.getOpenState','"open state" - the set of nodes opened or closed by the end user after tree data is loaded - when an entirely new tree of nodes is loaded from the server, as a consequence of calling ResultTree.invalidateCache or of changing criteria such that the current cache of nodes is dropped.
		 * Flags: IRW */
		autoPreserveOpenState: PreserveOpenState;

		/** When using FetchMode','fetchMode:"paged" and providing multiple levels of the tree in one DSResponse, this property specifies the default value assumed for the ResultTree.canReturnOpenSubfoldersProperty when no value for that property is provided for a node.
		 * Flags: IR */
		canReturnOpenFolders: boolean;

		/** When using FetchMode','fetchMode:"paged" and providing multiple levels of the tree in one DSResponse, canReturnOpenSubfoldersProperty may be set on any folder to indicate whether child folders might be returned by the server already open. If the property is set to false on a folder then subfolders of that folder are never allowed to be returned already open. This enables the paging mechanism to be more efficient in the amount of data that it requests from the server. For example, setting the canReturnOpenSubfoldersProperty value to false on a node is appropriate if the server-side code determines that the the node's children consist of entirely leaf nodes.
		 * Flags: IR */
		canReturnOpenSubfoldersProperty: string /* String */;

		/** When using FetchMode','fetchMode:"paged" and providing multiple levels of the tree in one DSResponse, childCountProperty must be set for any folders that include only a partial list of children. For a deeper discussion see the Paging large sets of children section of the treeDataBinding overview.
		 * Flags: IR */
		childCountProperty: string /* String */;

		/** The filter criteria to use when fetching rows. For usage see ResultTree.setCriteria.
		 * Flags: IRW */
		criteria: Criteria;

		/** Optional initial data for the tree. If the ResultTree.fetchMode','fetchMode is "basic" or "local" then the format of this data is exactly the same Tree.parentIdField','parentId-linked list of tree nodes as documented on Tree.data (when the modelType is set to "parent"). If the fetchMode is "paged" then the format is extended to allow the ResultTree.childCountProperty','childCountProperty to be set on folder nodes. Providing an initial set of nodes in this way does not affect the behavior of the ResultTree in its loading of unloaded folders. An equivalent result is achieved if the first fetch from the server returns this same data. If fetchMode is "paged" then you may make folder-by-folder choices as to whether to use paging for the childen of each folder. If you would like to use paging in a folder then you may include a partial list of that folder's children with the data, provided that you set the childCountProperty to the total number of children. Otherwise you will need to include either all children of the folder or none of the children. Open folders without any children provided will cause immediate, new fetches for the children, as usual. Because the initial data is treated exactly as though it were returned from the tree's first server fetch, the order of the initial data must match the initial sort order of the TreeGrid displaying the data or, if no such sort is specified, the native storage order on the server. For example, consider initial data containing n records having the parentId "X", meaning they are all in the same folder. These n records are the records at indices 0 through (n - 1) that are stored on the server under the parent node. If the childCountProperty set on the parent node indicates that there are m > n total rows under the parent node then the records at indices n to (m - 1) will be fetched from the server as the user scrolls the additional rows into view.
		 * Flags: IRA, Group: treeDataBinding */
		data: any /* List of TreeNode */;

		/** What DataSource is this resultTree associated with?
		 * Flags: IR, Group: databinding */
		dataSource: DataSource | string /* DataSource or ID */;

		/** Controls whether nodes are assumed to be folders or leaves by default. Nodes that have children or have the Tree.isFolderProperty','isFolderProperty set to true will always be considered folders. Other nodes will be considered folders or leaves by default according to this setting. If defaultIsFolder is unset, the ResultTree will automatically set it to match the value of ResultTree.loadDataOnDemand. This means that, when using folder-by-folder load on demand (loadDataOnDemand:true), by default a newly loaded node will be considered to be a folder that has not loaded its children yet. When not using folder-by-folder load on demand, by default a newly loaded node is considered a leaf. If you set defaultIsFolder:true explicitly, by default a newly loaded node is considered to be a folder with no children. See Tree.isFolder for details on how to explicitly mark nodes as folders or leaves.
		 * Flags: IR */
		defaultIsFolder: boolean;

		/** This attribute governs how to handle cache-synch when a new node is added to this dataSource with no explicit parentId. If set to true, when a new node is added to this dataSource via DataSource.addData, with no explicit parentId, the node will be added as a child of the root node of this result tree. Otherwise it will be ignored. Similar logic applies to DataSource.updateData','updated nodes - if this property is true and the parentId of an updated node is cleared, it will be moved to become a child of root, otherwise it will be dropped from the tree.
		 * Flags: IRWA */
		defaultNewNodesToRoot: boolean /* Boolean */;

		/** By default when the data of this ResultTree's dataSource is modified, the ResultTree will be updated to display these changes. Set this flag to true to disable this behavior.
		 * Flags: IRA, Group: cacheSync */
		disableCacheSync: boolean /* Boolean */;

		/** When data is loaded from the server, should nodes with an explicit value for the Tree.parentIdField which doesn't map to a valid parent node be dropped? If set to false, for TreeGrid.loadDataOnDemand:false trees, parentless nodes will be added as children of the root node - for TreeGrid.loadDataOnDemand:true, they will be added as children of the folder currently requesting children. This effectively allows nodes to be loaded into the current (or root) folder without needing an explicit Tree.parentIdField','parentIdField value that matches the folder's ID or rootValue for the resultTree. Note: For loadDataOnDemand:false trees, if this property is unset at init time, it will default to true if an explicit ResultTree.rootNode has been specified. This ensures that if the data tree retrieved from the server includes ancestors of the desired root-node we don't display them. Otherwise this property always defaults to false.
		 * Flags: IRA */
		discardParentlessNodes: boolean;

		/** Mode of fetching records from server. fetchMode:"local" implies that local filtering will always be performed. See ResultTree.keepParentsOnFilter for additional filtering details. fetchMode:"basic" or "paged" implies that if search criteria change, the entire tree will be discarded and re-fetched from the server. When retrieving the replacement tree data, the default behavior will be to preserve the ResultTree.getOpenState','openState for any nodes that the server returns which were previously opened by the user. Note that this implies that if ResultTree.loadDataOnDemand is enabled and the server returns only root-level nodes, open state will be preserved only for root-level nodes, and children of open root-level nodes will be immediately fetched from the server if they are not included in the server's initial response. fetchMode:"paged" enables paging for nodes that have very large numbers of children. Whenever the children of a folder are loaded, the resultTree will set DSRequest.startRow and DSRequest.endRow','endRow when requesting children from the DataSource, and will manage loading of further children on demand, similar to how a ResultSet manages paging for lists. For a deeper discussion see the Paging large sets of children section of the treeDataBinding overview.
		 * Flags: IR, Group: treeDataBinding */
		fetchMode: FetchMode;

		/** Criteria that are never shown to or edited by the user and are cumulative with any criteria provided via DataBoundComponent.initialCriteria, ResultTree.setCriteria etc.
		 * Flags: IRW */
		implicitCriteria: Criteria;

		/** If set, tree-based filtering is performed such that parent nodes are kept as long as they have children that match the filter criteria, even if the parents themselves do not match the filter criteria. If not set, filtering will exclude parent nodes not matching the criteria and all nodes below it in the tree. When keepParentsOnFilter is enabled for paged ResultTrees, server-side filtering is required. When enabled for non-paged trees, FetchMode','fetchMode:"local" is automatically enabled so that all filtering behavior shifts to the client-side and full criteria are no longer sent to the server. Instead, server fetches will always load all nodes, or with ResultTree.loadDataOnDemand:true, will always load all nodes under a given parent. This means that the server does not need to implement special tree filtering logic. Optionally, ResultTree.serverFilterFields can be set to a list of field names that will be sent to the server whenever they are present in the criteria.
		 * Flags: IR, Group: treeDataBinding */
		keepParentsOnFilter: boolean;

		/** Does this resultTree load data incrementally as folders within the tree are opened, or is it all loaded in a single request?
		 * Flags: IR */
		loadDataOnDemand: boolean /* Boolean */;

		/** Selects the model used to construct the tree representation. See TreeModelType for the available options and their implications. If the "parent" modelType is used, you can provide the initial parent-linked data set to the tree via the Tree.data attribute. If the "children" modelType is used, you can provide the initial tree structure to the Tree via the Tree.root attribute.
		 * Flags: IRWA */
		modelType: TreeModelType;

		/** Sets DataSource.progressiveLoading','progressive loading mode for this ResultTree. The ResultTree will copy this setting onto the DSRequests that it issues, overriding the OperationBinding- and DataSource-level settings, in cases where the use of progressive loading does not affect the correctness of the tree's paging algorithm. This setting is applied automatically by DataBoundComponents that have their own explicit setting for DataBoundComponent.progressiveLoading','progressiveLoading. Note: This property only has an effect for FetchMode','fetchMode:"paged" ResultTrees.
		 * Flags: IRW, Group: progressiveLoading */
		progressiveLoading: boolean;

		/** How many tree nodes to retrieve at once from each large set of children in the tree. Applicable only with fetchMode: "paged". When a paged ResultTree is asked for rows that have not yet been loaded, it will fetch adjacent rows that are likely to be required soon, in batches of this size.
		 * Flags: IRA, Group: treeDataBinding */
		resultSize: number /* integer */;

		/** This attribute may be used to specify a root value for the parentIdField of this resultTree. This overrides the default DataSourceField.rootValue for this tree, allowing a component to navigate a tree starting at a specific node. May be overridden via TreeGrid.treeRootValue for ResultTrees generated by a TreeGrid component.
		 * Flags: IR */
		rootNode: any;

		/** When ResultTree.keepParentsOnFilter is enabled for FetchMode','fetchMode:"local" ResultTrees, this property lists field names that will be sent to the server if they are present in the criteria.
		 * Flags: IR */
		serverFilterFields: Array<string> /* Array of String */;

		/** When a successful Add, Update or Remove type operation fires on this ResultTree's dataSource, if DSResponse.data is unset, should we integrate the submitted data values (from the request) into our data-set?
		 * Flags: IRA, Group: cacheSync */
		updateCacheFromRequest: boolean /* Boolean */;


		/* Instance Method Overrides */

		/** 
		 * Set the filter criteria to use when fetching rows. Depending on the result of ResultTree.compareCriteria and setting for ResultTree.fetchMode, setting criteria may cause a trip to the server to get a new set of nodes, or may simply cause already-fetched nodes to be re-filtered according to the new criteria. For a basic overview on when server fetches are generally performed, see ResultTree.fetchMode. However, this is not the final determination of when server fetches occur. Criteria can be split into local criteria and server criteria by specifying ResultTree.serverFilterFields. Thus, even when using fetchMode:"local" a new server fetch will occur if the server criteria changes. For details on how the criteria is split, see DataSource.splitCriteria. Note: if criteria is being split to retrieve server criteria portion and the criteria is an AdvancedCriteria, the criteria must consist of a single "and" operator and one or more simple criteria below it. No other logical operators may be used. In other words, the AdvancedCriteria provided must be exactly representable by a simple criteria.
		 * @param {Criteria} newCriteria - the filter criteria
		 */
		setCriteria?(newCriteria:Criteria): void; 

	} // ResultTree

	export interface ResultTreeStatic<T, P> extends ClassStatic<T, P> {
	} // ResultTreeStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a RPCRequest Props argument.
	 * This is derived from the methods in the RPCRequest class and it's parents and their properties marked with the I flag.
	 */
	export interface RPCRequestProps  {
		/** Overrides RPCManager.actionURL for this request only. If you're using queuing, note that queues as per-URL - in other words all RPCRequests in a queue must go to a single URL. If you attempt to send a request with an actionURL that is different from those already in the queue, it will be sent to the server separately, ahead of the queue, and a warning will be logged to the Developer Console.
		 * Flags: IRW */
		actionURL?: string /* URL */; // Flags=IRW
		/** Advanced flag to avoid a potential memory leak in Internet Explorer 9 for requests with JSON formatted responses. This attribute may be set to false to explicitly enable the workaround described RPCManager.allowIE9Leak','here for this request, avoiding a potential memory leak in Internet Explorer 9. This workaround has a limitation in that if parsing the JSON response generates certain object types including JavaScript Date or function objects, attempts to interact with these objects can subsequently lead to a JavaScript error with the message "Can't execute code from a freed script". This workaround therefore may not be suitable for all transactions or dataSources within a given application. This property may also be set globally within an application (via RPCManager.allowIE9Leak)_. Note: This memory leak and workaround is discussed further in the online <a href="http://forums.smartclient.com/showthread.php?t=8159">SmartClient FAQ</a>.
		 * Flags: IRA */
		allowIE9Leak?: boolean; // Flags=IRA
		/** For xmlHttp transport + httpMethod: "GET" only, set to true to force a conditional GET request even if the browser thinks it has a current cached response.
		 * Flags: IRWA */
		bypassCache?: boolean /* Boolean */; // Flags=IRWA
		/** If you expect to receive a response to your RPC request, you can specify a callback that will be called with an instance or RPCResponse class as sent by the server. Queuing does not affect callbacks in any way - your specified callback will be invoked for each RPCRequest that contained a callback regardless of whether the request was sent as part of a queue or not. Note that if the request encounters an error (such as 500 server error), by default the callback will not be fired, instead, RPCManager.handleError is called to invoke the default system-wide error handling. Set RPCRequest.willHandleError:true to have your callback invoked regardless of whether there are errors, however, make sure your callback properly handles malformed responses when RPCResponse.status is non-zero. See the errorHandling','error handling overview for more details.
		 * Flags: IRW, Group: errorHandling */
		callback?: any /* RPCCallback */; // Flags=IRW
		/** For use only with the RPCTransport','scriptInclude transport, this attribute specifies the name of the URL parameter which is used to specify the callback function that the server is expected to call by writing out JavaScript code. The actual function to call is automatically generated and differs for every request (to allow concurrency). For example, with callbackParam set to it's default value of "callback", the server might be contacted with a URL like: loadData?callback=isc_scriptIncludeCallback_5 .. then the server's response should look like: isc_scriptIncludeCallback_5({ .. data .. }); The name "isc_scriptIncludeCallback_5" is automatically generated and will differ each time the server is contacted. SmartClient makes of this server-provided callback mechanism, then calls RPCRequest.callback normally. rpcRequest.callbackParam is ignored by all transport other than scriptInclude.
		 * Flags: IRW */
		callbackParam?: string /* String */; // Flags=IRW
		/** An object to be held onto for the duration of the RPC turnaround to track application-specific context. When an RPC turnaround completes, the clientContext is available in the Callbacks.RPCCallback','RPCCallback as rpcResponse.clientContext. The clientContext is never sent to the server. The clientContext is useful for holding onto state that will be used when the Callbacks.RPCCallback','RPCCallback fires, such as the name of a component that will receive the returned data.
		 * Flags: IRW */
		clientContext?: any /* Object */; // Flags=IRW
		/** For use during relogin','Relogin, this property marks this request an attempt to login, therefore a response containing the loginRequiredMarker is a normal condition and should result in the status code RPCResponse.STATUS_LOGIN_INCORRECT rather than a call to RPCManager.loginRequired','loginRequired(). It is not required to set containsCredentials, however, it does typically simplify relogin logic by separating the handling of RPCs that are login attempts from RPCs that are not.
		 * Flags: IRWA, Group: relogin */
		containsCredentials?: boolean /* Boolean */; // Flags=IRWA
		/** Valid with the xmlHttpRequest transport only and only when RPCRequest.httpMethod is set to "POST".
		 * Flags: IRW */
		contentType?: string /* String */; // Flags=IRW
		/** This attribute specifies the payload of the RPCRequest. When using the iscServer','SmartClient server, any JavaScript simple type or arbitrarily nested set of Objects and Arrays can be sent to server and automatically translated to Java Objects. Here are the mapping of JavaScript types to their corresponding server object types: <table class='normal' border='1'> <tr><td>JS Type</td> <td>Java Type</td></tr> <tr><td>Object: {}</td> <td>Map</td></tr> <tr><td>Array: []</td> <td>List</td></tr> <tr><td>String</td> <td>String</td></tr> <tr><td>Number</td> <td>Long|Double</td></tr> <tr><td>Boolean</td> <td>Boolean</td></tr> <tr><td>Date</td> <td>java.util.Date</td></tr> <tr><td>String</td> <td>com.smartgwt.client.types.ValueEnum</td></tr> </table> Note that the order of keys/values in the Maps created on the server is not guaranteed because JavaScript Object literals do not guarantee order. When using JPA or Hibernate Java value used can be affected by the Java Bean declaration. See dsRequestBeanTypes for details. Server->client conversion follows this table as well, with some extras. See the toJS() method on JSTranslater in the server documentation for a description of additional behaviors. When not communicating with the SmartClient server, rpcRequest.data becomes simple HTTP parameters or an HTTP request body - see RPCRequest.useSimpleHttp for details.
		 * Flags: IRW */
		data?: string | any | any /* String | Record | Object */; // Flags=IRW
		/** If enabled, causes the RPCRequest to download the requested resource as a file, either showing the browser's Save dialog or displaying the file-content in RPCRequest.downloadToNewWindow','a new browser window. Setting this attribute to true means that no callback will be fired and implies that the request will silently use RPCRequest.transport','transport: "hiddenFrame".
		 * Flags: IRWA */
		downloadResult?: boolean /* Boolean */; // Flags=IRWA
		/** When RPCRequest.downloadResult','downloadResult is true, setting this attribute to true causes the content of the downloaded file to be displayed in a new browser window.
		 * Flags: IRWA */
		downloadToNewWindow?: boolean /* Boolean */; // Flags=IRWA
		/** This works similarly to RPCRequest.serverOutputAsString except the resulting String is automatically evaluated as JavaScript. The result of the evaluation is then passed to any specified RPCRequest.callback as RPCResponse.data. This feature can be used to dynamically load new application modules into a running application. An RPCRequest with evalResult enabled can be used to fetch a static .js file or JavaScript dynamically generated by the server. The returned JavaScript can contain anything that a JavaScript file loaded at init time can contain, including new views and new SmartClient class definitions. Example usage with RPCManager.sendRequest: isc.RPCManager.sendRequest({ evalResult:true, actionURL:"js/loadLabel.js", evalVars:{var1:"A Value"} }); This call would execute the code from loadLabel.js, and make the variable var1 available to that code. Therefore if the .js file contained this code: isc.Label.create({ contents:var1 }) A label would be created with contents set to the value of var1 - the string "A Value". This feature relies on the XMLHttpRequest object which can be disabled by end-users in some supported browsers. See platformDependencies for more information.
		 * Flags: IRWA, Group: viewLoading */
		evalResult?: boolean /* Boolean */; // Flags=IRWA
		/** If you've set RPCRequest.evalResult : true, then the property values of this object will be available in the evaluation scope of the result under the variable names specified by the property names. So e.g. if evalVars is: {foo: "bar"} then a reference to the variable foo in the result will evaluate to "bar".
		 * Flags: IRWA, Group: viewLoading */
		evalVars?: any /* Object */; // Flags=IRWA
		/** HTTP headers to send, as a Object mapping Header name -> Header value, eg { "Content-Type" : "text/xml" } Valid with the xmlHttpRequest RPCRequest.transport','transport only.
		 * Flags: IRW */
		httpHeaders?: any /* Object */; // Flags=IRW
		/** Selects the HTTP method that will be used for the request. Typical values are "POST" and "GET". The more obscure "PUT", "DELETE" and "HEAD" methods are also valid, however, none of these are supported by the Safari browser previous to version 3.0.
		 * Flags: IRW */
		httpMethod?: string /* String */; // Flags=IRW
		/** The proxy URL to use for this request (if RPCRequest.useHttpProxy is set for this request). If unset, the value of RPCManager.httpProxyURL will be used instead.
		 * Flags: IR */
		httpProxyURL?: string; // Flags=IR
		/** When set to true, no reply is expected from the server. However, if a reply is received, it will be processed. Note: setting this to true, forces RPCRequest.sendNoQueue to true for this request.
		 * Flags: IRWA */
		ignoreTimeout?: boolean /* Boolean */; // Flags=IRWA
		/** If enabled, the server omits any key/value pairs in map that have null values from the response. This can reduce the size of the response when many fields have null values. To enable this globally for all responses you can set RPCManager.omitNullMapValuesInResponse in server_properties','server.properties.
		 * Flags: IRWA */
		omitNullMapValuesInResponse?: boolean /* Boolean */; // Flags=IRWA
		/** Values to be sent as simple HTTP params, as a JavaScript Object where each property/value pair will become an HTTP parameter name and value. These parameters are then accessible on the server, for example, using servletRequest.getParameter(paramName) in Java Servlets. Array-valued parameters will be submitted as multiple instances of the same parameter, similar to an HTML form with a multi-select (?paramName=value1&amp;paramName=value2 ...), accessible as getParameterValues(paramName) in Java Servlets. Any non-atomic type, such as an Object, will be serialized to <a href='http://www.json.org/' target='_blank'>JSON</a> by the JSONEncoder. If this isn't desirable, serialize the data in advance so that the value provided in rpcRequest.params is a String. Note that this API is primarily used in combination with RPCRequest.useSimpleHttp - when contacting the SmartClient Server, use RPCRequest.data instead, which provides full JavaScript &lt;-&gt; Java translation of arbitrary structures. rpcRequest.params can also be used with the SmartClient Server, where it provides an an opportunity to send additional data aside from the main RPCRequest.data payload. This is useful for adding data to DataSource requests which will be kept separate from the automatically sent DataSource data, or for making parts of the request visible in the URL for HTTP-level logging or layer 4 switches. Note that in contrast to RPCRequest.data object, the data in rpcRequest.params is not deserialized by the SmartClient server, and all values arrive on the server as String type (like HTTP parameters always do). The params value can also be specified as a componentID or component instance that provides a method getValues() that returns an Object containing parameter names and values. SmartClient components DynamicForm, ValuesManager are two such classes. Lastly, you may specify the ID of a native form element (retrievable via getElementById()) and the params will be populated from there. If there is an error resolving your params directive, it will be logged to the Developer Console. Note: The params are submitted once per http transaction. If you are using RPCManager.startQueue','request queuing to bundle multiple RPCRequests or DSRequests into a single HTTP turnaround, the params from the various RPCRequests will be merged, with the later-queued transactions winning on parameter name collisions. A warning will be logged in the Developer Console if multiple RPCRequests specified params.
		 * Flags: IRW */
		params?: any /* Object */; // Flags=IRW
		/** Overrides RPCManager.defaultPrompt for this request only. If you're using queuing, note that the prompt string from the first request in the queue is the one that is shown to the user.
		 * Flags: IRW, Group: rpcPrompt */
		prompt?: string /* HTMLString */; // Flags=IRW
		/** Controls the cursor shown when RPCManager.promptStyle is set to "cursor" for this request only. Defaults to RPCManager.promptCursor.
		 * Flags: IRW, Group: rpcPrompt */
		promptCursor?: string /* String */; // Flags=IRW
		/** Overrides RPCManager.promptDelay for this request only. Defaults to RPCManager.promptDelay. If you're using queuing, note that the promptDelay of the first request is used for the entire queue.
		 * Flags: IRWA, Group: rpcPrompt */
		promptDelay?: number; // Flags=IRWA
		/** Controls the prompt style for this request only. Defaults to RPCManager.promptStyle.
		 * Flags: IRW, Group: rpcPrompt */
		promptStyle?: PromptStyle; // Flags=IRW
		/** When set to true, this request is sent to the server immediately, bypassing any current queue.
		 * Flags: IRWA */
		sendNoQueue?: boolean /* Boolean */; // Flags=IRWA
		/** Setting this flag makes the body of the HTTP response available as a String in the RPCRequest.callback as RPCResponse.data. This is typically only useful if you are sending a request that will not be received by the SmartClient Java Server, however in that case, set RPCRequest.useSimpleHttp:true instead, which implies serverOutputAsString:true. serverOutputAsString:true allows you to, for example, load the contents of static files off your webserver into a string for processing on the client with no server support. The RPCRequest.actionURL must be in the same domain as the current page for this to work. This feature relies on the XMLHttpRequest object which can be disabled by end-users in some supported browsers. See platformDependencies for more information. Generally this API is used for either nonJavaBackend','non-Java backends or for advanced usage such as content that requires processing before it can be used in SmartClient components (such as client-side web scraping). Note that SmartClient provides higher-level APIs for loading common types of data, see eg HTMLFlow for HTML content, ViewLoader for loading SmartClient components, XMLTools.loadXML for loading XML, RPCRequest.evalResult for loading <a href='http://www.json.org/' target='_blank'>JSON</a>, and DataSource for loading structured data in various formats.
		 * Flags: IRWA */
		serverOutputAsString?: boolean /* Boolean */; // Flags=IRWA
		/** Overrides RPCManager.showPrompt for this request only. If you're using queuing, note that if any of the requests in the queue specify showPrompt:true, then a prompt will be shown for the entire queue with the prompt text of the first request in the queue to specify a custom prompt if promptStyle is set to "dialog". If promptStyle is set to "cursor" for the request that specified showPrompt: true, then the entire queue uses the "cursor" style for the prompt.
		 * Flags: IRW, Group: rpcPrompt */
		showPrompt?: boolean /* Boolean */; // Flags=IRW
		/** If RPCRequest.evalResult is set, setting this property to true causes Canvas.autoDraw to be set to false for the duration of the result evaluation - which is generally what you want if you're returning new components from the server. This also effects components loaded via the RPCManager.loadScreen API.
		 * Flags: IRWA */
		suppressAutoDraw?: boolean /* Boolean */; // Flags=IRWA
		/** Sets the timeout on this request. Default is to use RPCManager.defaultTimeout. If you're using RPCManager.startQueue','queuing, note that the timeout setting derived from the last request in the queue is used for the entire queue. If you want to override the timeout for the queue, make sure to set your override at least on the last request in the queue. For the "xmlHttpRequest" RPCRequest.transport','transport, this timeout can only happen if the server actually fails to respond within the specified number of milliseconds. For the "hiddenFrame" transport, this timeout will occur for non-200 (HTTP_OK) responses. If timeout is set to zero, the RPCManager will not enforce a timeout for this request. However, note that all browsers enforce their own timeouts on HTTP requests, and may have different timeouts for different kinds of failures (no response at all from server, hung response after receiving headers, hung response after receiving partial data, etc). Also, intervening web proxies or firewalls may impose timeouts of their own. As a rough rule of thumb, if your server response will have a lengthy pause before data begins to be sent, 1-2 minutes is the maximum allowable pause for a public site and still may not work for a minority of users, but up to 4 minutes may be allowable in a controlled environment (intranet or extranet with well-known user base). Above these limits, your code should return some kind of immediate response to the browser, then kick off a server-side process to complete processing. The browser can then either poll for completion, or use a server-push notification system such as SmartClient Real-Time Messaging (see <a href='http://smartclient.com/product' target='_blank'>http://smartclient.com/product</a>).
		 * Flags: IRWA */
		timeout?: number /* int */; // Flags=IRWA
		/** Selects the transport used for this RPCRequest. If unset, the value of RPCManager.defaultTransport will be used. If you're using queueing, note that all requests in the queue must use the same transport. If you attempt to send a request via a different transport than those that are currently on the queue, it will be sent to the server separately, ahead of the queue, and a warning will be logged to the Developer Console. If you specify an unknown transport, an error will be logged to the DeveloperConsole and RPCManager.defaultTransport will be used instead. If you specify the xmlHttpRequest transport and it is not available, a warning will be logged to the Developer Console and the RPCManager will attempt to use the hiddenFrame transport instead for this request. Note that some features like RPCRequest.serverOutputAsString require the xmlHttpRequest transport and will not work if the xmlHttpRequest transport is unavailable (this can happen if the end user is using Internet Explorer and has disabled ActiveX). You can check whether or not the xmlHttpRequest transport is currently available by calling RPCManager.xmlHttpRequestAvailable.
		 * Flags: IRWA */
		transport?: RPCTransport; // Flags=IRWA
		/** Indicates whether this request should use the HttpProxyServlet in order to enable contacting hosts other than the origin server (available only in Pro Edition or better). When various UI components issues requests automatically, or when a call to RPCManager.sendProxied is made, the HttpProxy will automatically be used for a URL that starts with "http" and uses a hostname other than "localhost" or window.location.hostname, or if the port number differs. rpcRequest.useHttpProxy should only be used to force requests to go through the HttpProxy when the above rules don't work, or to avoid using the HttpProxy when contacting hosts that allow cross-site calls via the <a href='http://www.google.com/search?q=http+access+control' target='_blank'>Http Access Control</a> standard. You can also set RPCManager.useHttpProxy:false to avoid ever using the HttpProxyServlet.
		 * Flags: IR */
		useHttpProxy?: boolean; // Flags=IR
		/** When set to true, assume the request is not going to the SmartClient server, and hence send a simple HTTP request that does not use SmartClient-specific request encoding. Values specified in RPCRequest.params are sent to to the server as HTTP request parameters. If RPCRequest.httpMethod is "GET", parameters appear in the request URL, otherwise if httpMethod is "POST", parameters are encoded in the request body (exactly like an HTML form does). These parameters are then accessible via typical server-side APIs for retrieving HTTP parameters, eg, servletRequest.getParameter(paramName) in Java Servlets. Note that if RPCRequest.httpMethod method is POST and RPCRequest.data is supplied, RPCRequest.data is assumed to be a string to post as the HTTP request body, and RPCRequest.params are sent as URL parameters instead. This usage is for sending custom request bodies such as the XML payloads used for SOAP. In this case, RPCRequest.contentType is typically also set to indicate the content type of the request body. Setting useSimpleHttp to true also automatically sets RPCRequest.serverOutputAsString to true as well.
		 * Flags: IRWA */
		useSimpleHttp?: boolean /* Boolean */; // Flags=IRWA
		/** With willHandleError:false, rpcResponses that indicate an error go through centralized handling in the RPCManager and rpcRequest.callback is never invoked. Setting willHandleError:true means that your rpcRequest.callback will receive rpcResponses that have an error status and must handle them. See also the error handling section in the RPCManager docs.
		 * Flags: IRW, Group: errorHandling */
		willHandleError?: boolean /* Boolean */; // Flags=IRW
		/** In browsers that support <a href='http://www.w3.org/TR/cors/' target='_blank'>Cross-Origin Resource Sharing</a> and <a href='http://caniuse.com/#feat=xhr2' target='_blank'>XMLHttpRequest 2</a>, and where the service at the RPCRequest.actionURL','actionURL allows the origin to send credentials (see <a href='http://www.w3.org/TR/cors/#access-control-allow-credentials-response-header' target='_blank'>Access-Control-Allow-Credentials</a>), should <a href='http://www.w3.org/TR/cors/#user-credentials' target='_blank'>user credentials</a> such as cookies, HTTP authentication, and client-side SSL certificates be sent with the actual CORS request? This setting only applies when the request RPCRequest.transport','transport is "xmlHttpRequest". Note that Internet Explorer 10 and 11 do not send cookies as part of user credentials: <a href='https://connect.microsoft.com/IE/Feedback/Details/759587/' target='_blank'>IE10 doesn't support cookies on cross origin XMLHttpRequest withCredentials=true</a>.
		 * Flags: IRA */
		withCredentials?: boolean /* Boolean */; // Flags=IRA
	} // RPCRequestProps


	/**
	 * Encapsulates a client/server RPC request. You'll need to provide an instance of this class (or a constructor for it) to the RPCManager.sendRequest method. If you use the RPCManager.send method, an instance of RPCRequest will be created for you. 
	 */
	export interface RPCRequest  {
		/** Overrides RPCManager.actionURL for this request only. If you're using queuing, note that queues as per-URL - in other words all RPCRequests in a queue must go to a single URL. If you attempt to send a request with an actionURL that is different from those already in the queue, it will be sent to the server separately, ahead of the queue, and a warning will be logged to the Developer Console.
		 * Flags: IRW */
		actionURL: string /* URL */;

		/** Advanced flag to avoid a potential memory leak in Internet Explorer 9 for requests with JSON formatted responses. This attribute may be set to false to explicitly enable the workaround described RPCManager.allowIE9Leak','here for this request, avoiding a potential memory leak in Internet Explorer 9. This workaround has a limitation in that if parsing the JSON response generates certain object types including JavaScript Date or function objects, attempts to interact with these objects can subsequently lead to a JavaScript error with the message "Can't execute code from a freed script". This workaround therefore may not be suitable for all transactions or dataSources within a given application. This property may also be set globally within an application (via RPCManager.allowIE9Leak)_. Note: This memory leak and workaround is discussed further in the online <a href="http://forums.smartclient.com/showthread.php?t=8159">SmartClient FAQ</a>.
		 * Flags: IRA */
		allowIE9Leak: boolean;

		/** For xmlHttp transport + httpMethod: "GET" only, set to true to force a conditional GET request even if the browser thinks it has a current cached response.
		 * Flags: IRWA */
		bypassCache: boolean /* Boolean */;

		/** If you expect to receive a response to your RPC request, you can specify a callback that will be called with an instance or RPCResponse class as sent by the server. Queuing does not affect callbacks in any way - your specified callback will be invoked for each RPCRequest that contained a callback regardless of whether the request was sent as part of a queue or not. Note that if the request encounters an error (such as 500 server error), by default the callback will not be fired, instead, RPCManager.handleError is called to invoke the default system-wide error handling. Set RPCRequest.willHandleError:true to have your callback invoked regardless of whether there are errors, however, make sure your callback properly handles malformed responses when RPCResponse.status is non-zero. See the errorHandling','error handling overview for more details.
		 * Flags: IRW, Group: errorHandling */
		callback: any /* RPCCallback */;

		/** For use only with the RPCTransport','scriptInclude transport, this attribute specifies the name of the URL parameter which is used to specify the callback function that the server is expected to call by writing out JavaScript code. The actual function to call is automatically generated and differs for every request (to allow concurrency). For example, with callbackParam set to it's default value of "callback", the server might be contacted with a URL like: loadData?callback=isc_scriptIncludeCallback_5 .. then the server's response should look like: isc_scriptIncludeCallback_5({ .. data .. }); The name "isc_scriptIncludeCallback_5" is automatically generated and will differ each time the server is contacted. SmartClient makes of this server-provided callback mechanism, then calls RPCRequest.callback normally. rpcRequest.callbackParam is ignored by all transport other than scriptInclude.
		 * Flags: IRW */
		callbackParam: string /* String */;

		/** An object to be held onto for the duration of the RPC turnaround to track application-specific context. When an RPC turnaround completes, the clientContext is available in the Callbacks.RPCCallback','RPCCallback as rpcResponse.clientContext. The clientContext is never sent to the server. The clientContext is useful for holding onto state that will be used when the Callbacks.RPCCallback','RPCCallback fires, such as the name of a component that will receive the returned data.
		 * Flags: IRW */
		clientContext: any /* Object */;

		/** For use during relogin','Relogin, this property marks this request an attempt to login, therefore a response containing the loginRequiredMarker is a normal condition and should result in the status code RPCResponse.STATUS_LOGIN_INCORRECT rather than a call to RPCManager.loginRequired','loginRequired(). It is not required to set containsCredentials, however, it does typically simplify relogin logic by separating the handling of RPCs that are login attempts from RPCs that are not.
		 * Flags: IRWA, Group: relogin */
		containsCredentials: boolean /* Boolean */;

		/** Valid with the xmlHttpRequest transport only and only when RPCRequest.httpMethod is set to "POST".
		 * Flags: IRW */
		contentType: string /* String */;

		/** This attribute specifies the payload of the RPCRequest. When using the iscServer','SmartClient server, any JavaScript simple type or arbitrarily nested set of Objects and Arrays can be sent to server and automatically translated to Java Objects. Here are the mapping of JavaScript types to their corresponding server object types: <table class='normal' border='1'> <tr><td>JS Type</td> <td>Java Type</td></tr> <tr><td>Object: {}</td> <td>Map</td></tr> <tr><td>Array: []</td> <td>List</td></tr> <tr><td>String</td> <td>String</td></tr> <tr><td>Number</td> <td>Long|Double</td></tr> <tr><td>Boolean</td> <td>Boolean</td></tr> <tr><td>Date</td> <td>java.util.Date</td></tr> <tr><td>String</td> <td>com.smartgwt.client.types.ValueEnum</td></tr> </table> Note that the order of keys/values in the Maps created on the server is not guaranteed because JavaScript Object literals do not guarantee order. When using JPA or Hibernate Java value used can be affected by the Java Bean declaration. See dsRequestBeanTypes for details. Server->client conversion follows this table as well, with some extras. See the toJS() method on JSTranslater in the server documentation for a description of additional behaviors. When not communicating with the SmartClient server, rpcRequest.data becomes simple HTTP parameters or an HTTP request body - see RPCRequest.useSimpleHttp for details.
		 * Flags: IRW */
		data: string | any | any /* String | Record | Object */;

		/** If enabled, causes the RPCRequest to download the requested resource as a file, either showing the browser's Save dialog or displaying the file-content in RPCRequest.downloadToNewWindow','a new browser window. Setting this attribute to true means that no callback will be fired and implies that the request will silently use RPCRequest.transport','transport: "hiddenFrame".
		 * Flags: IRWA */
		downloadResult: boolean /* Boolean */;

		/** When RPCRequest.downloadResult','downloadResult is true, setting this attribute to true causes the content of the downloaded file to be displayed in a new browser window.
		 * Flags: IRWA */
		downloadToNewWindow: boolean /* Boolean */;

		/** This works similarly to RPCRequest.serverOutputAsString except the resulting String is automatically evaluated as JavaScript. The result of the evaluation is then passed to any specified RPCRequest.callback as RPCResponse.data. This feature can be used to dynamically load new application modules into a running application. An RPCRequest with evalResult enabled can be used to fetch a static .js file or JavaScript dynamically generated by the server. The returned JavaScript can contain anything that a JavaScript file loaded at init time can contain, including new views and new SmartClient class definitions. Example usage with RPCManager.sendRequest: isc.RPCManager.sendRequest({ evalResult:true, actionURL:"js/loadLabel.js", evalVars:{var1:"A Value"} }); This call would execute the code from loadLabel.js, and make the variable var1 available to that code. Therefore if the .js file contained this code: isc.Label.create({ contents:var1 }) A label would be created with contents set to the value of var1 - the string "A Value". This feature relies on the XMLHttpRequest object which can be disabled by end-users in some supported browsers. See platformDependencies for more information.
		 * Flags: IRWA, Group: viewLoading */
		evalResult: boolean /* Boolean */;

		/** If you've set RPCRequest.evalResult : true, then the property values of this object will be available in the evaluation scope of the result under the variable names specified by the property names. So e.g. if evalVars is: {foo: "bar"} then a reference to the variable foo in the result will evaluate to "bar".
		 * Flags: IRWA, Group: viewLoading */
		evalVars: any /* Object */;

		/** HTTP headers to send, as a Object mapping Header name -> Header value, eg { "Content-Type" : "text/xml" } Valid with the xmlHttpRequest RPCRequest.transport','transport only.
		 * Flags: IRW */
		httpHeaders: any /* Object */;

		/** Selects the HTTP method that will be used for the request. Typical values are "POST" and "GET". The more obscure "PUT", "DELETE" and "HEAD" methods are also valid, however, none of these are supported by the Safari browser previous to version 3.0.
		 * Flags: IRW */
		httpMethod: string /* String */;

		/** The proxy URL to use for this request (if RPCRequest.useHttpProxy is set for this request). If unset, the value of RPCManager.httpProxyURL will be used instead.
		 * Flags: IR */
		httpProxyURL: string;

		/** When set to true, no reply is expected from the server. However, if a reply is received, it will be processed. Note: setting this to true, forces RPCRequest.sendNoQueue to true for this request.
		 * Flags: IRWA */
		ignoreTimeout: boolean /* Boolean */;

		/** If enabled, the server omits any key/value pairs in map that have null values from the response. This can reduce the size of the response when many fields have null values. To enable this globally for all responses you can set RPCManager.omitNullMapValuesInResponse in server_properties','server.properties.
		 * Flags: IRWA */
		omitNullMapValuesInResponse: boolean /* Boolean */;

		/** Values to be sent as simple HTTP params, as a JavaScript Object where each property/value pair will become an HTTP parameter name and value. These parameters are then accessible on the server, for example, using servletRequest.getParameter(paramName) in Java Servlets. Array-valued parameters will be submitted as multiple instances of the same parameter, similar to an HTML form with a multi-select (?paramName=value1&amp;paramName=value2 ...), accessible as getParameterValues(paramName) in Java Servlets. Any non-atomic type, such as an Object, will be serialized to <a href='http://www.json.org/' target='_blank'>JSON</a> by the JSONEncoder. If this isn't desirable, serialize the data in advance so that the value provided in rpcRequest.params is a String. Note that this API is primarily used in combination with RPCRequest.useSimpleHttp - when contacting the SmartClient Server, use RPCRequest.data instead, which provides full JavaScript &lt;-&gt; Java translation of arbitrary structures. rpcRequest.params can also be used with the SmartClient Server, where it provides an an opportunity to send additional data aside from the main RPCRequest.data payload. This is useful for adding data to DataSource requests which will be kept separate from the automatically sent DataSource data, or for making parts of the request visible in the URL for HTTP-level logging or layer 4 switches. Note that in contrast to RPCRequest.data object, the data in rpcRequest.params is not deserialized by the SmartClient server, and all values arrive on the server as String type (like HTTP parameters always do). The params value can also be specified as a componentID or component instance that provides a method getValues() that returns an Object containing parameter names and values. SmartClient components DynamicForm, ValuesManager are two such classes. Lastly, you may specify the ID of a native form element (retrievable via getElementById()) and the params will be populated from there. If there is an error resolving your params directive, it will be logged to the Developer Console. Note: The params are submitted once per http transaction. If you are using RPCManager.startQueue','request queuing to bundle multiple RPCRequests or DSRequests into a single HTTP turnaround, the params from the various RPCRequests will be merged, with the later-queued transactions winning on parameter name collisions. A warning will be logged in the Developer Console if multiple RPCRequests specified params.
		 * Flags: IRW */
		params: any /* Object */;

		/** Overrides RPCManager.defaultPrompt for this request only. If you're using queuing, note that the prompt string from the first request in the queue is the one that is shown to the user.
		 * Flags: IRW, Group: rpcPrompt */
		prompt: string /* HTMLString */;

		/** Controls the cursor shown when RPCManager.promptStyle is set to "cursor" for this request only. Defaults to RPCManager.promptCursor.
		 * Flags: IRW, Group: rpcPrompt */
		promptCursor: string /* String */;

		/** Overrides RPCManager.promptDelay for this request only. Defaults to RPCManager.promptDelay. If you're using queuing, note that the promptDelay of the first request is used for the entire queue.
		 * Flags: IRWA, Group: rpcPrompt */
		promptDelay: number;

		/** Controls the prompt style for this request only. Defaults to RPCManager.promptStyle.
		 * Flags: IRW, Group: rpcPrompt */
		promptStyle: PromptStyle;

		/** When set to true, this request is sent to the server immediately, bypassing any current queue.
		 * Flags: IRWA */
		sendNoQueue: boolean /* Boolean */;

		/** Setting this flag makes the body of the HTTP response available as a String in the RPCRequest.callback as RPCResponse.data. This is typically only useful if you are sending a request that will not be received by the SmartClient Java Server, however in that case, set RPCRequest.useSimpleHttp:true instead, which implies serverOutputAsString:true. serverOutputAsString:true allows you to, for example, load the contents of static files off your webserver into a string for processing on the client with no server support. The RPCRequest.actionURL must be in the same domain as the current page for this to work. This feature relies on the XMLHttpRequest object which can be disabled by end-users in some supported browsers. See platformDependencies for more information. Generally this API is used for either nonJavaBackend','non-Java backends or for advanced usage such as content that requires processing before it can be used in SmartClient components (such as client-side web scraping). Note that SmartClient provides higher-level APIs for loading common types of data, see eg HTMLFlow for HTML content, ViewLoader for loading SmartClient components, XMLTools.loadXML for loading XML, RPCRequest.evalResult for loading <a href='http://www.json.org/' target='_blank'>JSON</a>, and DataSource for loading structured data in various formats.
		 * Flags: IRWA */
		serverOutputAsString: boolean /* Boolean */;

		/** Overrides RPCManager.showPrompt for this request only. If you're using queuing, note that if any of the requests in the queue specify showPrompt:true, then a prompt will be shown for the entire queue with the prompt text of the first request in the queue to specify a custom prompt if promptStyle is set to "dialog". If promptStyle is set to "cursor" for the request that specified showPrompt: true, then the entire queue uses the "cursor" style for the prompt.
		 * Flags: IRW, Group: rpcPrompt */
		showPrompt: boolean /* Boolean */;

		/** If RPCRequest.evalResult is set, setting this property to true causes Canvas.autoDraw to be set to false for the duration of the result evaluation - which is generally what you want if you're returning new components from the server. This also effects components loaded via the RPCManager.loadScreen API.
		 * Flags: IRWA */
		suppressAutoDraw: boolean /* Boolean */;

		/** Sets the timeout on this request. Default is to use RPCManager.defaultTimeout. If you're using RPCManager.startQueue','queuing, note that the timeout setting derived from the last request in the queue is used for the entire queue. If you want to override the timeout for the queue, make sure to set your override at least on the last request in the queue. For the "xmlHttpRequest" RPCRequest.transport','transport, this timeout can only happen if the server actually fails to respond within the specified number of milliseconds. For the "hiddenFrame" transport, this timeout will occur for non-200 (HTTP_OK) responses. If timeout is set to zero, the RPCManager will not enforce a timeout for this request. However, note that all browsers enforce their own timeouts on HTTP requests, and may have different timeouts for different kinds of failures (no response at all from server, hung response after receiving headers, hung response after receiving partial data, etc). Also, intervening web proxies or firewalls may impose timeouts of their own. As a rough rule of thumb, if your server response will have a lengthy pause before data begins to be sent, 1-2 minutes is the maximum allowable pause for a public site and still may not work for a minority of users, but up to 4 minutes may be allowable in a controlled environment (intranet or extranet with well-known user base). Above these limits, your code should return some kind of immediate response to the browser, then kick off a server-side process to complete processing. The browser can then either poll for completion, or use a server-push notification system such as SmartClient Real-Time Messaging (see <a href='http://smartclient.com/product' target='_blank'>http://smartclient.com/product</a>).
		 * Flags: IRWA */
		timeout: number /* int */;

		/** Selects the transport used for this RPCRequest. If unset, the value of RPCManager.defaultTransport will be used. If you're using queueing, note that all requests in the queue must use the same transport. If you attempt to send a request via a different transport than those that are currently on the queue, it will be sent to the server separately, ahead of the queue, and a warning will be logged to the Developer Console. If you specify an unknown transport, an error will be logged to the DeveloperConsole and RPCManager.defaultTransport will be used instead. If you specify the xmlHttpRequest transport and it is not available, a warning will be logged to the Developer Console and the RPCManager will attempt to use the hiddenFrame transport instead for this request. Note that some features like RPCRequest.serverOutputAsString require the xmlHttpRequest transport and will not work if the xmlHttpRequest transport is unavailable (this can happen if the end user is using Internet Explorer and has disabled ActiveX). You can check whether or not the xmlHttpRequest transport is currently available by calling RPCManager.xmlHttpRequestAvailable.
		 * Flags: IRWA */
		transport: RPCTransport;

		/** Indicates whether this request should use the HttpProxyServlet in order to enable contacting hosts other than the origin server (available only in Pro Edition or better). When various UI components issues requests automatically, or when a call to RPCManager.sendProxied is made, the HttpProxy will automatically be used for a URL that starts with "http" and uses a hostname other than "localhost" or window.location.hostname, or if the port number differs. rpcRequest.useHttpProxy should only be used to force requests to go through the HttpProxy when the above rules don't work, or to avoid using the HttpProxy when contacting hosts that allow cross-site calls via the <a href='http://www.google.com/search?q=http+access+control' target='_blank'>Http Access Control</a> standard. You can also set RPCManager.useHttpProxy:false to avoid ever using the HttpProxyServlet.
		 * Flags: IR */
		useHttpProxy: boolean;

		/** When set to true, assume the request is not going to the SmartClient server, and hence send a simple HTTP request that does not use SmartClient-specific request encoding. Values specified in RPCRequest.params are sent to to the server as HTTP request parameters. If RPCRequest.httpMethod is "GET", parameters appear in the request URL, otherwise if httpMethod is "POST", parameters are encoded in the request body (exactly like an HTML form does). These parameters are then accessible via typical server-side APIs for retrieving HTTP parameters, eg, servletRequest.getParameter(paramName) in Java Servlets. Note that if RPCRequest.httpMethod method is POST and RPCRequest.data is supplied, RPCRequest.data is assumed to be a string to post as the HTTP request body, and RPCRequest.params are sent as URL parameters instead. This usage is for sending custom request bodies such as the XML payloads used for SOAP. In this case, RPCRequest.contentType is typically also set to indicate the content type of the request body. Setting useSimpleHttp to true also automatically sets RPCRequest.serverOutputAsString to true as well.
		 * Flags: IRWA */
		useSimpleHttp: boolean /* Boolean */;

		/** With willHandleError:false, rpcResponses that indicate an error go through centralized handling in the RPCManager and rpcRequest.callback is never invoked. Setting willHandleError:true means that your rpcRequest.callback will receive rpcResponses that have an error status and must handle them. See also the error handling section in the RPCManager docs.
		 * Flags: IRW, Group: errorHandling */
		willHandleError: boolean /* Boolean */;

		/** In browsers that support <a href='http://www.w3.org/TR/cors/' target='_blank'>Cross-Origin Resource Sharing</a> and <a href='http://caniuse.com/#feat=xhr2' target='_blank'>XMLHttpRequest 2</a>, and where the service at the RPCRequest.actionURL','actionURL allows the origin to send credentials (see <a href='http://www.w3.org/TR/cors/#access-control-allow-credentials-response-header' target='_blank'>Access-Control-Allow-Credentials</a>), should <a href='http://www.w3.org/TR/cors/#user-credentials' target='_blank'>user credentials</a> such as cookies, HTTP authentication, and client-side SSL certificates be sent with the actual CORS request? This setting only applies when the request RPCRequest.transport','transport is "xmlHttpRequest". Note that Internet Explorer 10 and 11 do not send cookies as part of user credentials: <a href='https://connect.microsoft.com/IE/Feedback/Details/759587/' target='_blank'>IE10 doesn't support cookies on cross origin XMLHttpRequest withCredentials=true</a>.
		 * Flags: IRA */
		withCredentials: boolean /* Boolean */;

	} // RPCRequest

	export interface RPCRequestStatic<T, P> extends ClassStatic<T, P> {
		/** If true, an image is shown to the right of the cursor when RPCRequest.promptStyle is set to "cursor", otherwise the cursor itself is modified via css to the value of RPCRequest.promptCursor. If left unspecified, the default value is set by RPCManager.useCursorTracker.
		 * Flags: IRW, Group: rpcPrompt */
		useCursorTracker: boolean;


	/* Methods */

/* Not - because it conflicts with Class.create()
		/** 
		 * RPCRequest shouldn't be created directly. Instead, pass Properties to RPCManager.sendRequest and RPCManager.send.
		 * /
		create(): void; 

 */ 

	} // RPCRequestStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a RPCResponse Props argument.
	 * This is derived from the methods in the RPCResponse class and it's parents and their properties marked with the I flag.
	 */
	export interface RPCResponseProps  {
		/** Status code for this response. Status codes less than zero are considered errors by the RPCManager, those greater than or equal to zero are considered successes. Please see the error handling section the RPCManager','RPCManager docs for more information on what the RPCManager does with the status code and how you can override this behavior. When using the SmartClient server you can set the rpcResponse.status by calling the server-side method RPCResponse.setStatus(). When not using the SmartClient server, the RPCManager makes no assumptions about the structure of the response, so the status code just reflects the RPCResponse.httpResponseCode: status will be RPCResponse.STATUS_TRANSPORT_ERROR','STATUS_TRANSPORT_ERROR if an HTTP-level error occurred such as "500 server error". If you have a status code you need to transmit you can simply embed it in the response (as part of RPCResponse.data) and interpret it from the callback. With or without the SmartClient server, the relogin status codes (such as RPCResponse.STATUS_LOGIN_REQUIRED) are triggered whenever special markers, such as the loginRequiredMarker, appear in the body of the response. See the relogin','Relogin\n Overview for details.
		 * Flags: IR */
		status?: number /* int */; // Flags=IR
	} // RPCResponseProps


	/**
	 * Encapsulates an RPC response from the server. Instances of this class are automatically created and optionally passed to you in the callback you specify as part of your RPCRequest. 
	 */
	export interface RPCResponse  {
		/** The RPCRequest.clientContext object as set on the RPCRequest.
		 * Flags: R */
		clientContext: any /* Object */;

		/** The data sent by the server. When communicating with the SmartClient server, rpcResponse.data is the data passed to the server-side method RPCResponse.setData() by your Java code. This data is translated into JavaScript objects by the rules described under RPCRequest.data. When not communicating with the SmartClient server rpcResponse.data contains the raw HTTP response body. See RPCRequest.useSimpleHttp, RPCRequest.serverOutputAsString, RPCRequest.evalResult for details.
		 * Flags: R */
		data: string | any /* String | Object */;

		/** HTTP headers returned by the server as a map from header name to header value. Headers are available only when the default RPCTransport "xmlHttpRequest" is in use, and browsers may limit access to headers for cross-domain requests or in other security-sensitive scenarios.
		 * Flags: R */
		httpHeaders: any /* Object */;

		/** This attribute (available when using the the xmlHttpRequest transport) contains the HTTP response code sent by the server. Note that this is different from RPCResponse.status - that attribute is used to indicate a status code for the RPC itself whereas httpResponseCode is the raw HTTP response code for the HTTP request that contained the RPCRequest. This feature relies on the XMLHttpRequest object which can be disabled by end-users in some supported browsers. See platformDependencies for more information. If you're using this attribute, you'll typically want to avoid the default error handling response of RPCManager. To do so, set RPCRequest.willHandleError to true.
		 * Flags: R */
		httpResponseCode: number /* integer */;

		/** The actual text of the HTTP response. Only available when the default RPCTransport "xmlHttpRequest" transport is in use,
		 * Flags: R */
		httpResponseText: string /* String */;

		/** Status code for this response. Status codes less than zero are considered errors by the RPCManager, those greater than or equal to zero are considered successes. Please see the error handling section the RPCManager','RPCManager docs for more information on what the RPCManager does with the status code and how you can override this behavior. When using the SmartClient server you can set the rpcResponse.status by calling the server-side method RPCResponse.setStatus(). When not using the SmartClient server, the RPCManager makes no assumptions about the structure of the response, so the status code just reflects the RPCResponse.httpResponseCode: status will be RPCResponse.STATUS_TRANSPORT_ERROR','STATUS_TRANSPORT_ERROR if an HTTP-level error occurred such as "500 server error". If you have a status code you need to transmit you can simply embed it in the response (as part of RPCResponse.data) and interpret it from the callback. With or without the SmartClient server, the relogin status codes (such as RPCResponse.STATUS_LOGIN_REQUIRED) are triggered whenever special markers, such as the loginRequiredMarker, appear in the body of the response. See the relogin','Relogin\n Overview for details.
		 * Flags: IR */
		status: number /* int */;

		/** ID of the transaction sent to the server via RPCManager.sendQueue containing the RPCRequest associated with this response.
		 * Flags: R */
		transactionNum: number /* int */;

	} // RPCResponse

	export interface RPCResponseStatic<T, P> extends ClassStatic<T, P> {
		/** Indicates that a response with invalid format has been received from server. If the datasource is using "iscServer" dataFormat, this means that the response is not recognized as a valid ISC frame. One possible cause for this error can be the reception of a RestDataSource JSON response that lacks a valid RestDataSource.jsonPrefix and/or RestDataSource.jsonSuffix If it is using "xml" or "json" dataFormat, the response could not be parsed as XML or JSON.
		 * Flags: R, Group: statusCodes */
		INVALID_RESPONSE_FORMAT: number /* int */;

		/** Indicates a declarativeSecurity','Declarative Security failure on the server. See the error handling section in RPCManager','RPCManager documentation for more information.
		 * Flags: R, Group: statusCodes */
		STATUS_AUTHORIZATION_FAILURE: number /* int */;

		/** This response code only occurs when using the HTTP proxy. It is issued by the proxy servlet when the attempt to contact the target server results in a Java SocketException. This response probably indicates that the target server is currently down.
		 * Flags: R, Group: statusCodes */
		STATUS_CONNECTION_RESET_ERROR: number /* int */;

		/** Indicates a generic failure on the server. See the error handling section in RPCManager','RPCManager documentation for more information.
		 * Flags: R, Group: statusCodes */
		STATUS_FAILURE: number /* int */;

		/** Indicates that an empty file was uploaded for a required 'binary' field.
		 * Flags: R, Group: statusCodes */
		STATUS_FILE_REQUIRED_ERROR: number /* int */;

		/** Indicates that the RPC has been intercepted by an authenticator that requires the user to log in.
		 * Flags: R, Group: statusCodes */
		STATUS_LOGIN_INCORRECT: number /* int */;

		/** Indicates that a login is required before this RPCRequest can proceed. Applications do not directly set this status code, instead, to trigger the relogin flow, return the loginRequiredMarker in the response sent by your server when login is required. See the relogin','Relogin Overview for details.
		 * Flags: R, Group: statusCodes */
		STATUS_LOGIN_REQUIRED: number /* int */;

		/** Indicates that the login succeeded.
		 * Flags: R, Group: statusCodes */
		STATUS_LOGIN_SUCCESS: number /* int */;

		/** Indicates that an uploaded file's size exceeded the maximum file size allowed.
		 * Flags: R, Group: statusCodes */
		STATUS_MAX_FILE_SIZE_EXCEEDED: number /* int */;

		/** Indicates that too many authentication attempts have been made and the server refuses to accept any more login attempts.
		 * Flags: R, Group: statusCodes */
		STATUS_MAX_LOGIN_ATTEMPTS_EXCEEDED: number /* int */;

		/** Indicates that the total size of the data sent to the server was more than the server is configured to allow. Most servers limit the post size to prevent out of memory style attack vectors that push a bunch of data at the server. Apache Tomcat, for example, is pre-configured to limit post size to 2mb. On internal networks, these limits can typically be safely raised or removed. With Tomcat, for example, you can remove the post limit by specifying the following attribute on the &lt;Connector&gt; element in conf/server.xml: maxPostSize="-1" NOTE: this status code is used whenever the server framework receives a request where the POST data has been removed, however, there are other possible causes, including: security software installed on the server or network that erroneously detects some kind of exploit attempt, if its behavior is to just strip the POST data but allow the rest of the request through (SiteMinder is one product known to do this) incorrectly written filter servlets that drop POST'd data 
		 * Flags: R, Group: statusCodes */
		STATUS_MAX_POST_SIZE_EXCEEDED: number /* int */;

		/** Indicates that the browser is currently offline, and that we do not hold a cached response for the request.
		 * Flags: R, Group: statusCodes */
		STATUS_OFFLINE: number /* int */;

		/** Indicates a request timed out with no server response. This is a client-only error code - never sent by the server (since it's the server that times out). NOTE that if using hiddenFrame as the transport (not the default), a malformed response such as a "500 Server Error" or 404 errors will be reported as a timeout.
		 * Flags: R, Group: statusCodes */
		STATUS_SERVER_TIMEOUT: number /* int */;

		/** Indicates successful completion of the request. This is the default status and is automatically used by the RPCResponse on the server unless you override it with setStatus(). See the error handling section in RPCManager','RPCManager documentation for more information.
		 * Flags: R, Group: statusCodes */
		STATUS_SUCCESS: number /* int */;

		/** Indicates that the request was either never attempted or was rolled back, because automatic or user transactions are in force and another request in the same transaction failed. Note that the request(s) that actually failed will have a code specific to the failure; it is only the requests that would otherwise have succeeded that are marked with this failure code.
		 * Flags: R, Group: statusCodes */
		STATUS_TRANSACTION_FAILED: number /* int */;

		/** This response code is usable only with the XMLHttpRequest transport and indicates that the server returned an HTTP response code outside the range 200-299 (all of these statuses indicate success, but ordinarily only 200 is used). To get the actual response code, you can query rpcResponse.httpResponseCode in your callback. Note that currently this error code will never occur for the hiddenFrame transport - instead, use RPCResponse.STATUS_SERVER_TIMEOUT to detect hiddenFrame transport errors.
		 * Flags: R, Group: statusCodes */
		STATUS_TRANSPORT_ERROR: number /* int */;

		/** This response code only occurs when using the HTTP proxy. It is issued by the proxy servlet when the target host is unknown (ie, cannot be resolved through DNS). This response probably indicates that you are attempting to contact a nonexistent server (though it might mean that you have DNS problems).
		 * Flags: R, Group: statusCodes */
		STATUS_UNKNOWN_HOST_ERROR: number /* int */;

		/** Indicates that the client attempted an update or remove operation without providing primary key field(s)
		 * Flags: R, Group: statusCodes */
		STATUS_UPDATE_WITHOUT_PK_ERROR: number /* int */;

		/** Indicates a validation failure on the server. See the error handling section in RPCManager','RPCManager documentation for more information.
		 * Flags: R, Group: statusCodes */
		STATUS_VALIDATION_ERROR: number /* int */;


	/* Methods */

/* Not - because it conflicts with Class.create()
		/** 
		 * RPCResponses shouldn't be created directly. Instances of this class are automatically created and optionally passed to you in the callback you specify as part of your RPCRequest. 
		 * /
		create(): void; 

 */ 

	} // RPCResponseStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a SearchForm Props argument.
	 * This is derived from the methods in the SearchForm class and it's parents and their properties marked with the I flag.
	 */
	export interface SearchFormProps extends DynamicFormProps {
		/** This property is overridden in SearchForm to allow editing of dataSource fields marked as canFilter:true by default.
		 * Flags: IRA */
		canEditFieldAttribute?: string /* String */; // Flags=IRA
		/** If this attribute is true any DataSourceField.canFilter','canFilter:false fields specified on the dataSource will not be shown unless explicitly included in this component's DataBoundComponent.fields','fields array
		 * Flags: IRWA */
		showFilterFieldsOnly?: boolean /* Boolean */; // Flags=IRWA

		/* Method Overrides */

	} // SearchFormProps


	/**
	 * A SearchForm is a DynamicForm specialized for a user to enter search criteria. All DynamicForm properties and methods work on SearchForm. SearchForm extends and specializes DynamicForm for searching; for example, SearchForm sets hiliteRequiredFields false by default because fields are typically not required in a search. 
	 */
	export interface SearchForm extends DynamicForm {
		/** This property is overridden in SearchForm to allow editing of dataSource fields marked as canFilter:true by default.
		 * Flags: IRA */
		canEditFieldAttribute: string /* String */;

		/** If this attribute is true any DataSourceField.canFilter','canFilter:false fields specified on the dataSource will not be shown unless explicitly included in this component's DataBoundComponent.fields','fields array
		 * Flags: IRWA */
		showFilterFieldsOnly: boolean /* Boolean */;


		/* Instance Method Overrides */

	} // SearchForm

	export interface SearchFormStatic<T, P> extends DynamicFormStatic<T, P> {
	} // SearchFormStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a SectionStack Props argument.
	 * This is derived from the methods in the SectionStack class and it's parents and their properties marked with the I flag.
	 */
	export interface SectionStackProps extends VLayoutProps {
		/** If true, sections are animated during expand/collapse and addition/removal of SectionItems is likewise animated.
		 * Flags: IRW, Group: animation */
		animateSections?: boolean; // Flags=IRW
		/** In SectionStack.visibilityMode','visibilityMode "mutex", whether to allow the last remaining expanded section to be collapsed. If false, collapsing the last open section will open the next one (wrapping around at the end).
		 * Flags: IRW */
		canCollapseAll?: boolean /* Boolean */; // Flags=IRW
		/** SectionStacks provide the same default implementation of drag and drop interactions as Layout.canDropComponents','Layouts, except that members are added as items into the section over which they're dropped. If you want to completely suppress the builtin drag and drop logic, but still receive drag and drop events for your own custom implementation, set Canvas.canAcceptDrop to true and canDropComponents to false on your SectionStack.
		 * Flags: IRA, Group: dragdrop */
		canDropComponents?: boolean /* Boolean */; // Flags=IRA
		/** Whether sections can be drag reordered by the user dragging the section header. Note that, with canReorderSections:true, sections with SectionStackSection.canReorder','section.canReorder:false will not be able to be drag-reordered (though their index may still be changed by dropping other sections above or below them in the section stack).
		 * Flags: IRA */
		canReorderSections?: boolean /* Boolean */; // Flags=IRA
		/** Whether sections can be drag resized by the user dragging the section header. Note that, with canResizeSections:true, not all sections can be resized: sections that contain only Button.autoFit','autofitting components or that are marked with SectionStackSection.resizeable','section.resizeable:false will not be resizeable.
		 * Flags: IRA */
		canResizeSections?: boolean /* Boolean */; // Flags=IRA
		/** If true, the headers for the sections (if shown) will be included in the page's tab order for accessibility. May be overridden at the Section level via SectionStackSection.canTabToHeader If unset, section headers will be focusable if isc.setScreenReaderMode has been called. See accessibility.
		 * Flags: IRA */
		canTabToHeaders?: boolean; // Flags=IRA
		/** Default class used to construct the EditProxy for this component when the component is Canvas.setEditMode','first placed into edit mode.
		 * Flags: IR */
		editProxyConstructor?: string /* SCClassName */; // Flags=IR
		/** Height of headers for sections.
		 * Flags: IR */
		headerHeight?: number /* Number */; // Flags=IR
		/** Size, in pixels, of indentation of all member items relative to the end of the alignment axis. For instance, for left-aligned members, itemStartIndent specifies indentation for every item from the right side of the section stack.
		 * Flags: IRW, Group: layoutMember */
		itemEndIndent?: number /* Number */; // Flags=IRW
		/** Size, in pixels, of indentation of all member items. Items will be offset and reduced in width by this amount. Overridden by SectionStack.itemStartIndent or SectionStack.itemEndIndent. Setting itemIndent is equivalent to setting itemStartIndent to the same amount and itemEndIndent to 0.
		 * Flags: IRW, Group: layoutMember */
		itemIndent?: number /* Number */; // Flags=IRW
		/** Size, in pixels, of indentation of all member items relative to the start of the alignment axis. For instance, for left-aligned members, itemStartIndent specifies indentation for every item from the left side of the section stack. Overrides SectionStack.itemIndent.
		 * Flags: IRW, Group: layoutMember */
		itemStartIndent?: number /* Number */; // Flags=IRW
		/** When AutoTest.getElement is used to parse locator strings generated by AutoTest.getLocator, how should sections within this stack be identified? By default if a section has a specified SectionStackSection.name','Section.name this will always be used. For sections with no name, the following options are available: "title" use the title as an identifier "index" use the index of the section in the sections array as an identifier If unset, and the section has no specified name, default behavior is to identify by title (if available), otherwise by index.
		 * Flags: IRWA, Group: autoTest */
		locateSectionsBy?: LocatorStrategy; // Flags=IRWA
		/** LocatorTypeStrategy to use when finding Sections within this section Stack.
		 * Flags: IRWA, Group: autoTest */
		locateSectionsType?: LocatorTypeStrategy; // Flags=IRWA
		/** Normal Overflow settings can be used on layouts, for example, an overflow:auto Layout will scroll if sections are resized to exceed the specified size, whereas an overflow:visible Layout will grow to accommodate the resized sections.
		 * Flags: IRW */
		overflow?: Overflow; // Flags=IRW
		/** If an expanded or shown section expands past the current viewport and this property is true, then the viewport will auto-scroll to fit as much of the section content into the viewport without scrolling the top of the section out of the viewport.
		 * Flags: IR */
		scrollSectionIntoView?: boolean /* Boolean */; // Flags=IR
		/** Widget to use for section headers. Must be a subclass of either ImgSectionHeader or SectionHeader. The default class used depends on the skin; SectionHeader is the simpler and lighter-weight class and uses CSS styling rather than image-based styling, and is recommended for most use cases. Very advanced developers can use the following information to create custom header classes. The SectionStack will instantiate this class, giving the following properties on init: layout: the SectionStack expanded: true or false hidden: true or false title: section title Whenever the section is hidden or shown, sectionHeader.setExpanded(true|false) will be called if implemented. If you override event handlers on your custom SectionHeader or radically change it's structure such that the default event handling no longer works, you can call SectionStack.sectionHeaderClick to replicate the built-in expand/collapse handling for clicking a section header.
		 * Flags: IRA */
		sectionHeaderClass?: string /* Classname */; // Flags=IRA
		/** List of sections of components managed by this SectionStack.
		 * Flags: IR */
		sections?: Array<SectionStackSection> /* Array of SectionStackSection Properties */; // Flags=IR
		/** Whether to show the Expand/Collapse controls in the headers of sections. If false, hides the expand/collapse controls and, instead, treats a click anywhere on the header as if it were a click on the expand control.
		 * Flags: IRW */
		showExpandControls?: boolean /* Boolean */; // Flags=IRW
		/** Default CSS style for the SectionStack as a whole.
		 * Flags: IR */
		styleName?: string /* CSSStyleName */; // Flags=IR
		/** Should any specified SectionStackSection.ID be applied to the generated SectionHeader widget for the section as a widget ID? If set to false, SectionStackSection.ID will behave as a synonym for SectionStackSection.name.
		 * Flags: IR */
		useGlobalSectionIDs?: boolean /* Boolean */; // Flags=IR
		/** Whether multiple sections can be expanded.
		 * Flags: IRW */
		visibilityMode?: VisibilityMode; // Flags=IRW

		/* Method Overrides */

		/** 
		 * Add a canvas as an item to a section.
		 * @param {string} section - ID or index of the section to add item to
		 * @param {Canvas} item - Item to insert into the section
		 * @param {number} index - Index into section to insert item
		 */
		addItem?(section:string | number /* String or Number */, item:Canvas, index:number /* Number */): void; 

	} // SectionStackProps


	/**
	 * A container that manages a list of sections of widgets, each with a header. Sometimes called an "Accordion". SectionStack can be configured so that only one section is visible at a time (similar to MS Outlook's left-hand Nav), or to allow multiple sections to be visible and share the available space. 
	 */
	export interface SectionStack extends VLayout {
		/** If true, sections are animated during expand/collapse and addition/removal of SectionItems is likewise animated.
		 * Flags: IRW, Group: animation */
		animateSections: boolean;

		/** In SectionStack.visibilityMode','visibilityMode "mutex", whether to allow the last remaining expanded section to be collapsed. If false, collapsing the last open section will open the next one (wrapping around at the end).
		 * Flags: IRW */
		canCollapseAll: boolean /* Boolean */;

		/** SectionStacks provide the same default implementation of drag and drop interactions as Layout.canDropComponents','Layouts, except that members are added as items into the section over which they're dropped. If you want to completely suppress the builtin drag and drop logic, but still receive drag and drop events for your own custom implementation, set Canvas.canAcceptDrop to true and canDropComponents to false on your SectionStack.
		 * Flags: IRA, Group: dragdrop */
		canDropComponents: boolean /* Boolean */;

		/** Whether sections can be drag reordered by the user dragging the section header. Note that, with canReorderSections:true, sections with SectionStackSection.canReorder','section.canReorder:false will not be able to be drag-reordered (though their index may still be changed by dropping other sections above or below them in the section stack).
		 * Flags: IRA */
		canReorderSections: boolean /* Boolean */;

		/** Whether sections can be drag resized by the user dragging the section header. Note that, with canResizeSections:true, not all sections can be resized: sections that contain only Button.autoFit','autofitting components or that are marked with SectionStackSection.resizeable','section.resizeable:false will not be resizeable.
		 * Flags: IRA */
		canResizeSections: boolean /* Boolean */;

		/** If true, the headers for the sections (if shown) will be included in the page's tab order for accessibility. May be overridden at the Section level via SectionStackSection.canTabToHeader If unset, section headers will be focusable if isc.setScreenReaderMode has been called. See accessibility.
		 * Flags: IRA */
		canTabToHeaders: boolean;

		/** Default class used to construct the EditProxy for this component when the component is Canvas.setEditMode','first placed into edit mode.
		 * Flags: IR */
		editProxyConstructor: string /* SCClassName */;

		/** Height of headers for sections.
		 * Flags: IR */
		headerHeight: number /* Number */;

		/** Size, in pixels, of indentation of all member items relative to the end of the alignment axis. For instance, for left-aligned members, itemStartIndent specifies indentation for every item from the right side of the section stack.
		 * Flags: IRW, Group: layoutMember */
		itemEndIndent: number /* Number */;

		/** Size, in pixels, of indentation of all member items. Items will be offset and reduced in width by this amount. Overridden by SectionStack.itemStartIndent or SectionStack.itemEndIndent. Setting itemIndent is equivalent to setting itemStartIndent to the same amount and itemEndIndent to 0.
		 * Flags: IRW, Group: layoutMember */
		itemIndent: number /* Number */;

		/** Size, in pixels, of indentation of all member items relative to the start of the alignment axis. For instance, for left-aligned members, itemStartIndent specifies indentation for every item from the left side of the section stack. Overrides SectionStack.itemIndent.
		 * Flags: IRW, Group: layoutMember */
		itemStartIndent: number /* Number */;

		/** When AutoTest.getElement is used to parse locator strings generated by AutoTest.getLocator, how should sections within this stack be identified? By default if a section has a specified SectionStackSection.name','Section.name this will always be used. For sections with no name, the following options are available: "title" use the title as an identifier "index" use the index of the section in the sections array as an identifier If unset, and the section has no specified name, default behavior is to identify by title (if available), otherwise by index.
		 * Flags: IRWA, Group: autoTest */
		locateSectionsBy: LocatorStrategy;

		/** LocatorTypeStrategy to use when finding Sections within this section Stack.
		 * Flags: IRWA, Group: autoTest */
		locateSectionsType: LocatorTypeStrategy;

		/** Normal Overflow settings can be used on layouts, for example, an overflow:auto Layout will scroll if sections are resized to exceed the specified size, whereas an overflow:visible Layout will grow to accommodate the resized sections.
		 * Flags: IRW */
		overflow: Overflow;

		/** If an expanded or shown section expands past the current viewport and this property is true, then the viewport will auto-scroll to fit as much of the section content into the viewport without scrolling the top of the section out of the viewport.
		 * Flags: IR */
		scrollSectionIntoView: boolean /* Boolean */;

		/** Widget to use for section headers. Must be a subclass of either ImgSectionHeader or SectionHeader. The default class used depends on the skin; SectionHeader is the simpler and lighter-weight class and uses CSS styling rather than image-based styling, and is recommended for most use cases. Very advanced developers can use the following information to create custom header classes. The SectionStack will instantiate this class, giving the following properties on init: layout: the SectionStack expanded: true or false hidden: true or false title: section title Whenever the section is hidden or shown, sectionHeader.setExpanded(true|false) will be called if implemented. If you override event handlers on your custom SectionHeader or radically change it's structure such that the default event handling no longer works, you can call SectionStack.sectionHeaderClick to replicate the built-in expand/collapse handling for clicking a section header.
		 * Flags: IRA */
		sectionHeaderClass: string /* Classname */;

		/** List of sections of components managed by this SectionStack.
		 * Flags: IR */
		sections: Array<SectionStackSection> /* Array of SectionStackSection Properties */;

		/** Whether to show the Expand/Collapse controls in the headers of sections. If false, hides the expand/collapse controls and, instead, treats a click anywhere on the header as if it were a click on the expand control.
		 * Flags: IRW */
		showExpandControls: boolean /* Boolean */;

		/** Default CSS style for the SectionStack as a whole.
		 * Flags: IR */
		styleName: string /* CSSStyleName */;

		/** Should any specified SectionStackSection.ID be applied to the generated SectionHeader widget for the section as a widget ID? If set to false, SectionStackSection.ID will behave as a synonym for SectionStackSection.name.
		 * Flags: IR */
		useGlobalSectionIDs: boolean /* Boolean */;

		/** Whether multiple sections can be expanded.
		 * Flags: IRW */
		visibilityMode: VisibilityMode;


		/* Instance Method Overrides */

		/** 
		 * Add a canvas as an item to a section.
		 * @param {string} section - ID or index of the section to add item to
		 * @param {Canvas} item - Item to insert into the section
		 * @param {number} index - Index into section to insert item
		 */
		addItem?(section:string | number /* String or Number */, item:Canvas, index:number /* Number */): void; 

	} // SectionStack

	export interface SectionStackStatic<T, P> extends VLayoutStatic<T, P> {
	} // SectionStackStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a SelectItem Props argument.
	 * This is derived from the methods in the SelectItem class and it's parents and their properties marked with the I flag.
	 */
	export interface SelectItemProps extends FormItemProps {
		/** If this item's value is set (via SelectItem.setValue or similar) to a value which is not present in the ValueMap, should the value be rejected. If set to false the setValue() call will have no effect if the value is not a valid option. If set to true the item's value will be update to the new value, and the value will be added to the set of options displayed in the pick-list until the next call to SelectItem.setValueMap or SelectItem.setValue. Exception: If the value is set to null but there is no null entry in the valueMap for this item, setting addUnknownValues to true will not cause a null option to show up at the top of the select item pickList. Whether an empty option is shown in the pickList is governed by SelectItem.allowEmptyValue instead. Note that this property has no effect if the selectItem has a specified SelectItem.optionDataSource. If SelectItem.setValue is called on a databound SelectItem and the new value does not match any loaded options, the value will be accepted, but not added to the options displayed in the pickList. Also note that if a SelectItem.displayField exists, a fetch will be performed in an attempt to retrieve a valid display value, as described under FormItem.fetchMissingValues. If specified the FormItem.loadingDisplayValue will be displayed while the fetch is in progress, and then the real value (mapped to a display field value if a matching record was found) will be displayed when the fetch completes.
		 * Flags: IRWA */
		addUnknownValues?: boolean /* Boolean */; // Flags=IRWA
		/** If set to true, always show an empty option in this item's pickList, allowing the user to clear the value (even if there is no empty entry in the valueMap for the item). The empty value will be displayed with the FormItem.emptyDisplayValue','emptyDisplayValue. With a SelectItem.optionDataSource','databound selectItem, enabling allowEmptyValue disables data paging by default - all data matching the PickList.pickListCriteria','current criteria will be requested. However, enabling SelectItem.separateSpecialValues allows data paging to be used if required. See also SelectItem.specialValues as a way of providing several different special values in addition to an empty value, such as "Invalid". Note that setting specialValues disables the use of allowEmptyValue - see details of how to have an empty value while using specialValues in in SelectItem.specialValues','the specialValues documentation.
		 * Flags: IR */
		allowEmptyValue?: boolean /* Boolean */; // Flags=IR
		/** By default, if multiple keys are pressed in quick succession, a SelectItem will buffer them together and use the resulting multi-char string when searching. Set this attribute to false to force the item to match only one character at a time.
		 * Flags: IRW */
		allowMultiCharSearch?: boolean; // Flags=IRW
		/** If this select item retrieves its options from a dataSource, should options be fetched from the server when the item is first drawn, or should this fetch be delayed until the user opens the pickList. The default is true in order to allow the user to select a value via keyboard input while keyboard focus is on the SelectItem but the pickList has not actually been shown.
		 * Flags: IRA */
		autoFetchData?: boolean /* Boolean */; // Flags=IRA
		/** For databound pickLists (see PickList.optionDataSource), by default SmartClient will cache and re-use datasets shown by pickLists in an LRU (least recently used) caching pattern. Setting this flag to false avoids this caching for situations where it is too aggressive.
		 * Flags: IR */
		cachePickListResults?: boolean /* Boolean */; // Flags=IR
		/** By default SelectItems do not allow users to select the text of the selected value.
		 * Flags: IRW */
		canSelectText?: boolean; // Flags=IRW
		/** Base CSS class name for a form item's "control box". This is an HTML element which contains the text box and picker icon for the item. See FormItem.alwaysShowControlBox for details on when the control box is written out. See formItemStyling for an overview of formItem styling, and the CompoundFormItem_skinning discussion for special skinning considerations.
		 * Flags: IRW, Group: appearance */
		controlStyle?: string /* FormItemBaseStyle */; // Flags=IRW
		/** Select the first option as the default value for this SelectItem. If options are derived from a dataSource, the first value returned by the server will be used, otherwise the first value in the valueMap. Note that setting this property to true will trigger a fetch at soon as the form is created, because the form will try to establish a default value at that time. If enabled, this setting overrides SelectItem.defaultValue and SelectItem.defaultDynamicValue.
		 * Flags: IRW */
		defaultToFirstOption?: boolean /* Boolean */; // Flags=IRW
		/** Static default value for this SelectItem. To default to the first option use SelectItem.defaultToFirstOption instead.
		 * Flags: IRW */
		defaultValue?: boolean; // Flags=IRW
		/** If set, this item will display a value from another field to the user instead of showing the underlying data value for the FormItem.name','field name. The display value can be derived in two ways: The item will display the displayField value from the DynamicForm.getValues','record currently being edited if FormItem.useLocalDisplayFieldValue is true, (or if unset and the conditions outlined in the documentation for that property are met). Note that DataSourceField.useLocalDisplayFieldValue will default to true if not explicitly set in some cases, as described in the documentation for that property. Otherwise this item will perform a fetch against the FormItem.optionDataSource to find a record where the FormItem.getValueFieldName','value field matches this item's value, and use the displayField, or FormItem.foreignDisplayField value from that record. Note that the specified displayField must be explicitly defined in the optionDataSource to be used - see SelectItem.getDisplayFieldName for more on this behavior. This essentially allows the specified optionDataSource to be used as a server based valueMap. Note that if optionDataSource is set and no valid display field is specified, FormItem.getDisplayFieldName will return the dataSource title field by default. If a displayField is specified for a freeform text based item (such as a ComboBoxItem), any user-entered value will be treated as a display value. In this scenario, items will derive the data value for the item from the first record where the displayField value matches the user-entered value. To avoid ambiguity, developers may wish to avoid this usage if display values are not unique.
		 * Flags: IRW, Group: databinding */
		displayField?: string; // Flags=IRW
		/** Default class used to construct the EditProxy for this component when the component is Canvas.setEditMode','first placed into edit mode.
		 * Flags: IR */
		editProxyConstructor?: string /* SCClassName */; // Flags=IR
		/** Text to display when this form item has a null or undefined value. If the formItem has a databound pickList, and its FormItem.displayField or FormItem.valueField (if the former isn't set) has an undefined ListGridField.emptyCellValue','emptyCellValue setting, that field's emptyCellValue will automatically be set to the emptyDisplayValue.
		 * Flags: IRW, Group: display_values */
		emptyDisplayValue?: string /* HTMLString */; // Flags=IRW
		/** Empty message to display in the selectItem if PickList.hideEmptyPickList is false.
		 * Flags: IRWA, Group: i18nMessages */
		emptyPickListMessage?: string; // Flags=IRWA
		/** By default HTML values in a selectItem will be interpreted by the browser. Setting this flag to true will causes HTML characters to be escaped, meaning the raw value of the field (for example "&lt;b&gt;AAA&lt;/b&gt;") is displayed to the user rather than the interpreted HTML (for example "AAA")
		 * Flags: IRW, Group: appearance */
		escapeHTML?: boolean /* Boolean */; // Flags=IRW
		/** If this item has a specified optionDataSource and this property is true, the list of fields used by this pickList will be passed to the datasource as DSRequest.outputs. If the datasource supports this feature the returned fields will be limited to this list. A custom datasource will need to add code to implement field limiting. This list of used fields consists of the values of FormItem.valueField','valueField, FormItem.displayField','displayField and SelectItem.pickListFields','pickListFields. NOTE: When enabled, FormItem.getSelectedRecord','getSelectedRecord will only include the fetched fields.
		 * Flags: IRA */
		fetchDisplayedFieldsOnly?: boolean; // Flags=IRA
		/** If filterLocally is set for this item, and this item is showing options from a dataSource, fetch the entire set of options from the server, and use these values to map the item value to the appropriate display value. Also use "local" type filtering on drop down list of options. This means data will only be fetched once from the server, and then filtered on the client. Note - when this property is set to false, filtering will still be performed on the client if a complete set of data for some criteria has been cached by a fetch, and a subsequent fetch has more restrictive criteria. To explicitly disable client-side filtering set the SelectItem.useClientFiltering property to false.
		 * Flags: IRA */
		filterLocally?: boolean /* Boolean */; // Flags=IRA
		/** Height of the FormItem. Can be either a number indicating a fixed height in pixels, a percentage indicating a percentage of the overall form's height, or "*" indicating take whatever remaining space is available. See the formLayout overview for details. For form items having a SelectItem.showPickerIcon','picker icon (e.g. SelectItem, ComboBoxItem) and SpinnerItems, if skinning','spriting is enabled, it is not recommended to change the height of the form item from the default because the image sprites are set up assuming a specific, fixed height of the item. If the item height must be changed, then the SelectItem.pickerIconStyle','pickerIconStyle should be changed to a custom CSS style name. Or, in the case of SpinnerItems, the FormItemIcon.baseStyle','baseStyle and FormItemIcon.src','src of the SpinnerItem.increaseIcon and SpinnerItem.decreaseIcon AutoChildren should be customized. Note that when FormItem is rendered as read-only with readOnlyDisplay as "static" the property FormItem.staticHeight is used instead.
		 * Flags: IRW, Group: formLayout */
		height?: number; // Flags=IRW
		/** For PickList items with PickListItemIconPlacement set such that the pickList does not render near-origin, should specified FormItem.icons','icons be rendered inline within the formItem itself, or within the ComboBoxItem.pickerNavigationBar','pickerNavigationBar. May be overridden at the icon level via FormItemIcon.iconPlacement. For mobile browsing with limited available screen space, icons rendered in the navigation bar may be easier for the user to interact with.
		 * Flags: IR */
		iconPlacement?: PickListItemIconPlacement; // Flags=IR
		/** An array of SortSpecifier objects used to set up the initial sort configuration for this pickList. If specified, this will be used instead of any PickList.sortField specified.
		 * Flags: IR, Group: sorting */
		initialSort?: Array<SortSpecifier> /* Array of SortSpecifier */; // Flags=IR
		/** If true, multiple values may be selected. The SelectItem will either render as a drop-down allowing multiple selections, or a multi-row list of options similar to a small headerless ListGrid, based on the MultipleAppearance setting. The logical value of the formItem, as retrieved by FormItem.getValue','getValue() and set via FormItem.setValue','setValue(), is an Array of Strings reflecting the selected values. When this value is true, we disable doubleClick events by default, instead issuing two single clicks by forcibly setting Canvas.noDoubleClicks','noDoubleClicks: true. If you need to work with doubleClick events, you can disable this default behavior by explicitly setting formItem.pickListProperties.noDoubleClicks: false. Note: multiple:true SelectItems with multipleAppearance:"grid" do not currently support optionDataSource binding. You can get around this by calling DataSource.fetchData directly and calling List.getValueMap','dsResponse.data.getValueMap() to obtain a valueMap.
		 * Flags: IRW, Group: appearance */
		multiple?: boolean /* Boolean */; // Flags=IRW
		/** How should items with SelectItem.multiple set to 'true' be displayed?
		 * Flags: IR */
		multipleAppearance?: MultipleAppearance; // Flags=IR
		/** Causes the PickList to open when the down arrow is pressed, default false. For native OS widgets, the down arrow changes the value of a select on Windows, but opens the select on Macs. This setting is not recommended unless you are certain that all users of your applications will expect the Mac convention.
		 * Flags: IRW */
		openOnDownArrow?: boolean /* Boolean */; // Flags=IRW
		/** Causes the PickList to open when the spacebar is pressed, default false. For native OS widgets, space opens the PickList on Macs, but not on Windows. Consider using this setting if your users are almost entirely Mac users, or enabling it only for users running MacOS. However, before using this setting, consider that it means that Spacebar will not be able to be used for another purpose when focus is in a SelectItem.
		 * Flags: IRW */
		openOnSpace?: boolean /* Boolean */; // Flags=IRW
		/** If set, this FormItem will derive data to show in the PickList by fetching records from the specified optionDataSource. The fetched data will be used as a FormItem.valueMap','valueMap by extracting the FormItem.valueField','valueField and FormItem.displayField','displayField in the loaded records, to derive one valueMap entry per record loaded from the optionDataSource. Multiple fields from the fetched data may be shown in the pickList by setting SelectItem.pickListFields. The data will be retrieved via a "fetch" operation on the DataSource, passing the PickList.pickListCriteria (if set) as criteria, and passing SelectItem.optionFilterContext (if set) as DSRequest Properties. The fetch will be triggered when the pickList is first shown, or, you can set SelectItem.autoFetchData','autoFetchData:true to fetch when the FormItem is first drawn. Note that providing an initial value when FormItem.fetchMissingValues','fetchMissingValues is enabled, or enabling SelectItem.defaultToFirstOption','defaultToFirstOption, can also cause a fetch to be initiated immediately upon form creation. You can also call PickList.fetchData at any time to manually trigger a fetch. Data paging is automatically enabled if the optionDataSource supports it. As the pickList is scrolled by the user, requests for additional data will be automatically issued. For a pickList attached to a ComboBoxItem','ComboBoxItem, new fetches are issued as the user types, with criteria set as described under ComboBoxItem.getPickListFilterCriteria. If your dataSource is not capable of filtering results by search criteria (eg, the dataSource is backed by an XML flat file), you can set SelectItem.filterLocally to have the entire dataset loaded up front and filtering performed in the browser. This disables data paging. Note that if a normal, static FormItem.valueMap','valueMap is also specified for the field (either directly in the form item or as part of the field definition in the dataSource), it will be preferred to the data derived from the optionDataSource for whatever mappings are present.
		 * Flags: IRA */
		optionDataSource?: DataSource | string /* DataSource | String */; // Flags=IRA
		/** If this item has a specified optionDataSource, and this property is not null, this will be passed to the datasource as DSRequest properties when performing the filter operation on the dataSource to obtain the set of options for the list. This provides, among other capabilities, a way to trigger the server to return summary records.
		 * Flags: IRA */
		optionFilterContext?: DSRequestProps /* DSRequest Properties */; // Flags=IRA
		/** If this item has a specified optionDataSource, this attribute may be set to specify an explicit DSRequest.operationId when performing a fetch against the option dataSource to pick up display value mapping.
		 * Flags: IR */
		optionOperationId?: string; // Flags=IR
		/** NavigationButton to dismiss the picker interface, created when SelectItem.pickListPlacement indicates that the search interface takes over the entire panel or screen. The following autoChildUsage','passthroughs apply: SelectItem.pickerExitButtonTitle','pickerExitButtonTitle for Button.title 
		 * Flags: IR, Group: panelPlacement */
		pickerExitButton?:  NavigationButton /* AutoChild NavigationButton */; // Flags=IR
		/** The title for the SelectItem.pickerExitButton.
		 * Flags: IR, Group: i18nMessages */
		pickerExitButtonTitle?: string /* HTMLString */; // Flags=IR
		/** If SelectItem.showPickerIcon','showPickerIcon is true for this item, this property governs the size of the picker icon. If unset, the picker icon will be sized as a square to fit in the available height for the icon. It is not recommended to change the pickerIconHeight from the default value if skinning','spriting is enabled because the image sprites are set up assuming specific, fixed dimensions of the picker icon. If the pickerIconHeight must be changed, then the FormItem.pickerIconStyle','pickerIconStyle should be changed to a custom CSS style name.
		 * Flags: IRWA, Group: pickerIcon */
		pickerIconHeight?: number /* int */; // Flags=IRWA
		/** If SelectItem.showPickerIcon','showPickerIcon is true for this item, this property governs the FormItemIcon.src','src of the picker icon image to be displayed. When skinning','spriting is enabled, this property will not be used to locate an image, instead, the image is drawn via CSS based on the SelectItem.pickerIconStyle property.
		 * Flags: IRWA, Group: pickerIcon */
		pickerIconSrc?: string /* SCImgURL */; // Flags=IRWA
		/** Base CSS class name for a form item's picker icon cell. If unset, inherits from this item's SelectItem.controlStyle','controlStyle.
		 * Flags: IRW, Group: pickerIcon */
		pickerIconStyle?: string /* FormItemBaseStyle */; // Flags=IRW
		/** If SelectItem.showPickerIcon','showPickerIcon is true for this item, this property governs the size of the picker icon. If unset, the picker icon will be sized as a square to fit in the available height for the icon. It is not recommended to change the pickerIconWidth from the default value if skinning','spriting is enabled because the image sprites are set up assuming specific, fixed dimensions of the picker icon. If the pickerIconWidth must be changed, then the FormItem.pickerIconStyle','pickerIconStyle should be changed to a custom CSS style name.
		 * Flags: IRWA, Group: pickerIcon */
		pickerIconWidth?: number /* int */; // Flags=IRWA
		/** NavigationBar created when SelectItem.pickListPlacement indicates that the search interface takes over the entire panel or screen.
		 * Flags: IR, Group: panelPlacement */
		pickerNavigationBar?:  NavigationBar /* AutoChild NavigationBar */; // Flags=IR
		/** The Class to use when creating the pickList for a FormItem. Must be a subclass of the builtin default, PickListMenu','PickListMenu.
		 * Flags: IR */
		pickListConstructor?: string /* SCClassName */; // Flags=IR
		/** If this item has a databound pickList (for example PickList.optionDataSource is set), this property can be used to provide static filter criteria when retrieving the data for the pickList.
		 * Flags: IRWA */
		pickListCriteria?: Criteria; // Flags=IRWA
		/** This property allows the developer to specify which field[s] will be displayed in the drop down list of options. Only applies to databound pickLists (see PickList.optionDataSource, or pickLists with custom data set up via the advanced PickList.getClientPickListData method. If this property is unset, we display the PickList.displayField, if specified, otherwise the PickList.valueField. If there are multiple fields, column headers will be shown for each field, the height of which can be customized via the PickList.pickListHeaderHeight attribute. Each field to display should be specified as a ListGridField object. Note that unlike in ListGrid','listGrids, dataSource fields marked as DataSourceField.hidden','hidden:true will be hidden by default in pickLists. To override this behavior, ensure that you specify an explicit value for ListGridField.showIf','showIf.
		 * Flags: IRA */
		pickListFields?: Array<ListGridField> /* Array of ListGridField */; // Flags=IRA
		/** Controls where the PickList is placed. Can be specified as a PanelPlacement or a specific widget that should be filled (by specifying an actual Canvas or Canvas.ID). Default behavior is to "fillPanel" if Browser.isHandset or Browser.isTablet, to better accomodate the smaller screen real estate and less precise pointing ability on such devices. When filling the whole screen, part of the screen or a specific panel, the expanded interface is created as a FormItem.picker','standard FormItem picker, and incorporates a SelectItem.pickerNavigationBar','navigation bar and SelectItem.pickerExitButton','done button that hides the expanded interface.
		 * Flags: IR, Group: panelPlacement */
		pickListPlacement?: PanelPlacement | Canvas | string /* PanelPlacement | Canvas | String */; // Flags=IR
		/** If specified this properties block will be applied to the PickListMenu','pickList created for this FormItem. Note: Not every ListGrid property is supported when assigned to a pickList. Where there is a dedicated API on the form item (such as PickList.pickListCellHeight','pickListCellHeight), we recommend that be used in favor of setting the equivalent property on the pickListProperties block. PickLists and ListGrid.showFilterEditor: ComboBoxItem','ComboBoxItems do not support setting showFilterEditor to true on pickListProperties. This combination of settings leads to an ambiguous user exprience as the two sets of filter-criteria (those from the text-box and those from the pickList filter editor) interact with each other. SelectItem.pickListProperties is a valid way to create a filterable pickList, on a SelectItem, but this setting is not supported on a SelectItem with SelectItem.multiple set to true - this combination of settings can cause a selected value to be filtered out of view at which point further selection changes will discard that value. In general we recommend the ComboBoxItem class (with ComboBoxItem.addUnknownValues set as appropriate) as a better interface for filtering pickList data.
		 * Flags: IRA */
		pickListProperties?: ListGridProps /* ListGrid Properties */; // Flags=IRA
		/** Indicates whether or not this SelectItem will load its list of options DataSource.progressiveLoading','progressively. This property is copied onto the underlying PickList.
		 * Flags: IRW, Group: progressiveLoading */
		progressiveLoading?: boolean; // Flags=IRW
		/** Select items will submit their containing form on enter keypress if DynamicForm.saveOnEnter','saveOnEnter is true. Setting this property to false will disable this behavior. Note that if the drop down list of options (pickList) is visible an Enter keypress is used to select a value from the available set of options and will not automatically cause form submission.
		 * Flags: IRW */
		saveOnEnter?: boolean /* Boolean */; // Flags=IRW
		/** If true, SelectItem.specialValues','special values such as the empty value will be shown in a separate non-scrolling area, in the SelectItem.separateValuesList. Aside from making these values more easily accessible, showing them in a separate list allows data paging to be used, which is disabled if the separateValues are shown in the normal drop-down list along with other values.
		 * Flags: IR */
		separateSpecialValues?: boolean; // Flags=IR
		/** AutoChild used to show SelectItem.specialValues.
		 * Flags: IR */
		separateValuesList?:  ListGrid /* AutoChild ListGrid */; // Flags=IR
		/** When this item receives focus, should it be re-styled to indicate it has focus? See formItemStyling for more details on formItem styling.
		 * Flags: IRWA, Group: formItemStyling */
		showFocused?: boolean /* Boolean */; // Flags=IRWA
		/** If showing a hint for this form item, should it be shown within the field? CSS style for the hint is SelectItem.textBoxStyle with the suffix "Hint" appended to it.
		 * Flags: IRWA, Group: appearance */
		showHintInField?: boolean; // Flags=IRWA
		/** If this item is part of a databound form, and has a specified valueMap, by default we show the valueMap options in the pickList for the item. Setting this property to true will ensure that the options displayed in our pickList are derived from the form's dataSource.
		 * Flags: IRWA, Group: databinding */
		showOptionsFromDataSource?: boolean; // Flags=IRWA
		/** When the user rolls over this item, should it be re-styled to indicate it has focus? By default this property is true for SelectItems, and SelectItem.updateTextBoxOnOver and SelectItem.updateControlOnOver are set to false. This means the picker icon will show over styling when the user rolls over the control table. These defaults may be overridden by different SmartClient skins. See formItemStyling for more details on formItem styling.
		 * Flags: IRWA, Group: formItemStyling */
		showOver?: boolean; // Flags=IRWA
		/** Should we show a special 'picker' FormItemIcon','icon for this form item? Picker icons are customizable via FormItem.pickerIconProperties','pickerIconProperties. By default they will be rendered inside the form item's FormItem.controlStyle','"control box" area, and will call FormItem.showPicker when clicked.
		 * Flags: IRW, Group: pickerIcon */
		showPickerIcon?: boolean /* Boolean */; // Flags=IRW
		/** Specifies one or more fields by which this item should be initially sorted. It can be a ListGridField.name','field name, or an array of field names - but note that, if multiple fields are supplied, then each will be sorted in the same ListGrid.sortDirection','direction. For full sorting control, set PickList.initialSort','initialSort to a list of custom SortSpecifier','sortSpecifiers. This attribute can also be set to the index of a field in the fields array, but note that it will be converted to a string (field name) after initialization.
		 * Flags: IR, Group: sorting */
		sortField?: Array<string> /* String | Array of String | int */; // Flags=IR
		/** A set of "special" values such as "All", "None" or "Invalid" that do not appear in the normal ValueMap or in the data returned by the SelectItem.optionDataSource. Like other uses of ValueMap, either a list of values or a mapping from stored to display value can be provided. These values can either be shown at the top of the list of values (in the order specified), or can be shown in a separate, non-scrolling region - the setting SelectItem.separateSpecialValues','separateSpecialValues controls this. Note that data paging can only be used if separateSpecialValues is enabled. If specialValues are configured, SelectItem.allowEmptyValue','allowEmptyValue is ignored - an empty value, if desired, must be included in the specialValues. To provide a specialValue which clears the value of the field, use the special constant PickList.emptyStoredValue. specialValues can also be used to take a value that does appear in the normal data and redundantly display it at the top of the list to make it more accessible. Note that in this case it is expected that the special value appears both at the top of the list and in it's normal position in the list, so this works best with SelectItem.separateSpecialValues','separateSpecialValues mode enabled. Also, if an SelectItem.optionDataSource is used, SelectItem.specialValues that appear in the normal dataset will be updated by automatic cacheSync','cache synchronization (if the SelectItem.displayField is updated). However when using a distinct SelectItem.valueField and SelectItem.displayField, you are required to provide SelectItem.specialValues as a map (there is no support for FormItem.fetchMissingValues','fetchMissingValues automatically fetching appropriate display values). Note that specialValues are not supported in conjunction with MultiComboBoxItem. Whereas with SelectItem.multiple','selectItem.multiple:true, specialValues will never be normal values that may be selected. So, specialValues should have options such as "Select All", "Select None" and others.
		 * Flags: IR */
		specialValues?: ValueMap; // Flags=IR
		/** Base CSS class name for a form item's text box element. See formItemStyling for an overview of formItem styling, and the CompoundFormItem_skinning discussion for special skinning considerations. If the textBoxStyle is changed at runtime, FormItem.updateState','updateState() must be called to update the visual state of this item.
		 * Flags: IRW, Group: appearance */
		textBoxStyle?: string /* FormItemBaseStyle */; // Flags=IRW
		/** When applying filter criteria to pickList data, what type of matching to use. For a databound pickList (SelectItem.optionDataSource set), textMatchStyle is sent to the server as DSRequest.textMatchStyle. For a non-databound pickList, textMatchStyle is applied by PickList.filterClientPickListData','filterClientPickListData().
		 * Flags: IR */
		textMatchStyle?: TextMatchStyle; // Flags=IR
		/** If FormItem.showOver is true, setting this property to false will explicitly disable showing the "Over" state for the control table element of this item (if present).
		 * Flags: IRWA, Group: formItemStyling */
		updateControlOnOver?: boolean /* Boolean */; // Flags=IRWA
		/** If FormItem.showOver is true, setting this property to false will explicitly disable showing the "Over" state for the TextBox element of this item.
		 * Flags: IRWA, Group: formItemStyling */
		updateTextBoxOnOver?: boolean /* Boolean */; // Flags=IRWA
		/** For SelectItem.optionDataSource','databound items, this property will be passed to the generated ResultSet data object for the pickList as ResultSet.useClientFiltering. Setting to false will disable filtering on the client and ensure criteria are always passed to the DataSource directly.
		 * Flags: IRA */
		useClientFiltering?: boolean /* Boolean */; // Flags=IRA
		/** If this form item maps data values to display values by retrieving the FormItem.displayField values from an FormItem.optionDataSource','optionDataSource, this property denotes the the field to use as the underlying data value in records from the optionDataSource. If not explicitly supplied, the valueField name will be derived as described in FormItem.getValueFieldName.
		 * Flags: IRW, Group: databinding */
		valueField?: string; // Flags=IRW

		/* Method Overrides */

		/** 
		 * Only applies to databound items (see PickList.optionDataSource). Performs a fetch type operation on this item's DataSource to retrieve the set of valid options for the item, based on the current PickList.pickListCriteria.
		 * @param {DSCallback} callback - Callback to fire when the fetch completes. Callback will fire with 4 parameters: item a pointer to the form item dsResponse the DSResponse returned by the server data the raw data returned by the server dsRequest the DSRequest sent to the server 
		 * @param {DSRequestProps} requestProperties - properties to apply to the dsRequest for this fetch.
		 */
		fetchData?(callback?:DSCallback, requestProperties?:DSRequestProps /* DSRequest properties */): void; 

		/** 
		 * For a SelectItem with an SelectItem.optionDataSource and allowing multiple selection (SelectItem.multiple','via multiple:true), returns the list of currently selected records, or null if none are selected. 
		 */
		getSelectedRecords?(): Array<ListGridRecord> /* Array of ListGridRecord */; 

	} // SelectItemProps


	/**
	 * FormItem that allows picking between several mutually exclusive options via a select list. Options may be derived from a dataSource or a valueMap. Note that to select the first option as a default value for the item, SelectItem.defaultToFirstOption may be set. 
	 */
	export interface SelectItem extends FormItem {
		/** If this item's value is set (via SelectItem.setValue or similar) to a value which is not present in the ValueMap, should the value be rejected. If set to false the setValue() call will have no effect if the value is not a valid option. If set to true the item's value will be update to the new value, and the value will be added to the set of options displayed in the pick-list until the next call to SelectItem.setValueMap or SelectItem.setValue. Exception: If the value is set to null but there is no null entry in the valueMap for this item, setting addUnknownValues to true will not cause a null option to show up at the top of the select item pickList. Whether an empty option is shown in the pickList is governed by SelectItem.allowEmptyValue instead. Note that this property has no effect if the selectItem has a specified SelectItem.optionDataSource. If SelectItem.setValue is called on a databound SelectItem and the new value does not match any loaded options, the value will be accepted, but not added to the options displayed in the pickList. Also note that if a SelectItem.displayField exists, a fetch will be performed in an attempt to retrieve a valid display value, as described under FormItem.fetchMissingValues. If specified the FormItem.loadingDisplayValue will be displayed while the fetch is in progress, and then the real value (mapped to a display field value if a matching record was found) will be displayed when the fetch completes.
		 * Flags: IRWA */
		addUnknownValues: boolean /* Boolean */;

		/** If set to true, always show an empty option in this item's pickList, allowing the user to clear the value (even if there is no empty entry in the valueMap for the item). The empty value will be displayed with the FormItem.emptyDisplayValue','emptyDisplayValue. With a SelectItem.optionDataSource','databound selectItem, enabling allowEmptyValue disables data paging by default - all data matching the PickList.pickListCriteria','current criteria will be requested. However, enabling SelectItem.separateSpecialValues allows data paging to be used if required. See also SelectItem.specialValues as a way of providing several different special values in addition to an empty value, such as "Invalid". Note that setting specialValues disables the use of allowEmptyValue - see details of how to have an empty value while using specialValues in in SelectItem.specialValues','the specialValues documentation.
		 * Flags: IR */
		allowEmptyValue: boolean /* Boolean */;

		/** By default, if multiple keys are pressed in quick succession, a SelectItem will buffer them together and use the resulting multi-char string when searching. Set this attribute to false to force the item to match only one character at a time.
		 * Flags: IRW */
		allowMultiCharSearch: boolean;

		/** If this select item retrieves its options from a dataSource, should options be fetched from the server when the item is first drawn, or should this fetch be delayed until the user opens the pickList. The default is true in order to allow the user to select a value via keyboard input while keyboard focus is on the SelectItem but the pickList has not actually been shown.
		 * Flags: IRA */
		autoFetchData: boolean /* Boolean */;

		/** For databound pickLists (see PickList.optionDataSource), by default SmartClient will cache and re-use datasets shown by pickLists in an LRU (least recently used) caching pattern. Setting this flag to false avoids this caching for situations where it is too aggressive.
		 * Flags: IR */
		cachePickListResults: boolean /* Boolean */;

		/** By default SelectItems do not allow users to select the text of the selected value.
		 * Flags: IRW */
		canSelectText: boolean;

		/** Base CSS class name for a form item's "control box". This is an HTML element which contains the text box and picker icon for the item. See FormItem.alwaysShowControlBox for details on when the control box is written out. See formItemStyling for an overview of formItem styling, and the CompoundFormItem_skinning discussion for special skinning considerations.
		 * Flags: IRW, Group: appearance */
		controlStyle: string /* FormItemBaseStyle */;

		/** Select the first option as the default value for this SelectItem. If options are derived from a dataSource, the first value returned by the server will be used, otherwise the first value in the valueMap. Note that setting this property to true will trigger a fetch at soon as the form is created, because the form will try to establish a default value at that time. If enabled, this setting overrides SelectItem.defaultValue and SelectItem.defaultDynamicValue.
		 * Flags: IRW */
		defaultToFirstOption: boolean /* Boolean */;

		/** Static default value for this SelectItem. To default to the first option use SelectItem.defaultToFirstOption instead.
		 * Flags: IRW */
		defaultValue: boolean;

		/** If set, this item will display a value from another field to the user instead of showing the underlying data value for the FormItem.name','field name. The display value can be derived in two ways: The item will display the displayField value from the DynamicForm.getValues','record currently being edited if FormItem.useLocalDisplayFieldValue is true, (or if unset and the conditions outlined in the documentation for that property are met). Note that DataSourceField.useLocalDisplayFieldValue will default to true if not explicitly set in some cases, as described in the documentation for that property. Otherwise this item will perform a fetch against the FormItem.optionDataSource to find a record where the FormItem.getValueFieldName','value field matches this item's value, and use the displayField, or FormItem.foreignDisplayField value from that record. Note that the specified displayField must be explicitly defined in the optionDataSource to be used - see SelectItem.getDisplayFieldName for more on this behavior. This essentially allows the specified optionDataSource to be used as a server based valueMap. Note that if optionDataSource is set and no valid display field is specified, FormItem.getDisplayFieldName will return the dataSource title field by default. If a displayField is specified for a freeform text based item (such as a ComboBoxItem), any user-entered value will be treated as a display value. In this scenario, items will derive the data value for the item from the first record where the displayField value matches the user-entered value. To avoid ambiguity, developers may wish to avoid this usage if display values are not unique.
		 * Flags: IRW, Group: databinding */
		displayField: string;

		/** Default class used to construct the EditProxy for this component when the component is Canvas.setEditMode','first placed into edit mode.
		 * Flags: IR */
		editProxyConstructor: string /* SCClassName */;

		/** Text to display when this form item has a null or undefined value. If the formItem has a databound pickList, and its FormItem.displayField or FormItem.valueField (if the former isn't set) has an undefined ListGridField.emptyCellValue','emptyCellValue setting, that field's emptyCellValue will automatically be set to the emptyDisplayValue.
		 * Flags: IRW, Group: display_values */
		emptyDisplayValue: string /* HTMLString */;

		/** Empty message to display in the selectItem if PickList.hideEmptyPickList is false.
		 * Flags: IRWA, Group: i18nMessages */
		emptyPickListMessage: string;

		/** By default HTML values in a selectItem will be interpreted by the browser. Setting this flag to true will causes HTML characters to be escaped, meaning the raw value of the field (for example "&lt;b&gt;AAA&lt;/b&gt;") is displayed to the user rather than the interpreted HTML (for example "AAA")
		 * Flags: IRW, Group: appearance */
		escapeHTML: boolean /* Boolean */;

		/** If this item has a specified optionDataSource and this property is true, the list of fields used by this pickList will be passed to the datasource as DSRequest.outputs. If the datasource supports this feature the returned fields will be limited to this list. A custom datasource will need to add code to implement field limiting. This list of used fields consists of the values of FormItem.valueField','valueField, FormItem.displayField','displayField and SelectItem.pickListFields','pickListFields. NOTE: When enabled, FormItem.getSelectedRecord','getSelectedRecord will only include the fetched fields.
		 * Flags: IRA */
		fetchDisplayedFieldsOnly: boolean;

		/** If filterLocally is set for this item, and this item is showing options from a dataSource, fetch the entire set of options from the server, and use these values to map the item value to the appropriate display value. Also use "local" type filtering on drop down list of options. This means data will only be fetched once from the server, and then filtered on the client. Note - when this property is set to false, filtering will still be performed on the client if a complete set of data for some criteria has been cached by a fetch, and a subsequent fetch has more restrictive criteria. To explicitly disable client-side filtering set the SelectItem.useClientFiltering property to false.
		 * Flags: IRA */
		filterLocally: boolean /* Boolean */;

		/** Height of the FormItem. Can be either a number indicating a fixed height in pixels, a percentage indicating a percentage of the overall form's height, or "*" indicating take whatever remaining space is available. See the formLayout overview for details. For form items having a SelectItem.showPickerIcon','picker icon (e.g. SelectItem, ComboBoxItem) and SpinnerItems, if skinning','spriting is enabled, it is not recommended to change the height of the form item from the default because the image sprites are set up assuming a specific, fixed height of the item. If the item height must be changed, then the SelectItem.pickerIconStyle','pickerIconStyle should be changed to a custom CSS style name. Or, in the case of SpinnerItems, the FormItemIcon.baseStyle','baseStyle and FormItemIcon.src','src of the SpinnerItem.increaseIcon and SpinnerItem.decreaseIcon AutoChildren should be customized. Note that when FormItem is rendered as read-only with readOnlyDisplay as "static" the property FormItem.staticHeight is used instead.
		 * Flags: IRW, Group: formLayout */
		height: number;

		/** For PickList items with PickListItemIconPlacement set such that the pickList does not render near-origin, should specified FormItem.icons','icons be rendered inline within the formItem itself, or within the ComboBoxItem.pickerNavigationBar','pickerNavigationBar. May be overridden at the icon level via FormItemIcon.iconPlacement. For mobile browsing with limited available screen space, icons rendered in the navigation bar may be easier for the user to interact with.
		 * Flags: IR */
		iconPlacement: PickListItemIconPlacement;

		/** An array of SortSpecifier objects used to set up the initial sort configuration for this pickList. If specified, this will be used instead of any PickList.sortField specified.
		 * Flags: IR, Group: sorting */
		initialSort: Array<SortSpecifier> /* Array of SortSpecifier */;

		/** If true, multiple values may be selected. The SelectItem will either render as a drop-down allowing multiple selections, or a multi-row list of options similar to a small headerless ListGrid, based on the MultipleAppearance setting. The logical value of the formItem, as retrieved by FormItem.getValue','getValue() and set via FormItem.setValue','setValue(), is an Array of Strings reflecting the selected values. When this value is true, we disable doubleClick events by default, instead issuing two single clicks by forcibly setting Canvas.noDoubleClicks','noDoubleClicks: true. If you need to work with doubleClick events, you can disable this default behavior by explicitly setting formItem.pickListProperties.noDoubleClicks: false. Note: multiple:true SelectItems with multipleAppearance:"grid" do not currently support optionDataSource binding. You can get around this by calling DataSource.fetchData directly and calling List.getValueMap','dsResponse.data.getValueMap() to obtain a valueMap.
		 * Flags: IRW, Group: appearance */
		multiple: boolean /* Boolean */;

		/** How should items with SelectItem.multiple set to 'true' be displayed?
		 * Flags: IR */
		multipleAppearance: MultipleAppearance;

		/** Causes the PickList to open when the down arrow is pressed, default false. For native OS widgets, the down arrow changes the value of a select on Windows, but opens the select on Macs. This setting is not recommended unless you are certain that all users of your applications will expect the Mac convention.
		 * Flags: IRW */
		openOnDownArrow: boolean /* Boolean */;

		/** Causes the PickList to open when the spacebar is pressed, default false. For native OS widgets, space opens the PickList on Macs, but not on Windows. Consider using this setting if your users are almost entirely Mac users, or enabling it only for users running MacOS. However, before using this setting, consider that it means that Spacebar will not be able to be used for another purpose when focus is in a SelectItem.
		 * Flags: IRW */
		openOnSpace: boolean /* Boolean */;

		/** If set, this FormItem will derive data to show in the PickList by fetching records from the specified optionDataSource. The fetched data will be used as a FormItem.valueMap','valueMap by extracting the FormItem.valueField','valueField and FormItem.displayField','displayField in the loaded records, to derive one valueMap entry per record loaded from the optionDataSource. Multiple fields from the fetched data may be shown in the pickList by setting SelectItem.pickListFields. The data will be retrieved via a "fetch" operation on the DataSource, passing the PickList.pickListCriteria (if set) as criteria, and passing SelectItem.optionFilterContext (if set) as DSRequest Properties. The fetch will be triggered when the pickList is first shown, or, you can set SelectItem.autoFetchData','autoFetchData:true to fetch when the FormItem is first drawn. Note that providing an initial value when FormItem.fetchMissingValues','fetchMissingValues is enabled, or enabling SelectItem.defaultToFirstOption','defaultToFirstOption, can also cause a fetch to be initiated immediately upon form creation. You can also call PickList.fetchData at any time to manually trigger a fetch. Data paging is automatically enabled if the optionDataSource supports it. As the pickList is scrolled by the user, requests for additional data will be automatically issued. For a pickList attached to a ComboBoxItem','ComboBoxItem, new fetches are issued as the user types, with criteria set as described under ComboBoxItem.getPickListFilterCriteria. If your dataSource is not capable of filtering results by search criteria (eg, the dataSource is backed by an XML flat file), you can set SelectItem.filterLocally to have the entire dataset loaded up front and filtering performed in the browser. This disables data paging. Note that if a normal, static FormItem.valueMap','valueMap is also specified for the field (either directly in the form item or as part of the field definition in the dataSource), it will be preferred to the data derived from the optionDataSource for whatever mappings are present.
		 * Flags: IRA */
		optionDataSource: DataSource | string /* DataSource | String */;

		/** If this item has a specified optionDataSource, and this property is not null, this will be passed to the datasource as DSRequest properties when performing the filter operation on the dataSource to obtain the set of options for the list. This provides, among other capabilities, a way to trigger the server to return summary records.
		 * Flags: IRA */
		optionFilterContext: DSRequestProps /* DSRequest Properties */;

		/** If this item has a specified optionDataSource, this attribute may be set to specify an explicit DSRequest.operationId when performing a fetch against the option dataSource to pick up display value mapping.
		 * Flags: IR */
		optionOperationId: string;

		/** NavigationButton to dismiss the picker interface, created when SelectItem.pickListPlacement indicates that the search interface takes over the entire panel or screen. The following autoChildUsage','passthroughs apply: SelectItem.pickerExitButtonTitle','pickerExitButtonTitle for Button.title 
		 * Flags: IR, Group: panelPlacement */
		pickerExitButton:  NavigationButton /* AutoChild NavigationButton */;

		/** The title for the SelectItem.pickerExitButton.
		 * Flags: IR, Group: i18nMessages */
		pickerExitButtonTitle: string /* HTMLString */;

		/** If SelectItem.showPickerIcon','showPickerIcon is true for this item, this property governs the size of the picker icon. If unset, the picker icon will be sized as a square to fit in the available height for the icon. It is not recommended to change the pickerIconHeight from the default value if skinning','spriting is enabled because the image sprites are set up assuming specific, fixed dimensions of the picker icon. If the pickerIconHeight must be changed, then the FormItem.pickerIconStyle','pickerIconStyle should be changed to a custom CSS style name.
		 * Flags: IRWA, Group: pickerIcon */
		pickerIconHeight: number /* int */;

		/** If SelectItem.showPickerIcon','showPickerIcon is true for this item, this property governs the FormItemIcon.src','src of the picker icon image to be displayed. When skinning','spriting is enabled, this property will not be used to locate an image, instead, the image is drawn via CSS based on the SelectItem.pickerIconStyle property.
		 * Flags: IRWA, Group: pickerIcon */
		pickerIconSrc: string /* SCImgURL */;

		/** Base CSS class name for a form item's picker icon cell. If unset, inherits from this item's SelectItem.controlStyle','controlStyle.
		 * Flags: IRW, Group: pickerIcon */
		pickerIconStyle: string /* FormItemBaseStyle */;

		/** If SelectItem.showPickerIcon','showPickerIcon is true for this item, this property governs the size of the picker icon. If unset, the picker icon will be sized as a square to fit in the available height for the icon. It is not recommended to change the pickerIconWidth from the default value if skinning','spriting is enabled because the image sprites are set up assuming specific, fixed dimensions of the picker icon. If the pickerIconWidth must be changed, then the FormItem.pickerIconStyle','pickerIconStyle should be changed to a custom CSS style name.
		 * Flags: IRWA, Group: pickerIcon */
		pickerIconWidth: number /* int */;

		/** NavigationBar created when SelectItem.pickListPlacement indicates that the search interface takes over the entire panel or screen.
		 * Flags: IR, Group: panelPlacement */
		pickerNavigationBar:  NavigationBar /* AutoChild NavigationBar */;

		/** The Class to use when creating the pickList for a FormItem. Must be a subclass of the builtin default, PickListMenu','PickListMenu.
		 * Flags: IR */
		pickListConstructor: string /* SCClassName */;

		/** If this item has a databound pickList (for example PickList.optionDataSource is set), this property can be used to provide static filter criteria when retrieving the data for the pickList.
		 * Flags: IRWA */
		pickListCriteria: Criteria;

		/** This property allows the developer to specify which field[s] will be displayed in the drop down list of options. Only applies to databound pickLists (see PickList.optionDataSource, or pickLists with custom data set up via the advanced PickList.getClientPickListData method. If this property is unset, we display the PickList.displayField, if specified, otherwise the PickList.valueField. If there are multiple fields, column headers will be shown for each field, the height of which can be customized via the PickList.pickListHeaderHeight attribute. Each field to display should be specified as a ListGridField object. Note that unlike in ListGrid','listGrids, dataSource fields marked as DataSourceField.hidden','hidden:true will be hidden by default in pickLists. To override this behavior, ensure that you specify an explicit value for ListGridField.showIf','showIf.
		 * Flags: IRA */
		pickListFields: Array<ListGridField> /* Array of ListGridField */;

		/** Controls where the PickList is placed. Can be specified as a PanelPlacement or a specific widget that should be filled (by specifying an actual Canvas or Canvas.ID). Default behavior is to "fillPanel" if Browser.isHandset or Browser.isTablet, to better accomodate the smaller screen real estate and less precise pointing ability on such devices. When filling the whole screen, part of the screen or a specific panel, the expanded interface is created as a FormItem.picker','standard FormItem picker, and incorporates a SelectItem.pickerNavigationBar','navigation bar and SelectItem.pickerExitButton','done button that hides the expanded interface.
		 * Flags: IR, Group: panelPlacement */
		pickListPlacement: PanelPlacement | Canvas | string /* PanelPlacement | Canvas | String */;

		/** If specified this properties block will be applied to the PickListMenu','pickList created for this FormItem. Note: Not every ListGrid property is supported when assigned to a pickList. Where there is a dedicated API on the form item (such as PickList.pickListCellHeight','pickListCellHeight), we recommend that be used in favor of setting the equivalent property on the pickListProperties block. PickLists and ListGrid.showFilterEditor: ComboBoxItem','ComboBoxItems do not support setting showFilterEditor to true on pickListProperties. This combination of settings leads to an ambiguous user exprience as the two sets of filter-criteria (those from the text-box and those from the pickList filter editor) interact with each other. SelectItem.pickListProperties is a valid way to create a filterable pickList, on a SelectItem, but this setting is not supported on a SelectItem with SelectItem.multiple set to true - this combination of settings can cause a selected value to be filtered out of view at which point further selection changes will discard that value. In general we recommend the ComboBoxItem class (with ComboBoxItem.addUnknownValues set as appropriate) as a better interface for filtering pickList data.
		 * Flags: IRA */
		pickListProperties: ListGridProps /* ListGrid Properties */;

		/** Indicates whether or not this SelectItem will load its list of options DataSource.progressiveLoading','progressively. This property is copied onto the underlying PickList.
		 * Flags: IRW, Group: progressiveLoading */
		progressiveLoading: boolean;

		/** Select items will submit their containing form on enter keypress if DynamicForm.saveOnEnter','saveOnEnter is true. Setting this property to false will disable this behavior. Note that if the drop down list of options (pickList) is visible an Enter keypress is used to select a value from the available set of options and will not automatically cause form submission.
		 * Flags: IRW */
		saveOnEnter: boolean /* Boolean */;

		/** If true, SelectItem.specialValues','special values such as the empty value will be shown in a separate non-scrolling area, in the SelectItem.separateValuesList. Aside from making these values more easily accessible, showing them in a separate list allows data paging to be used, which is disabled if the separateValues are shown in the normal drop-down list along with other values.
		 * Flags: IR */
		separateSpecialValues: boolean;

		/** AutoChild used to show SelectItem.specialValues.
		 * Flags: IR */
		separateValuesList:  ListGrid /* AutoChild ListGrid */;

		/** When this item receives focus, should it be re-styled to indicate it has focus? See formItemStyling for more details on formItem styling.
		 * Flags: IRWA, Group: formItemStyling */
		showFocused: boolean /* Boolean */;

		/** If showing a hint for this form item, should it be shown within the field? CSS style for the hint is SelectItem.textBoxStyle with the suffix "Hint" appended to it.
		 * Flags: IRWA, Group: appearance */
		showHintInField: boolean;

		/** If this item is part of a databound form, and has a specified valueMap, by default we show the valueMap options in the pickList for the item. Setting this property to true will ensure that the options displayed in our pickList are derived from the form's dataSource.
		 * Flags: IRWA, Group: databinding */
		showOptionsFromDataSource: boolean;

		/** When the user rolls over this item, should it be re-styled to indicate it has focus? By default this property is true for SelectItems, and SelectItem.updateTextBoxOnOver and SelectItem.updateControlOnOver are set to false. This means the picker icon will show over styling when the user rolls over the control table. These defaults may be overridden by different SmartClient skins. See formItemStyling for more details on formItem styling.
		 * Flags: IRWA, Group: formItemStyling */
		showOver: boolean;

		/** Should we show a special 'picker' FormItemIcon','icon for this form item? Picker icons are customizable via FormItem.pickerIconProperties','pickerIconProperties. By default they will be rendered inside the form item's FormItem.controlStyle','"control box" area, and will call FormItem.showPicker when clicked.
		 * Flags: IRW, Group: pickerIcon */
		showPickerIcon: boolean /* Boolean */;

		/** Specifies one or more fields by which this item should be initially sorted. It can be a ListGridField.name','field name, or an array of field names - but note that, if multiple fields are supplied, then each will be sorted in the same ListGrid.sortDirection','direction. For full sorting control, set PickList.initialSort','initialSort to a list of custom SortSpecifier','sortSpecifiers. This attribute can also be set to the index of a field in the fields array, but note that it will be converted to a string (field name) after initialization.
		 * Flags: IR, Group: sorting */
		sortField: Array<string> /* String | Array of String | int */;

		/** A set of "special" values such as "All", "None" or "Invalid" that do not appear in the normal ValueMap or in the data returned by the SelectItem.optionDataSource. Like other uses of ValueMap, either a list of values or a mapping from stored to display value can be provided. These values can either be shown at the top of the list of values (in the order specified), or can be shown in a separate, non-scrolling region - the setting SelectItem.separateSpecialValues','separateSpecialValues controls this. Note that data paging can only be used if separateSpecialValues is enabled. If specialValues are configured, SelectItem.allowEmptyValue','allowEmptyValue is ignored - an empty value, if desired, must be included in the specialValues. To provide a specialValue which clears the value of the field, use the special constant PickList.emptyStoredValue. specialValues can also be used to take a value that does appear in the normal data and redundantly display it at the top of the list to make it more accessible. Note that in this case it is expected that the special value appears both at the top of the list and in it's normal position in the list, so this works best with SelectItem.separateSpecialValues','separateSpecialValues mode enabled. Also, if an SelectItem.optionDataSource is used, SelectItem.specialValues that appear in the normal dataset will be updated by automatic cacheSync','cache synchronization (if the SelectItem.displayField is updated). However when using a distinct SelectItem.valueField and SelectItem.displayField, you are required to provide SelectItem.specialValues as a map (there is no support for FormItem.fetchMissingValues','fetchMissingValues automatically fetching appropriate display values). Note that specialValues are not supported in conjunction with MultiComboBoxItem. Whereas with SelectItem.multiple','selectItem.multiple:true, specialValues will never be normal values that may be selected. So, specialValues should have options such as "Select All", "Select None" and others.
		 * Flags: IR */
		specialValues: ValueMap;

		/** Base CSS class name for a form item's text box element. See formItemStyling for an overview of formItem styling, and the CompoundFormItem_skinning discussion for special skinning considerations. If the textBoxStyle is changed at runtime, FormItem.updateState','updateState() must be called to update the visual state of this item.
		 * Flags: IRW, Group: appearance */
		textBoxStyle: string /* FormItemBaseStyle */;

		/** When applying filter criteria to pickList data, what type of matching to use. For a databound pickList (SelectItem.optionDataSource set), textMatchStyle is sent to the server as DSRequest.textMatchStyle. For a non-databound pickList, textMatchStyle is applied by PickList.filterClientPickListData','filterClientPickListData().
		 * Flags: IR */
		textMatchStyle: TextMatchStyle;

		/** If FormItem.showOver is true, setting this property to false will explicitly disable showing the "Over" state for the control table element of this item (if present).
		 * Flags: IRWA, Group: formItemStyling */
		updateControlOnOver: boolean /* Boolean */;

		/** If FormItem.showOver is true, setting this property to false will explicitly disable showing the "Over" state for the TextBox element of this item.
		 * Flags: IRWA, Group: formItemStyling */
		updateTextBoxOnOver: boolean /* Boolean */;

		/** For SelectItem.optionDataSource','databound items, this property will be passed to the generated ResultSet data object for the pickList as ResultSet.useClientFiltering. Setting to false will disable filtering on the client and ensure criteria are always passed to the DataSource directly.
		 * Flags: IRA */
		useClientFiltering: boolean /* Boolean */;

		/** If this form item maps data values to display values by retrieving the FormItem.displayField values from an FormItem.optionDataSource','optionDataSource, this property denotes the the field to use as the underlying data value in records from the optionDataSource. If not explicitly supplied, the valueField name will be derived as described in FormItem.getValueFieldName.
		 * Flags: IRW, Group: databinding */
		valueField: string;


		/* Instance Method Overrides */

		/** 
		 * Only applies to databound items (see PickList.optionDataSource). Performs a fetch type operation on this item's DataSource to retrieve the set of valid options for the item, based on the current PickList.pickListCriteria.
		 * @param {DSCallback} callback - Callback to fire when the fetch completes. Callback will fire with 4 parameters: item a pointer to the form item dsResponse the DSResponse returned by the server data the raw data returned by the server dsRequest the DSRequest sent to the server 
		 * @param {DSRequestProps} requestProperties - properties to apply to the dsRequest for this fetch.
		 */
		fetchData?(callback?:DSCallback, requestProperties?:DSRequestProps /* DSRequest properties */): void; 

		/** 
		 * For a SelectItem with an SelectItem.optionDataSource and allowing multiple selection (SelectItem.multiple','via multiple:true), returns the list of currently selected records, or null if none are selected. 
		 */
		getSelectedRecords?(): Array<ListGridRecord> /* Array of ListGridRecord */; 

	} // SelectItem

	export interface SelectItemStatic<T, P> extends FormItemStatic<T, P> {
	} // SelectItemStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a ServerObject Props argument.
	 * This is derived from the methods in the ServerObject class and it's parents and their properties marked with the I flag.
	 */
	export interface ServerObjectProps  {
		/** Specifies the name of the attribute by which to look up the DMI instance. This attribute is consulted only when the value of ServerObject.lookupStyle is "attribute".
		 * Flags: IR */
		attributeName?: string /* String */; // Flags=IR
		/** Specifies the scope in which the DMI instance is to be looked up. Valid values are: "request", "session", and "application". If attributeScope is left out of the ServerObject definition, then all scopes are searched in the order in which they are listed above. This attribute is consulted only when the value of ServerObject.lookupStyle is "attribute".
		 * Flags: IR */
		attributeScope?: "request"|"session"|"application"; // Flags=IR
		/** For use when ServerObject.lookupStyle is "spring" or "cdi", id (name) of the bean to ask Spring (CDI) to create.
		 * Flags: IR */
		bean?: string /* String */; // Flags=IR
		/** Specifies the fully-qualified class name that provides the server-side endpoint of the DMI (ServerObject.lookupStyle:"new") or the class name of the factory that produces the DMI instance (ServerObject.lookupStyle:"factory"). This is one of the values that you need to pass to DMI.call to invoke the DMI from the client. The value of this attribute is used for "new" and "factory" values of ServerObject.lookupStyle. It is also used for "cdi" value of ServerObject.lookupStyle, to provide class name of the bean to ask CDI to create.
		 * Flags: IR */
		className?: string /* String */; // Flags=IR
		/** For a ServerObject defined at the DataSource.serverObject','DataSource level, by default we only allow it to intercept standard CRUD operations (ie, ordinary fetches, adds, updates and removes). To allow the ServerObject to intercept other types of operation - custom operations, validations, etc - set this property to false. Note that ServerObjects declared at the OperationBinding.serverObject','OperationBinding level always intercept that operation, whatever its type, and this property has no effect. NOTE: If you are intercepting operations on the server because you wish to inspect them before deciding whether to process them with bespoke code or allow them to proceed with normal processing, the way to invoke normal processing without causing any interference is: return dsRequest.execute(); 
		 * Flags: IR */
		crudOnly?: boolean; // Flags=IR
		/** By default, for DMI DSResponses, DSResponse.data is filtered on the server to just the set of fields defined on the DataSource. This behavior can be overridden in several ways - see the overview in dmiOverview','DMI for details. The value of this attribute overrides DataSource.dropExtraFields.
		 * Flags: IR */
		dropExtraFields?: boolean /* Boolean */; // Flags=IR
		/** You can optionally specify an ID on the ServerObject config block - in which case you can use that value as the "className" argument when calling DMI.call. This allows you to hide the name of the server-side class used as the factory or implementer of the DMI from the browser as a security precaution.
		 * Flags: IR */
		ID?: string /* String */; // Flags=IR
		/** Specifies the mechanism for locating the class instance on which to invoke the method. Valid values are as follows: "spring": For use with the <a href='http://springframework.com' target='_blank'>Spring framework</a>. ServerObject.bean contains the name of the bean to invoke. Which application context is used can be configured via web.xml (see the example web.xml in the SDK). See also serverInit for special concerns with framework initialization when using Spring. "cdi": For use with <a href='http://docs.oracle.com/javaee/6/tutorial/doc/giwhb.html' target='_blank'>CDI (Contexts and Dependency Injection)</a>. Use ServerObject.bean to configure the name of the bean to invoke or, alternatively, ServerObject.className to configure its class name. "new": A new instance of the class specified by ServerObject.className will be created and the DMI method will be invoked on that instance (unless the specified method is static, in which case no instance is created, but the class specified by ServerObject.className is still used). "factory": A custom factory provides the class instance on which the DMI method is to be invoked. In this case, ServerObject.className specifies the className of the factory that will provide the instance on which the DMI method is to be invoked. The class specified by ServerObject.className must provide exactly one method named create that must return the class instance on which you wish the DMI method to be invoked. Like the DMI methods, the create method can request a standard set of values as arguments. See dmiOverview','DMI for a list of available values. "attribute": The instance on which the DMI method is to be invoked is looked up in the scope defined by ServerObject.attributeScope via the attribute name specified in ServerObject.attributeName. 
		 * Flags: IR */
		lookupStyle?: "new"|"factory"|"attribute"|"spring"|"cdi"; // Flags=IR
		/** Specifies the name of the method to call for operations using this ServerObject. This is a DataSource-level default; you can override it for individual operations either by specifying the OperationBinding.serverMethod attribute, or by declaring an operation-level serverObject that specifies a different methodName (if you specify both an operationBinding.serverMethod and an operation-level serverObject.methodName, the latter takes precedence)
		 * Flags: IR */
		methodName?: string /* String */; // Flags=IR
		/** If set, the SmartClient server will use JXPath to call your server code. The JXPathContext (start point) will be the object arrived at by applying the ServerObject.lookupStyle','lookupStyle and related ServerObject properties. The intention of this property is to allow easier access to your existing Java objects and reduce the need to write SmartClient-specific server code.
		 * Flags: IR */
		targetXPath?: string /* String */; // Flags=IR
		/** When the ServerObject appears in a .app.xml file (for RPC DMI), this property specifies the list of methods on the ServerObject that are callable from the client. See the builtin.app.xml file in the /shared/app directory of the SDK for an example of a visibleMethods declaration block.
		 * Flags: IR */
		visibleMethods?: any /* List */; // Flags=IR
	} // ServerObjectProps


	/**
	 * The ServerObject tells the ISC server how to find or create a server-side object involved in dmiOverview','DMI (Direct Method Invocation). A ServerObject declaration appears in the XML definition of a DataSource (for responding to DSRequests) or in an Application configuration file (.app.xml) for responding to RPCRequests. NOTE: Please take note of the points made in serverDataSourceImplementation','this discussion of caching and thread-safety issues in server-side DataSources. 
	 */
	export interface ServerObject  {
		/** Specifies the name of the attribute by which to look up the DMI instance. This attribute is consulted only when the value of ServerObject.lookupStyle is "attribute".
		 * Flags: IR */
		attributeName: string /* String */;

		/** Specifies the scope in which the DMI instance is to be looked up. Valid values are: "request", "session", and "application". If attributeScope is left out of the ServerObject definition, then all scopes are searched in the order in which they are listed above. This attribute is consulted only when the value of ServerObject.lookupStyle is "attribute".
		 * Flags: IR */
		attributeScope: "request"|"session"|"application";

		/** For use when ServerObject.lookupStyle is "spring" or "cdi", id (name) of the bean to ask Spring (CDI) to create.
		 * Flags: IR */
		bean: string /* String */;

		/** Specifies the fully-qualified class name that provides the server-side endpoint of the DMI (ServerObject.lookupStyle:"new") or the class name of the factory that produces the DMI instance (ServerObject.lookupStyle:"factory"). This is one of the values that you need to pass to DMI.call to invoke the DMI from the client. The value of this attribute is used for "new" and "factory" values of ServerObject.lookupStyle. It is also used for "cdi" value of ServerObject.lookupStyle, to provide class name of the bean to ask CDI to create.
		 * Flags: IR */
		className: string /* String */;

		/** For a ServerObject defined at the DataSource.serverObject','DataSource level, by default we only allow it to intercept standard CRUD operations (ie, ordinary fetches, adds, updates and removes). To allow the ServerObject to intercept other types of operation - custom operations, validations, etc - set this property to false. Note that ServerObjects declared at the OperationBinding.serverObject','OperationBinding level always intercept that operation, whatever its type, and this property has no effect. NOTE: If you are intercepting operations on the server because you wish to inspect them before deciding whether to process them with bespoke code or allow them to proceed with normal processing, the way to invoke normal processing without causing any interference is: return dsRequest.execute(); 
		 * Flags: IR */
		crudOnly: boolean;

		/** By default, for DMI DSResponses, DSResponse.data is filtered on the server to just the set of fields defined on the DataSource. This behavior can be overridden in several ways - see the overview in dmiOverview','DMI for details. The value of this attribute overrides DataSource.dropExtraFields.
		 * Flags: IR */
		dropExtraFields: boolean /* Boolean */;

		/** You can optionally specify an ID on the ServerObject config block - in which case you can use that value as the "className" argument when calling DMI.call. This allows you to hide the name of the server-side class used as the factory or implementer of the DMI from the browser as a security precaution.
		 * Flags: IR */
		ID: string /* String */;

		/** Specifies the mechanism for locating the class instance on which to invoke the method. Valid values are as follows: "spring": For use with the <a href='http://springframework.com' target='_blank'>Spring framework</a>. ServerObject.bean contains the name of the bean to invoke. Which application context is used can be configured via web.xml (see the example web.xml in the SDK). See also serverInit for special concerns with framework initialization when using Spring. "cdi": For use with <a href='http://docs.oracle.com/javaee/6/tutorial/doc/giwhb.html' target='_blank'>CDI (Contexts and Dependency Injection)</a>. Use ServerObject.bean to configure the name of the bean to invoke or, alternatively, ServerObject.className to configure its class name. "new": A new instance of the class specified by ServerObject.className will be created and the DMI method will be invoked on that instance (unless the specified method is static, in which case no instance is created, but the class specified by ServerObject.className is still used). "factory": A custom factory provides the class instance on which the DMI method is to be invoked. In this case, ServerObject.className specifies the className of the factory that will provide the instance on which the DMI method is to be invoked. The class specified by ServerObject.className must provide exactly one method named create that must return the class instance on which you wish the DMI method to be invoked. Like the DMI methods, the create method can request a standard set of values as arguments. See dmiOverview','DMI for a list of available values. "attribute": The instance on which the DMI method is to be invoked is looked up in the scope defined by ServerObject.attributeScope via the attribute name specified in ServerObject.attributeName. 
		 * Flags: IR */
		lookupStyle: "new"|"factory"|"attribute"|"spring"|"cdi";

		/** Specifies the name of the method to call for operations using this ServerObject. This is a DataSource-level default; you can override it for individual operations either by specifying the OperationBinding.serverMethod attribute, or by declaring an operation-level serverObject that specifies a different methodName (if you specify both an operationBinding.serverMethod and an operation-level serverObject.methodName, the latter takes precedence)
		 * Flags: IR */
		methodName: string /* String */;

		/** If set, the SmartClient server will use JXPath to call your server code. The JXPathContext (start point) will be the object arrived at by applying the ServerObject.lookupStyle','lookupStyle and related ServerObject properties. The intention of this property is to allow easier access to your existing Java objects and reduce the need to write SmartClient-specific server code.
		 * Flags: IR */
		targetXPath: string /* String */;

		/** When the ServerObject appears in a .app.xml file (for RPC DMI), this property specifies the list of methods on the ServerObject that are callable from the client. See the builtin.app.xml file in the /shared/app directory of the SDK for an example of a visibleMethods declaration block.
		 * Flags: IR */
		visibleMethods: any /* List */;

	} // ServerObject

	export interface ServerObjectStatic<T, P> extends ClassStatic<T, P> {
	} // ServerObjectStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a Splitbar Props argument.
	 * This is derived from the methods in the Splitbar class and it's parents and their properties marked with the I flag.
	 */
	export interface SplitbarProps  {
		/** If this property is true, a click on the Splitbar will collapse its Splitbar.target','target, hiding it and shifting the Splitbar and other members of the layout across to fill the newly available space. If the target is already hidden a click will expand it again (showing it at its normal size). Note that on touch devices, to enable collapsing/uncollapsing the target in response to a tap, Splitbar.canCollapseOnTap','canCollapseOnTap must be set to true.
		 * Flags: IRW */
		canCollapse?: boolean; // Flags=IRW
		/** If Splitbar.canCollapse','canCollapse is true, should a tap result in collapsing/uncollapsing the Splitbar.target','target? By default this is false because it can be difficult to tap a thin Splitbar. If this property is set to true, it is recommended to increase the width/height of the Splitbar on touch devices (see, e.g., Layout.resizeBarSize).
		 * Flags: IRW */
		canCollapseOnTap?: boolean; // Flags=IRW
		/** canDrag set to true to allow dragging of the split bar. Dragging the Splitbar will resize it's Splitbar.target','target
		 * Flags: IRW */
		canDrag?: boolean /* Boolean */; // Flags=IRW
		/** If the default items are used, capSize is the size in pixels of the first and last images in this stretchImg.
		 * Flags: IR, Group: appearance */
		capSize?: number /* integer */; // Flags=IR
		/** Splitbars' cursors are set at init time based on whether they are to be used for vertical or horizontal resize. To customize the cursor for this class, modify Splitbar.vResizeCursor or Splitbar.hResizeCursor rather than this property.
		 * Flags: IRW, Group: cursor */
		cursor?: Cursor; // Flags=IRW
		/** Suffix used the 'grip' image if StretchImg.showGrip is true.
		 * Flags: IRA, Group: grip */
		gripImgSuffix?: string; // Flags=IRA
		/** Cursor to display if this Splitbar is to be used for horizontal resize of widgets.
		 * Flags: IR, Group: cursor */
		hResizeCursor?: Cursor; // Flags=IR
		/** Base URL for the image if StretchImg.vertical is false and StretchImg.src is unset.
		 * Flags: IR, Group: appearance */
		hSrc?: string /* SCImgURL */; // Flags=IR
		/** If Splitbar.showClosedGrip is true, and Splitbar.targetAfter is true should we show the "closed" state for the grip when the target is visible (rather than when it is hidden). This property is useful for the case where the grip media is a simple directional arrow. The same image can be used for expanded state on one side of the bar or collapsed state on the other.
		 * Flags: IRWA, Group: grip */
		invertClosedGripIfTargetAfter?: boolean; // Flags=IRWA
		/** If Splitbar.showGrip is true, this property determines whether the grip image displayed should show the "Closed" state when the Splitbar.target is hidden. Note that if Splitbar.invertClosedGripIfTargetAfter is true, we may show the "closed" state when the target is visible, rather than when it is hidden.
		 * Flags: IRA, Group: grip */
		showClosedGrip?: boolean /* Boolean */; // Flags=IRA
		/** If StretchImg.showGrip is true, this property determines whether to show the 'Down' state on the grip image when the user mousedown's on this widget. Has no effect if StatefulCanvas.showDown is false.
		 * Flags: IRA, Group: grip */
		showDownGrip?: boolean /* Boolean */; // Flags=IRA
		/** Should we show a "grip" image floating above the center of this widget?
		 * Flags: IRA, Group: grip */
		showGrip?: boolean /* Boolean */; // Flags=IRA
		/** If StretchImg.showGrip is true, this property determines whether to show the 'Over' state on the grip image when the user rolls over on this widget. Has no effect if StatefulCanvas.showRollOver is false.
		 * Flags: IRA, Group: grip */
		showRollOverGrip?: boolean /* Boolean */; // Flags=IRA
		/** Default directory for skin images (those defined by the class), relative to the Page-wide Page.getSkinDir','skinDir.
		 * Flags: IR, Group: images */
		skinImgDir?: string; // Flags=IR
		/** The base URL for the image. The State for the component will be combined with this URL using the same approach as described in Img.src. Then the image segment StretchItem.name','name as specified by each StretchItem is added. For example, for a stretchImg in "Over" state with a src of "button.png" and a segment name of "stretch", the resulting URL would be "button_Over_stretch.png".
		 * Flags: IR, Group: appearance */
		src?: string /* SCImgURL */; // Flags=IR
		/** Is the Splitbar.target being shown before or after the bar? This property is automatically populated for splitbars created by a layout.
		 * Flags: IRWA */
		targetAfter?: boolean /* Boolean */; // Flags=IRWA
		/** Cursor to display if this Splitbar is to be used for vertical resize of widgets.
		 * Flags: IR, Group: cursor */
		vResizeCursor?: Cursor; // Flags=IR
		/** Base URL for the image if StretchImg.vertical is true and StretchImg.src is unset.
		 * Flags: IR, Group: appearance */
		vSrc?: string /* SCImgURL */; // Flags=IR
	} // SplitbarProps


	/**
	 * Resize bar for use in Layout.resizeBarClass','Layouts, based on the StretchImg class. As with the ImgSplitbar class, widgets of this class can be displayed as a resize-bar for widgets in Layouts where showResizeBar is set to true. Provides a different appearance from the ImgSplitbar class. To specify the resizeBar class for some layout, use the Layout.resizeBarClass property. 
	 */
	export interface Splitbar  {
		/** If this property is true, a click on the Splitbar will collapse its Splitbar.target','target, hiding it and shifting the Splitbar and other members of the layout across to fill the newly available space. If the target is already hidden a click will expand it again (showing it at its normal size). Note that on touch devices, to enable collapsing/uncollapsing the target in response to a tap, Splitbar.canCollapseOnTap','canCollapseOnTap must be set to true.
		 * Flags: IRW */
		canCollapse: boolean;

		/** If Splitbar.canCollapse','canCollapse is true, should a tap result in collapsing/uncollapsing the Splitbar.target','target? By default this is false because it can be difficult to tap a thin Splitbar. If this property is set to true, it is recommended to increase the width/height of the Splitbar on touch devices (see, e.g., Layout.resizeBarSize).
		 * Flags: IRW */
		canCollapseOnTap: boolean;

		/** canDrag set to true to allow dragging of the split bar. Dragging the Splitbar will resize it's Splitbar.target','target
		 * Flags: IRW */
		canDrag: boolean /* Boolean */;

		/** If the default items are used, capSize is the size in pixels of the first and last images in this stretchImg.
		 * Flags: IR, Group: appearance */
		capSize: number /* integer */;

		/** Splitbars' cursors are set at init time based on whether they are to be used for vertical or horizontal resize. To customize the cursor for this class, modify Splitbar.vResizeCursor or Splitbar.hResizeCursor rather than this property.
		 * Flags: IRW, Group: cursor */
		cursor: Cursor;

		/** Suffix used the 'grip' image if StretchImg.showGrip is true.
		 * Flags: IRA, Group: grip */
		gripImgSuffix: string;

		/** Cursor to display if this Splitbar is to be used for horizontal resize of widgets.
		 * Flags: IR, Group: cursor */
		hResizeCursor: Cursor;

		/** Base URL for the image if StretchImg.vertical is false and StretchImg.src is unset.
		 * Flags: IR, Group: appearance */
		hSrc: string /* SCImgURL */;

		/** If Splitbar.showClosedGrip is true, and Splitbar.targetAfter is true should we show the "closed" state for the grip when the target is visible (rather than when it is hidden). This property is useful for the case where the grip media is a simple directional arrow. The same image can be used for expanded state on one side of the bar or collapsed state on the other.
		 * Flags: IRWA, Group: grip */
		invertClosedGripIfTargetAfter: boolean;

		/** If Splitbar.showGrip is true, this property determines whether the grip image displayed should show the "Closed" state when the Splitbar.target is hidden. Note that if Splitbar.invertClosedGripIfTargetAfter is true, we may show the "closed" state when the target is visible, rather than when it is hidden.
		 * Flags: IRA, Group: grip */
		showClosedGrip: boolean /* Boolean */;

		/** If StretchImg.showGrip is true, this property determines whether to show the 'Down' state on the grip image when the user mousedown's on this widget. Has no effect if StatefulCanvas.showDown is false.
		 * Flags: IRA, Group: grip */
		showDownGrip: boolean /* Boolean */;

		/** Should we show a "grip" image floating above the center of this widget?
		 * Flags: IRA, Group: grip */
		showGrip: boolean /* Boolean */;

		/** If StretchImg.showGrip is true, this property determines whether to show the 'Over' state on the grip image when the user rolls over on this widget. Has no effect if StatefulCanvas.showRollOver is false.
		 * Flags: IRA, Group: grip */
		showRollOverGrip: boolean /* Boolean */;

		/** Default directory for skin images (those defined by the class), relative to the Page-wide Page.getSkinDir','skinDir.
		 * Flags: IR, Group: images */
		skinImgDir: string;

		/** The base URL for the image. The State for the component will be combined with this URL using the same approach as described in Img.src. Then the image segment StretchItem.name','name as specified by each StretchItem is added. For example, for a stretchImg in "Over" state with a src of "button.png" and a segment name of "stretch", the resulting URL would be "button_Over_stretch.png".
		 * Flags: IR, Group: appearance */
		src: string /* SCImgURL */;

		/** When a Splitbar is created by a layout, the target property of the Splitbar will be a pointer to the member for which it is acting as a resizeBar. The Splitbar will be positioned next to its target, and will resize it on drag completion. See Layout.resizeBarClass, Canvas.showResizeBar and Canvas.resizeBarTarget for details on configuring the resize bars shown in Layouts.
		 * Flags: R */
		target: Canvas;

		/** Is the Splitbar.target being shown before or after the bar? This property is automatically populated for splitbars created by a layout.
		 * Flags: IRWA */
		targetAfter: boolean /* Boolean */;

		/** Is this split bar vertically orientated? When a Splitbar is created by a layout to be the resizeBar for some member of the layout, the vertical property will be set to true if the layout is horizontal, meaning this resizeBar will be taller than it is wide, and will allow horizontal resizing of the member.
		 * Flags: R */
		vertical: boolean;

		/** Cursor to display if this Splitbar is to be used for vertical resize of widgets.
		 * Flags: IR, Group: cursor */
		vResizeCursor: Cursor;

		/** Base URL for the image if StretchImg.vertical is true and StretchImg.src is unset.
		 * Flags: IR, Group: appearance */
		vSrc: string /* SCImgURL */;

	} // Splitbar

	export interface SplitbarStatic<T, P> extends ClassStatic<T, P> {
	} // SplitbarStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a StatefulCanvas Props argument.
	 * This is derived from the methods in the StatefulCanvas class and it's parents and their properties marked with the I flag.
	 */
	export interface StatefulCanvasProps extends CanvasProps {
		/** Behavior on state changes -- BUTTON, RADIO or CHECKBOX
		 * Flags: IRW, Group: state */
		actionType?: SelectionType; // Flags=IRW
		/** Horizontal alignment of this component's title.
		 * Flags: IRW, Group: appearance */
		align?: Alignment; // Flags=IRW
		/** If true, ignore the specified size of this widget and always size just large enough to accommodate the title. If setWidth() is explicitly called on an autoFit:true button, autoFit will be reset to false. Note that for StretchImgButton instances, autoFit will occur horizontally only, as unpredictable vertical sizing is likely to distort the media. If you do want vertical auto-fit, this can be achieved by simply setting a small height, and having overflow:"visible"
		 * Flags: IRW, Group: sizing */
		autoFit?: boolean; // Flags=IRW
		/** Base CSS style className applied to the component. As the component changes StatefulCanvas.state and/or is selected, suffixes will be added to the base style. In some cases more than one suffix will be appended to reflect a combined state ("Selected" + "Disabled", for example). See StatefulCanvas.getStateSuffix for a description of the default set of suffixes which may be applied to the baseStyle
		 * Flags: IRW */
		baseStyle?: string /* CSSStyleName */; // Flags=IRW
		/** Default class used to construct the EditProxy for this component when the component is Canvas.setEditMode','first placed into edit mode.
		 * Flags: IR */
		editProxyConstructor?: string /* SCClassName */; // Flags=IR
		/** Optional icon to be shown with the button title text. Specify as the partial URL to an image, relative to the imgDir of this component. Note that the string "blank" is a valid setting for this attribute and will always result in the system blank image, with no state suffixes applied. Typically, this might be used when an iconStyle is also specified and the iconStyle renders the icon via a stateful background-image or other CSS approach.
		 * Flags: IRW, Group: buttonIcon */
		icon?: string /* SCImgURL */; // Flags=IRW
		/** Height in pixels of the icon image. If unset, defaults to StatefulCanvas.iconSize','iconSize.
		 * Flags: IR, Group: buttonIcon */
		iconHeight?: number /* integer */; // Flags=IR
		/** If this button is showing an icon should it appear to the left or right of the title? valid options are "left" and "right".
		 * Flags: IR, Group: buttonIcon */
		iconOrientation?: string; // Flags=IR
		/** Size in pixels of the icon image. The StatefulCanvas.iconWidth','iconWidth and StatefulCanvas.iconHeight','iconHeight properties can be used to configure width and height separately. Note: When configuring the properties of a StatefulCanvas (or derivative) AutoChild','AutoChild, it is best to set the iconWidth and iconHeight to the same value rather than setting an iconSize. This is because certain skins or customizations thereto might set the iconWidth and iconHeight, making the customization of the AutoChild's iconSize ineffective.
		 * Flags: IR, Group: buttonIcon */
		iconSize?: number /* int */; // Flags=IR
		/** Pixels between icon and title text.
		 * Flags: IR, Group: buttonIcon */
		iconSpacing?: number /* int */; // Flags=IR
		/** Base CSS style applied to the icon image. If set, as the StatefulCanvas changes StatefulCanvas.state','state and/or is StatefulCanvas.selected','selected, suffixes will be appended to iconStyle to form the className set on the image element. The following table lists out the standard set of suffixes which may be appended: <table border=1> <tr><th>CSS Class Applied</th><th>Description</th></tr> <tr><td>iconStyle</td><td>Default CSS style</td></tr> <tr><td>iconStyle+Selected</td> <td>Applied when StatefulCanvas.selected and StatefulCanvas.showSelectedIcon are true.</td></tr> <tr><td>iconStyle+Focused</td> <td>Applied when the component has keyboard focus, if StatefulCanvas.showFocusedIcon is true, and StatefulCanvas.showFocusedAsOver is not true.</td></tr> <tr><td>iconStyle+Over</td> <td>Applied when StatefulCanvas.showRollOverIcon is set to true and either the user rolls over the component or StatefulCanvas.showFocusedAsOver is true and the component has keyboard focus.</td></tr> <tr><td>iconStyle+Down</td> <td>Applied when the user presses the mouse button on the component if StatefulCanvas.showDownIcon is set to true</td></tr> <tr><td>iconStyle+Disabled</td> <td>Applied when the component is Canvas.disabled','disabled if StatefulCanvas.showDisabledIcon is true.</td></tr> <tr><td colspan=2>Combined styles</td></tr> <tr><td>iconStyle+SelectedFocused</td> <td>Combined Selected and focused styling</td></tr> <tr><td>iconStyle+SelectedOver</td> <td>Combined Selected and rollOver styling</td></tr> <tr><td>iconStyle+FocusedOver</td> <td>Combined Focused and rollOver styling</td></tr> <tr><td>iconStyle+SelectedFocusedOver</td> <td>Combined Selected, Focused and rollOver styling</td></tr> <tr><td>iconStyle+SelectedDown</td> <td>Combined Selected and mouse-down styling</td></tr> <tr><td>iconStyle+FocusedDown</td> <td>Combined Focused and mouse-down styling</td></tr> <tr><td>iconStyle+SelectedFocusedDown</td> <td>Combined Selected, Focused and mouse-down styling</td></tr> <tr><td>iconStyle+SelectedDisabled</td> <td>Combined Selected and Disabled styling</td></tr> </table> In addition, if StatefulCanvas.showRTLIcon is true, then in RTL mode, a final "RTL" suffix will be appended.
		 * Flags: IRW, Group: buttonIcon */
		iconStyle?: string /* CSSStyleName */; // Flags=IRW
		/** Width in pixels of the icon image. If unset, defaults to StatefulCanvas.iconSize','iconSize.
		 * Flags: IR, Group: buttonIcon */
		iconWidth?: number /* integer */; // Flags=IR
		/** Should horizontal alignment-related attributes StatefulCanvas.align','align and StatefulCanvas.iconOrientation','iconOrientation be mirrored in RTL mode? This is the default behavior unless ignoreRTL is set to true.
		 * Flags: IRWA, Group: RTL */
		ignoreRTL?: boolean; // Flags=IRWA
		/** Constructor class name for this widget's StatefulCanvas.overCanvas','overCanvas
		 * Flags: IRWA */
		overCanvasConstructor?: string /* String */; // Flags=IRWA
		/** Default properties for this widgets StatefulCanvas.overCanvas','overCanvas. To modify these defaults, use Class.changeDefaults
		 * Flags: IRWA */
		overCanvasDefaults?: Canvas; // Flags=IRWA
		/** String identifier for this canvas's mutually exclusive selection group.
		 * Flags: IRWA, Group: state */
		radioGroup?: string; // Flags=IRWA
		/** Whether this widget needs to redraw to reflect state change
		 * Flags: IRWA, Group: state */
		redrawOnStateChange?: boolean /* Boolean */; // Flags=IRWA
		/** Whether this component is selected. For some components, selection affects appearance.
		 * Flags: IRW, Group: state */
		selected?: boolean /* Boolean */; // Flags=IRW
		/** Should we visibly change state when disabled?
		 * Flags: IRW, Group: state */
		showDisabled?: boolean /* Boolean */; // Flags=IRW
		/** If using an icon for this button, whether to switch the icon image if the button becomes disabled.
		 * Flags: IR, Group: buttonIcon */
		showDisabledIcon?: boolean /* Boolean */; // Flags=IR
		/** Should we visibly change state when the mouse goes down in this object?
		 * Flags: IRW, Group: state */
		showDown?: boolean /* Boolean */; // Flags=IRW
		/** If using an icon for this button, whether to switch the icon image when the mouse goes down on the button.
		 * Flags: IR, Group: buttonIcon */
		showDownIcon?: boolean /* Boolean */; // Flags=IR
		/** Should we visibly change state when the canvas receives focus? If StatefulCanvas.showFocusedAsOver is true, then "over" will be used to indicate focus. Otherwise a separate "focused" state will be used.
		 * Flags: IRW, Group: state */
		showFocused?: boolean /* Boolean */; // Flags=IRW
		/** If StatefulCanvas.showFocused','showFocused is true for this widget, should the "over" state be used to indicate the widget as focused. If set to false, a separate "focused" state will be used.
		 * Flags: IRW, Group: state */
		showFocusedAsOver?: boolean /* Boolean */; // Flags=IRW
		/** If using an icon for this button, whether to switch the icon image when the button receives focus. If StatefulCanvas.showFocusedAsOver is true, the "Over" icon will be displayed when the canvas has focus, otherwise a separate "Focused" icon will be displayed
		 * Flags: IR, Group: buttonIcon */
		showFocusedIcon?: boolean /* Boolean */; // Flags=IR
		/** When this property is set to true, this widget will create and show the StatefulCanvas.overCanvas on user rollover.
		 * Flags: IRWA */
		showOverCanvas?: boolean /* Boolean */; // Flags=IRWA
		/** Should we visibly change state when the mouse goes over this object?
		 * Flags: IRW, Group: state */
		showRollOver?: boolean /* Boolean */; // Flags=IRW
		/** If using an icon for this button, whether to switch the icon image on mouse rollover.
		 * Flags: IR, Group: buttonIcon */
		showRollOverIcon?: boolean /* Boolean */; // Flags=IR
		/** Is Page.isRTL','RTL media available for the icon? If true, then in RTL mode, the image's src will have "_rtl" inserted immediately before the file extension. For example, if StatefulCanvas.icon','icon is "myIcon.png" and showRTLIcon is true, then in RTL mode, the image's src will be set to "myIcon_rtl.png".
		 * Flags: IR, Group: RTL */
		showRTLIcon?: boolean; // Flags=IR
		/** If using an icon for this button, whether to switch the icon image when the button becomes selected.
		 * Flags: IR, Group: buttonIcon */
		showSelectedIcon?: boolean /* Boolean */; // Flags=IR
		/** Current "state" of this widget. The state setting is automatically updated as the user interacts with the component (see StatefulCanvas.showRollOver, StatefulCanvas.showDown, StatefulCanvas.showDisabled). StatefulCanvases will have a different appearance based on their current state. By default this is handled by changing the css className applied to the StatefulCanvas - see StatefulCanvas.baseStyle and StatefulCanvas.getStateSuffix for a description of how this is done. For Img or StretchImg based subclasses of StatefulCanvas, the appearance may also be updated by changing the src of the rendered image. See Img.src and StretchImgButton.src for a description of how the URL is modified to reflect the state of the widget in this case.
		 * Flags: IRWA, Group: state */
		state?: State; // Flags=IRWA
		/** The title HTML to display in this button.
		 * Flags: IRW, Group: basics */
		title?: string /* HTMLString */; // Flags=IRW
		/** Vertical alignment of this component's title.
		 * Flags: IRW, Group: appearance */
		valign?: VerticalAlignment; // Flags=IRW

		/* Method Overrides */

	} // StatefulCanvasProps


	/**
	 * A component that has a set of possible states, and which presents itself differently according to which state it is in. An example is a button, which can be "up", "down", "over" or "disabled". 
	 */
	export interface StatefulCanvas extends Canvas {
		/** Behavior on state changes -- BUTTON, RADIO or CHECKBOX
		 * Flags: IRW, Group: state */
		actionType: SelectionType;

		/** Horizontal alignment of this component's title.
		 * Flags: IRW, Group: appearance */
		align: Alignment;

		/** If true, ignore the specified size of this widget and always size just large enough to accommodate the title. If setWidth() is explicitly called on an autoFit:true button, autoFit will be reset to false. Note that for StretchImgButton instances, autoFit will occur horizontally only, as unpredictable vertical sizing is likely to distort the media. If you do want vertical auto-fit, this can be achieved by simply setting a small height, and having overflow:"visible"
		 * Flags: IRW, Group: sizing */
		autoFit: boolean;

		/** Base CSS style className applied to the component. As the component changes StatefulCanvas.state and/or is selected, suffixes will be added to the base style. In some cases more than one suffix will be appended to reflect a combined state ("Selected" + "Disabled", for example). See StatefulCanvas.getStateSuffix for a description of the default set of suffixes which may be applied to the baseStyle
		 * Flags: IRW */
		baseStyle: string /* CSSStyleName */;

		/** Default class used to construct the EditProxy for this component when the component is Canvas.setEditMode','first placed into edit mode.
		 * Flags: IR */
		editProxyConstructor: string /* SCClassName */;

		/** Optional icon to be shown with the button title text. Specify as the partial URL to an image, relative to the imgDir of this component. Note that the string "blank" is a valid setting for this attribute and will always result in the system blank image, with no state suffixes applied. Typically, this might be used when an iconStyle is also specified and the iconStyle renders the icon via a stateful background-image or other CSS approach.
		 * Flags: IRW, Group: buttonIcon */
		icon: string /* SCImgURL */;

		/** Height in pixels of the icon image. If unset, defaults to StatefulCanvas.iconSize','iconSize.
		 * Flags: IR, Group: buttonIcon */
		iconHeight: number /* integer */;

		/** If this button is showing an icon should it appear to the left or right of the title? valid options are "left" and "right".
		 * Flags: IR, Group: buttonIcon */
		iconOrientation: string;

		/** Size in pixels of the icon image. The StatefulCanvas.iconWidth','iconWidth and StatefulCanvas.iconHeight','iconHeight properties can be used to configure width and height separately. Note: When configuring the properties of a StatefulCanvas (or derivative) AutoChild','AutoChild, it is best to set the iconWidth and iconHeight to the same value rather than setting an iconSize. This is because certain skins or customizations thereto might set the iconWidth and iconHeight, making the customization of the AutoChild's iconSize ineffective.
		 * Flags: IR, Group: buttonIcon */
		iconSize: number /* int */;

		/** Pixels between icon and title text.
		 * Flags: IR, Group: buttonIcon */
		iconSpacing: number /* int */;

		/** Base CSS style applied to the icon image. If set, as the StatefulCanvas changes StatefulCanvas.state','state and/or is StatefulCanvas.selected','selected, suffixes will be appended to iconStyle to form the className set on the image element. The following table lists out the standard set of suffixes which may be appended: <table border=1> <tr><th>CSS Class Applied</th><th>Description</th></tr> <tr><td>iconStyle</td><td>Default CSS style</td></tr> <tr><td>iconStyle+Selected</td> <td>Applied when StatefulCanvas.selected and StatefulCanvas.showSelectedIcon are true.</td></tr> <tr><td>iconStyle+Focused</td> <td>Applied when the component has keyboard focus, if StatefulCanvas.showFocusedIcon is true, and StatefulCanvas.showFocusedAsOver is not true.</td></tr> <tr><td>iconStyle+Over</td> <td>Applied when StatefulCanvas.showRollOverIcon is set to true and either the user rolls over the component or StatefulCanvas.showFocusedAsOver is true and the component has keyboard focus.</td></tr> <tr><td>iconStyle+Down</td> <td>Applied when the user presses the mouse button on the component if StatefulCanvas.showDownIcon is set to true</td></tr> <tr><td>iconStyle+Disabled</td> <td>Applied when the component is Canvas.disabled','disabled if StatefulCanvas.showDisabledIcon is true.</td></tr> <tr><td colspan=2>Combined styles</td></tr> <tr><td>iconStyle+SelectedFocused</td> <td>Combined Selected and focused styling</td></tr> <tr><td>iconStyle+SelectedOver</td> <td>Combined Selected and rollOver styling</td></tr> <tr><td>iconStyle+FocusedOver</td> <td>Combined Focused and rollOver styling</td></tr> <tr><td>iconStyle+SelectedFocusedOver</td> <td>Combined Selected, Focused and rollOver styling</td></tr> <tr><td>iconStyle+SelectedDown</td> <td>Combined Selected and mouse-down styling</td></tr> <tr><td>iconStyle+FocusedDown</td> <td>Combined Focused and mouse-down styling</td></tr> <tr><td>iconStyle+SelectedFocusedDown</td> <td>Combined Selected, Focused and mouse-down styling</td></tr> <tr><td>iconStyle+SelectedDisabled</td> <td>Combined Selected and Disabled styling</td></tr> </table> In addition, if StatefulCanvas.showRTLIcon is true, then in RTL mode, a final "RTL" suffix will be appended.
		 * Flags: IRW, Group: buttonIcon */
		iconStyle: string /* CSSStyleName */;

		/** Width in pixels of the icon image. If unset, defaults to StatefulCanvas.iconSize','iconSize.
		 * Flags: IR, Group: buttonIcon */
		iconWidth: number /* integer */;

		/** Should horizontal alignment-related attributes StatefulCanvas.align','align and StatefulCanvas.iconOrientation','iconOrientation be mirrored in RTL mode? This is the default behavior unless ignoreRTL is set to true.
		 * Flags: IRWA, Group: RTL */
		ignoreRTL: boolean;

		/** Auto generated child widget to be shown when the user rolls over this canvas if StatefulCanvas.showOverCanvas is true. See documentation for AutoChild for information on how to customize this canvas.
		 * Flags: R */
		overCanvas:  Canvas /* AutoChild Canvas */;

		/** Constructor class name for this widget's StatefulCanvas.overCanvas','overCanvas
		 * Flags: IRWA */
		overCanvasConstructor: string /* String */;

		/** Default properties for this widgets StatefulCanvas.overCanvas','overCanvas. To modify these defaults, use Class.changeDefaults
		 * Flags: IRWA */
		overCanvasDefaults: Canvas;

		/** String identifier for this canvas's mutually exclusive selection group.
		 * Flags: IRWA, Group: state */
		radioGroup: string;

		/** Whether this widget needs to redraw to reflect state change
		 * Flags: IRWA, Group: state */
		redrawOnStateChange: boolean /* Boolean */;

		/** Whether this component is selected. For some components, selection affects appearance.
		 * Flags: IRW, Group: state */
		selected: boolean /* Boolean */;

		/** Should we visibly change state when disabled?
		 * Flags: IRW, Group: state */
		showDisabled: boolean /* Boolean */;

		/** If using an icon for this button, whether to switch the icon image if the button becomes disabled.
		 * Flags: IR, Group: buttonIcon */
		showDisabledIcon: boolean /* Boolean */;

		/** Should we visibly change state when the mouse goes down in this object?
		 * Flags: IRW, Group: state */
		showDown: boolean /* Boolean */;

		/** If using an icon for this button, whether to switch the icon image when the mouse goes down on the button.
		 * Flags: IR, Group: buttonIcon */
		showDownIcon: boolean /* Boolean */;

		/** Should we visibly change state when the canvas receives focus? If StatefulCanvas.showFocusedAsOver is true, then "over" will be used to indicate focus. Otherwise a separate "focused" state will be used.
		 * Flags: IRW, Group: state */
		showFocused: boolean /* Boolean */;

		/** If StatefulCanvas.showFocused','showFocused is true for this widget, should the "over" state be used to indicate the widget as focused. If set to false, a separate "focused" state will be used.
		 * Flags: IRW, Group: state */
		showFocusedAsOver: boolean /* Boolean */;

		/** If using an icon for this button, whether to switch the icon image when the button receives focus. If StatefulCanvas.showFocusedAsOver is true, the "Over" icon will be displayed when the canvas has focus, otherwise a separate "Focused" icon will be displayed
		 * Flags: IR, Group: buttonIcon */
		showFocusedIcon: boolean /* Boolean */;

		/** When this property is set to true, this widget will create and show the StatefulCanvas.overCanvas on user rollover.
		 * Flags: IRWA */
		showOverCanvas: boolean /* Boolean */;

		/** Should we visibly change state when the mouse goes over this object?
		 * Flags: IRW, Group: state */
		showRollOver: boolean /* Boolean */;

		/** If using an icon for this button, whether to switch the icon image on mouse rollover.
		 * Flags: IR, Group: buttonIcon */
		showRollOverIcon: boolean /* Boolean */;

		/** Is Page.isRTL','RTL media available for the icon? If true, then in RTL mode, the image's src will have "_rtl" inserted immediately before the file extension. For example, if StatefulCanvas.icon','icon is "myIcon.png" and showRTLIcon is true, then in RTL mode, the image's src will be set to "myIcon_rtl.png".
		 * Flags: IR, Group: RTL */
		showRTLIcon: boolean;

		/** If using an icon for this button, whether to switch the icon image when the button becomes selected.
		 * Flags: IR, Group: buttonIcon */
		showSelectedIcon: boolean /* Boolean */;

		/** Current "state" of this widget. The state setting is automatically updated as the user interacts with the component (see StatefulCanvas.showRollOver, StatefulCanvas.showDown, StatefulCanvas.showDisabled). StatefulCanvases will have a different appearance based on their current state. By default this is handled by changing the css className applied to the StatefulCanvas - see StatefulCanvas.baseStyle and StatefulCanvas.getStateSuffix for a description of how this is done. For Img or StretchImg based subclasses of StatefulCanvas, the appearance may also be updated by changing the src of the rendered image. See Img.src and StretchImgButton.src for a description of how the URL is modified to reflect the state of the widget in this case.
		 * Flags: IRWA, Group: state */
		state: State;

		/** The title HTML to display in this button.
		 * Flags: IRW, Group: basics */
		title: string /* HTMLString */;

		/** Vertical alignment of this component's title.
		 * Flags: IRW, Group: appearance */
		valign: VerticalAlignment;


		/* Instance Method Overrides */

	} // StatefulCanvas

	export interface StatefulCanvasStatic<T, P> extends CanvasStatic<T, P> {
	} // StatefulCanvasStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a StretchImg Props argument.
	 * This is derived from the methods in the StretchImg class and it's parents and their properties marked with the I flag.
	 */
	export interface StretchImgProps extends StatefulCanvasProps {
		/** If the default items are used, capSize is the size in pixels of the first and last images in this stretchImg.
		 * Flags: IRW, Group: appearance */
		capSize?: number; // Flags=IRW
		/** Suffix used the 'grip' image if StretchImg.showGrip is true.
		 * Flags: IRA, Group: grip */
		gripImgSuffix?: string; // Flags=IRA
		/** Base URL for the image if StretchImg.vertical is false and StretchImg.src is unset.
		 * Flags: IRW, Group: appearance */
		hSrc?: string /* SCImgURL */; // Flags=IRW
		/** Should the StretchImg.items','items for this StretchImg display left-to-right even if this page is displaying Page.isRTL','right to left text? Only has an effect if this StretchImg is horizontal (StretchImg.vertical','vertical is set to false). Having this property set to true is usually desirable for the common pattern of media consisting of fixed size "end caps" and a stretchable center, because it allows the same media to be used for LTR and RTL pages. If set to false, items will be displayed in RTL order for RTL pages.
		 * Flags: IRW, Group: RTL */
		ignoreRTL?: boolean; // Flags=IRW
		/** Indicates whether the image should be tiled/cropped, stretched, or centered when the size of this widget does not match the size of the image. See ImageStyle for details.
		 * Flags: IRW, Group: appearance */
		imageType?: ImageStyle; // Flags=IRW
		/** If specified this css class will be applied to the individual item images within this StretchImg. May be overridden by specifying item-specific base styles to each object in the StretchImg.items','items array. This base style will have standard stateful suffixes appended to indicate the state of this component (as described in StatefulCanvas.baseStyle).
		 * Flags: IRW */
		itemBaseStyle?: string /* CSSStyleName */; // Flags=IRW
		/** The list of images to display as an array of objects specifying the image names and sizes. The StretchItem.name','name is appended as a suffix to the StretchImg.src URL in order to fetch separate media files for each image. Alternatively a StretchItem may specify its own StretchItem.src','src. The StretchItem.height','height and StretchItem.width','width can be set to a number, "*" (remaining space, divided amongst all images that specify "*") or to the name of a property on this StretchImg component, such as "capSize" for the StretchImg.capSize. Height or width is only used for the axis along which images are stacked. For example, if StretchImg.vertical is true, images stack vertically and heights are used to size images on the vertical axis, but all images will have width matching the overall component size. For example, the default setting for items, which is used to produce stretchable buttons and headers with fixed-size endcaps, is as follows: items:[ {height:"capSize", name:"start", width:"capSize"}, {height:"*", name:"stretch", width:"*"}, {height:"capSize", name:"end", width:"capSize"} ] Note that by default horizontal StretchImg instances will always render their items in left-to-right order, even if the page is localized for right-to-left display (see Page.isRTL). This default behavior may be overridden by setting the StretchImg.ignoreRTL flag to false.
		 * Flags: IRW, Group: appearance */
		items?: Array<StretchItem> /* Array of StretchItem */; // Flags=IRW
		/** If StretchImg.showGrip is true, this property determines whether to show the 'Down' state on the grip image when the user mousedown's on this widget. Has no effect if StatefulCanvas.showDown is false.
		 * Flags: IRA, Group: grip */
		showDownGrip?: boolean; // Flags=IRA
		/** Should we show a "grip" image floating above the center of this widget?
		 * Flags: IRA, Group: grip */
		showGrip?: boolean; // Flags=IRA
		/** If StretchImg.showGrip is true, this property determines whether to show the 'Over' state on the grip image when the user rolls over on this widget. Has no effect if StatefulCanvas.showRollOver is false.
		 * Flags: IRA, Group: grip */
		showRollOverGrip?: boolean; // Flags=IRA
		/** Determines whether any specified StatefulCanvas.getTitle','title will be displayed for this component. Applies to Image-based components only, where the title will be rendered out in a label floating over the component
		 * Flags: IRWA */
		showTitle?: boolean /* Boolean */; // Flags=IRWA
		/** The base URL for the image. The State for the component will be combined with this URL using the same approach as described in Img.src. Then the image segment StretchItem.name','name as specified by each StretchItem is added. For example, for a stretchImg in "Over" state with a src of "button.png" and a segment name of "stretch", the resulting URL would be "button_Over_stretch.png".
		 * Flags: IRW, Group: appearance */
		src?: string /* SCImgURL */; // Flags=IRW
		/** Indicates whether the list of images is drawn vertically from top to bottom (true), or horizontally from left to right (false).
		 * Flags: IRW, Group: appearance */
		vertical?: boolean /* Boolean */; // Flags=IRW
		/** Base URL for the image if StretchImg.vertical is true and StretchImg.src is unset.
		 * Flags: IRW, Group: appearance */
		vSrc?: string /* SCImgURL */; // Flags=IRW

		/* Method Overrides */

	} // StretchImgProps


	/**
	 * The StretchImg widget class implements a widget type that displays a list of multiple images that make up a single image. 
	 */
	export interface StretchImg extends StatefulCanvas {
		/** If the default items are used, capSize is the size in pixels of the first and last images in this stretchImg.
		 * Flags: IRW, Group: appearance */
		capSize: number;

		/** Suffix used the 'grip' image if StretchImg.showGrip is true.
		 * Flags: IRA, Group: grip */
		gripImgSuffix: string;

		/** Base URL for the image if StretchImg.vertical is false and StretchImg.src is unset.
		 * Flags: IRW, Group: appearance */
		hSrc: string /* SCImgURL */;

		/** Should the StretchImg.items','items for this StretchImg display left-to-right even if this page is displaying Page.isRTL','right to left text? Only has an effect if this StretchImg is horizontal (StretchImg.vertical','vertical is set to false). Having this property set to true is usually desirable for the common pattern of media consisting of fixed size "end caps" and a stretchable center, because it allows the same media to be used for LTR and RTL pages. If set to false, items will be displayed in RTL order for RTL pages.
		 * Flags: IRW, Group: RTL */
		ignoreRTL: boolean;

		/** Indicates whether the image should be tiled/cropped, stretched, or centered when the size of this widget does not match the size of the image. See ImageStyle for details.
		 * Flags: IRW, Group: appearance */
		imageType: ImageStyle;

		/** If specified this css class will be applied to the individual item images within this StretchImg. May be overridden by specifying item-specific base styles to each object in the StretchImg.items','items array. This base style will have standard stateful suffixes appended to indicate the state of this component (as described in StatefulCanvas.baseStyle).
		 * Flags: IRW */
		itemBaseStyle: string /* CSSStyleName */;

		/** The list of images to display as an array of objects specifying the image names and sizes. The StretchItem.name','name is appended as a suffix to the StretchImg.src URL in order to fetch separate media files for each image. Alternatively a StretchItem may specify its own StretchItem.src','src. The StretchItem.height','height and StretchItem.width','width can be set to a number, "*" (remaining space, divided amongst all images that specify "*") or to the name of a property on this StretchImg component, such as "capSize" for the StretchImg.capSize. Height or width is only used for the axis along which images are stacked. For example, if StretchImg.vertical is true, images stack vertically and heights are used to size images on the vertical axis, but all images will have width matching the overall component size. For example, the default setting for items, which is used to produce stretchable buttons and headers with fixed-size endcaps, is as follows: items:[ {height:"capSize", name:"start", width:"capSize"}, {height:"*", name:"stretch", width:"*"}, {height:"capSize", name:"end", width:"capSize"} ] Note that by default horizontal StretchImg instances will always render their items in left-to-right order, even if the page is localized for right-to-left display (see Page.isRTL). This default behavior may be overridden by setting the StretchImg.ignoreRTL flag to false.
		 * Flags: IRW, Group: appearance */
		items: Array<StretchItem> /* Array of StretchItem */;

		/** If StretchImg.showGrip is true, this property determines whether to show the 'Down' state on the grip image when the user mousedown's on this widget. Has no effect if StatefulCanvas.showDown is false.
		 * Flags: IRA, Group: grip */
		showDownGrip: boolean;

		/** Should we show a "grip" image floating above the center of this widget?
		 * Flags: IRA, Group: grip */
		showGrip: boolean;

		/** If StretchImg.showGrip is true, this property determines whether to show the 'Over' state on the grip image when the user rolls over on this widget. Has no effect if StatefulCanvas.showRollOver is false.
		 * Flags: IRA, Group: grip */
		showRollOverGrip: boolean;

		/** Determines whether any specified StatefulCanvas.getTitle','title will be displayed for this component. Applies to Image-based components only, where the title will be rendered out in a label floating over the component
		 * Flags: IRWA */
		showTitle: boolean /* Boolean */;

		/** The base URL for the image. The State for the component will be combined with this URL using the same approach as described in Img.src. Then the image segment StretchItem.name','name as specified by each StretchItem is added. For example, for a stretchImg in "Over" state with a src of "button.png" and a segment name of "stretch", the resulting URL would be "button_Over_stretch.png".
		 * Flags: IRW, Group: appearance */
		src: string /* SCImgURL */;

		/** Indicates whether the list of images is drawn vertically from top to bottom (true), or horizontally from left to right (false).
		 * Flags: IRW, Group: appearance */
		vertical: boolean /* Boolean */;

		/** Base URL for the image if StretchImg.vertical is true and StretchImg.src is unset.
		 * Flags: IRW, Group: appearance */
		vSrc: string /* SCImgURL */;


		/* Instance Method Overrides */

	} // StretchImg

	export interface StretchImgStatic<T, P> extends StatefulCanvasStatic<T, P> {
	} // StretchImgStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a StretchImgButton Props argument.
	 * This is derived from the methods in the StretchImgButton class and it's parents and their properties marked with the I flag.
	 */
	export interface StretchImgButtonProps  {
		/** Behavior on state changes -- BUTTON, RADIO or CHECKBOX
		 * Flags: IRW, Group: state */
		actionType?: SelectionType; // Flags=IRW
		/** Horizontal alignment of this component's title.
		 * Flags: IRW, Group: appearance */
		align?: Alignment; // Flags=IRW
		/** If true, ignore the specified size of this widget and always size just large enough to accommodate the title. If setWidth() is explicitly called on an autoFit:true button, autoFit will be reset to false. Note that for StretchImgButton instances, autoFit will occur horizontally only, as unpredictable vertical sizing is likely to distort the media. If you do want vertical auto-fit, this can be achieved by simply setting a small height, and having overflow:"visible"
		 * Flags: IRW, Group: sizing */
		autoFit?: boolean; // Flags=IRW
		/** Base CSS style className applied to the component. As the component changes StatefulCanvas.state and/or is selected, suffixes will be added to the base style. In some cases more than one suffix will be appended to reflect a combined state ("Selected" + "Disabled", for example). See StatefulCanvas.getStateSuffix for a description of the default set of suffixes which may be applied to the baseStyle
		 * Flags: IRW */
		baseStyle?: string /* CSSStyleName */; // Flags=IRW
		/** How big are the end pieces by default
		 * Flags: IRW, Group: appearance */
		capSize?: number; // Flags=IRW
		/** If set to true, if the StatefulCanvas.title','title of this button contains the specified Canvas.accessKey','accessKey, when the title is displayed to the user it will be modified to include HTML to underline the accessKey. Note that this property may cause titles that include HTML (rather than simple strings) to be inappropriately modified, so should be disabled if your title string includes HTML characters.
		 * Flags: IRW */
		hiliteAccessKey?: boolean /* Boolean */; // Flags=IRW
		/** Optional icon to be shown with the button title text. Specify as the partial URL to an image, relative to the imgDir of this component. Note that the string "blank" is a valid setting for this attribute and will always result in the system blank image, with no state suffixes applied. Typically, this might be used when an iconStyle is also specified and the iconStyle renders the icon via a stateful background-image or other CSS approach.
		 * Flags: IRW, Group: buttonIcon */
		icon?: string /* SCImgURL */; // Flags=IRW
		/** If this button is showing an icon should it be right or left aligned?
		 * Flags: IR, Group: buttonIcon */
		iconAlign?: string; // Flags=IR
		/** Height in pixels of the icon image. If unset, defaults to StatefulCanvas.iconSize','iconSize.
		 * Flags: IR, Group: buttonIcon */
		iconHeight?: number /* integer */; // Flags=IR
		/** If this button is showing an icon should it appear to the left or right of the title? valid options are "left" and "right".
		 * Flags: IR, Group: buttonIcon */
		iconOrientation?: string; // Flags=IR
		/** Size in pixels of the icon image. The StatefulCanvas.iconWidth','iconWidth and StatefulCanvas.iconHeight','iconHeight properties can be used to configure width and height separately. Note: When configuring the properties of a StatefulCanvas (or derivative) AutoChild','AutoChild, it is best to set the iconWidth and iconHeight to the same value rather than setting an iconSize. This is because certain skins or customizations thereto might set the iconWidth and iconHeight, making the customization of the AutoChild's iconSize ineffective.
		 * Flags: IR, Group: buttonIcon */
		iconSize?: number /* int */; // Flags=IR
		/** Pixels between icon and title text.
		 * Flags: IR, Group: buttonIcon */
		iconSpacing?: number /* int */; // Flags=IR
		/** Width in pixels of the icon image. If unset, defaults to StatefulCanvas.iconSize','iconSize.
		 * Flags: IR, Group: buttonIcon */
		iconWidth?: number /* integer */; // Flags=IR
		/** The padding for a StretchImgButton's label is determined as follows. If labelHPad is set it will specify the horizontal padding applied to the label. Similarly if labelVPad is set it will specify the vertical padding for the label, regardless of the button's StretchImgButton.vertical','vertical setting. Otherwise labelLengthPad can be set to specify the label padding along the length axis (ie: horizontal padding if StretchImgButton.vertical is false, otherwise vertical padding), and labelBreadthPad can be set to specify the label padding along the other axis. Otherwise the padding on the length axis will match the StretchImgButton.capSize and will be set to zero on the breadth axis. So by default the label will be sized to match the center image of the StretchImgButton, but these settings allow the label to partially or wholly overlap the caps.
		 * Flags: IRW */
		labelBreadthPad?: number; // Flags=IRW
		/** The padding for a StretchImgButton's label is determined as follows. If labelHPad is set it will specify the horizontal padding applied to the label. Similarly if labelVPad is set it will specify the vertical padding for the label, regardless of the button's StretchImgButton.vertical','vertical setting. Otherwise labelLengthPad can be set to specify the label padding along the length axis (ie: horizontal padding if StretchImgButton.vertical is false, otherwise vertical padding), and labelBreadthPad can be set to specify the label padding along the other axis. Otherwise the padding on the length axis will match the StretchImgButton.capSize and will be set to zero on the breadth axis. So by default the label will be sized to match the center image of the StretchImgButton, but these settings allow the label to partially or wholly overlap the caps.
		 * Flags: IRW */
		labelHPad?: number; // Flags=IRW
		/** The padding for a StretchImgButton's label is determined as follows. If labelHPad is set it will specify the horizontal padding applied to the label. Similarly if labelVPad is set it will specify the vertical padding for the label, regardless of the button's StretchImgButton.vertical','vertical setting. Otherwise labelLengthPad can be set to specify the label padding along the length axis (ie: horizontal padding if StretchImgButton.vertical is false, otherwise vertical padding), and labelBreadthPad can be set to specify the label padding along the other axis. Otherwise the padding on the length axis will match the StretchImgButton.capSize and will be set to zero on the breadth axis. So by default the label will be sized to match the center image of the StretchImgButton, but these settings allow the label to partially or wholly overlap the caps.
		 * Flags: IRW */
		labelLengthPad?: number; // Flags=IRW
		/** Specifies a skinImgDir to apply to the label containing the title of this StretchImgButton. May be null in which case this.skinImgDir will be applied to the label as well. Note that icons displayed in the title may make use of the skin img dir set here
		 * Flags: IRWA */
		labelSkinImgDir?: string /* URL */; // Flags=IRWA
		/** The padding for a StretchImgButton's label is determined as follows. If labelHPad is set it will specify the horizontal padding applied to the label. Similarly if labelVPad is set it will specify the vertical padding for the label, regardless of the button's StretchImgButton.vertical','vertical setting. Otherwise labelLengthPad can be set to specify the label padding along the length axis (ie: horizontal padding if StretchImgButton.vertical is false, otherwise vertical padding), and labelBreadthPad can be set to specify the label padding along the other axis. Otherwise the padding on the length axis will match the StretchImgButton.capSize and will be set to zero on the breadth axis. So by default the label will be sized to match the center image of the StretchImgButton, but these settings allow the label to partially or wholly overlap the caps.
		 * Flags: IRW */
		labelVPad?: number; // Flags=IRW
		/** String identifier for this canvas's mutually exclusive selection group.
		 * Flags: IRWA, Group: state */
		radioGroup?: string; // Flags=IRWA
		/** Whether this component is selected. For some components, selection affects appearance.
		 * Flags: IRW, Group: state */
		selected?: boolean /* Boolean */; // Flags=IRW
		/** If true and the title is clipped, then a hover containing the full title of this button is enabled.
		 * Flags: IRW, Group: hovers */
		showClippedTitleOnHover?: boolean /* Boolean */; // Flags=IRW
		/** Should we visibly change state when disabled?
		 * Flags: IRW, Group: state */
		showDisabled?: boolean /* Boolean */; // Flags=IRW
		/** If using an icon for this button, whether to switch the icon image if the button becomes disabled.
		 * Flags: IR, Group: buttonIcon */
		showDisabledIcon?: boolean /* Boolean */; // Flags=IR
		/** Should we visibly change state when the mouse goes down in this object?
		 * Flags: IRW, Group: state */
		showDown?: boolean /* Boolean */; // Flags=IRW
		/** If using an icon for this button, whether to switch the icon image when the mouse goes down on the button.
		 * Flags: IR, Group: buttonIcon */
		showDownIcon?: boolean /* Boolean */; // Flags=IR
		/** Should we visibly change state when the canvas receives focus? If StatefulCanvas.showFocusedAsOver is true, then "over" will be used to indicate focus. Otherwise a separate "focused" state will be used.
		 * Flags: IRW, Group: state */
		showFocused?: boolean /* Boolean */; // Flags=IRW
		/** If using an icon for this button, whether to switch the icon image when the button receives focus. If StatefulCanvas.showFocusedAsOver is true, the "Over" icon will be displayed when the canvas has focus, otherwise a separate "Focused" icon will be displayed
		 * Flags: IR, Group: buttonIcon */
		showFocusedIcon?: boolean /* Boolean */; // Flags=IR
		/** Should we visibly change state when the mouse goes over this object?
		 * Flags: IRW, Group: state */
		showRollOver?: boolean /* Boolean */; // Flags=IRW
		/** If using an icon for this button, whether to switch the icon image on mouse rollover.
		 * Flags: IR, Group: buttonIcon */
		showRollOverIcon?: boolean /* Boolean */; // Flags=IR
		/** If using an icon for this button, whether to switch the icon image when the button becomes selected.
		 * Flags: IR, Group: buttonIcon */
		showSelectedIcon?: boolean /* Boolean */; // Flags=IR
		/** Determines whether any specified StatefulCanvas.getTitle','title will be displayed for this component. Applies to Image-based components only, where the title will be rendered out in a label floating over the component
		 * Flags: IRW */
		showTitle?: boolean /* Boolean */; // Flags=IRW
		/** Base URL for the image. By default, StretchImgButtons consist of three image parts: A start image (displayed at the top or left), a scalable central image and an end image displayed at the bottom or right. The images displayed in the stretchImgButton are derived from this property in the following way: When the button is in its standard state the suffixes "_start", "_end" and "_stretch" are applied to the src (before the file extension), so by default the images displayed will be "button_start.gif" (sized to be this.capSize by the specified width of the stretchImgButton), "button_stretch.gif" (stretched to the necessary width) and "button_end.gif" (sized the same as the start image). As the button's state changes, the images will have suffixes appended before the "_start" / "_end" / "_stretch" to represent the button state. See Img.src for an overview of how states are combined into a compound URL. For example the center piece of a selected stretchImgButton with the mouse hovering over it might have the URL: "button_Selected_Down_stretch.gif". Media should be present for each possible state of the _start, _end and _stretch images.
		 * Flags: IRW */
		src?: string /* SCImgURL */; // Flags=IRW
		/** Current "state" of this widget. The state setting is automatically updated as the user interacts with the component (see StatefulCanvas.showRollOver, StatefulCanvas.showDown, StatefulCanvas.showDisabled). StatefulCanvases will have a different appearance based on their current state. By default this is handled by changing the css className applied to the StatefulCanvas - see StatefulCanvas.baseStyle and StatefulCanvas.getStateSuffix for a description of how this is done. For Img or StretchImg based subclasses of StatefulCanvas, the appearance may also be updated by changing the src of the rendered image. See Img.src and StretchImgButton.src for a description of how the URL is modified to reflect the state of the widget in this case.
		 * Flags: IRWA, Group: state */
		state?: State; // Flags=IRWA
		/** The title HTML to display in this button.
		 * Flags: IRW, Group: basics */
		title?: string /* HTMLString */; // Flags=IRW
		/** CSS style applied to the title text only. Defaults to StretchImgButton.baseStyle when unset. With a separate titleStyle and StretchImgButton.baseStyle set, you can provide a backgroundColor via baseStyle that will allow translucent .png media to be "tinted" by the underlying background color, so that a single set of media can provide range of color options. In this usage, the titleStyle should generally not specify a background color as this would block out the media that appears behind the title.
		 * Flags: IRW */
		titleStyle?: string /* CSSStyleName */; // Flags=IRW
		/** Vertical alignment of this component's title.
		 * Flags: IRW, Group: appearance */
		valign?: VerticalAlignment; // Flags=IRW
		/** Default is a horizontal button. Vertical StretchImgButtons are allowed, but title text, if any, will not be automatically rotated.
		 * Flags: IRW, Group: appearance */
		vertical?: boolean /* Boolean */; // Flags=IRW
		/** Should the title for this button wrap? If unset, default behavior is to allow wrapping if this.vertical is true, otherwise disallow wrapping
		 * Flags: IRW */
		wrap?: boolean; // Flags=IRW

		/* Method Overrides */

	} // StretchImgButtonProps


	/**
	 * A StretchImg that behaves like a button, going through up/down/over state transitions in response to user events. Supports an optional title, and will auto-size to accommodate the title text if overflow is set to "visible". Examples of use include fancy buttons, poplist headers, and tabs. 
	 */
	export interface StretchImgButton  {
		/** Behavior on state changes -- BUTTON, RADIO or CHECKBOX
		 * Flags: IRW, Group: state */
		actionType: SelectionType;

		/** Horizontal alignment of this component's title.
		 * Flags: IRW, Group: appearance */
		align: Alignment;

		/** If true, ignore the specified size of this widget and always size just large enough to accommodate the title. If setWidth() is explicitly called on an autoFit:true button, autoFit will be reset to false. Note that for StretchImgButton instances, autoFit will occur horizontally only, as unpredictable vertical sizing is likely to distort the media. If you do want vertical auto-fit, this can be achieved by simply setting a small height, and having overflow:"visible"
		 * Flags: IRW, Group: sizing */
		autoFit: boolean;

		/** Base CSS style className applied to the component. As the component changes StatefulCanvas.state and/or is selected, suffixes will be added to the base style. In some cases more than one suffix will be appended to reflect a combined state ("Selected" + "Disabled", for example). See StatefulCanvas.getStateSuffix for a description of the default set of suffixes which may be applied to the baseStyle
		 * Flags: IRW */
		baseStyle: string /* CSSStyleName */;

		/** How big are the end pieces by default
		 * Flags: IRW, Group: appearance */
		capSize: number;

		/** If set to true, if the StatefulCanvas.title','title of this button contains the specified Canvas.accessKey','accessKey, when the title is displayed to the user it will be modified to include HTML to underline the accessKey. Note that this property may cause titles that include HTML (rather than simple strings) to be inappropriately modified, so should be disabled if your title string includes HTML characters.
		 * Flags: IRW */
		hiliteAccessKey: boolean /* Boolean */;

		/** Optional icon to be shown with the button title text. Specify as the partial URL to an image, relative to the imgDir of this component. Note that the string "blank" is a valid setting for this attribute and will always result in the system blank image, with no state suffixes applied. Typically, this might be used when an iconStyle is also specified and the iconStyle renders the icon via a stateful background-image or other CSS approach.
		 * Flags: IRW, Group: buttonIcon */
		icon: string /* SCImgURL */;

		/** If this button is showing an icon should it be right or left aligned?
		 * Flags: IR, Group: buttonIcon */
		iconAlign: string;

		/** Height in pixels of the icon image. If unset, defaults to StatefulCanvas.iconSize','iconSize.
		 * Flags: IR, Group: buttonIcon */
		iconHeight: number /* integer */;

		/** If this button is showing an icon should it appear to the left or right of the title? valid options are "left" and "right".
		 * Flags: IR, Group: buttonIcon */
		iconOrientation: string;

		/** Size in pixels of the icon image. The StatefulCanvas.iconWidth','iconWidth and StatefulCanvas.iconHeight','iconHeight properties can be used to configure width and height separately. Note: When configuring the properties of a StatefulCanvas (or derivative) AutoChild','AutoChild, it is best to set the iconWidth and iconHeight to the same value rather than setting an iconSize. This is because certain skins or customizations thereto might set the iconWidth and iconHeight, making the customization of the AutoChild's iconSize ineffective.
		 * Flags: IR, Group: buttonIcon */
		iconSize: number /* int */;

		/** Pixels between icon and title text.
		 * Flags: IR, Group: buttonIcon */
		iconSpacing: number /* int */;

		/** Width in pixels of the icon image. If unset, defaults to StatefulCanvas.iconSize','iconSize.
		 * Flags: IR, Group: buttonIcon */
		iconWidth: number /* integer */;

		/** The padding for a StretchImgButton's label is determined as follows. If labelHPad is set it will specify the horizontal padding applied to the label. Similarly if labelVPad is set it will specify the vertical padding for the label, regardless of the button's StretchImgButton.vertical','vertical setting. Otherwise labelLengthPad can be set to specify the label padding along the length axis (ie: horizontal padding if StretchImgButton.vertical is false, otherwise vertical padding), and labelBreadthPad can be set to specify the label padding along the other axis. Otherwise the padding on the length axis will match the StretchImgButton.capSize and will be set to zero on the breadth axis. So by default the label will be sized to match the center image of the StretchImgButton, but these settings allow the label to partially or wholly overlap the caps.
		 * Flags: IRW */
		labelBreadthPad: number;

		/** The padding for a StretchImgButton's label is determined as follows. If labelHPad is set it will specify the horizontal padding applied to the label. Similarly if labelVPad is set it will specify the vertical padding for the label, regardless of the button's StretchImgButton.vertical','vertical setting. Otherwise labelLengthPad can be set to specify the label padding along the length axis (ie: horizontal padding if StretchImgButton.vertical is false, otherwise vertical padding), and labelBreadthPad can be set to specify the label padding along the other axis. Otherwise the padding on the length axis will match the StretchImgButton.capSize and will be set to zero on the breadth axis. So by default the label will be sized to match the center image of the StretchImgButton, but these settings allow the label to partially or wholly overlap the caps.
		 * Flags: IRW */
		labelHPad: number;

		/** The padding for a StretchImgButton's label is determined as follows. If labelHPad is set it will specify the horizontal padding applied to the label. Similarly if labelVPad is set it will specify the vertical padding for the label, regardless of the button's StretchImgButton.vertical','vertical setting. Otherwise labelLengthPad can be set to specify the label padding along the length axis (ie: horizontal padding if StretchImgButton.vertical is false, otherwise vertical padding), and labelBreadthPad can be set to specify the label padding along the other axis. Otherwise the padding on the length axis will match the StretchImgButton.capSize and will be set to zero on the breadth axis. So by default the label will be sized to match the center image of the StretchImgButton, but these settings allow the label to partially or wholly overlap the caps.
		 * Flags: IRW */
		labelLengthPad: number;

		/** Specifies a skinImgDir to apply to the label containing the title of this StretchImgButton. May be null in which case this.skinImgDir will be applied to the label as well. Note that icons displayed in the title may make use of the skin img dir set here
		 * Flags: IRWA */
		labelSkinImgDir: string /* URL */;

		/** The padding for a StretchImgButton's label is determined as follows. If labelHPad is set it will specify the horizontal padding applied to the label. Similarly if labelVPad is set it will specify the vertical padding for the label, regardless of the button's StretchImgButton.vertical','vertical setting. Otherwise labelLengthPad can be set to specify the label padding along the length axis (ie: horizontal padding if StretchImgButton.vertical is false, otherwise vertical padding), and labelBreadthPad can be set to specify the label padding along the other axis. Otherwise the padding on the length axis will match the StretchImgButton.capSize and will be set to zero on the breadth axis. So by default the label will be sized to match the center image of the StretchImgButton, but these settings allow the label to partially or wholly overlap the caps.
		 * Flags: IRW */
		labelVPad: number;

		/** String identifier for this canvas's mutually exclusive selection group.
		 * Flags: IRWA, Group: state */
		radioGroup: string;

		/** Whether this component is selected. For some components, selection affects appearance.
		 * Flags: IRW, Group: state */
		selected: boolean /* Boolean */;

		/** If true and the title is clipped, then a hover containing the full title of this button is enabled.
		 * Flags: IRW, Group: hovers */
		showClippedTitleOnHover: boolean /* Boolean */;

		/** Should we visibly change state when disabled?
		 * Flags: IRW, Group: state */
		showDisabled: boolean /* Boolean */;

		/** If using an icon for this button, whether to switch the icon image if the button becomes disabled.
		 * Flags: IR, Group: buttonIcon */
		showDisabledIcon: boolean /* Boolean */;

		/** Should we visibly change state when the mouse goes down in this object?
		 * Flags: IRW, Group: state */
		showDown: boolean /* Boolean */;

		/** If using an icon for this button, whether to switch the icon image when the mouse goes down on the button.
		 * Flags: IR, Group: buttonIcon */
		showDownIcon: boolean /* Boolean */;

		/** Should we visibly change state when the canvas receives focus? If StatefulCanvas.showFocusedAsOver is true, then "over" will be used to indicate focus. Otherwise a separate "focused" state will be used.
		 * Flags: IRW, Group: state */
		showFocused: boolean /* Boolean */;

		/** If using an icon for this button, whether to switch the icon image when the button receives focus. If StatefulCanvas.showFocusedAsOver is true, the "Over" icon will be displayed when the canvas has focus, otherwise a separate "Focused" icon will be displayed
		 * Flags: IR, Group: buttonIcon */
		showFocusedIcon: boolean /* Boolean */;

		/** Should we visibly change state when the mouse goes over this object?
		 * Flags: IRW, Group: state */
		showRollOver: boolean /* Boolean */;

		/** If using an icon for this button, whether to switch the icon image on mouse rollover.
		 * Flags: IR, Group: buttonIcon */
		showRollOverIcon: boolean /* Boolean */;

		/** If using an icon for this button, whether to switch the icon image when the button becomes selected.
		 * Flags: IR, Group: buttonIcon */
		showSelectedIcon: boolean /* Boolean */;

		/** Determines whether any specified StatefulCanvas.getTitle','title will be displayed for this component. Applies to Image-based components only, where the title will be rendered out in a label floating over the component
		 * Flags: IRW */
		showTitle: boolean /* Boolean */;

		/** Base URL for the image. By default, StretchImgButtons consist of three image parts: A start image (displayed at the top or left), a scalable central image and an end image displayed at the bottom or right. The images displayed in the stretchImgButton are derived from this property in the following way: When the button is in its standard state the suffixes "_start", "_end" and "_stretch" are applied to the src (before the file extension), so by default the images displayed will be "button_start.gif" (sized to be this.capSize by the specified width of the stretchImgButton), "button_stretch.gif" (stretched to the necessary width) and "button_end.gif" (sized the same as the start image). As the button's state changes, the images will have suffixes appended before the "_start" / "_end" / "_stretch" to represent the button state. See Img.src for an overview of how states are combined into a compound URL. For example the center piece of a selected stretchImgButton with the mouse hovering over it might have the URL: "button_Selected_Down_stretch.gif". Media should be present for each possible state of the _start, _end and _stretch images.
		 * Flags: IRW */
		src: string /* SCImgURL */;

		/** Current "state" of this widget. The state setting is automatically updated as the user interacts with the component (see StatefulCanvas.showRollOver, StatefulCanvas.showDown, StatefulCanvas.showDisabled). StatefulCanvases will have a different appearance based on their current state. By default this is handled by changing the css className applied to the StatefulCanvas - see StatefulCanvas.baseStyle and StatefulCanvas.getStateSuffix for a description of how this is done. For Img or StretchImg based subclasses of StatefulCanvas, the appearance may also be updated by changing the src of the rendered image. See Img.src and StretchImgButton.src for a description of how the URL is modified to reflect the state of the widget in this case.
		 * Flags: IRWA, Group: state */
		state: State;

		/** The title HTML to display in this button.
		 * Flags: IRW, Group: basics */
		title: string /* HTMLString */;

		/** CSS style applied to the title text only. Defaults to StretchImgButton.baseStyle when unset. With a separate titleStyle and StretchImgButton.baseStyle set, you can provide a backgroundColor via baseStyle that will allow translucent .png media to be "tinted" by the underlying background color, so that a single set of media can provide range of color options. In this usage, the titleStyle should generally not specify a background color as this would block out the media that appears behind the title.
		 * Flags: IRW */
		titleStyle: string /* CSSStyleName */;

		/** Vertical alignment of this component's title.
		 * Flags: IRW, Group: appearance */
		valign: VerticalAlignment;

		/** Default is a horizontal button. Vertical StretchImgButtons are allowed, but title text, if any, will not be automatically rotated.
		 * Flags: IRW, Group: appearance */
		vertical: boolean /* Boolean */;

		/** Should the title for this button wrap? If unset, default behavior is to allow wrapping if this.vertical is true, otherwise disallow wrapping
		 * Flags: IRW */
		wrap: boolean;


		/* Instance Method Overrides */

	} // StretchImgButton

	export interface StretchImgButtonStatic<T, P> extends ClassStatic<T, P> {
	} // StretchImgButtonStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a TabBar Props argument.
	 * This is derived from the methods in the TabBar class and it's parents and their properties marked with the I flag.
	 */
	export interface TabBarProps  {
		/** Set StretchImg.capSize for the baseLine stretchImg.
		 * Flags: IR, Group: baseLine */
		baseLineCapSize?: number; // Flags=IR
		/** Sets StretchImg.src for the baseLine StretchImg.
		 * Flags: IR, Group: baseLine */
		baseLineSrc?: string /* SCImgURL */; // Flags=IR
		/** Thickness of the baseLine, in pixels. This should be set to match the media specified by TabBar.baseLineSrc. The baseLineThickness also determines the degree of overlap with the TabSet's paneContainer when using decorative edges - see TabSet.paneContainer for details.
		 * Flags: IR, Group: baseLine */
		baseLineThickness?: number; // Flags=IR
		/** Breadth of the tabBar (including baseline breadth)
		 * Flags: IRW */
		breadth?: number; // Flags=IRW
		/** SmartClient component used for the tabs of the tabBar. Must be Button or Button subclass.
		 * Flags: AIRW */
		buttonConstructor?: Class /* class */; // Flags=AIRW
		/** An array of shortcut keyboard commands which will close the currently selected tab, if the currently selected tab is closeable. Either this TabBar or the currently selected tab must have keyboard focus. By default, this is an array of two KeyIdentifiers: Alt+Delete, which is the keyboard command recommended by <a href='http://www.w3.org/WAI/PF/aria-practices/#tabpanel' target='_blank'>WAI-ARIA Authoring Practices</a> and <a href='http://access.aol.com/dhtml-style-guide-working-group/#tabpanel' target='_blank'>DHTML Style Guide Working Group</a>, and Ctrl+W. Notes: On Mac, the Alt+Delete keyboard command is accomplished via Fn-Option-Delete. Alt+Delete is a <a href='http://doccenter.freedomscientific.com/doccenter/archives/training/jawskeystrokes.htm' target='_blank'>JAWS Keystroke</a> to "Say Active Cursor". If using JAWS, pressing Alt+Shift+Delete will close the tab. In Chrome, Firefox, and Internet Explorer on Windows, Ctrl+W will also close the browser tab/window if focus is not within a TabBar. If Ctrl+W will be used frequently by the application's users, it may be useful to Page.registerKey','register this key to cancel it by default: isc.Page.registerKey({ctrlKey: true, keyName: "W"}, "return false"); 
		 * Flags: IRA */
		closeTabKeys?: Array<string> /* Array of KeyIdentifier */; // Flags=IRA
		/** Default size (length) in pixels for tabs within this tabBar
		 * Flags: IR */
		defaultTabSize?: number; // Flags=IR
		/** Default class used to construct the EditProxy for this component when the component is Canvas.setEditMode','first placed into edit mode.
		 * Flags: IR */
		editProxyConstructor?: string /* SCClassName */; // Flags=IR
		/** Tab to show as the "more" tab when TabBar.showMoreTab is enabled and the number of tabs to show exceeds TabBar.moreTabCount.
		 * Flags: IR */
		moreTab?: Tab; // Flags=IR
		/** This property defines the number tab buttons that should be shown before automatically adding a "more" button to handle the remaining tabs. This property is only used when TabBar.showMoreTab is enabled.
		 * Flags: IR */
		moreTabCount?: number /* int */; // Flags=IR
		/** Should tabs exceeding TabBar.moreTabCount be shown on a "more" tab? This setting is used to emulate an iPhone-style tab bar "more" button.
		 * Flags: IR */
		showMoreTab?: boolean; // Flags=IR
		/** Tab for this TabBar.
		 * Flags: IR */
		tabs?: Array<Tab> /* Array of Tab Properties */; // Flags=IR

		/* Method Overrides */

		/** 
		 * Select a tab
		 * @param {number} tabNum - index of tab to select
		 */
		selectTab?(tabNum:number): void; 

	} // TabBarProps


	/**
	 * Shows a set of Tabs. TabBars are automatically created by TabSets and shouldn't be used directly. The TabBar is documented for skinning purposes. 
	 */
	export interface TabBar  {
		/** Set StretchImg.capSize for the baseLine stretchImg.
		 * Flags: IR, Group: baseLine */
		baseLineCapSize: number;

		/** Sets StretchImg.src for the baseLine StretchImg.
		 * Flags: IR, Group: baseLine */
		baseLineSrc: string /* SCImgURL */;

		/** Thickness of the baseLine, in pixels. This should be set to match the media specified by TabBar.baseLineSrc. The baseLineThickness also determines the degree of overlap with the TabSet's paneContainer when using decorative edges - see TabSet.paneContainer for details.
		 * Flags: IR, Group: baseLine */
		baseLineThickness: number;

		/** Breadth of the tabBar (including baseline breadth)
		 * Flags: IRW */
		breadth: number;

		/** SmartClient component used for the tabs of the tabBar. Must be Button or Button subclass.
		 * Flags: AIRW */
		buttonConstructor: Class /* class */;

		/** An array of shortcut keyboard commands which will close the currently selected tab, if the currently selected tab is closeable. Either this TabBar or the currently selected tab must have keyboard focus. By default, this is an array of two KeyIdentifiers: Alt+Delete, which is the keyboard command recommended by <a href='http://www.w3.org/WAI/PF/aria-practices/#tabpanel' target='_blank'>WAI-ARIA Authoring Practices</a> and <a href='http://access.aol.com/dhtml-style-guide-working-group/#tabpanel' target='_blank'>DHTML Style Guide Working Group</a>, and Ctrl+W. Notes: On Mac, the Alt+Delete keyboard command is accomplished via Fn-Option-Delete. Alt+Delete is a <a href='http://doccenter.freedomscientific.com/doccenter/archives/training/jawskeystrokes.htm' target='_blank'>JAWS Keystroke</a> to "Say Active Cursor". If using JAWS, pressing Alt+Shift+Delete will close the tab. In Chrome, Firefox, and Internet Explorer on Windows, Ctrl+W will also close the browser tab/window if focus is not within a TabBar. If Ctrl+W will be used frequently by the application's users, it may be useful to Page.registerKey','register this key to cancel it by default: isc.Page.registerKey({ctrlKey: true, keyName: "W"}, "return false"); 
		 * Flags: IRA */
		closeTabKeys: Array<string> /* Array of KeyIdentifier */;

		/** Default size (length) in pixels for tabs within this tabBar
		 * Flags: IR */
		defaultTabSize: number;

		/** Default class used to construct the EditProxy for this component when the component is Canvas.setEditMode','first placed into edit mode.
		 * Flags: IR */
		editProxyConstructor: string /* SCClassName */;

		/** Tab to show as the "more" tab when TabBar.showMoreTab is enabled and the number of tabs to show exceeds TabBar.moreTabCount.
		 * Flags: IR */
		moreTab: Tab;

		/** This property defines the number tab buttons that should be shown before automatically adding a "more" button to handle the remaining tabs. This property is only used when TabBar.showMoreTab is enabled.
		 * Flags: IR */
		moreTabCount: number /* int */;

		/** Should tabs exceeding TabBar.moreTabCount be shown on a "more" tab? This setting is used to emulate an iPhone-style tab bar "more" button.
		 * Flags: IR */
		showMoreTab: boolean;

		/** Tab for this TabBar.
		 * Flags: IR */
		tabs: Array<Tab> /* Array of Tab Properties */;


		/* Instance Method Overrides */

		/** 
		 * Select a tab
		 * @param {number} tabNum - index of tab to select
		 */
		selectTab?(tabNum:number): void; 

	} // TabBar

	export interface TabBarStatic<T, P> extends ClassStatic<T, P> {
	} // TabBarStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a TableView Props argument.
	 * This is derived from the methods in the TableView class and it's parents and their properties marked with the I flag.
	 */
	export interface TableViewProps  {
		/** Field to display as part of individual record in "summary" RecordLayouts.
		 * Flags: IRW */
		dataField?: string /* String */; // Flags=IRW
		/** Field to display as part of individual record in all RecordLayouts except "titleOnly".
		 * Flags: IRW */
		descriptionField?: string /* String */; // Flags=IRW
		/** This property allows the developer to specify the icon displayed next to a record. Set record[tableView.iconField] to the URL of the desired icon to display. Only applies if TableView.showIconField is true.
		 * Flags: IRW */
		iconField?: string /* String */; // Flags=IRW
		/** Field to display as part of individual record in "summary" RecordLayouts.
		 * Flags: IRW */
		infoField?: string /* String */; // Flags=IRW
		/** The navigation icon shown next to records when TableView.showNavigation is true and NavigationMode is set to "navIconOny".
		 * Flags: IRW */
		navIcon?: string /* SCImgURL */; // Flags=IRW
		/** Set navigation mode for this TableView.
		 * Flags: IRW */
		navigationMode?: NavigationMode; // Flags=IRW
		/** Default style for data field.
		 * Flags: IRW */
		recordDataStyle?: string /* CSSStyleName */; // Flags=IRW
		/** Default style for description.
		 * Flags: IRW */
		recordDescriptionStyle?: string /* CSSStyleName */; // Flags=IRW
		/** Default style for info field.
		 * Flags: IRW */
		recordInfoStyle?: string /* CSSStyleName */; // Flags=IRW
		/** Sets the arrangement of data fields from the record. <p/> Note that controls supported by the TableView itself, such as navigation icons, are implicitly added to the data fields described in the RecordLayout. If an TableView.iconField has been configured, it too is an implicitly shown field, to the left of the area controlled by RecordLayout.
		 * Flags: IRW */
		recordLayout?: RecordLayout; // Flags=IRW
		/** Boolean property on each record that controls whether navigation controls are shown for that record. If property is not defined on the record a navigation icon is shown if TableView.showNavigation is true.
		 * Flags: IRW */
		recordNavigationProperty?: string /* String */; // Flags=IRW
		/** Default style for title.
		 * Flags: IRW */
		recordTitleStyle?: string /* CSSStyleName */; // Flags=IRW
		/** Should an icon field be shown for each record? A column in the table is set aside for an icon as specified on each record in the TableView.iconField.
		 * Flags: IRW */
		showIconField?: boolean /* Boolean */; // Flags=IRW
		/** Whether to show navigation controls by default on all records. Can also be configured per-record with TableView.recordNavigationProperty.
		 * Flags: IRW */
		showNavigation?: boolean; // Flags=IRW
		/** The display mode of the table.
		 * Flags: IRW */
		tableMode?: TableMode; // Flags=IRW
		/** Field to display for an individual record as the main title.
		 * Flags: IRW */
		titleField?: string /* String */; // Flags=IRW
		/** The navigation icon shown next to records when TableView.showNavigation is true and NavigationMode is set to "wholeRecord".
		 * Flags: IRW */
		wholeRecordNavIcon?: string /* SCImgURL */; // Flags=IRW

		/* Method Overrides */

	} // TableViewProps


	/**
	 * Shows a listing of records with one or more fields from each record, with built-in support for navigation and editing of lists of records. <p/> The TableView provides built-in controls such as TableView.showNavigation','navigation arrows and shows fields from the provided records in one of several built-in RecordLayouts. <p/> NOTE: This widget is intended primarily for creating handset/phone-sized interfaces and does not have an appearance in any skin other than Mobile. 
	 */
	export interface TableView  {
		/** Field to display as part of individual record in "summary" RecordLayouts.
		 * Flags: IRW */
		dataField: string /* String */;

		/** Field to display as part of individual record in all RecordLayouts except "titleOnly".
		 * Flags: IRW */
		descriptionField: string /* String */;

		/** This property allows the developer to specify the icon displayed next to a record. Set record[tableView.iconField] to the URL of the desired icon to display. Only applies if TableView.showIconField is true.
		 * Flags: IRW */
		iconField: string /* String */;

		/** Field to display as part of individual record in "summary" RecordLayouts.
		 * Flags: IRW */
		infoField: string /* String */;

		/** The navigation icon shown next to records when TableView.showNavigation is true and NavigationMode is set to "navIconOny".
		 * Flags: IRW */
		navIcon: string /* SCImgURL */;

		/** Set navigation mode for this TableView.
		 * Flags: IRW */
		navigationMode: NavigationMode;

		/** Default style for data field.
		 * Flags: IRW */
		recordDataStyle: string /* CSSStyleName */;

		/** Default style for description.
		 * Flags: IRW */
		recordDescriptionStyle: string /* CSSStyleName */;

		/** Default style for info field.
		 * Flags: IRW */
		recordInfoStyle: string /* CSSStyleName */;

		/** Sets the arrangement of data fields from the record. <p/> Note that controls supported by the TableView itself, such as navigation icons, are implicitly added to the data fields described in the RecordLayout. If an TableView.iconField has been configured, it too is an implicitly shown field, to the left of the area controlled by RecordLayout.
		 * Flags: IRW */
		recordLayout: RecordLayout;

		/** Boolean property on each record that controls whether navigation controls are shown for that record. If property is not defined on the record a navigation icon is shown if TableView.showNavigation is true.
		 * Flags: IRW */
		recordNavigationProperty: string /* String */;

		/** Default style for title.
		 * Flags: IRW */
		recordTitleStyle: string /* CSSStyleName */;

		/** Should an icon field be shown for each record? A column in the table is set aside for an icon as specified on each record in the TableView.iconField.
		 * Flags: IRW */
		showIconField: boolean /* Boolean */;

		/** Whether to show navigation controls by default on all records. Can also be configured per-record with TableView.recordNavigationProperty.
		 * Flags: IRW */
		showNavigation: boolean;

		/** The display mode of the table.
		 * Flags: IRW */
		tableMode: TableMode;

		/** Field to display for an individual record as the main title.
		 * Flags: IRW */
		titleField: string /* String */;

		/** The navigation icon shown next to records when TableView.showNavigation is true and NavigationMode is set to "wholeRecord".
		 * Flags: IRW */
		wholeRecordNavIcon: string /* SCImgURL */;


		/* Instance Method Overrides */

	} // TableView

	export interface TableViewStatic<T, P> extends ClassStatic<T, P> {
	} // TableViewStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a TabSet Props argument.
	 * This is derived from the methods in the TabSet class and it's parents and their properties marked with the I flag.
	 */
	export interface TabSetProps extends CanvasProps {
		/** Appears when TabSet.canAddTabs is enabled.
		 * Flags: IR */
		addTabButton?:  ImgButton /* AutoChild ImgButton */; // Flags=IR
		/** Icon for the TabSet.addTabButton.
		 * Flags: IR */
		addTabButtonIcon?: string /* SCImgURL */; // Flags=IR
		/** If TabSet.showTabScroller is true, should tabs be scrolled into view via an animation when the user interacts with the scroller buttons?
		 * Flags: IR, Group: tabBarControls */
		animateTabScrolling?: boolean /* Boolean */; // Flags=IR
		/** When isc.setScreenReaderMode','screen reader mode is enabled and a tab is TabSet.canCloseTabs','closeable, the ariaCloseableSuffix is a string that is appended to the label of closeable tabs. This suffix is hidden from sighted users, but is announced by screen readers to indicate that the tab may be closed. Set to null to disable appending this suffix.
		 * Flags: IRA, Group: i18nMessages */
		ariaCloseableSuffix?: string /* String */; // Flags=IRA
		/** If this tabSet will TabSet.showPaneContainerEdges','show edges for the paneContainer, and TabSet.symmetricEdges is set to false, the leftEdgeOffsets, rightEdgeOffsets, topEdgeOffsets and bottomEdgeOffsets properties allow the offsets of edges for the paneContainer to be customized depending on the TabSet.tabBarPosition. The attribute should be specified an EdgeSizes','edgeSizes map, specifying the desired edge offsets where for the appropriate TabSet.tabBarPosition.
		 * Flags: IR */
		bottomEdgeOffsets?: EdgeSizes; // Flags=IR
		/** If this tabSet will TabSet.showPaneContainerEdges','show edges for the paneContainer, and TabSet.symmetricEdges is set to false, the leftEdgeSizes, rightEdgeSizes, topEdgeSizes and bottomEdgeSizes properties allow the sizes of edges for the paneContainer to be customized depending on the TabSet.tabBarPosition. The attribute should be specified an EdgeSizes','edgeSizes map, specifying the desired edge sizes where for the appropriate TabSet.tabBarPosition.
		 * Flags: IR */
		bottomEdgeSizes?: EdgeSizes; // Flags=IR
		/** Causes the TabSet.addTabButton to appear after the TabSet.tabs and before the TabSet.tabBarControls. There is no default behavior for what happens when the addTabButton is clicked. Add a handler for the TabSet.addTabClicked event to implement a behavior.
		 * Flags: IR */
		canAddTabs?: boolean /* Boolean */; // Flags=IR
		/** Should tabs in this tabSet show an icon allowing the user to dismiss the tab by clicking on it directly. May be overridden for individual tabs by setting Tab.canClose. The URL for this icon's image will be derived from TabSet.closeTabIcon by default, but may be overridden by explicitly specifying Tab.closeIcon. Note: Currently, tabs can only show a single icon, so a closable tab will show the close icon only even if Tab.icon is set. To work around this, add the icon as an HTML &lt;img&gt; tag to the Tab.title property, for example: title : "&lt;span&gt;" + isc.Canvas.imgHTML("path/to/icon.png") + " Tab Title&lt;/span&gt;" 
		 * Flags: IRW */
		canCloseTabs?: boolean; // Flags=IRW
		/** If true, users can edit the titles of tabs in this TabSet when the TabSet.titleEditEvent','titleEditEvent fires. You can override this behavior per tab with the Tab.canEditTitle property. Note that this TabSet's TabSet.titleEditEvent','titleEditEvent must be set to a supported TabTitleEditEvent in order for users to be able to edit the titles of tabs.
		 * Flags: IRW */
		canEditTabTitles?: boolean /* Boolean */; // Flags=IRW
		/** If true, tabs can be reordered by dragging on them. To disallow drag-reorder of a specific tab, see Tab.canReorder.
		 * Flags: IR, Group: dragdrop */
		canReorderTabs?: boolean; // Flags=IR
		/** Default src for the close icon for tabs to display if TabSet.canCloseTabs is true.
		 * Flags: IR */
		closeTabIcon?: string /* SCImgURL */; // Flags=IR
		/** Size in pixels of the icon for closing tabs, displayed when TabSet.canCloseTabs is true.
		 * Flags: IR */
		closeTabIconSize?: number /* int */; // Flags=IR
		/** If set, is passed as "height" to all tabs when TabSet.tabBarPosition is set to "left" or "right". If unset, height will be picked up from the Tab constructor class defaults. Note that tabs expand to fit their content so this height acts as a minimum. May be customized by individual skinning','skins.
		 * Flags: IR */
		defaultTabHeight?: number; // Flags=IR
		/** If set, is passed as "width" to all tabs when TabSet.tabBarPosition is set to "top" or "bottom". If unset, width will be picked up from the Tab constructor class defaults. Tabs expand to fit their content, so this width acts as a minimum. Setting width:1 will result in tabs that are only as wide as their titles. May be customized by individual skinning','skins.
		 * Flags: IR */
		defaultTabWidth?: number; // Flags=IR
		/** Whether Canvas.destroy','destroy() should be called on Tab.pane when it a tab is removed via TabSet.removeTab. With the default setting of null panes will be automatically destroyed. An application might set this to false in order to re-use panes in different tabs or in different parts of the application.
		 * Flags: IR */
		destroyPanes?: boolean; // Flags=IR
		/** Default class used to construct the EditProxy for this component when the component is Canvas.setEditMode','first placed into edit mode.
		 * Flags: IR */
		editProxyConstructor?: string /* SCClassName */; // Flags=IR
		/** If this tabSet will TabSet.showPaneContainerEdges','show edges for the paneContainer, and TabSet.symmetricEdges is set to false, the leftEdgeOffsets, rightEdgeOffsets, topEdgeOffsets and bottomEdgeOffsets properties allow the offsets of edges for the paneContainer to be customized depending on the TabSet.tabBarPosition. The attribute should be specified an EdgeSizes','edgeSizes map, specifying the desired edge offsets where for the appropriate TabSet.tabBarPosition.
		 * Flags: IR */
		leftEdgeOffsets?: EdgeSizes; // Flags=IR
		/** If this tabSet will TabSet.showPaneContainerEdges','show edges for the paneContainer, and TabSet.symmetricEdges is set to false, the leftEdgeSizes, rightEdgeSizes, topEdgeSizes and bottomEdgeSizes properties allow the sizes of edges for the paneContainer to be customized depending on the TabSet.tabBarPosition. The attribute should be specified an EdgeSizes','edgeSizes map, specifying the desired edge sizes where for the appropriate TabSet.tabBarPosition.
		 * Flags: IR */
		leftEdgeSizes?: EdgeSizes; // Flags=IR
		/** When AutoTest.getElement is used to parse locator strings generated by AutoTest.getLocator, how should tabs within this tabset be identified? By default if tab has a specified Tab.ID this will always be used. For tabs with no ID, the following options are available: "title" use the title as an identifier "index" use the index of the tab in the tabset as an identifier If unset, and the tab has no specified ID, default behavior is to identify by title (if available), otherwise by index.
		 * Flags: IRWA, Group: autoTest */
		locateTabsBy?: string; // Flags=IRWA
		/** This property defines the number tab buttons that should be shown before automatically adding a "more" button to handle the remaining tabs. This property is only used when TabSet.showMoreTab is enabled.
		 * Flags: IR */
		moreTabCount?: number; // Flags=IR
		/** If TabSet.showMoreTab is enabled this property determines the image to display on the "More" tab button.
		 * Flags: IR */
		moreTabImage?: string /* SCImgURL */; // Flags=IR
		/** Default properties for the "more" tab's pane. Currently constructs a VLayout with a NavigationBar and TableView.
		 * Flags: IR */
		moreTabPaneDefaults?: CanvasProps /* Canvas Properties */; // Flags=IR
		/** Navigation bar shown in the TabSet.moreTabPane;
		 * Flags: IR */
		moreTabPaneNavBar?:  NavigationBar /* AutoChild NavigationBar */; // Flags=IR
		/** Properties to apply to the "more" tab's pane created by this TabSet.
		 * Flags: IR */
		moreTabPaneProperties?: CanvasProps /* Canvas Properties */; // Flags=IR
		/** TableView used to show links to other tabs in the TabSet.moreTabPane;
		 * Flags: IR */
		moreTabPaneTable?:  TableView /* AutoChild TableView */; // Flags=IR
		/** Properties to apply to the "more" tab created by this TabSet.
		 * Flags: IR */
		moreTabProperties?: Tab /* Tab Properties */; // Flags=IR
		/** Title for the "More" tab.
		 * Flags: IR */
		moreTabTitle?: string /* String */; // Flags=IR
		/** CSS style used for the paneContainer.
		 * Flags: IRW */
		paneContainerClassName?: string /* CSSStyleName */; // Flags=IRW
		/** Specifies the overflow of the pane container (the component that holds the pane contents for all tabs). By default this is set to "auto", meaning the pane container will automatically introduce scrolling when the pane contents exceed the TabSet's specified size. For other values and their meaning, see Overflow
		 * Flags: IRWA */
		paneContainerOverflow?: Overflow; // Flags=IRWA
		/** Space to leave around the panes in our paneContainer Note that this property may be specified on a per-tab basis via Tab.paneMargin.
		 * Flags: IR */
		paneMargin?: number /* int */; // Flags=IR
		/** If TabSet.showTabPicker is true, and TabSet.symmetricPickerButton is set to true, this property governs the base URL for the picker button image, when displayed in a horizontal tab-bar [IE TabSet.tabBarPosition is set to "top" or "bottom"]. Note that if symmetricPickerButton is false, the TabSet.pickerButtonSrc property will be used instead. This base URL will have a suffix of "Down" appended when the user holds the mouse down over the button, and "Disabled" if the tabset as a whole is disabled.
		 * Flags: IR, Group: tabBarScrolling */
		pickerButtonHSrc?: string /* SCImgURL */; // Flags=IR
		/** If TabSet.showTabPicker','showTabPicker is true and Browser.isTouch is false, this property governs the size of the tab picker button. This value is applied as the width of the tab picker button if the TabSet.tabBar','tabBar is horizontal, or the height if the tabBar is vertical. Note that the other dimension is determined by TabSet.tabBarThickness','this.tabBarThickness. On touch browsers (where Browser.isTouch is true), TabSet.touchPickerButtonSize','touchPickerButtonSize is used instead.
		 * Flags: IR, Group: tabBarControls */
		pickerButtonSize?: number /* int */; // Flags=IR
		/** If TabSet.showTabPicker is true, this property governs the base URL for the picker button image, when TabSet.symmetricPickerButton is set to false Note that if symmetricPickerButton is true, the TabSet.pickerButtonHSrc and TabSet.pickerButtonVSrc properties will be used instead. To get the path to the image to display, this base URL will be modified as follows: If appropriate a state suffix of "Down" or "Disabled" will be appended. The TabSet.tabBarPosition','tabBarPosition for this tabSet will be appended. 
		 * Flags: IR, Group: tabBarScrolling */
		pickerButtonSrc?: string /* SCImgURL */; // Flags=IR
		/** If TabSet.showTabPicker is true, and TabSet.symmetricPickerButton is set to true, this property governs the base URL for the picker button image, when displayed in a verricaL tab-bar [IE TabSet.tabBarPosition is set to "LEFT" or "right"]. Note that if symmetricPickerButton is false, the TabSet.pickerButtonSrc property will be used instead. This base URL will have a suffix of "Down" appended when the user holds the mouse down over the button, and "Disabled" if the tabset as a whole is disabled.
		 * Flags: IR, Group: tabBarScrolling */
		pickerButtonVSrc?: string /* SCImgURL */; // Flags=IR
		/** If this tabSet will TabSet.showPaneContainerEdges','show edges for the paneContainer, and TabSet.symmetricEdges is set to false, the leftEdgeOffsets, rightEdgeOffsets, topEdgeOffsets and bottomEdgeOffsets properties allow the offsets of edges for the paneContainer to be customized depending on the TabSet.tabBarPosition. The attribute should be specified an EdgeSizes','edgeSizes map, specifying the desired edge offsets where for the appropriate TabSet.tabBarPosition.
		 * Flags: IR */
		rightEdgeOffsets?: EdgeSizes; // Flags=IR
		/** If this tabSet will TabSet.showPaneContainerEdges','show edges for the paneContainer, and TabSet.symmetricEdges is set to false, the leftEdgeSizes, rightEdgeSizes, topEdgeSizes and bottomEdgeSizes properties allow the sizes of edges for the paneContainer to be customized depending on the TabSet.tabBarPosition. The attribute should be specified an EdgeSizes','edgeSizes map, specifying the desired edge sizes where for the appropriate TabSet.tabBarPosition.
		 * Flags: IR */
		rightEdgeSizes?: EdgeSizes; // Flags=IR
		/** If TabSet.showTabScroller is true, this property governs the size of scroller buttons. Applied as the width of buttons if the tabBar is horizontal, or the height if tabBar is vertical. Note that the other dimension is determined by TabSet.tabBarThickness','this.tabBarThickness
		 * Flags: IR, Group: tabBarControls */
		scrollerButtonSize?: number; // Flags=IR
		/** If this TabSet is showing TabSet.showTabScroller','tab scroller buttons, and TabSet.symmetricScroller','symmetricScroller is true, this property governs the base URL for the tab bar back and forward scroller button images for horizontal tab bars [IE for tab sets with TabSet.tabBarPosition','tabBarPosition set to "top" or "bottom"]. Note that if TabSet.symmetricScroller','symmetricScroller is false, TabSet.scrollerSrc will be used instead. To get the path to the image to display, this base URL will be modified as follows: If appropriate a state suffix of "Down" or "Disabled" will be appended. A suffix of "forward" or "back" will be appended for the forward or backward scrolling button. For example - if the scrollerHSrc is set to "[SKIN]hscroll.gif", the image displayed for the back-scroller button on a tabSet with tabBarPosition set to "top" and symmetricScroller set to true would be one of "[SKIN]hscroll_back.gif", "[SKIN]hscroll_Down_back.gif", and "[SKIN]hscroll_Disabled_back.gif". Note that for best results the media should be sized to match the scroller button sizes, determined by TabSet.tabBarThickness and TabSet.scrollerButtonSize.
		 * Flags: IR, Group: tabBarScrolling */
		scrollerHSrc?: string /* SCImgURL */; // Flags=IR
		/** If this TabSet is showing TabSet.showTabScroller','tab scroller buttons, and TabSet.symmetricScroller','symmetricScroller is false, this property governs the base URL for the tab bar back and forward scroller button images. Note that if TabSet.symmetricScroller','symmetricScroller is true, TabSet.scrollerHSrc and TabSet.scrollerVSrc will be used instead. To get the path to the image to display, this base URL will be modified as follows: If appropriate a state suffix of "Down" or "Disabled" will be appended. The TabSet.tabBarPosition','tabBarPosition for this tabSet will be appended. A suffix of "forward" or "back" will be appended for the forward or backward scrolling button. For example - if the scrollerSrc is set to "[SKIN]scroll.gif", the image displayed for the back-scroller button on a tabSet with tabBarPosition set to "top" and symmetricScroller set to false would be one of "[SKIN]scroll_top_back.gif", "[SKIN]scroll_Down_top_back.gif", and "[SKIN]scroll_Disabled_top_back.gif". Note that for best results the media should be sized to match the scroller button sizes, determined by TabSet.tabBarThickness and TabSet.scrollerButtonSize.
		 * Flags: IR, Group: tabBarScrolling */
		scrollerSrc?: string /* SCImgURL */; // Flags=IR
		/** If this TabSet is showing TabSet.showTabScroller','tab scroller buttons, and TabSet.symmetricScroller','symmetricScroller is true, this property governs the base URL for the tab bar back and forward scroller button images for vertical tab bars [IE for tab sets with TabSet.tabBarPosition','tabBarPosition set to "left" or "right"]. Note that if TabSet.symmetricScroller','symmetricScroller is false, TabSet.scrollerSrc will be used instead. To get the path to the image to display, this base URL will be modified as follows: If appropriate a state suffix of "Down" or "Disabled" will be appended. A suffix of "forward" or "back" will be appended for the forward or backward scrolling button. For example - if the scrollerVSrc is set to "[SKIN]vscroll.gif", the image displayed for the back-scroller button on a tabSet with tabBarPosition set to "left" and symmetricScroller set to true would be one of "[SKIN]vscroll_back.gif", "[SKIN]vscroll_Down_back.gif", and "[SKIN]vscroll_Disabled_back.gif". Note that for best results the media should be sized to match the scroller button sizes, determined by TabSet.tabBarThickness and TabSet.scrollerButtonSize.
		 * Flags: IR, Group: tabBarScrolling */
		scrollerVSrc?: string /* SCImgURL */; // Flags=IR
		/** Specifies the index of the initially selected tab.
		 * Flags: IRW, Group: tabBar */
		selectedTab?: number; // Flags=IRW
		/** Should tabs exceeding TabSet.moreTabCount be shown on a "more" tab? This setting is used to emulate an iPhone-style tab bar "more" button.
		 * Flags: IR */
		showMoreTab?: boolean; // Flags=IR
		/** Should the paneContainer for this tabset show Canvas.showEdges','edges.
		 * Flags: IRWA */
		showPaneContainerEdges?: boolean; // Flags=IRWA
		/** If the paneContainer for this tab set is showing Canvas.showEdges','edges, setting this attribute to true will set the paneContainer to show Canvas.customEdges','customEdges for the three sides opposing the tabBarPosition.
		 * Flags: IRA */
		showPartialEdges?: boolean /* Boolean */; // Flags=IRA
		/** Should the tabBar be displayed or not If shrinkElementOnHide is true, the paneContainer will expand over the space occupied by TabBar
		 * Flags: IRW */
		showTabBar?: boolean /* Boolean */; // Flags=IRW
		/** If there is not enough space to display all the tab-buttons in this tabSet, should a drop-down "picker" be displayed to allow selection of tabs that are clipped?
		 * Flags: IR, Group: tabBarControls */
		showTabPicker?: boolean /* Boolean */; // Flags=IR
		/** If there is not enough space to display all the tab-buttons in this tabSet, should scroll buttons be displayed to allow access to tabs that are clipped? If unset, defaults to false for Browser.isHandset','handsets and true otherwise.
		 * Flags: IR, Group: tabBarControls */
		showTabScroller?: boolean /* Boolean */; // Flags=IR
		/** If this.useSimpleTabs is true, simpleTabBaseClass will be the base style used to determine the css style to apply to the tabs. This property will be suffixed with the side on which the tab-bar will appear, followed by with the tab's state (selected, over, etc), resolving to a className like "tabButtonTopOver"
		 * Flags: IRW */
		simpleTabBaseStyle?: string /* CSSStyleName */; // Flags=IRW
		/** Tab button constructor if TabSet.useSimpleTabs is true.
		 * Flags: IRA */
		simpleTabButtonConstructor?: Class; // Flags=IRA
		/** Default directory for skin images (those defined by the class), relative to the Page-wide Page.getSkinDir','skinDir.
		 * Flags: IR, Group: images */
		skinImgDir?: string; // Flags=IR
		/** If this tabSet will TabSet.showPaneContainerEdges','show edges for the paneContainer, this property determines whether the same edge media will be used regardless of the tab bar position, or whether different media should be used (necessary if the edge appearance is not symmetrical on all sides). If this property is set to false the paneContainer edge image URLs will be prefixed with the tabBarPosition of the tabSet - for example "[SKIN]edge_top_T.gif" rather than just "[SKIN]edge_T.gif". When symmetricEdges is false, custom edge sizes for the pane container may be specified via TabSet.topEdgeSizes et al, and custom edge offsets via TabSet.topEdgeOffsets et al.
		 * Flags: IR */
		symmetricEdges?: boolean /* Boolean */; // Flags=IR
		/** If this TabSet is showing a TabSet.showTabPicker','tab picker button, this property determines whether the TabSet.pickerButtonHSrc and TabSet.pickerButtonVSrc media will be used for vertical and horizontal tab-bar picker buttons, or whether separate media should be used for each possible TabSet.tabBarPosition','tabBarPosition based on the TabSet.pickerButtonSrc property for this tabSet.
		 * Flags: IR, Group: tabBarScrolling */
		symmetricPickerButton?: boolean /* Boolean */; // Flags=IR
		/** If this TabSet is showing TabSet.showTabScroller','tab scroller buttons, this property determines whether the TabSet.scrollerHSrc and TabSet.scrollerVSrc media will be used for vertical and horizontal tab-bar scroller buttons, or whether separate media should be used for each possible TabSet.tabBarPosition','tabBarPosition based on the TabSet.scrollerSrc property for this tabSet.
		 * Flags: IR, Group: tabBarScrolling */
		symmetricScroller?: boolean /* Boolean */; // Flags=IR
		/** Alignment of the tabBar. If the TabSet.tabBarPosition','tabBarPosition is "top" or "bottom", then this attribute may be set to "left", "right" or "center". The default is "left", or "right" in Page.isRTL','RTL mode. If the TabSet.tabBarPosition','tabBarPosition is "left" or "right", then this attribute may be set to "top", "bottom" or "center". The default is "top".
		 * Flags: IR, Group: tabBar */
		tabBarAlign?: Side | Alignment; // Flags=IR
		/** AutoChild of type Layout that holds the TabSet.tabBarControls as well as the built-in controls such as the TabSet.showTabPicker','tab picker menu.
		 * Flags: IR */
		tabBarControlLayout?:  Layout /* AutoChild Layout */; // Flags=IR
		/** This property determines what controls should show up after the tabBar for this TabSet. Standard controls can be included using the strings "tabScroller" and "tabPicker". These correspond to the TabSet.scroller and TabSet.tabPicker AutoChildren, respectively. The "tabScroller" standard control shows two buttons for scrolling through the tabs in order and the "tabPicker" standard control allows tabs to be picked directly from a menu. The standard controls show up only if TabSet.showTabScroller or TabSet.showTabPicker is true and there is not enough space available to show all of the tabs in the tabBar. layout_tabs_custom_controls', 'This sample illustrates the usage of this property Additional controls can be included by adding any widget to this array. Controls will show up in the order in which they are specified. For example, the following code would add a button in the tabBar area, while preserving the normal behavior of the tabScroller and tabPicker: isc.TabSet.create({ width:300, tabs : [ { title: "Tab one" } ], tabBarControls : [ isc.ImgButton.create({ src:"[SKINIMG]/actions/add.png", width:16, height:16, layoutAlign:"center" }), "tabScroller", "tabPicker" ] }); You can also refer to the default tabPicker/tabScroll controls from Component XML: &lt;TabSet width="300"&gt; &lt;tabBarControls&gt; &lt;Button title="Custom Button"/&gt; &lt;value xsi:type="string"&gt;tabPicker&lt;/value&gt; &lt;value xsi:type="string"&gt;tabScroller&lt;/value&gt; &lt;/tabBarControls&gt; &lt;tabs&gt; &lt;tab title="Foo"/&gt; &lt;tab title="Bar"/&gt; &lt;/tabs&gt; &lt;/TabSet&gt; When Browser.isTouch is true and native touch scrolling is supported, then by default, only the "tabPicker" is shown. The "tabScroller" control is omitted by default on touch devices because the tabs in the tab bar are native touch-scrollable, so the "tabScroller" control is unnecessary. To override the omission of the "tabScroller", simply add "tabScroller" to the tabBarControls array.
		 * Flags: IRA, Group: tabBarControls */
		tabBarControls?: Array<any> /* Array */; // Flags=IRA
		/** Which side of the TabSet the TabBar should appear on.
		 * Flags: IR, Group: tabBar */
		tabBarPosition?: Side; // Flags=IR
		/** This attribute allows developers to specify custom properties for this tabset's TabSet.tabBar
		 * Flags: IR */
		tabBarProperties?: TabBarProps /* TabBar Properties */; // Flags=IR
		/** Thickness of tabBar, applies to either orientation (specifies height for horizontal, width for vertical orientation). Note that overriding this value for TabSets that are skinned with images generally means providing new media for the borders.
		 * Flags: IRW, Group: tabBar */
		tabBarThickness?: number; // Flags=IRW
		/** Properties to apply to all Tabs created by this TabSet.
		 * Flags: IR */
		tabProperties?: Tab /* Tab Properties */; // Flags=IR
		/** An array of Tab objects, specifying the title and pane contents of each tab in the TabSet. When developing in JavaScript, tabs are specified as an array of object literals, not instances - see Tab. After providing Tab instances to setTabs(), the TabSet creates actual UI widgets to serve as interactive tabs. Any further modifications to tabs should be performed via TabSet APIs such as TabSet.setTabTitle, TabSet.setTabIcon and TabSet.setTabPane. You can add and remove tabs after creating the TabSet by calling TabSet.addTab and TabSet.removeTab
		 * Flags: IRW */
		tabs?: Array<Tab> /* Array of Tab */; // Flags=IRW
		/** The event that triggers title editing on this TabSet.
		 * Flags: IRW */
		titleEditEvent?: TabTitleEditEvent; // Flags=IRW
		/** If set, offsets the tab title editor further in from the left-hand edge of the tab, by the number of pixels set in this property. Note that the editor is always offset to avoid overlapping the endcaps of the tab; this property is applied on top of that default offset.
		 * Flags: IRW */
		titleEditorLeftOffset?: number /* Integer */; // Flags=IRW
		/** Properties for the auto-generated TabSet.titleEditor. This is the text item we use to edit tab titles in this tabSet.
		 * Flags: IR */
		titleEditorProperties?: TextItemProps /* TextItem properties */; // Flags=IR
		/** If set, offsets the tab title editor further in from the right-hand edge of the tab, by the number of pixels set in this property. Note that the editor is always offset to avoid overlapping the endcaps of the tab; this property is applied on top of that default offset.
		 * Flags: IRW */
		titleEditorRightOffset?: number /* Integer */; // Flags=IRW
		/** If set, offsets the tab title editor further down from the top edge of the tab, by the number of pixels set in this property. You can use this property, together with the left and right offset properties, to fine tune positioning of the editor within or around the tab button. Note: The height of the editor is an attribute of the editor itself, and can be set by specifying a "height" property in TabSet.titleEditor','titleEditorDefaults.
		 * Flags: IRW */
		titleEditorTopOffset?: number /* Integer */; // Flags=IRW
		/** If this tabSet will TabSet.showPaneContainerEdges','show edges for the paneContainer, and TabSet.symmetricEdges is set to false, the leftEdgeOffsets, rightEdgeOffsets, topEdgeOffsets and bottomEdgeOffsets properties allow the offsets of edges for the paneContainer to be customized depending on the TabSet.tabBarPosition. The attribute should be specified an EdgeSizes','edgeSizes map, specifying the desired edge offsets where for the appropriate TabSet.tabBarPosition.
		 * Flags: IR */
		topEdgeOffsets?: EdgeSizes; // Flags=IR
		/** If this tabSet will TabSet.showPaneContainerEdges','show edges for the paneContainer, and TabSet.symmetricEdges is set to false, the leftEdgeSizes, rightEdgeSizes, topEdgeSizes and bottomEdgeSizes properties allow the sizes of edges for the paneContainer to be customized depending on the TabSet.tabBarPosition. The attribute should be specified an EdgeSizes','edgeSizes map, specifying the desired edge sizes where for the appropriate TabSet.tabBarPosition.
		 * Flags: IR */
		topEdgeSizes?: EdgeSizes; // Flags=IR
		/** The size of the tab picker button when Browser.isTouch is true.
		 * Flags: IR, Group: tabBarControls */
		touchPickerButtonSize?: number /* int */; // Flags=IR
		/** Setting this to true turns on a different appearance for tabs, similar to iOS tabs from the "Music" app, where the tab.icon is enlarged and shown as a black and white mask. This mode does not support a clickable icon - clicking the enlarged icon just switches tabs. This attribute only has an effect for tabs that are not Tab.canClose','closable, and only for Mobile WebKit.
		 * Flags: IR */
		useIOSTabs?: boolean /* Boolean */; // Flags=IR
		/** Should we use simple button based tabs styled with CSS rather than image based ImgTab tabs? If set to true the TabSet.simpleTabButtonConstructor will be used and tabs will by styled according to TabSet.simpleTabBaseStyle. 
		 * Flags: IRA */
		useSimpleTabs?: boolean /* Boolean */; // Flags=IRA

		/* Method Overrides */

		/** 
		 * Add a tab
		 * @param {Tab} tab - new tab
		 * @param {number} position - position where tab should be added
		 */
		addTab?(tab:Tab, position?:number): void; 

		/** 
		 * When TabSet.canCloseTabs is set, method fired when the user clicks the "close" icon for a tab. Default implementation will remove the tab from the tabSet via TabSet.removeTab.
		 * @param {Tab} tab - tab to close
		 */
		closeClick?(tab:Tab): void; 

		/** 
		 * Returns the currently selected tab object. This is the object literal used to configure the tab, rather than the tab button widget.
		 */
		getSelectedTab?(): Tab; 

		/** 
		 * Select a tab
		 * @param {number} tab - tab to select
		 */
		selectTab?(tab:number | string | string | Tab /* number | ID | name | Tab */): void; 

		/** 
		 * Notification fired when a tab is selected. Note that this will only fire if this tabSet is drawn. If a tab is selected before TabSet.draw() is called, the tabSelected() notification will fire on draw()
		 * @param {number} tabNum - number of the tab
		 * @param {Canvas} tabPane - pane for this tab
		 * @param {string} ID - id of the tab
		 * @param {Tab} tab - the tab object (not tab button instance)
		 * @param {string} name - the name of the newly selected tab
		 */
		tabSelected?(tabNum:number, tabPane:Canvas, ID:string /* id */, tab:Tab /* tab */, name:string /* String */): void; 

		/** 
		 * Notification method executed when one or more tabs in the TabSet are reordered.
		 * @param {StatefulCanvas} tabCanvas - the live Canvas representing the tab that was moved
		 * @param {number} tabIndex - the new index of the tab in the tabSet
		 */
		tabsReordered?(tabCanvas:StatefulCanvas, tabIndex:number /* Integer */): void; 

	} // TabSetProps


	/**
	 * The TabSet class allows components on several panes to share the same space. The tabs at the top can be selected by the user to show each pane. Tabs are configured via the tabs property, each of which has a pane property which will be displayed in the main pane when that tab is selected. 
	 */
	export interface TabSet extends Canvas {
		/** Appears when TabSet.canAddTabs is enabled.
		 * Flags: IR */
		addTabButton:  ImgButton /* AutoChild ImgButton */;

		/** Icon for the TabSet.addTabButton.
		 * Flags: IR */
		addTabButtonIcon: string /* SCImgURL */;

		/** If TabSet.showTabScroller is true, should tabs be scrolled into view via an animation when the user interacts with the scroller buttons?
		 * Flags: IR, Group: tabBarControls */
		animateTabScrolling: boolean /* Boolean */;

		/** When isc.setScreenReaderMode','screen reader mode is enabled and a tab is TabSet.canCloseTabs','closeable, the ariaCloseableSuffix is a string that is appended to the label of closeable tabs. This suffix is hidden from sighted users, but is announced by screen readers to indicate that the tab may be closed. Set to null to disable appending this suffix.
		 * Flags: IRA, Group: i18nMessages */
		ariaCloseableSuffix: string /* String */;

		/** If this tabSet will TabSet.showPaneContainerEdges','show edges for the paneContainer, and TabSet.symmetricEdges is set to false, the leftEdgeOffsets, rightEdgeOffsets, topEdgeOffsets and bottomEdgeOffsets properties allow the offsets of edges for the paneContainer to be customized depending on the TabSet.tabBarPosition. The attribute should be specified an EdgeSizes','edgeSizes map, specifying the desired edge offsets where for the appropriate TabSet.tabBarPosition.
		 * Flags: IR */
		bottomEdgeOffsets: EdgeSizes;

		/** If this tabSet will TabSet.showPaneContainerEdges','show edges for the paneContainer, and TabSet.symmetricEdges is set to false, the leftEdgeSizes, rightEdgeSizes, topEdgeSizes and bottomEdgeSizes properties allow the sizes of edges for the paneContainer to be customized depending on the TabSet.tabBarPosition. The attribute should be specified an EdgeSizes','edgeSizes map, specifying the desired edge sizes where for the appropriate TabSet.tabBarPosition.
		 * Flags: IR */
		bottomEdgeSizes: EdgeSizes;

		/** Causes the TabSet.addTabButton to appear after the TabSet.tabs and before the TabSet.tabBarControls. There is no default behavior for what happens when the addTabButton is clicked. Add a handler for the TabSet.addTabClicked event to implement a behavior.
		 * Flags: IR */
		canAddTabs: boolean /* Boolean */;

		/** Should tabs in this tabSet show an icon allowing the user to dismiss the tab by clicking on it directly. May be overridden for individual tabs by setting Tab.canClose. The URL for this icon's image will be derived from TabSet.closeTabIcon by default, but may be overridden by explicitly specifying Tab.closeIcon. Note: Currently, tabs can only show a single icon, so a closable tab will show the close icon only even if Tab.icon is set. To work around this, add the icon as an HTML &lt;img&gt; tag to the Tab.title property, for example: title : "&lt;span&gt;" + isc.Canvas.imgHTML("path/to/icon.png") + " Tab Title&lt;/span&gt;" 
		 * Flags: IRW */
		canCloseTabs: boolean;

		/** If true, users can edit the titles of tabs in this TabSet when the TabSet.titleEditEvent','titleEditEvent fires. You can override this behavior per tab with the Tab.canEditTitle property. Note that this TabSet's TabSet.titleEditEvent','titleEditEvent must be set to a supported TabTitleEditEvent in order for users to be able to edit the titles of tabs.
		 * Flags: IRW */
		canEditTabTitles: boolean /* Boolean */;

		/** If true, tabs can be reordered by dragging on them. To disallow drag-reorder of a specific tab, see Tab.canReorder.
		 * Flags: IR, Group: dragdrop */
		canReorderTabs: boolean;

		/** Default src for the close icon for tabs to display if TabSet.canCloseTabs is true.
		 * Flags: IR */
		closeTabIcon: string /* SCImgURL */;

		/** Size in pixels of the icon for closing tabs, displayed when TabSet.canCloseTabs is true.
		 * Flags: IR */
		closeTabIconSize: number /* int */;

		/** If set, is passed as "height" to all tabs when TabSet.tabBarPosition is set to "left" or "right". If unset, height will be picked up from the Tab constructor class defaults. Note that tabs expand to fit their content so this height acts as a minimum. May be customized by individual skinning','skins.
		 * Flags: IR */
		defaultTabHeight: number;

		/** If set, is passed as "width" to all tabs when TabSet.tabBarPosition is set to "top" or "bottom". If unset, width will be picked up from the Tab constructor class defaults. Tabs expand to fit their content, so this width acts as a minimum. Setting width:1 will result in tabs that are only as wide as their titles. May be customized by individual skinning','skins.
		 * Flags: IR */
		defaultTabWidth: number;

		/** Whether Canvas.destroy','destroy() should be called on Tab.pane when it a tab is removed via TabSet.removeTab. With the default setting of null panes will be automatically destroyed. An application might set this to false in order to re-use panes in different tabs or in different parts of the application.
		 * Flags: IR */
		destroyPanes: boolean;

		/** Default class used to construct the EditProxy for this component when the component is Canvas.setEditMode','first placed into edit mode.
		 * Flags: IR */
		editProxyConstructor: string /* SCClassName */;

		/** If this tabSet will TabSet.showPaneContainerEdges','show edges for the paneContainer, and TabSet.symmetricEdges is set to false, the leftEdgeOffsets, rightEdgeOffsets, topEdgeOffsets and bottomEdgeOffsets properties allow the offsets of edges for the paneContainer to be customized depending on the TabSet.tabBarPosition. The attribute should be specified an EdgeSizes','edgeSizes map, specifying the desired edge offsets where for the appropriate TabSet.tabBarPosition.
		 * Flags: IR */
		leftEdgeOffsets: EdgeSizes;

		/** If this tabSet will TabSet.showPaneContainerEdges','show edges for the paneContainer, and TabSet.symmetricEdges is set to false, the leftEdgeSizes, rightEdgeSizes, topEdgeSizes and bottomEdgeSizes properties allow the sizes of edges for the paneContainer to be customized depending on the TabSet.tabBarPosition. The attribute should be specified an EdgeSizes','edgeSizes map, specifying the desired edge sizes where for the appropriate TabSet.tabBarPosition.
		 * Flags: IR */
		leftEdgeSizes: EdgeSizes;

		/** When AutoTest.getElement is used to parse locator strings generated by AutoTest.getLocator, how should tabs within this tabset be identified? By default if tab has a specified Tab.ID this will always be used. For tabs with no ID, the following options are available: "title" use the title as an identifier "index" use the index of the tab in the tabset as an identifier If unset, and the tab has no specified ID, default behavior is to identify by title (if available), otherwise by index.
		 * Flags: IRWA, Group: autoTest */
		locateTabsBy: string;

		/** Tab to be shown when TabSet.showMoreTab is enabled more than TabSet.moreTabCount tabs are provided.
		 * Flags: R */
		moreTab:  Tab /* AutoChild Tab */;

		/** This property defines the number tab buttons that should be shown before automatically adding a "more" button to handle the remaining tabs. This property is only used when TabSet.showMoreTab is enabled.
		 * Flags: IR */
		moreTabCount: number;

		/** If TabSet.showMoreTab is enabled this property determines the image to display on the "More" tab button.
		 * Flags: IR */
		moreTabImage: string /* SCImgURL */;

		/** Pane contents for the "more" tab based on a VLayout. Typically contains a NavigationBar and TableView.
		 * Flags: R */
		moreTabPane:  VLayout /* AutoChild VLayout */;

		/** Default properties for the "more" tab's pane. Currently constructs a VLayout with a NavigationBar and TableView.
		 * Flags: IR */
		moreTabPaneDefaults: CanvasProps /* Canvas Properties */;

		/** Navigation bar shown in the TabSet.moreTabPane;
		 * Flags: IR */
		moreTabPaneNavBar:  NavigationBar /* AutoChild NavigationBar */;

		/** Properties to apply to the "more" tab's pane created by this TabSet.
		 * Flags: IR */
		moreTabPaneProperties: CanvasProps /* Canvas Properties */;

		/** TableView used to show links to other tabs in the TabSet.moreTabPane;
		 * Flags: IR */
		moreTabPaneTable:  TableView /* AutoChild TableView */;

		/** Properties to apply to the "more" tab created by this TabSet.
		 * Flags: IR */
		moreTabProperties: Tab /* Tab Properties */;

		/** Title for the "More" tab.
		 * Flags: IR */
		moreTabTitle: string /* String */;

		/** Container where the component specified by Tab.pane is shown. Note: paneContainer and showEdges:true for rounded tabsets: you can enable decorative image-based edges on the paneContainer by setting Canvas.showEdges','showEdges:true via paneContainerDefaults (to skin all tabsets) or paneContainerProperties (to use edges on one instance). In this structure, the baseLine should use media that matches the appearance of the decorative edges and fully overlaps the edge of the paneContainer that it is adjacent to. In the most typical appearance (symmetric edges on all 4 sides), both TabBar.baseLineCapSize and TabBar.baseLineThickness match the Canvas.edgeSize','edgeSize set on the paneContainer. See the load_skin.js file for the "SmartClient" skin for an example of setting all relevant properties. To disable edges for a particular TabSet, which you may want to do for a TabSet that is already within a clearly defined container, configure the paneContainer to show only it's top edge: paneContainerProperties : { customEdges:["T"] }, To completely flatten even the top edge of the TabSet: paneContainerProperties : { customEdges:["T"] }, tabBarProperties :{ baseLineCapSize:0 }, This "flattens" the baseLine so that only the center image is used.
		 * Flags: R */
		paneContainer:  VLayout /* AutoChild VLayout */;

		/** CSS style used for the paneContainer.
		 * Flags: IRW */
		paneContainerClassName: string /* CSSStyleName */;

		/** Specifies the overflow of the pane container (the component that holds the pane contents for all tabs). By default this is set to "auto", meaning the pane container will automatically introduce scrolling when the pane contents exceed the TabSet's specified size. For other values and their meaning, see Overflow
		 * Flags: IRWA */
		paneContainerOverflow: Overflow;

		/** Space to leave around the panes in our paneContainer Note that this property may be specified on a per-tab basis via Tab.paneMargin.
		 * Flags: IR */
		paneMargin: number /* int */;

		/** If TabSet.showTabPicker is true, and TabSet.symmetricPickerButton is set to true, this property governs the base URL for the picker button image, when displayed in a horizontal tab-bar [IE TabSet.tabBarPosition is set to "top" or "bottom"]. Note that if symmetricPickerButton is false, the TabSet.pickerButtonSrc property will be used instead. This base URL will have a suffix of "Down" appended when the user holds the mouse down over the button, and "Disabled" if the tabset as a whole is disabled.
		 * Flags: IR, Group: tabBarScrolling */
		pickerButtonHSrc: string /* SCImgURL */;

		/** If TabSet.showTabPicker','showTabPicker is true and Browser.isTouch is false, this property governs the size of the tab picker button. This value is applied as the width of the tab picker button if the TabSet.tabBar','tabBar is horizontal, or the height if the tabBar is vertical. Note that the other dimension is determined by TabSet.tabBarThickness','this.tabBarThickness. On touch browsers (where Browser.isTouch is true), TabSet.touchPickerButtonSize','touchPickerButtonSize is used instead.
		 * Flags: IR, Group: tabBarControls */
		pickerButtonSize: number /* int */;

		/** If TabSet.showTabPicker is true, this property governs the base URL for the picker button image, when TabSet.symmetricPickerButton is set to false Note that if symmetricPickerButton is true, the TabSet.pickerButtonHSrc and TabSet.pickerButtonVSrc properties will be used instead. To get the path to the image to display, this base URL will be modified as follows: If appropriate a state suffix of "Down" or "Disabled" will be appended. The TabSet.tabBarPosition','tabBarPosition for this tabSet will be appended. 
		 * Flags: IR, Group: tabBarScrolling */
		pickerButtonSrc: string /* SCImgURL */;

		/** If TabSet.showTabPicker is true, and TabSet.symmetricPickerButton is set to true, this property governs the base URL for the picker button image, when displayed in a verricaL tab-bar [IE TabSet.tabBarPosition is set to "LEFT" or "right"]. Note that if symmetricPickerButton is false, the TabSet.pickerButtonSrc property will be used instead. This base URL will have a suffix of "Down" appended when the user holds the mouse down over the button, and "Disabled" if the tabset as a whole is disabled.
		 * Flags: IR, Group: tabBarScrolling */
		pickerButtonVSrc: string /* SCImgURL */;

		/** If this tabSet will TabSet.showPaneContainerEdges','show edges for the paneContainer, and TabSet.symmetricEdges is set to false, the leftEdgeOffsets, rightEdgeOffsets, topEdgeOffsets and bottomEdgeOffsets properties allow the offsets of edges for the paneContainer to be customized depending on the TabSet.tabBarPosition. The attribute should be specified an EdgeSizes','edgeSizes map, specifying the desired edge offsets where for the appropriate TabSet.tabBarPosition.
		 * Flags: IR */
		rightEdgeOffsets: EdgeSizes;

		/** If this tabSet will TabSet.showPaneContainerEdges','show edges for the paneContainer, and TabSet.symmetricEdges is set to false, the leftEdgeSizes, rightEdgeSizes, topEdgeSizes and bottomEdgeSizes properties allow the sizes of edges for the paneContainer to be customized depending on the TabSet.tabBarPosition. The attribute should be specified an EdgeSizes','edgeSizes map, specifying the desired edge sizes where for the appropriate TabSet.tabBarPosition.
		 * Flags: IR */
		rightEdgeSizes: EdgeSizes;

		/** A component containing back and forward buttons for scrolling through all of the tabs of the TabSet. The scroller is created automatically when needed and when "tabScroller" is specified in the TabSet.tabBarControls. By default, the scroller constructor is StretchImgButton. Note that the scroller StretchImg.items','items are determined automatically, so any items set in scrollerProperties will be ignored.
		 * Flags: R, Group: tabBarControls */
		scroller:  StretchImgButton /* AutoChild StretchImgButton */;

		/** If TabSet.showTabScroller is true, this property governs the size of scroller buttons. Applied as the width of buttons if the tabBar is horizontal, or the height if tabBar is vertical. Note that the other dimension is determined by TabSet.tabBarThickness','this.tabBarThickness
		 * Flags: IR, Group: tabBarControls */
		scrollerButtonSize: number;

		/** If this TabSet is showing TabSet.showTabScroller','tab scroller buttons, and TabSet.symmetricScroller','symmetricScroller is true, this property governs the base URL for the tab bar back and forward scroller button images for horizontal tab bars [IE for tab sets with TabSet.tabBarPosition','tabBarPosition set to "top" or "bottom"]. Note that if TabSet.symmetricScroller','symmetricScroller is false, TabSet.scrollerSrc will be used instead. To get the path to the image to display, this base URL will be modified as follows: If appropriate a state suffix of "Down" or "Disabled" will be appended. A suffix of "forward" or "back" will be appended for the forward or backward scrolling button. For example - if the scrollerHSrc is set to "[SKIN]hscroll.gif", the image displayed for the back-scroller button on a tabSet with tabBarPosition set to "top" and symmetricScroller set to true would be one of "[SKIN]hscroll_back.gif", "[SKIN]hscroll_Down_back.gif", and "[SKIN]hscroll_Disabled_back.gif". Note that for best results the media should be sized to match the scroller button sizes, determined by TabSet.tabBarThickness and TabSet.scrollerButtonSize.
		 * Flags: IR, Group: tabBarScrolling */
		scrollerHSrc: string /* SCImgURL */;

		/** If this TabSet is showing TabSet.showTabScroller','tab scroller buttons, and TabSet.symmetricScroller','symmetricScroller is false, this property governs the base URL for the tab bar back and forward scroller button images. Note that if TabSet.symmetricScroller','symmetricScroller is true, TabSet.scrollerHSrc and TabSet.scrollerVSrc will be used instead. To get the path to the image to display, this base URL will be modified as follows: If appropriate a state suffix of "Down" or "Disabled" will be appended. The TabSet.tabBarPosition','tabBarPosition for this tabSet will be appended. A suffix of "forward" or "back" will be appended for the forward or backward scrolling button. For example - if the scrollerSrc is set to "[SKIN]scroll.gif", the image displayed for the back-scroller button on a tabSet with tabBarPosition set to "top" and symmetricScroller set to false would be one of "[SKIN]scroll_top_back.gif", "[SKIN]scroll_Down_top_back.gif", and "[SKIN]scroll_Disabled_top_back.gif". Note that for best results the media should be sized to match the scroller button sizes, determined by TabSet.tabBarThickness and TabSet.scrollerButtonSize.
		 * Flags: IR, Group: tabBarScrolling */
		scrollerSrc: string /* SCImgURL */;

		/** If this TabSet is showing TabSet.showTabScroller','tab scroller buttons, and TabSet.symmetricScroller','symmetricScroller is true, this property governs the base URL for the tab bar back and forward scroller button images for vertical tab bars [IE for tab sets with TabSet.tabBarPosition','tabBarPosition set to "left" or "right"]. Note that if TabSet.symmetricScroller','symmetricScroller is false, TabSet.scrollerSrc will be used instead. To get the path to the image to display, this base URL will be modified as follows: If appropriate a state suffix of "Down" or "Disabled" will be appended. A suffix of "forward" or "back" will be appended for the forward or backward scrolling button. For example - if the scrollerVSrc is set to "[SKIN]vscroll.gif", the image displayed for the back-scroller button on a tabSet with tabBarPosition set to "left" and symmetricScroller set to true would be one of "[SKIN]vscroll_back.gif", "[SKIN]vscroll_Down_back.gif", and "[SKIN]vscroll_Disabled_back.gif". Note that for best results the media should be sized to match the scroller button sizes, determined by TabSet.tabBarThickness and TabSet.scrollerButtonSize.
		 * Flags: IR, Group: tabBarScrolling */
		scrollerVSrc: string /* SCImgURL */;

		/** Specifies the index of the initially selected tab.
		 * Flags: IRW, Group: tabBar */
		selectedTab: number;

		/** Should tabs exceeding TabSet.moreTabCount be shown on a "more" tab? This setting is used to emulate an iPhone-style tab bar "more" button.
		 * Flags: IR */
		showMoreTab: boolean;

		/** Should the paneContainer for this tabset show Canvas.showEdges','edges.
		 * Flags: IRWA */
		showPaneContainerEdges: boolean;

		/** If the paneContainer for this tab set is showing Canvas.showEdges','edges, setting this attribute to true will set the paneContainer to show Canvas.customEdges','customEdges for the three sides opposing the tabBarPosition.
		 * Flags: IRA */
		showPartialEdges: boolean /* Boolean */;

		/** Should the tabBar be displayed or not If shrinkElementOnHide is true, the paneContainer will expand over the space occupied by TabBar
		 * Flags: IRW */
		showTabBar: boolean /* Boolean */;

		/** If there is not enough space to display all the tab-buttons in this tabSet, should a drop-down "picker" be displayed to allow selection of tabs that are clipped?
		 * Flags: IR, Group: tabBarControls */
		showTabPicker: boolean /* Boolean */;

		/** If there is not enough space to display all the tab-buttons in this tabSet, should scroll buttons be displayed to allow access to tabs that are clipped? If unset, defaults to false for Browser.isHandset','handsets and true otherwise.
		 * Flags: IR, Group: tabBarControls */
		showTabScroller: boolean /* Boolean */;

		/** If this.useSimpleTabs is true, simpleTabBaseClass will be the base style used to determine the css style to apply to the tabs. This property will be suffixed with the side on which the tab-bar will appear, followed by with the tab's state (selected, over, etc), resolving to a className like "tabButtonTopOver"
		 * Flags: IRW */
		simpleTabBaseStyle: string /* CSSStyleName */;

		/** Tab button constructor if TabSet.useSimpleTabs is true.
		 * Flags: IRA */
		simpleTabButtonConstructor: Class;

		/** Default directory for skin images (those defined by the class), relative to the Page-wide Page.getSkinDir','skinDir.
		 * Flags: IR, Group: images */
		skinImgDir: string;

		/** If this tabSet will TabSet.showPaneContainerEdges','show edges for the paneContainer, this property determines whether the same edge media will be used regardless of the tab bar position, or whether different media should be used (necessary if the edge appearance is not symmetrical on all sides). If this property is set to false the paneContainer edge image URLs will be prefixed with the tabBarPosition of the tabSet - for example "[SKIN]edge_top_T.gif" rather than just "[SKIN]edge_T.gif". When symmetricEdges is false, custom edge sizes for the pane container may be specified via TabSet.topEdgeSizes et al, and custom edge offsets via TabSet.topEdgeOffsets et al.
		 * Flags: IR */
		symmetricEdges: boolean /* Boolean */;

		/** If this TabSet is showing a TabSet.showTabPicker','tab picker button, this property determines whether the TabSet.pickerButtonHSrc and TabSet.pickerButtonVSrc media will be used for vertical and horizontal tab-bar picker buttons, or whether separate media should be used for each possible TabSet.tabBarPosition','tabBarPosition based on the TabSet.pickerButtonSrc property for this tabSet.
		 * Flags: IR, Group: tabBarScrolling */
		symmetricPickerButton: boolean /* Boolean */;

		/** If this TabSet is showing TabSet.showTabScroller','tab scroller buttons, this property determines whether the TabSet.scrollerHSrc and TabSet.scrollerVSrc media will be used for vertical and horizontal tab-bar scroller buttons, or whether separate media should be used for each possible TabSet.tabBarPosition','tabBarPosition based on the TabSet.scrollerSrc property for this tabSet.
		 * Flags: IR, Group: tabBarScrolling */
		symmetricScroller: boolean /* Boolean */;

		/** TabBar for this TabSet, an instance of TabBar.
		 * Flags: R */
		tabBar:  TabBar /* AutoChild TabBar */;

		/** Alignment of the tabBar. If the TabSet.tabBarPosition','tabBarPosition is "top" or "bottom", then this attribute may be set to "left", "right" or "center". The default is "left", or "right" in Page.isRTL','RTL mode. If the TabSet.tabBarPosition','tabBarPosition is "left" or "right", then this attribute may be set to "top", "bottom" or "center". The default is "top".
		 * Flags: IR, Group: tabBar */
		tabBarAlign: Side | Alignment;

		/** AutoChild of type Layout that holds the TabSet.tabBarControls as well as the built-in controls such as the TabSet.showTabPicker','tab picker menu.
		 * Flags: IR */
		tabBarControlLayout:  Layout /* AutoChild Layout */;

		/** This property determines what controls should show up after the tabBar for this TabSet. Standard controls can be included using the strings "tabScroller" and "tabPicker". These correspond to the TabSet.scroller and TabSet.tabPicker AutoChildren, respectively. The "tabScroller" standard control shows two buttons for scrolling through the tabs in order and the "tabPicker" standard control allows tabs to be picked directly from a menu. The standard controls show up only if TabSet.showTabScroller or TabSet.showTabPicker is true and there is not enough space available to show all of the tabs in the tabBar. layout_tabs_custom_controls', 'This sample illustrates the usage of this property Additional controls can be included by adding any widget to this array. Controls will show up in the order in which they are specified. For example, the following code would add a button in the tabBar area, while preserving the normal behavior of the tabScroller and tabPicker: isc.TabSet.create({ width:300, tabs : [ { title: "Tab one" } ], tabBarControls : [ isc.ImgButton.create({ src:"[SKINIMG]/actions/add.png", width:16, height:16, layoutAlign:"center" }), "tabScroller", "tabPicker" ] }); You can also refer to the default tabPicker/tabScroll controls from Component XML: &lt;TabSet width="300"&gt; &lt;tabBarControls&gt; &lt;Button title="Custom Button"/&gt; &lt;value xsi:type="string"&gt;tabPicker&lt;/value&gt; &lt;value xsi:type="string"&gt;tabScroller&lt;/value&gt; &lt;/tabBarControls&gt; &lt;tabs&gt; &lt;tab title="Foo"/&gt; &lt;tab title="Bar"/&gt; &lt;/tabs&gt; &lt;/TabSet&gt; When Browser.isTouch is true and native touch scrolling is supported, then by default, only the "tabPicker" is shown. The "tabScroller" control is omitted by default on touch devices because the tabs in the tab bar are native touch-scrollable, so the "tabScroller" control is unnecessary. To override the omission of the "tabScroller", simply add "tabScroller" to the tabBarControls array.
		 * Flags: IRA, Group: tabBarControls */
		tabBarControls: Array<any> /* Array */;

		/** Which side of the TabSet the TabBar should appear on.
		 * Flags: IR, Group: tabBar */
		tabBarPosition: Side;

		/** This attribute allows developers to specify custom properties for this tabset's TabSet.tabBar
		 * Flags: IR */
		tabBarProperties: TabBarProps /* TabBar Properties */;

		/** Thickness of tabBar, applies to either orientation (specifies height for horizontal, width for vertical orientation). Note that overriding this value for TabSets that are skinned with images generally means providing new media for the borders.
		 * Flags: IRW, Group: tabBar */
		tabBarThickness: number;

		/** A button control that allows tabs to be picked directly from a popup menu. The tabPicker is created automatically when needed and when "tabPicker" is specified in the TabSet.tabBarControls.
		 * Flags: R, Group: tabBarControls */
		tabPicker:  ImgButton /* AutoChild ImgButton */;

		/** Properties to apply to all Tabs created by this TabSet.
		 * Flags: IR */
		tabProperties: Tab /* Tab Properties */;

		/** An array of Tab objects, specifying the title and pane contents of each tab in the TabSet. When developing in JavaScript, tabs are specified as an array of object literals, not instances - see Tab. After providing Tab instances to setTabs(), the TabSet creates actual UI widgets to serve as interactive tabs. Any further modifications to tabs should be performed via TabSet APIs such as TabSet.setTabTitle, TabSet.setTabIcon and TabSet.setTabPane. You can add and remove tabs after creating the TabSet by calling TabSet.addTab and TabSet.removeTab
		 * Flags: IRW */
		tabs: Array<Tab> /* Array of Tab */;

		/** The event that triggers title editing on this TabSet.
		 * Flags: IRW */
		titleEditEvent: TabTitleEditEvent;

		/** TextItem we use to edit tab titles in this TabSet. You can override this property using the normal AutoChild facilities.
		 * Flags: R */
		titleEditor:  TextItem /* AutoChild TextItem */;

		/** If set, offsets the tab title editor further in from the left-hand edge of the tab, by the number of pixels set in this property. Note that the editor is always offset to avoid overlapping the endcaps of the tab; this property is applied on top of that default offset.
		 * Flags: IRW */
		titleEditorLeftOffset: number /* Integer */;

		/** Properties for the auto-generated TabSet.titleEditor. This is the text item we use to edit tab titles in this tabSet.
		 * Flags: IR */
		titleEditorProperties: TextItemProps /* TextItem properties */;

		/** If set, offsets the tab title editor further in from the right-hand edge of the tab, by the number of pixels set in this property. Note that the editor is always offset to avoid overlapping the endcaps of the tab; this property is applied on top of that default offset.
		 * Flags: IRW */
		titleEditorRightOffset: number /* Integer */;

		/** If set, offsets the tab title editor further down from the top edge of the tab, by the number of pixels set in this property. You can use this property, together with the left and right offset properties, to fine tune positioning of the editor within or around the tab button. Note: The height of the editor is an attribute of the editor itself, and can be set by specifying a "height" property in TabSet.titleEditor','titleEditorDefaults.
		 * Flags: IRW */
		titleEditorTopOffset: number /* Integer */;

		/** If this tabSet will TabSet.showPaneContainerEdges','show edges for the paneContainer, and TabSet.symmetricEdges is set to false, the leftEdgeOffsets, rightEdgeOffsets, topEdgeOffsets and bottomEdgeOffsets properties allow the offsets of edges for the paneContainer to be customized depending on the TabSet.tabBarPosition. The attribute should be specified an EdgeSizes','edgeSizes map, specifying the desired edge offsets where for the appropriate TabSet.tabBarPosition.
		 * Flags: IR */
		topEdgeOffsets: EdgeSizes;

		/** If this tabSet will TabSet.showPaneContainerEdges','show edges for the paneContainer, and TabSet.symmetricEdges is set to false, the leftEdgeSizes, rightEdgeSizes, topEdgeSizes and bottomEdgeSizes properties allow the sizes of edges for the paneContainer to be customized depending on the TabSet.tabBarPosition. The attribute should be specified an EdgeSizes','edgeSizes map, specifying the desired edge sizes where for the appropriate TabSet.tabBarPosition.
		 * Flags: IR */
		topEdgeSizes: EdgeSizes;

		/** The size of the tab picker button when Browser.isTouch is true.
		 * Flags: IR, Group: tabBarControls */
		touchPickerButtonSize: number /* int */;

		/** Setting this to true turns on a different appearance for tabs, similar to iOS tabs from the "Music" app, where the tab.icon is enlarged and shown as a black and white mask. This mode does not support a clickable icon - clicking the enlarged icon just switches tabs. This attribute only has an effect for tabs that are not Tab.canClose','closable, and only for Mobile WebKit.
		 * Flags: IR */
		useIOSTabs: boolean /* Boolean */;

		/** Should we use simple button based tabs styled with CSS rather than image based ImgTab tabs? If set to true the TabSet.simpleTabButtonConstructor will be used and tabs will by styled according to TabSet.simpleTabBaseStyle. 
		 * Flags: IRA */
		useSimpleTabs: boolean /* Boolean */;


		/* Instance Method Overrides */

		/** 
		 * Add a tab
		 * @param {Tab} tab - new tab
		 * @param {number} position - position where tab should be added
		 */
		addTab?(tab:Tab, position?:number): void; 

		/** 
		 * When TabSet.canCloseTabs is set, method fired when the user clicks the "close" icon for a tab. Default implementation will remove the tab from the tabSet via TabSet.removeTab.
		 * @param {Tab} tab - tab to close
		 */
		closeClick?(tab:Tab): void; 

		/** 
		 * Returns the currently selected tab object. This is the object literal used to configure the tab, rather than the tab button widget.
		 */
		getSelectedTab?(): Tab; 

		/** 
		 * Select a tab
		 * @param {number} tab - tab to select
		 */
		selectTab?(tab:number | string | string | Tab /* number | ID | name | Tab */): void; 

		/** 
		 * Notification fired when a tab is selected. Note that this will only fire if this tabSet is drawn. If a tab is selected before TabSet.draw() is called, the tabSelected() notification will fire on draw()
		 * @param {number} tabNum - number of the tab
		 * @param {Canvas} tabPane - pane for this tab
		 * @param {string} ID - id of the tab
		 * @param {Tab} tab - the tab object (not tab button instance)
		 * @param {string} name - the name of the newly selected tab
		 */
		tabSelected?(tabNum:number, tabPane:Canvas, ID:string /* id */, tab:Tab /* tab */, name:string /* String */): void; 

		/** 
		 * Notification method executed when one or more tabs in the TabSet are reordered.
		 * @param {StatefulCanvas} tabCanvas - the live Canvas representing the tab that was moved
		 * @param {number} tabIndex - the new index of the tab in the tabSet
		 */
		tabsReordered?(tabCanvas:StatefulCanvas, tabIndex:number /* Integer */): void; 

	} // TabSet

	export interface TabSetStatic<T, P> extends CanvasStatic<T, P> {
	} // TabSetStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a Task Props argument.
	 * This is derived from the methods in the Task class and it's parents and their properties marked with the I flag.
	 */
	export interface TaskProps  {
		/** Field in the Process.state','process state which is provided as input data to this task. See taskIO.
		 * Flags: IR */
		inputField?: string /* String */; // Flags=IR
		/** List of multiple fields from the Process.state','process state which are provided as input data to this task. See taskIO. If Task.inputField is also specified, it will be implicitly added to the inputFieldList if it is not already present.
		 * Flags: IR */
		inputFieldList?: Array<string> /* Array of String */; // Flags=IR
		/** Field in the Process.state','process state which this task writes outputs to. See taskIO.
		 * Flags: IR */
		outputField?: string /* String */; // Flags=IR
		/** List of multiple fields from the Process.state','process state which this task will write to. See taskIO. If Task.outputField is also specified, it will be implicitly added to the outputFieldList if it is not already present.
		 * Flags: IR */
		outputFieldList?: Array<string> /* Array of String */; // Flags=IR
	} // TaskProps


	/**
	 * A Task is an abstract superclass for Process and for all Task types that can be involved in a Process, such as a ServiceTask. 
	 */
	export interface Task  {
		/** Field in the Process.state','process state which is provided as input data to this task. See taskIO.
		 * Flags: IR */
		inputField: string /* String */;

		/** List of multiple fields from the Process.state','process state which are provided as input data to this task. See taskIO. If Task.inputField is also specified, it will be implicitly added to the inputFieldList if it is not already present.
		 * Flags: IR */
		inputFieldList: Array<string> /* Array of String */;

		/** Field in the Process.state','process state which this task writes outputs to. See taskIO.
		 * Flags: IR */
		outputField: string /* String */;

		/** List of multiple fields from the Process.state','process state which this task will write to. See taskIO. If Task.outputField is also specified, it will be implicitly added to the outputFieldList if it is not already present.
		 * Flags: IR */
		outputFieldList: Array<string> /* Array of String */;

	} // Task

	export interface TaskStatic<T, P> extends ClassStatic<T, P> {
	} // TaskStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a TextAreaItem Props argument.
	 * This is derived from the methods in the TextAreaItem class and it's parents and their properties marked with the I flag.
	 */
	export interface TextAreaItemProps extends FormItemProps {
		browserAutoCapitalize?: boolean /* Boolean */; // Flags=IRA
		/** In Mobile Safari, should automatic correction be offered for text in the item's text box? If null, then Mobile Safari determines automatically whether to enable autocorrect. When enabled, Mobile Safari displays "autocorrect bubbles" to suggest automatic corrections: <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAABaCAIAAACNE/xKAAANy0lEQVR4Ae2dB3hV5R3G7d6tdW9wgIoDtQ4cldZRq9Q9invSKlVkqgzZIIgICohKQUCUEBNIghjEhARCCJgACUrYZJA9ySAhi9Nf8vU5z9d7yXhI48017/t8T5573nPOHXB+9z++7yTHOD6VJEmCUJIEoSQJQkmSBKEkCUJJag8ShKGx6b2HBWtoaLTpWLZmR6MQrtxSLA41NNqawOXrdzcFIcORJKnNBIGCsAlJkiCUJEH43sr0xNTidjuSUosdSRKEvh2OJAlCQShJglCSBKEglCRBKEmCUBBKkiCUJEEoCCVJEEqSDyQIJanjQRjzTfrwKR/2fv7VB/sMHvbmB1+s32bvXRAazd41SamRm/aMnv7R/c8OHDTu3aCIeLM3JHrL4PEz7n6yX99hk7+K32XM0DWJnDLns1X288wNjsD8ZMU623x3YSgmb6DjQigJwilzAo/t3P2YYzsxfnjc2fz8+SnnA4Z7wOMvjcCcMGvRcedczgMzfnzCufNDot5ZEPKTE89zzV+fcRH4ccqyqM1sdr36VvuFLr6hF+ZN9z3tOpv3Ff6u06W8+qa9BYKwg0oQQsvPTu7605O6EAAJRxt2ZMPkb8+6BFqmz19mQwh1Pe9+YtHnMWB23zMDcIAHXAeOfYcISTzs8de/Y/Z6tK85q1P3G9lkl9lcuzXtB7/vjPObMy+GPWOCMQ5RVOlox5UgvPKW+8HgtUmzbXP24i8wT72wR8KefBfCzpf1BFFzQOy2DBMzH+k71D0rODIBp8tVt5jNJ/q9zub4mR+78ZZNQ+bi8PXGfGbgGEO7IOygEoQkgSSTvzztwvjdeR5wwhJ4wJUL4QPPDbIPINXEBFfXgUyc48+9wmzOWxppB0YqSbgdNW0e5oAx04153pU3E0thu4NCKAnCsLVJduyyx18e6sOuqXODXAj7j55mH9C9512GUhtpHOpGd5N8lc0tKUVsntbtWmpCslOOue6Oh3HC45LdErGDQigJQlOSXXHTvd4Q3vt0f3bRC3Uh5LE3hEtXb2oMQsadj7+IE7AyztD+7KCxJvr94tQLSHSHTn4fc9yMhR0XQkkQRiTsBgNilDeE197em100P1sDIYEU5+VRb9P14cGHgV9iPvbicB7D//W9HvnR8ecw89GhIZTUmPnV6d0o1VbEfmub65MzmTkAFSYMWwMhz0PNedWtD5Dc0oDduDMHc8bHYRz2VP9ROOzSZL3U0SHsM2S8KcxMI5ThBitDSGsgZNzwt0eZ2wDpa257yDhx27Nw6Mdw8CsTZ3V0CCVBSGfSTBt0u+52ZvyYqzCJ6AU9bmNmr/UQjnhrDiaj38iprnn5n+/BMZG2o0MoCUKTNDL9QHJowDixy5XMK0QnprCr9RCu+nonJoNZftd8Yegkw7nWjkqOILQRYtULq2G0gFuSdBeFJAlCQShJglCSBKEglCRBKEmCUBBKkiCUJD+Q/jSaJPkPhJ9KfqLFixcHBAQEBgYGBweHhISEh4dHRUVt3Lhx69atWVlZ1dXVjv9KEDp+Jelwg2praysrK0tKSnJychISEoKCglauXJmUlITp+ESSIJRqamrS0tKWLl0aFxcnFAWh5Ms4SXYKinv37nUkQSj5MCquXbuWihEmHZ9IEoRSbd3h6JjYoLDwqO350TsKfDU0uEG3KQjj95R8jyGUCIJx8ZuXha8WCT7nsFEI0fceQik2Nnbbtm2O7yV1YAjVqgkLCysqKnL8VIKQ/8J9+dXLE8tnrT4QvKksMf2QI/2ftD2r6tvMqvTCGqeNVVxcHBER4fidBCGV/bRVxZ1eST3h5RR7XDsxY0Fsqdpurdc5r6Xx7/nU3Fyn7RUTE5ORkeH4kQQh0e/2aVmGuuvfyHh+Yd4bK4pe+iT/0lHpxnxybm7ZoTqnLSUImXxn5p2FaU6T4gAO42CncbG2Zs2aNY6/SBBW1Ry+etx+ro+LXk9fkVTuWKqpPTwz8oDh8LE5OU5bShDGGRkOmyTQyGlSoaGhFRUVjl9IEL69qpiL4+xXU3NKjlyujAotNBwu+brMkY5W5zZA+PS83JYAxuOjOMBWcnLyvn37nPYvQZhVXHPm4Po68P3okia6NY98mMMxf5yU4ZofrSsxp2QW18xfV/qvRXmkr3PWlhSV1zrNiXM/aDiXLsXcmJJ/LMgbE1YYkXywru6wicyfJ5W/FlTw7Ee5U1YW84RuWH4v6gAdI96z4yUKV3bllh7h1RfF1e8i5bbNzWmHML2/Vnhj+JXVda6TkHJodtSBgUvyH/937vClhfNiSgqtzxi3t5LjQ7eUO17allnFLje5uGx0fW7Pv1Kzqea6BnlgxqbxW0IgokHKGhqn/UsQBmws48o4b2gal7jTuKDCBENafMY5f1jaKQNStqQd6josDd8d3UelJ+1vpqfKuacPSl2/p7Lz//aBJnxeVFFV99DsHNu8YHiaS92d72bhTP7Cs/++I7sKn6etPtKnoMRlL1WubUI45mkDU3hF1/wmowrzmvH7zWZZZd3AgHwcj8FbWrerwhwTs6sC56whqeVeNfMzvIT17XbTlEw2X19W6DQpA5vLYeNm82vZuAHKaf8ShFz3XBm3Ts10mlRaQbW5/hauL3VBYpNuKmAQxHbnVAfGl1FVYt49I7tZCE/sn3LG4FSOZDokPqWy36f55vlvnJRBNygooYwnXLa53BA+ICDfMe9/QymbV41rgMQSgRSfMOUcSSFbyj0+IyGX7x3zimt2Vrj+1C+LcUaHFprNVz8rYPO6iRnE0j151btyqqiQe0zIwPzTm5lumnDFmP04fHzH0oGDtRDO91R+Wa1x7puVzWG8hNlsOYdHQaB5Y9yI6LR/CUJKFK6M5+bntrCkeTO82IaQVqodQokPmIy80tqmITQXt91xNZfyyQNSCGuu+UkDdZBpNok2nYak4pAi2kRdPDIdkzjmeMkEtFMHpoC9m9kSwDneED5+eZF75G1vZ+F8va+Sx6WV/30tvg4cS+FbD2Iysg/UGGdyeDGbBHCP9BiTDNYj9pJ+m82Wc3gUBBotWbLEaf8ShCZHovXiNKeb36o/clhwgQ0S1Z1jidQOk5GcVdUshDMiDtgmVSUmcdU2N+6rxIR/16GmwiFGuU70jgqcnpMBtVE9ODubYwitdi9qWsNPwDMmIQtQu41IN5Oih2oOUzeu2nbQsWR8vinq4cytttOEk/qn2BXpHdOzMO1u86AlBTgEeQe1jMPWEOg3C6QEIQkhV0bfRXlOc7pweJq5cG2QVm/3bIJ3aUjzKAubhTAssdw2iUiYL9K3sEQUwqR0dB0qSVP+uRH4hY/zcOidOI2L+MMxL3+abzbvmpFtAiPBEKIIlZiLG8pjikDHS0Rsgudn8WW8yV4NdDF2WhH7npnZdvlHE8i7RjUfkNRdECJB6Bl/TDRoQlyF5sqjkWOD5A0bTYsWQkic8YZwSGCBbRJtPCBE1ISYX3570CSoNEXc0qsxZRTVcMolI9PNKWSnt7yV6fZOeCo3M/+K0GcFdtqbZhLVHXwZeUNIQYhDsmA2aR3ZWYMRT+WRSDtI6agg5NvdXOUmGjQmIp658vYX1dggbW0FhJx7dBCa9kmf+Xk8Zo6hhQsJTOJNwUmGyYOxYUVu5UbHkpDFq9BnYoLEnRHp/X6OyTNvnpLJlAntGT5XbR3pqCeEB6vqON0tIP8wdr/nBzT1rUli1ZgRhLYIC2aecGRIo2UhnQ+agW7B5nMICWskk3RNKM8enVPPCTMoTnOifWKyVpDjAZUkZkp+takn6ZHygN6JezxTf6b96xGxUwuq7dkaV7RwTfOTz243k+wZxXtnZhcfrNUUhSD01Dtf1adJZHRcJc6RRB1od/N9DiF64L1sfDjhG6SrKb2ak2GDHiYhkVlKpuPtruw/F+Z5dE2Y8MB5+APPGLt0Uzm+dzOWnqrJSA3trCtwWihN1gtC8iuaDSbvYgbCXixCu4+1juaaG2HPwvkaQm6zwr+8gZ+hlF4tEzOQ4EcUpY/iEcEYFIolFXUeSS8vXWol6tzbxfo+czzTmzi2rpmwH5+VMeSr3pM09GZZWrRhb+V3s2yNW3tTUlIcv5AgNCWNaUuYmTpSKSKAucQZXLV0GkhK2w+EfFOY9dD2azWrVxom3xlMUdhsGJPo6nFniZknpMAjKpIvUCLSBGKTYeLwEXMKBkmy4yUzy8970AJuQdhoHU9ldVfDujB3sOaDhZ3uV377gRANDiw4YunVkvbSptRDrllQVmvMeV7T6CxJM+QwzNsYt7x+Yd3EFUVs8i/jcTzT92QT7GIZUIsg1K1MgrCx9SXcAL52ZwWNPpOatk8xAeBOD7adiP/MxTM5yc9m72xmmoQ8gq8Y02JtXrqpVxD6r+iL0o+hirNvaPC5mAlsyRJtP/71FpIgpHZlmQs3T7HGwL0tyOfiPkwWM0QmV7C8jnSUaY/v7S96kgShuWXJDFqd5i5kn8ssu7FbPj5UZGRkG/7KQ0kQsrSApWdMM9w/K5vC1WkfoinKW2K+0dyy6EPxd5o2bNjgIEkQtnWzRG/JW4mJidHR0fq9eIJQ8s0fhKEdSgysq/vOu9mSIJR886fRJEEoVVdXf0d/JFQShBJJZm1tLWvQmADMzMz0+z+XLQglv1BAgwIDA4l1rALlpiSWocXHxzP9QP5JGHT8VIJQkiRBKEmCUJIkQShJglCSJEEoSYJQkiRBKEmCUJKkNtZ/AFmg+xQr+VKLAAAAAElFTkSuQmCC" width="150" height="45" alt="Screenshot of Mobile Safari suggesting &quot;On my way!&quot; to replace &quot;omw&quot;">
		 * Flags: IRA */
		browserAutoCorrect?: boolean /* Boolean */; // Flags=IRA
		/** Should this form item fire its FormItem.change','change handler (and store its value in the form) on every keypress? Set to false to suppress the 'change' handler firing (and the value stored) on every keypress. Note: If false, the value returned by FormItem.getValue','getValue will not reflect the value displayed in the form item element as long as focus is in the form item element.
		 * Flags: IRW, Group: eventHandling */
		changeOnKeypress?: boolean /* Boolean */; // Flags=IRW
		/** Default class used to construct the EditProxy for this component when the component is Canvas.setEditMode','first placed into edit mode.
		 * Flags: IR */
		editProxyConstructor?: string /* SCClassName */; // Flags=IR
		/** How should an empty string entered by the user be stored? This value is typically set to null or "". Note that a call to FormItem.setValue','setValue(null) or FormItem.setValue','setValue("") automatically updates this property to ensure that "empty" values are stored in a consistent format.
		 * Flags: IRW, Group: formValues */
		emptyStringValue?: any; // Flags=IRW
		/** If a TextAreaItem.length is specified for this item, should user input be limited to the specified length? If set to true, user input and values passed to FormItem.setValue','setValue() will be trimmed to the specified length. Otherwise values exceeding the specified length will raise an error on validation. Note that having this value set to true limits user interactivity in some ways. For example users would be unable to paste a longer string into the field for editing without seeing it be truncated. Given how text areas are typically used to edit longer values than non-wrapping TextItems, this value is false by default for textAreaItems.
		 * Flags: IRW */
		enforceLength?: boolean; // Flags=IRW
		/** With formatOnBlur enabled, this textAreaItem will format its value according to the rules described in FormItem.mapValueToDisplay as long as the item does not have focus. Once the user puts focus into the item the formatter will be removed. This provides a simple way for developers to show a nicely formatted display value in a freeform text field, without the need for an explicit FormItem.formatEditorValue and FormItem.parseEditorValue pair.
		 * Flags: IRW */
		formatOnBlur?: boolean /* Boolean */; // Flags=IRW
		/** Default height of this item Note that when item is rendered as read-only with readOnlyDisplay as "static" the property FormItem.staticHeight is used instead.
		 * Flags: IRW, Group: appearance */
		height?: number; // Flags=IRW
		/** Align icons with the top edge of text area icons by default.
		 * Flags: IR, Group: formIcons */
		iconVAlign?: VerticalAlignment; // Flags=IR
		/** If set, maximum number of characters for this field. If TextAreaItem.enforceLength is set to true, user input will be limited to this value, and values exceeding this length passed to FormItem.setValue','setValue() will be trimmed. Otherwise values exceeding the specified length will raise an error on validation. See also DataSourceField.length.
		 * Flags: IRW, Group: validation */
		length?: number; // Flags=IRW
		/** Minimum valid height for this TextAreaItem in px. If the specified TextAreaItem.height is less than this value, the text area will still render at this height.
		 * Flags: IRW */
		minHeight?: number /* int */; // Flags=IRW
		/** When generating a print-view of the component containing this TextArea, should the form item expand to accommodate its value? If set to false the text box not expand to fit its content in the print view, instead showing exactly as it does in the live form, possibly with scrollbars.
		 * Flags: IRW, Group: printing */
		printFullText?: boolean /* Boolean */; // Flags=IRW
		/** Allows the DynamicForm.selectOnClick','selectOnClick behavior to be configured on a per-FormItem basis. Normally all items in a form default to the value of DynamicForm.selectOnClick.
		 * Flags: IRW, Group: focus */
		selectOnClick?: boolean; // Flags=IRW
		/** Allows the DynamicForm.selectOnFocus','selectOnFocus behavior to be configured on a per-FormItem basis. Normally all items in a form default to the value of DynamicForm.selectOnFocus.
		 * Flags: IRW, Group: focus */
		selectOnFocus?: boolean; // Flags=IRW
		/** If FormItem.showHint','showing a hint for this form item, should the hint be shown within the field? Unless the HTML5 placeholder attribute is used to display the hint (see TextAreaItem.usePlaceholderForHint), the value of the FormItem.getDataElement','data element will be set to the hint whenever this item is not focused. Also, when displaying the hint, the CSS style of the data element will be set to the TextItem.textBoxStyle','textBoxStyle with the suffix "Hint" appended to it; or, if the item is disabled, the suffix "DisabledHint" will be used. In Page.isRTL','RTL mode when FormItem.showRTL','showRTL is true, an additional "RTL" suffix will be appended; i.e. the CSS style of the data element when the hint is displayed will be the textBoxStyle plus "HintRTL" or "DisabledHintRTL". To change this attribute after being drawn, it is necessary to call FormItem.redraw or redraw the form. <h3>Styling the in-field hint</h3> The in-field hint can be styled with CSS for the textBoxStyle + "Hint" / "HintRTL" / "DisabledHint" / "DisabledHintRTL" styles. For example, if this item's textBoxStyle is set to "mySpecialItem", then changing the hint color to blue can be accomplished with the following CSS: .mySpecialItemHint,.mySpecialItemHintRTL,.mySpecialItemDisabledHint,.mySpecialItemDisabledHintRTL { color: blue;}
		 * Flags: IRWA, Group: appearance */
		showHintInField?: boolean /* Boolean */; // Flags=IRWA
		/** Height of the FormItem when canEdit is false and readOnlyDisplay is "static". The normal TextAreaItem.height is used if this property is not set.
		 * Flags: IR, Group: formLayout */
		staticHeight?: number /* Integer */; // Flags=IR
		/** Does the current formItem support native cut and paste events? This attribute only applies to freeform text entry fields such as TextItem and TextAreaItem, and only if TextAreaItem.changeOnKeypress is true. If true, developers can detect the user editing the value via cut or paste interactions (triggered from keyboard shortcuts or the native browser menu options) using the FormItem.isCutEvent and FormItem.isPasteEvent methods. This allows custom cut/paste handling to be added to the various change notification flow methods including FormItem.change, FormItem.handleChange and FormItem.transformInput.
		 * Flags: IRW */
		supportsCutPasteEvents?: boolean; // Flags=IRW
		/** Base CSS class to apply to this item's input element. NOTE: See the CompoundFormItem_skinning discussion for special skinning considerations.
		 * Flags: IRW, Group: appearance */
		textBoxStyle?: string /* FormItemBaseStyle */; // Flags=IRW
		/** If TextAreaItem.showHintInField','showing the hint in field and if supported by the browser, should the HTML5 <a href='http://www.whatwg.org/specs/web-apps/current-work/multipage/forms.html#attr-input-placeholder' target='_blank'>placeholder attribute</a> be used to display the hint within the field? If set to false, then use of the placeholder attribute is disabled and an alternative technique to display the hint in-field is used instead. The HTML5 placeholder attribute is supported in the following major browsers: Chrome 4+ Firefox 4+ Internet Explorer 10+ Safari 5+ Opera 11.50+ Android 2.1+ WebView (used by the stock Browser app and when phonegapIntegration','packaging with PhoneGap) Mobile Safari for iOS 3.2+ In browsers other than the above, in-field hints are implemented via a different technique. Note that placeholder behavior is known to differ in Internet Explorer and certain old versions of the above browsers due to a recent change in the HTML5 specification regarding the placeholder attribute. Under the old rules, the placeholder is cleared when the element is focused. In the latest HTML5 spec as published by WHATWG, the placeholder is still displayed when the element is focused as long as the value is an empty string. <h3>Styling the placeholder</h3> While there isn't a standard way to style the placeholder text, Chrome, Firefox, Internet Explorer, and Safari provide vendor-prefixed pseudo-classes and/or pseudo-elements that can be used in CSS selectors: <table border="1"> <tr> <th>Browser</th> <th>Pseudo-class or pseudo-element</th> </tr> <tr> <td>Chrome, Safari</td> <td>::-webkit-input-placeholder</td> </tr> <tr> <td>Firefox 4 - 18</td> <td>:-moz-placeholder</td> </tr> <tr> <td>Firefox 19+</td> <td>::-moz-placeholder</td> </tr> <tr> <td>Internet Explorer</td> <td>:-ms-input-placeholder</td> </tr> </table> Note that unlike other browsers, Firefox 19+ applies opacity:0.4 to the placeholder text. See <a href='https://bugzilla.mozilla.org/show_bug.cgi?id=556145' target='_blank'>Bug 556145 - Placeholder text default style should use opacity instead of GrayText</a> Because browsers are required to ignore the entire rule if a selector is invalid, separate rules are needed for each browser. For example: ::-webkit-input-placeholder { color: blue; opacity: 1;&#125;:-moz-placeholder { color: blue; opacity: 1;&#125;::-moz-placeholder { color: blue; opacity: 1;&#125;:-ms-input-placeholder { color: blue; opacity: 1;&#125; If using <a href='http://sass-lang.com' target='_blank'>Sass</a>, it may be useful to utilize Sass' <a href='http://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector' target='_blank'>parent selector feature</a>. For example: .myCustomItem,.myCustomItemRTL,.myCustomItemDisabled,.myCustomItemDisabledRTL,.myCustomItemError,.myCustomItemErrorRTL,.myCustomItemFocused,.myCustomItemFocusedRTL,.myCustomItemHint,.myCustomItemHintRTL,.myCustomItemDisabledHint,.myCustomItemDisabledHintRTL { // ... &amp;::-webkit-input-placeholder { color: blue; opacity: 1; } &amp;:-moz-placeholder { color: blue; opacity: 1; } &amp;::-moz-placeholder { color: blue; opacity: 1; } &amp;:-ms-input-placeholder { color: blue; opacity: 1; }&#125; If using <a href='http://compass-style.org' target='_blank'>Compass</a>, the <a href='http://compass-style.org/reference/compass/css3/user_interface/#mixin-input-placeholder' target='_blank'>input-placeholder mixin</a> that was added in version 1.0 can further simplify the code to style the placeholder text For example: .myCustomItem,.myCustomItemRTL,.myCustomItemDisabled,.myCustomItemDisabledRTL,.myCustomItemError,.myCustomItemErrorRTL,.myCustomItemFocused,.myCustomItemFocusedRTL,.myCustomItemHint,.myCustomItemHintRTL,.myCustomItemDisabledHint,.myCustomItemDisabledHintRTL { // ... &#64;include input-placeholder { color: blue; opacity: 1; }&#125; <h3>Accessibility concerns</h3> The HTML5 specification notes that a placeholder should not be used as a replacement for a title. The placeholder is intended to be a <em>short</em> hint that assists the user who is entering a value into the empty field. The placeholder can be mistaken by some users for a pre-filled value, particularly in Internet Explorer because the same color is used, and the placeholder text color may provide insufficient contrast, particularly in Firefox 19+ because of the default 0.4 opacity. Furthermore, not having a title reduces the hit area available for setting focus on the item.
		 * Flags: IRA, Group: appearance */
		usePlaceholderForHint?: boolean; // Flags=IRA
		/** default width of this item
		 * Flags: IRW, Group: appearance */
		width?: number; // Flags=IRW
		/** Text wrapping style.
		 * Flags: IRW, Group: appearance */
		wrap?: TEXTAREA_WRAP; // Flags=IRW

		/* Method Overrides */

	} // TextAreaItemProps


	/**
	 * Class for editable multi-line text areas (uses HTML &lt;TEXTAREA&gt; object) 
	 */
	export interface TextAreaItem extends FormItem {
		browserAutoCapitalize: boolean /* Boolean */;

		/** In Mobile Safari, should automatic correction be offered for text in the item's text box? If null, then Mobile Safari determines automatically whether to enable autocorrect. When enabled, Mobile Safari displays "autocorrect bubbles" to suggest automatic corrections: <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAABaCAIAAACNE/xKAAANy0lEQVR4Ae2dB3hV5R3G7d6tdW9wgIoDtQ4cldZRq9Q9invSKlVkqgzZIIgICohKQUCUEBNIghjEhARCCJgACUrYZJA9ySAhi9Nf8vU5z9d7yXhI48017/t8T5573nPOHXB+9z++7yTHOD6VJEmCUJIEoSQJQkmSBKEkCUJJag8ShKGx6b2HBWtoaLTpWLZmR6MQrtxSLA41NNqawOXrdzcFIcORJKnNBIGCsAlJkiCUJEH43sr0xNTidjuSUosdSRKEvh2OJAlCQShJglCSBKEglCRBKEmCUBBKkiCUJEEoCCVJEEqSDyQIJanjQRjzTfrwKR/2fv7VB/sMHvbmB1+s32bvXRAazd41SamRm/aMnv7R/c8OHDTu3aCIeLM3JHrL4PEz7n6yX99hk7+K32XM0DWJnDLns1X288wNjsD8ZMU623x3YSgmb6DjQigJwilzAo/t3P2YYzsxfnjc2fz8+SnnA4Z7wOMvjcCcMGvRcedczgMzfnzCufNDot5ZEPKTE89zzV+fcRH4ccqyqM1sdr36VvuFLr6hF+ZN9z3tOpv3Ff6u06W8+qa9BYKwg0oQQsvPTu7605O6EAAJRxt2ZMPkb8+6BFqmz19mQwh1Pe9+YtHnMWB23zMDcIAHXAeOfYcISTzs8de/Y/Z6tK85q1P3G9lkl9lcuzXtB7/vjPObMy+GPWOCMQ5RVOlox5UgvPKW+8HgtUmzbXP24i8wT72wR8KefBfCzpf1BFFzQOy2DBMzH+k71D0rODIBp8tVt5jNJ/q9zub4mR+78ZZNQ+bi8PXGfGbgGEO7IOygEoQkgSSTvzztwvjdeR5wwhJ4wJUL4QPPDbIPINXEBFfXgUyc48+9wmzOWxppB0YqSbgdNW0e5oAx04153pU3E0thu4NCKAnCsLVJduyyx18e6sOuqXODXAj7j55mH9C9512GUhtpHOpGd5N8lc0tKUVsntbtWmpCslOOue6Oh3HC45LdErGDQigJQlOSXXHTvd4Q3vt0f3bRC3Uh5LE3hEtXb2oMQsadj7+IE7AyztD+7KCxJvr94tQLSHSHTn4fc9yMhR0XQkkQRiTsBgNilDeE197em100P1sDIYEU5+VRb9P14cGHgV9iPvbicB7D//W9HvnR8ecw89GhIZTUmPnV6d0o1VbEfmub65MzmTkAFSYMWwMhz0PNedWtD5Dc0oDduDMHc8bHYRz2VP9ROOzSZL3U0SHsM2S8KcxMI5ThBitDSGsgZNzwt0eZ2wDpa257yDhx27Nw6Mdw8CsTZ3V0CCVBSGfSTBt0u+52ZvyYqzCJ6AU9bmNmr/UQjnhrDiaj38iprnn5n+/BMZG2o0MoCUKTNDL9QHJowDixy5XMK0QnprCr9RCu+nonJoNZftd8Yegkw7nWjkqOILQRYtULq2G0gFuSdBeFJAlCQShJglCSBKEglCRBKEmCUBBKkiCUJD+Q/jSaJPkPhJ9KfqLFixcHBAQEBgYGBweHhISEh4dHRUVt3Lhx69atWVlZ1dXVjv9KEDp+Jelwg2praysrK0tKSnJychISEoKCglauXJmUlITp+ESSIJRqamrS0tKWLl0aFxcnFAWh5Ms4SXYKinv37nUkQSj5MCquXbuWihEmHZ9IEoRSbd3h6JjYoLDwqO350TsKfDU0uEG3KQjj95R8jyGUCIJx8ZuXha8WCT7nsFEI0fceQik2Nnbbtm2O7yV1YAjVqgkLCysqKnL8VIKQ/8J9+dXLE8tnrT4QvKksMf2QI/2ftD2r6tvMqvTCGqeNVVxcHBER4fidBCGV/bRVxZ1eST3h5RR7XDsxY0Fsqdpurdc5r6Xx7/nU3Fyn7RUTE5ORkeH4kQQh0e/2aVmGuuvfyHh+Yd4bK4pe+iT/0lHpxnxybm7ZoTqnLSUImXxn5p2FaU6T4gAO42CncbG2Zs2aNY6/SBBW1Ry+etx+ro+LXk9fkVTuWKqpPTwz8oDh8LE5OU5bShDGGRkOmyTQyGlSoaGhFRUVjl9IEL69qpiL4+xXU3NKjlyujAotNBwu+brMkY5W5zZA+PS83JYAxuOjOMBWcnLyvn37nPYvQZhVXHPm4Po68P3okia6NY98mMMxf5yU4ZofrSsxp2QW18xfV/qvRXmkr3PWlhSV1zrNiXM/aDiXLsXcmJJ/LMgbE1YYkXywru6wicyfJ5W/FlTw7Ee5U1YW84RuWH4v6gAdI96z4yUKV3bllh7h1RfF1e8i5bbNzWmHML2/Vnhj+JXVda6TkHJodtSBgUvyH/937vClhfNiSgqtzxi3t5LjQ7eUO17allnFLje5uGx0fW7Pv1Kzqea6BnlgxqbxW0IgokHKGhqn/UsQBmws48o4b2gal7jTuKDCBENafMY5f1jaKQNStqQd6josDd8d3UelJ+1vpqfKuacPSl2/p7Lz//aBJnxeVFFV99DsHNu8YHiaS92d72bhTP7Cs/++I7sKn6etPtKnoMRlL1WubUI45mkDU3hF1/wmowrzmvH7zWZZZd3AgHwcj8FbWrerwhwTs6sC56whqeVeNfMzvIT17XbTlEw2X19W6DQpA5vLYeNm82vZuAHKaf8ShFz3XBm3Ts10mlRaQbW5/hauL3VBYpNuKmAQxHbnVAfGl1FVYt49I7tZCE/sn3LG4FSOZDokPqWy36f55vlvnJRBNygooYwnXLa53BA+ICDfMe9/QymbV41rgMQSgRSfMOUcSSFbyj0+IyGX7x3zimt2Vrj+1C+LcUaHFprNVz8rYPO6iRnE0j151btyqqiQe0zIwPzTm5lumnDFmP04fHzH0oGDtRDO91R+Wa1x7puVzWG8hNlsOYdHQaB5Y9yI6LR/CUJKFK6M5+bntrCkeTO82IaQVqodQokPmIy80tqmITQXt91xNZfyyQNSCGuu+UkDdZBpNok2nYak4pAi2kRdPDIdkzjmeMkEtFMHpoC9m9kSwDneED5+eZF75G1vZ+F8va+Sx6WV/30tvg4cS+FbD2Iysg/UGGdyeDGbBHCP9BiTDNYj9pJ+m82Wc3gUBBotWbLEaf8ShCZHovXiNKeb36o/clhwgQ0S1Z1jidQOk5GcVdUshDMiDtgmVSUmcdU2N+6rxIR/16GmwiFGuU70jgqcnpMBtVE9ODubYwitdi9qWsNPwDMmIQtQu41IN5Oih2oOUzeu2nbQsWR8vinq4cytttOEk/qn2BXpHdOzMO1u86AlBTgEeQe1jMPWEOg3C6QEIQkhV0bfRXlOc7pweJq5cG2QVm/3bIJ3aUjzKAubhTAssdw2iUiYL9K3sEQUwqR0dB0qSVP+uRH4hY/zcOidOI2L+MMxL3+abzbvmpFtAiPBEKIIlZiLG8pjikDHS0Rsgudn8WW8yV4NdDF2WhH7npnZdvlHE8i7RjUfkNRdECJB6Bl/TDRoQlyF5sqjkWOD5A0bTYsWQkic8YZwSGCBbRJtPCBE1ISYX3570CSoNEXc0qsxZRTVcMolI9PNKWSnt7yV6fZOeCo3M/+K0GcFdtqbZhLVHXwZeUNIQYhDsmA2aR3ZWYMRT+WRSDtI6agg5NvdXOUmGjQmIp658vYX1dggbW0FhJx7dBCa9kmf+Xk8Zo6hhQsJTOJNwUmGyYOxYUVu5UbHkpDFq9BnYoLEnRHp/X6OyTNvnpLJlAntGT5XbR3pqCeEB6vqON0tIP8wdr/nBzT1rUli1ZgRhLYIC2aecGRIo2UhnQ+agW7B5nMICWskk3RNKM8enVPPCTMoTnOifWKyVpDjAZUkZkp+takn6ZHygN6JezxTf6b96xGxUwuq7dkaV7RwTfOTz243k+wZxXtnZhcfrNUUhSD01Dtf1adJZHRcJc6RRB1od/N9DiF64L1sfDjhG6SrKb2ak2GDHiYhkVlKpuPtruw/F+Z5dE2Y8MB5+APPGLt0Uzm+dzOWnqrJSA3trCtwWihN1gtC8iuaDSbvYgbCXixCu4+1juaaG2HPwvkaQm6zwr+8gZ+hlF4tEzOQ4EcUpY/iEcEYFIolFXUeSS8vXWol6tzbxfo+czzTmzi2rpmwH5+VMeSr3pM09GZZWrRhb+V3s2yNW3tTUlIcv5AgNCWNaUuYmTpSKSKAucQZXLV0GkhK2w+EfFOY9dD2azWrVxom3xlMUdhsGJPo6nFniZknpMAjKpIvUCLSBGKTYeLwEXMKBkmy4yUzy8970AJuQdhoHU9ldVfDujB3sOaDhZ3uV377gRANDiw4YunVkvbSptRDrllQVmvMeV7T6CxJM+QwzNsYt7x+Yd3EFUVs8i/jcTzT92QT7GIZUIsg1K1MgrCx9SXcAL52ZwWNPpOatk8xAeBOD7adiP/MxTM5yc9m72xmmoQ8gq8Y02JtXrqpVxD6r+iL0o+hirNvaPC5mAlsyRJtP/71FpIgpHZlmQs3T7HGwL0tyOfiPkwWM0QmV7C8jnSUaY/v7S96kgShuWXJDFqd5i5kn8ssu7FbPj5UZGRkG/7KQ0kQsrSApWdMM9w/K5vC1WkfoinKW2K+0dyy6EPxd5o2bNjgIEkQtnWzRG/JW4mJidHR0fq9eIJQ8s0fhKEdSgysq/vOu9mSIJR886fRJEEoVVdXf0d/JFQShBJJZm1tLWvQmADMzMz0+z+XLQglv1BAgwIDA4l1rALlpiSWocXHxzP9QP5JGHT8VIJQkiRBKEmCUJIkQShJglCSJEEoSYJQkiRBKEmCUJKkNtZ/AFmg+xQr+VKLAAAAAElFTkSuQmCC" width="150" height="45" alt="Screenshot of Mobile Safari suggesting &quot;On my way!&quot; to replace &quot;omw&quot;">
		 * Flags: IRA */
		browserAutoCorrect: boolean /* Boolean */;

		/** Should this form item fire its FormItem.change','change handler (and store its value in the form) on every keypress? Set to false to suppress the 'change' handler firing (and the value stored) on every keypress. Note: If false, the value returned by FormItem.getValue','getValue will not reflect the value displayed in the form item element as long as focus is in the form item element.
		 * Flags: IRW, Group: eventHandling */
		changeOnKeypress: boolean /* Boolean */;

		/** Default class used to construct the EditProxy for this component when the component is Canvas.setEditMode','first placed into edit mode.
		 * Flags: IR */
		editProxyConstructor: string /* SCClassName */;

		/** How should an empty string entered by the user be stored? This value is typically set to null or "". Note that a call to FormItem.setValue','setValue(null) or FormItem.setValue','setValue("") automatically updates this property to ensure that "empty" values are stored in a consistent format.
		 * Flags: IRW, Group: formValues */
		emptyStringValue: any;

		/** If a TextAreaItem.length is specified for this item, should user input be limited to the specified length? If set to true, user input and values passed to FormItem.setValue','setValue() will be trimmed to the specified length. Otherwise values exceeding the specified length will raise an error on validation. Note that having this value set to true limits user interactivity in some ways. For example users would be unable to paste a longer string into the field for editing without seeing it be truncated. Given how text areas are typically used to edit longer values than non-wrapping TextItems, this value is false by default for textAreaItems.
		 * Flags: IRW */
		enforceLength: boolean;

		/** With formatOnBlur enabled, this textAreaItem will format its value according to the rules described in FormItem.mapValueToDisplay as long as the item does not have focus. Once the user puts focus into the item the formatter will be removed. This provides a simple way for developers to show a nicely formatted display value in a freeform text field, without the need for an explicit FormItem.formatEditorValue and FormItem.parseEditorValue pair.
		 * Flags: IRW */
		formatOnBlur: boolean /* Boolean */;

		/** Default height of this item Note that when item is rendered as read-only with readOnlyDisplay as "static" the property FormItem.staticHeight is used instead.
		 * Flags: IRW, Group: appearance */
		height: number;

		/** Align icons with the top edge of text area icons by default.
		 * Flags: IR, Group: formIcons */
		iconVAlign: VerticalAlignment;

		/** If set, maximum number of characters for this field. If TextAreaItem.enforceLength is set to true, user input will be limited to this value, and values exceeding this length passed to FormItem.setValue','setValue() will be trimmed. Otherwise values exceeding the specified length will raise an error on validation. See also DataSourceField.length.
		 * Flags: IRW, Group: validation */
		length: number;

		/** Minimum valid height for this TextAreaItem in px. If the specified TextAreaItem.height is less than this value, the text area will still render at this height.
		 * Flags: IRW */
		minHeight: number /* int */;

		/** When generating a print-view of the component containing this TextArea, should the form item expand to accommodate its value? If set to false the text box not expand to fit its content in the print view, instead showing exactly as it does in the live form, possibly with scrollbars.
		 * Flags: IRW, Group: printing */
		printFullText: boolean /* Boolean */;

		/** Allows the DynamicForm.selectOnClick','selectOnClick behavior to be configured on a per-FormItem basis. Normally all items in a form default to the value of DynamicForm.selectOnClick.
		 * Flags: IRW, Group: focus */
		selectOnClick: boolean;

		/** Allows the DynamicForm.selectOnFocus','selectOnFocus behavior to be configured on a per-FormItem basis. Normally all items in a form default to the value of DynamicForm.selectOnFocus.
		 * Flags: IRW, Group: focus */
		selectOnFocus: boolean;

		/** If FormItem.showHint','showing a hint for this form item, should the hint be shown within the field? Unless the HTML5 placeholder attribute is used to display the hint (see TextAreaItem.usePlaceholderForHint), the value of the FormItem.getDataElement','data element will be set to the hint whenever this item is not focused. Also, when displaying the hint, the CSS style of the data element will be set to the TextItem.textBoxStyle','textBoxStyle with the suffix "Hint" appended to it; or, if the item is disabled, the suffix "DisabledHint" will be used. In Page.isRTL','RTL mode when FormItem.showRTL','showRTL is true, an additional "RTL" suffix will be appended; i.e. the CSS style of the data element when the hint is displayed will be the textBoxStyle plus "HintRTL" or "DisabledHintRTL". To change this attribute after being drawn, it is necessary to call FormItem.redraw or redraw the form. <h3>Styling the in-field hint</h3> The in-field hint can be styled with CSS for the textBoxStyle + "Hint" / "HintRTL" / "DisabledHint" / "DisabledHintRTL" styles. For example, if this item's textBoxStyle is set to "mySpecialItem", then changing the hint color to blue can be accomplished with the following CSS: .mySpecialItemHint,.mySpecialItemHintRTL,.mySpecialItemDisabledHint,.mySpecialItemDisabledHintRTL { color: blue;}
		 * Flags: IRWA, Group: appearance */
		showHintInField: boolean /* Boolean */;

		/** Height of the FormItem when canEdit is false and readOnlyDisplay is "static". The normal TextAreaItem.height is used if this property is not set.
		 * Flags: IR, Group: formLayout */
		staticHeight: number /* Integer */;

		/** Does the current formItem support native cut and paste events? This attribute only applies to freeform text entry fields such as TextItem and TextAreaItem, and only if TextAreaItem.changeOnKeypress is true. If true, developers can detect the user editing the value via cut or paste interactions (triggered from keyboard shortcuts or the native browser menu options) using the FormItem.isCutEvent and FormItem.isPasteEvent methods. This allows custom cut/paste handling to be added to the various change notification flow methods including FormItem.change, FormItem.handleChange and FormItem.transformInput.
		 * Flags: IRW */
		supportsCutPasteEvents: boolean;

		/** Base CSS class to apply to this item's input element. NOTE: See the CompoundFormItem_skinning discussion for special skinning considerations.
		 * Flags: IRW, Group: appearance */
		textBoxStyle: string /* FormItemBaseStyle */;

		/** If TextAreaItem.showHintInField','showing the hint in field and if supported by the browser, should the HTML5 <a href='http://www.whatwg.org/specs/web-apps/current-work/multipage/forms.html#attr-input-placeholder' target='_blank'>placeholder attribute</a> be used to display the hint within the field? If set to false, then use of the placeholder attribute is disabled and an alternative technique to display the hint in-field is used instead. The HTML5 placeholder attribute is supported in the following major browsers: Chrome 4+ Firefox 4+ Internet Explorer 10+ Safari 5+ Opera 11.50+ Android 2.1+ WebView (used by the stock Browser app and when phonegapIntegration','packaging with PhoneGap) Mobile Safari for iOS 3.2+ In browsers other than the above, in-field hints are implemented via a different technique. Note that placeholder behavior is known to differ in Internet Explorer and certain old versions of the above browsers due to a recent change in the HTML5 specification regarding the placeholder attribute. Under the old rules, the placeholder is cleared when the element is focused. In the latest HTML5 spec as published by WHATWG, the placeholder is still displayed when the element is focused as long as the value is an empty string. <h3>Styling the placeholder</h3> While there isn't a standard way to style the placeholder text, Chrome, Firefox, Internet Explorer, and Safari provide vendor-prefixed pseudo-classes and/or pseudo-elements that can be used in CSS selectors: <table border="1"> <tr> <th>Browser</th> <th>Pseudo-class or pseudo-element</th> </tr> <tr> <td>Chrome, Safari</td> <td>::-webkit-input-placeholder</td> </tr> <tr> <td>Firefox 4 - 18</td> <td>:-moz-placeholder</td> </tr> <tr> <td>Firefox 19+</td> <td>::-moz-placeholder</td> </tr> <tr> <td>Internet Explorer</td> <td>:-ms-input-placeholder</td> </tr> </table> Note that unlike other browsers, Firefox 19+ applies opacity:0.4 to the placeholder text. See <a href='https://bugzilla.mozilla.org/show_bug.cgi?id=556145' target='_blank'>Bug 556145 - Placeholder text default style should use opacity instead of GrayText</a> Because browsers are required to ignore the entire rule if a selector is invalid, separate rules are needed for each browser. For example: ::-webkit-input-placeholder { color: blue; opacity: 1;&#125;:-moz-placeholder { color: blue; opacity: 1;&#125;::-moz-placeholder { color: blue; opacity: 1;&#125;:-ms-input-placeholder { color: blue; opacity: 1;&#125; If using <a href='http://sass-lang.com' target='_blank'>Sass</a>, it may be useful to utilize Sass' <a href='http://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector' target='_blank'>parent selector feature</a>. For example: .myCustomItem,.myCustomItemRTL,.myCustomItemDisabled,.myCustomItemDisabledRTL,.myCustomItemError,.myCustomItemErrorRTL,.myCustomItemFocused,.myCustomItemFocusedRTL,.myCustomItemHint,.myCustomItemHintRTL,.myCustomItemDisabledHint,.myCustomItemDisabledHintRTL { // ... &amp;::-webkit-input-placeholder { color: blue; opacity: 1; } &amp;:-moz-placeholder { color: blue; opacity: 1; } &amp;::-moz-placeholder { color: blue; opacity: 1; } &amp;:-ms-input-placeholder { color: blue; opacity: 1; }&#125; If using <a href='http://compass-style.org' target='_blank'>Compass</a>, the <a href='http://compass-style.org/reference/compass/css3/user_interface/#mixin-input-placeholder' target='_blank'>input-placeholder mixin</a> that was added in version 1.0 can further simplify the code to style the placeholder text For example: .myCustomItem,.myCustomItemRTL,.myCustomItemDisabled,.myCustomItemDisabledRTL,.myCustomItemError,.myCustomItemErrorRTL,.myCustomItemFocused,.myCustomItemFocusedRTL,.myCustomItemHint,.myCustomItemHintRTL,.myCustomItemDisabledHint,.myCustomItemDisabledHintRTL { // ... &#64;include input-placeholder { color: blue; opacity: 1; }&#125; <h3>Accessibility concerns</h3> The HTML5 specification notes that a placeholder should not be used as a replacement for a title. The placeholder is intended to be a <em>short</em> hint that assists the user who is entering a value into the empty field. The placeholder can be mistaken by some users for a pre-filled value, particularly in Internet Explorer because the same color is used, and the placeholder text color may provide insufficient contrast, particularly in Firefox 19+ because of the default 0.4 opacity. Furthermore, not having a title reduces the hit area available for setting focus on the item.
		 * Flags: IRA, Group: appearance */
		usePlaceholderForHint: boolean;

		/** default width of this item
		 * Flags: IRW, Group: appearance */
		width: number;

		/** Text wrapping style.
		 * Flags: IRW, Group: appearance */
		wrap: TEXTAREA_WRAP;


		/* Instance Method Overrides */

	} // TextAreaItem

	export interface TextAreaItemStatic<T, P> extends FormItemStatic<T, P> {
	} // TextAreaItemStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a TextExportSettings Props argument.
	 * This is derived from the methods in the TextExportSettings class and it's parents and their properties marked with the I flag.
	 */
	export interface TextExportSettingsProps  {
		/** Format to use when outputting date values. Default is to use the format expected by Microsoft Excel (eg 1-2-2011), which Excel will turn into a real date value (see excelPasting). The current month-day-year order as set by DateUtil.setInputFormat will be used.
		 * Flags: IR */
		dateFormat?: DateDisplayFormat; // Flags=IR
		/** Format to use when outputting datetime values. Default is to combine the configured date and time formats with a space (" ").
		 * Flags: IR */
		dateTimeFormat?: DateDisplayFormat; // Flags=IR
		/** If set, all text fields will use the indicated ForceTextApproach unless they have a specific setting for DataSourceField.exportForceText.
		 * Flags: IR */
		forceText?: ForceTextApproach; // Flags=IR
		/** Separator between Records. Default is a newline character ("\n").
		 * Flags: IR */
		lineSeparator?: string /* String */; // Flags=IR
		/** Text to export for a field with a null value. If this property is null, then null fields will be assumed to have the default value for their field type.
		 * Flags: IR */
		nullValueText?: string /* String */; // Flags=IR
		/** Whether to surround each value with quotes ("").
		 * Flags: IR */
		quoteValues?: boolean /* Boolean */; // Flags=IR
		/** Format to use when outputting time values. Default is 24 hour time.
		 * Flags: IR */
		timeFormat?: TimeDisplayFormat; // Flags=IR
		/** Whether to convert each field's value to the corresponding display value for export. Default of false will directly export the field's value.
		 * Flags: IR */
		useDisplayValue?: boolean /* Boolean */; // Flags=IR
	} // TextExportSettingsProps


	/**
	 * Settings for use with DataSource.recordsAsText. 
	 */
	export interface TextExportSettings  {
		/** Format to use when outputting date values. Default is to use the format expected by Microsoft Excel (eg 1-2-2011), which Excel will turn into a real date value (see excelPasting). The current month-day-year order as set by DateUtil.setInputFormat will be used.
		 * Flags: IR */
		dateFormat: DateDisplayFormat;

		/** Format to use when outputting datetime values. Default is to combine the configured date and time formats with a space (" ").
		 * Flags: IR */
		dateTimeFormat: DateDisplayFormat;

		/** If set, all text fields will use the indicated ForceTextApproach unless they have a specific setting for DataSourceField.exportForceText.
		 * Flags: IR */
		forceText: ForceTextApproach;

		/** Separator between Records. Default is a newline character ("\n").
		 * Flags: IR */
		lineSeparator: string /* String */;

		/** Text to export for a field with a null value. If this property is null, then null fields will be assumed to have the default value for their field type.
		 * Flags: IR */
		nullValueText: string /* String */;

		/** Whether to surround each value with quotes ("").
		 * Flags: IR */
		quoteValues: boolean /* Boolean */;

		/** Format to use when outputting time values. Default is 24 hour time.
		 * Flags: IR */
		timeFormat: TimeDisplayFormat;

		/** Whether to convert each field's value to the corresponding display value for export. Default of false will directly export the field's value.
		 * Flags: IR */
		useDisplayValue: boolean /* Boolean */;

	} // TextExportSettings

	export interface TextExportSettingsStatic<T, P> extends ClassStatic<T, P> {
	} // TextExportSettingsStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a TextItem Props argument.
	 * This is derived from the methods in the TextItem class and it's parents and their properties marked with the I flag.
	 */
	export interface TextItemProps extends FormItemProps {
		browserAutoCapitalize?: boolean /* Boolean */; // Flags=IRA
		/** In Mobile Safari, should automatic correction be offered for text in the item's text box? If null, then Mobile Safari determines automatically whether to enable autocorrect. When enabled, Mobile Safari displays "autocorrect bubbles" to suggest automatic corrections: <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAABaCAIAAACNE/xKAAANy0lEQVR4Ae2dB3hV5R3G7d6tdW9wgIoDtQ4cldZRq9Q9invSKlVkqgzZIIgICohKQUCUEBNIghjEhARCCJgACUrYZJA9ySAhi9Nf8vU5z9d7yXhI48017/t8T5573nPOHXB+9z++7yTHOD6VJEmCUJIEoSQJQkmSBKEkCUJJag8ShKGx6b2HBWtoaLTpWLZmR6MQrtxSLA41NNqawOXrdzcFIcORJKnNBIGCsAlJkiCUJEH43sr0xNTidjuSUosdSRKEvh2OJAlCQShJglCSBKEglCRBKEmCUBBKkiCUJEEoCCVJEEqSDyQIJanjQRjzTfrwKR/2fv7VB/sMHvbmB1+s32bvXRAazd41SamRm/aMnv7R/c8OHDTu3aCIeLM3JHrL4PEz7n6yX99hk7+K32XM0DWJnDLns1X288wNjsD8ZMU623x3YSgmb6DjQigJwilzAo/t3P2YYzsxfnjc2fz8+SnnA4Z7wOMvjcCcMGvRcedczgMzfnzCufNDot5ZEPKTE89zzV+fcRH4ccqyqM1sdr36VvuFLr6hF+ZN9z3tOpv3Ff6u06W8+qa9BYKwg0oQQsvPTu7605O6EAAJRxt2ZMPkb8+6BFqmz19mQwh1Pe9+YtHnMWB23zMDcIAHXAeOfYcISTzs8de/Y/Z6tK85q1P3G9lkl9lcuzXtB7/vjPObMy+GPWOCMQ5RVOlox5UgvPKW+8HgtUmzbXP24i8wT72wR8KefBfCzpf1BFFzQOy2DBMzH+k71D0rODIBp8tVt5jNJ/q9zub4mR+78ZZNQ+bi8PXGfGbgGEO7IOygEoQkgSSTvzztwvjdeR5wwhJ4wJUL4QPPDbIPINXEBFfXgUyc48+9wmzOWxppB0YqSbgdNW0e5oAx04153pU3E0thu4NCKAnCsLVJduyyx18e6sOuqXODXAj7j55mH9C9512GUhtpHOpGd5N8lc0tKUVsntbtWmpCslOOue6Oh3HC45LdErGDQigJQlOSXXHTvd4Q3vt0f3bRC3Uh5LE3hEtXb2oMQsadj7+IE7AyztD+7KCxJvr94tQLSHSHTn4fc9yMhR0XQkkQRiTsBgNilDeE197em100P1sDIYEU5+VRb9P14cGHgV9iPvbicB7D//W9HvnR8ecw89GhIZTUmPnV6d0o1VbEfmub65MzmTkAFSYMWwMhz0PNedWtD5Dc0oDduDMHc8bHYRz2VP9ROOzSZL3U0SHsM2S8KcxMI5ThBitDSGsgZNzwt0eZ2wDpa257yDhx27Nw6Mdw8CsTZ3V0CCVBSGfSTBt0u+52ZvyYqzCJ6AU9bmNmr/UQjnhrDiaj38iprnn5n+/BMZG2o0MoCUKTNDL9QHJowDixy5XMK0QnprCr9RCu+nonJoNZftd8Yegkw7nWjkqOILQRYtULq2G0gFuSdBeFJAlCQShJglCSBKEglCRBKEmCUBBKkiCUJD+Q/jSaJPkPhJ9KfqLFixcHBAQEBgYGBweHhISEh4dHRUVt3Lhx69atWVlZ1dXVjv9KEDp+Jelwg2praysrK0tKSnJychISEoKCglauXJmUlITp+ESSIJRqamrS0tKWLl0aFxcnFAWh5Ms4SXYKinv37nUkQSj5MCquXbuWihEmHZ9IEoRSbd3h6JjYoLDwqO350TsKfDU0uEG3KQjj95R8jyGUCIJx8ZuXha8WCT7nsFEI0fceQik2Nnbbtm2O7yV1YAjVqgkLCysqKnL8VIKQ/8J9+dXLE8tnrT4QvKksMf2QI/2ftD2r6tvMqvTCGqeNVVxcHBER4fidBCGV/bRVxZ1eST3h5RR7XDsxY0Fsqdpurdc5r6Xx7/nU3Fyn7RUTE5ORkeH4kQQh0e/2aVmGuuvfyHh+Yd4bK4pe+iT/0lHpxnxybm7ZoTqnLSUImXxn5p2FaU6T4gAO42CncbG2Zs2aNY6/SBBW1Ry+etx+ro+LXk9fkVTuWKqpPTwz8oDh8LE5OU5bShDGGRkOmyTQyGlSoaGhFRUVjl9IEL69qpiL4+xXU3NKjlyujAotNBwu+brMkY5W5zZA+PS83JYAxuOjOMBWcnLyvn37nPYvQZhVXHPm4Po68P3okia6NY98mMMxf5yU4ZofrSsxp2QW18xfV/qvRXmkr3PWlhSV1zrNiXM/aDiXLsXcmJJ/LMgbE1YYkXywru6wicyfJ5W/FlTw7Ee5U1YW84RuWH4v6gAdI96z4yUKV3bllh7h1RfF1e8i5bbNzWmHML2/Vnhj+JXVda6TkHJodtSBgUvyH/937vClhfNiSgqtzxi3t5LjQ7eUO17allnFLje5uGx0fW7Pv1Kzqea6BnlgxqbxW0IgokHKGhqn/UsQBmws48o4b2gal7jTuKDCBENafMY5f1jaKQNStqQd6josDd8d3UelJ+1vpqfKuacPSl2/p7Lz//aBJnxeVFFV99DsHNu8YHiaS92d72bhTP7Cs/++I7sKn6etPtKnoMRlL1WubUI45mkDU3hF1/wmowrzmvH7zWZZZd3AgHwcj8FbWrerwhwTs6sC56whqeVeNfMzvIT17XbTlEw2X19W6DQpA5vLYeNm82vZuAHKaf8ShFz3XBm3Ts10mlRaQbW5/hauL3VBYpNuKmAQxHbnVAfGl1FVYt49I7tZCE/sn3LG4FSOZDokPqWy36f55vlvnJRBNygooYwnXLa53BA+ICDfMe9/QymbV41rgMQSgRSfMOUcSSFbyj0+IyGX7x3zimt2Vrj+1C+LcUaHFprNVz8rYPO6iRnE0j151btyqqiQe0zIwPzTm5lumnDFmP04fHzH0oGDtRDO91R+Wa1x7puVzWG8hNlsOYdHQaB5Y9yI6LR/CUJKFK6M5+bntrCkeTO82IaQVqodQokPmIy80tqmITQXt91xNZfyyQNSCGuu+UkDdZBpNok2nYak4pAi2kRdPDIdkzjmeMkEtFMHpoC9m9kSwDneED5+eZF75G1vZ+F8va+Sx6WV/30tvg4cS+FbD2Iysg/UGGdyeDGbBHCP9BiTDNYj9pJ+m82Wc3gUBBotWbLEaf8ShCZHovXiNKeb36o/clhwgQ0S1Z1jidQOk5GcVdUshDMiDtgmVSUmcdU2N+6rxIR/16GmwiFGuU70jgqcnpMBtVE9ODubYwitdi9qWsNPwDMmIQtQu41IN5Oih2oOUzeu2nbQsWR8vinq4cytttOEk/qn2BXpHdOzMO1u86AlBTgEeQe1jMPWEOg3C6QEIQkhV0bfRXlOc7pweJq5cG2QVm/3bIJ3aUjzKAubhTAssdw2iUiYL9K3sEQUwqR0dB0qSVP+uRH4hY/zcOidOI2L+MMxL3+abzbvmpFtAiPBEKIIlZiLG8pjikDHS0Rsgudn8WW8yV4NdDF2WhH7npnZdvlHE8i7RjUfkNRdECJB6Bl/TDRoQlyF5sqjkWOD5A0bTYsWQkic8YZwSGCBbRJtPCBE1ISYX3570CSoNEXc0qsxZRTVcMolI9PNKWSnt7yV6fZOeCo3M/+K0GcFdtqbZhLVHXwZeUNIQYhDsmA2aR3ZWYMRT+WRSDtI6agg5NvdXOUmGjQmIp658vYX1dggbW0FhJx7dBCa9kmf+Xk8Zo6hhQsJTOJNwUmGyYOxYUVu5UbHkpDFq9BnYoLEnRHp/X6OyTNvnpLJlAntGT5XbR3pqCeEB6vqON0tIP8wdr/nBzT1rUli1ZgRhLYIC2aecGRIo2UhnQ+agW7B5nMICWskk3RNKM8enVPPCTMoTnOifWKyVpDjAZUkZkp+takn6ZHygN6JezxTf6b96xGxUwuq7dkaV7RwTfOTz243k+wZxXtnZhcfrNUUhSD01Dtf1adJZHRcJc6RRB1od/N9DiF64L1sfDjhG6SrKb2ak2GDHiYhkVlKpuPtruw/F+Z5dE2Y8MB5+APPGLt0Uzm+dzOWnqrJSA3trCtwWihN1gtC8iuaDSbvYgbCXixCu4+1juaaG2HPwvkaQm6zwr+8gZ+hlF4tEzOQ4EcUpY/iEcEYFIolFXUeSS8vXWol6tzbxfo+czzTmzi2rpmwH5+VMeSr3pM09GZZWrRhb+V3s2yNW3tTUlIcv5AgNCWNaUuYmTpSKSKAucQZXLV0GkhK2w+EfFOY9dD2azWrVxom3xlMUdhsGJPo6nFniZknpMAjKpIvUCLSBGKTYeLwEXMKBkmy4yUzy8970AJuQdhoHU9ldVfDujB3sOaDhZ3uV377gRANDiw4YunVkvbSptRDrllQVmvMeV7T6CxJM+QwzNsYt7x+Yd3EFUVs8i/jcTzT92QT7GIZUIsg1K1MgrCx9SXcAL52ZwWNPpOatk8xAeBOD7adiP/MxTM5yc9m72xmmoQ8gq8Y02JtXrqpVxD6r+iL0o+hirNvaPC5mAlsyRJtP/71FpIgpHZlmQs3T7HGwL0tyOfiPkwWM0QmV7C8jnSUaY/v7S96kgShuWXJDFqd5i5kn8ssu7FbPj5UZGRkG/7KQ0kQsrSApWdMM9w/K5vC1WkfoinKW2K+0dyy6EPxd5o2bNjgIEkQtnWzRG/JW4mJidHR0fq9eIJQ8s0fhKEdSgysq/vOu9mSIJR886fRJEEoVVdXf0d/JFQShBJJZm1tLWvQmADMzMz0+z+XLQglv1BAgwIDA4l1rALlpiSWocXHxzP9QP5JGHT8VIJQkiRBKEmCUJIkQShJglCSJEEoSYJQkiRBKEmCUJKkNtZ/AFmg+xQr+VKLAAAAAElFTkSuQmCC" width="150" height="45" alt="Screenshot of Mobile Safari suggesting &quot;On my way!&quot; to replace &quot;omw&quot;">
		 * Flags: IRA */
		browserAutoCorrect?: boolean /* Boolean */; // Flags=IRA
		/** This property corresponds to the HTML5 "inputType" attribute applied to the &lt;input&gt; element for this TextItem. The only currently supported use of this attribute is hinting to touch-enabled mobile devices that a particular keyboard layout should be used. Even here, be careful; to take a random example, using type "number" on Android up to at least 3.2 leads to a keyboard with no "-" key, so negative numbers cannot be entered. Valid values: <table class="normal" cellpadding="2"> <tbody> <tr> <td valign="top"><em>"text"</em></td> <td>Normal text keyboard</td> </tr> <tr> <td valign="top"><em>"digits"</em></td> <td>Makes the text field more suitable for entering a string of digits 0 - 9. On iOS, this causes the virtual keyboard to show a numeric keypad with only "0", "1", "2", ..., "9", and delete keys.</td> </tr> <tr> <td valign="top"><em>"email"</em></td> <td>Makes the text field more suitable for entering an e-mail address. On iOS, this causes the virtual keyboard to show special "@" and "." keys on the alphabetic keys screen.</td> </tr> <tr> <td valign="top"><em>"tel"</em></td> <td>Makes the text field more suitable for entering a telephone number. On iOS, this causes the virtual keyboard to show a numeric keypad with a "+*#" key for displaying punctuation keys.</td> </tr> <tr> <td valign="top"><em>"number"</em></td> <td>Makes the text field more suitable for entering a floating-point value. On iOS, this causes the virtual keyboard to start on the number and punctuation keys screen. NOTE: This is not an appropriate text input type for credit card numbers, postal codes, ISBNs, and other formats that are not strictly parsable as floating-point numbers. This is because the browser is required to perform floating-point value sanitization to ensure that the value is a <a href="http://www.w3.org/TR/html5/infrastructure.html#valid-floating-point-number">valid floating-point number</a>.</td> </tr> <tr> <td valign="top"><em>"url"</em></td> <td>Makes the text field more suitable for entering a URL. On iOS, this causes the virtual keyboard to show a special ".com" key.</td> </tr> <tr> <td valign="top">Any&nbsp;vendor-specific value</td> <td>If a browser supports another input type.</td> </tr> </tbody> </table>
		 * Flags: IRA */
		browserInputType?: string /* String */; // Flags=IRA
		/** Should this form item fire its FormItem.change','change handler (and store its value in the form) on every keypress? Set to false to suppress the 'change' handler firing (and the value stored) on every keypress. Note: If false, the value returned by FormItem.getValue','getValue will not reflect the value displayed in the form item element as long as focus is in the form item element.
		 * Flags: IRW, Group: eventHandling */
		changeOnKeypress?: boolean /* Boolean */; // Flags=IRW
		/** Should entered characters be converted to upper or lowercase? Also applies to values applied with FormItem.setValue. Note: character casing cannot be used at the same time as a TextItem.mask.
		 * Flags: IRWA */
		characterCasing?: CharacterCasing; // Flags=IRWA
		/** Default class used to construct the EditProxy for this component when the component is Canvas.setEditMode','first placed into edit mode.
		 * Flags: IR */
		editProxyConstructor?: string /* SCClassName */; // Flags=IR
		/** How should an empty string entered by the user be stored? This value is typically set to null or "". Note that a call to FormItem.setValue','setValue(null) or FormItem.setValue','setValue("") automatically updates this property to ensure that "empty" values are stored in a consistent format.
		 * Flags: IRW, Group: formValues */
		emptyStringValue?: any; // Flags=IRW
		/** If a TextItem.length is specified for this item, should user input be limited to the specified length? If set to true, user input and values passed to FormItem.setValue','setValue() will be trimmed to the specified length. Otherwise values exceeding the specified length will raise an error on validation. Note that having this value set to true limits user interactivity in some ways. For example users would be unable to paste a longer string into the field for editing without seeing it be truncated.
		 * Flags: IRW */
		enforceLength?: boolean; // Flags=IRW
		/** If this form item has a specified FormItem.optionDataSource, should the item ever perform a fetch against this dataSource to retrieve the related record. Note that for editable textItems, behavior differs slightly than for other item types as we will not issue fetches unless FormItem.alwaysFetchMissingValues has been set to true. See TextItem.shouldFetchMissingValue for more details.
		 * Flags: IRWA, Group: display_values */
		fetchMissingValues?: boolean /* Boolean */; // Flags=IRWA
		/** With formatOnBlur enabled, this textItem will format its value according to the rules described in FormItem.mapValueToDisplay as long as the item does not have focus. Once the user puts focus into the item the formatter will be removed. This provides a simple way for developers to show a nicely formatted display value in a freeform text field, without the need for an explicit FormItem.formatEditorValue and FormItem.parseEditorValue pair.
		 * Flags: IRW */
		formatOnBlur?: boolean /* Boolean */; // Flags=IRW
		/** Should FormItem.formatEditorValue re-run whenever this item recieves or loses focus? Setting this property allows developers to conditionally format the display value based on item.hasFocus, typically to display a longer, more informative string while the item does not have focus, and simplifying it down to an easier-to-edit string when the user puts focus into the item.
		 * Flags: IRW */
		formatOnFocusChange?: boolean /* Boolean */; // Flags=IRW
		/** Default height for text items.
		 * Flags: IRW, Group: appearance */
		height?: number; // Flags=IRW
		/** Sets a keypress filter regular expression to limit valid characters that can be entered by the user. If defined, keys that match the regular expression are allowed; all others are suppressed. The filter is applied after character casing, if defined. Note: keypress filtering cannot be used at the same time as a TextItem.mask.
		 * Flags: IRWA */
		keyPressFilter?: string; // Flags=IRWA
		/** If set, the maximum number of characters for this field. If TextItem.enforceLength','enforceLength is set to true, user input will be limited to this value, and values exceeding this length passed to FormItem.setValue','setValue() will be trimmed. Otherwise values exceeding the specified length will raise an error on validation. If the item has a numeric type, like IntegerItem','integer or FloatItem','float, length is applied to the raw number value, after any specified FormItem.decimalPrecision','decimalPrecision and FormItem.decimalPad','decimalPad but before any formatters - this means the string measured includes sign and decimal placeholder, and padded decimal places as required, but not thousands separators or any custom formatting. See also DataSourceField.length.
		 * Flags: IRW, Group: validation */
		length?: number; // Flags=IRW
		/** Input mask used to filter text entry. Sample masks: Phone number: (###) ###-#### Social Security number: ###-##-#### First name: &gt;?&lt;?????????? Date: ##/##/#### State: &gt;LL Overview of available mask characters <table class="normal"> <tr><th>Character</th><th>Description</th></tr> <tr><td>0</td><td>Digit (0 through 9) or plus [+] or minus [-] signs</td></tr> <tr><td>9</td><td>Digit or space</td></tr> <tr><td>#</td><td>Digit</td></tr> <tr><td>L</td><td>Letter (A through Z)</td></tr> <tr><td>?</td><td>Letter (A through Z) or space</td></tr> <tr><td>A</td><td>Letter or digit</td></tr> <tr><td>a</td><td>Letter or digit</td></tr> <tr><td>C</td><td>Any character or space</td></tr> <tr><td>&nbsp;</td></tr> <tr><td>&lt;</td><td>Causes all characters that follow to be converted to lowercase</td></tr> <tr><td>&gt;</td><td>Causes all characters that follow to be converted to uppercase</td></tr> </table> Any character not matching one of the above mask characters or that is escaped with a backslash (\) is considered to be a literal. Custom mask characters can be defined by standard regular expression character set or range. For example, a hexadecimal color code mask could be: Color: \#>[0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F] Note: input mask cannot be used at the same time as a TextItem.keyPressFilter. Also note that this property is not supported for ComboBoxItem or SpinnerItem, or for items with TextItem.browserInputType set to "digits" or "number".
		 * Flags: IRWA */
		mask?: string; // Flags=IRWA
		/** During entry into masked field, should keystrokes overwrite current position value? By default new keystrokes are inserted into the field.
		 * Flags: IRWA */
		maskOverwriteMode?: boolean; // Flags=IRWA
		/** Character that is used to fill required empty mask positions to display text while control has no focus.
		 * Flags: IRWA */
		maskPadChar?: string; // Flags=IRWA
		/** Character that is used to fill required empty mask positions to display text while control has focus.
		 * Flags: IRWA */
		maskPromptChar?: string; // Flags=IRWA
		/** Should entered mask value be saved with embedded literals?
		 * Flags: IRWA */
		maskSaveLiterals?: boolean; // Flags=IRWA
		/** When generating a print-view of the component containing this TextItem, should the form item expand to accommodate its value? If set to false the text box will not expand to fit its content in the print view, instead showing exactly as it does in the live form.
		 * Flags: IRW, Group: printing */
		printFullText?: boolean /* Boolean */; // Flags=IRW
		/** Text items will submit their containing form on enter keypress if DynamicForm.saveOnEnter','saveOnEnter is true. Setting this property to false will disable this behavior.
		 * Flags: IRW */
		saveOnEnter?: boolean /* Boolean */; // Flags=IRW
		/** Allows the DynamicForm.selectOnClick','selectOnClick behavior to be configured on a per-FormItem basis. Normally all items in a form default to the value of DynamicForm.selectOnClick.
		 * Flags: IRW, Group: focus */
		selectOnClick?: boolean; // Flags=IRW
		/** Allows the DynamicForm.selectOnFocus','selectOnFocus behavior to be configured on a per-FormItem basis. Normally all items in a form default to the value of DynamicForm.selectOnFocus.
		 * Flags: IRW, Group: focus */
		selectOnFocus?: boolean; // Flags=IRW
		/** If FormItem.showHint','showing a hint for this form item, should the hint be shown within the field? Unless the HTML5 placeholder attribute is used to display the hint (see TextItem.usePlaceholderForHint), the value of the FormItem.getDataElement','data element will be set to the hint whenever this item is not focused. Also, when displaying the hint, the CSS style of the data element will be set to the TextItem.textBoxStyle','textBoxStyle with the suffix "Hint" appended to it; or, if the item is disabled, the suffix "DisabledHint" will be used. In Page.isRTL','RTL mode when FormItem.showRTL','showRTL is true, an additional "RTL" suffix will be appended; i.e. the CSS style of the data element when the hint is displayed will be the textBoxStyle plus "HintRTL" or "DisabledHintRTL". To change this attribute after being drawn, it is necessary to call FormItem.redraw or redraw the form. <h3>Styling the in-field hint</h3> The in-field hint can be styled with CSS for the textBoxStyle + "Hint" / "HintRTL" / "DisabledHint" / "DisabledHintRTL" styles. For example, if this item's textBoxStyle is set to "mySpecialItem", then changing the hint color to blue can be accomplished with the following CSS: .mySpecialItemHint,.mySpecialItemHintRTL,.mySpecialItemDisabledHint,.mySpecialItemDisabledHintRTL { color: blue;}
		 * Flags: IRWA, Group: appearance */
		showHintInField?: boolean /* Boolean */; // Flags=IRWA
		/** Does the current formItem support native cut and paste events? This attribute only applies to freeform text entry fields such as TextItem and TextAreaItem, and only if TextItem.changeOnKeypress is true. If true, developers can detect the user editing the value via cut or paste interactions (triggered from keyboard shortcuts or the native browser menu options) using the FormItem.isCutEvent and FormItem.isPasteEvent methods. This allows custom cut/paste handling to be added to the various change notification flow methods including FormItem.change, FormItem.handleChange and FormItem.transformInput.
		 * Flags: IRW */
		supportsCutPasteEvents?: boolean; // Flags=IRW
		/** Base CSS class name for this item's input element. NOTE: See the CompoundFormItem_skinning discussion for special skinning considerations. For a rounded text item, you can set textBoxStyle to "roundedTextItem". This style exists only in Enterprise, EnterpriseBlue and Graphite skins. There is no corresponding rounded style for SelectItem or ComboBoxItem as this creates an awkward seam with the pop-up list (and a rounded pop-up list wouldn't help: data could not be flush to corners). For these reasons we recommend rounded inputs only in limited cases like single standalone fields.
		 * Flags: IRW, Group: appearance */
		textBoxStyle?: string /* FormItemBaseStyle */; // Flags=IRW
		/** If TextItem.showHintInField','showing the hint in field and if supported by the browser, should the HTML5 <a href='http://www.whatwg.org/specs/web-apps/current-work/multipage/forms.html#attr-input-placeholder' target='_blank'>placeholder attribute</a> be used to display the hint within the field? If set to false, then use of the placeholder attribute is disabled and an alternative technique to display the hint in-field is used instead. The HTML5 placeholder attribute is supported in the following major browsers: Chrome 4+ Firefox 4+ Internet Explorer 10+ Safari 5+ Opera 11.50+ Android 2.1+ WebView (used by the stock Browser app and when phonegapIntegration','packaging with PhoneGap) Mobile Safari for iOS 3.2+ In browsers other than the above, in-field hints are implemented via a different technique. Note that placeholder behavior is known to differ in Internet Explorer and certain old versions of the above browsers due to a recent change in the HTML5 specification regarding the placeholder attribute. Under the old rules, the placeholder is cleared when the element is focused. In the latest HTML5 spec as published by WHATWG, the placeholder is still displayed when the element is focused as long as the value is an empty string. <h3>Styling the placeholder</h3> While there isn't a standard way to style the placeholder text, Chrome, Firefox, Internet Explorer, and Safari provide vendor-prefixed pseudo-classes and/or pseudo-elements that can be used in CSS selectors: <table border="1"> <tr> <th>Browser</th> <th>Pseudo-class or pseudo-element</th> </tr> <tr> <td>Chrome, Safari</td> <td>::-webkit-input-placeholder</td> </tr> <tr> <td>Firefox 4 - 18</td> <td>:-moz-placeholder</td> </tr> <tr> <td>Firefox 19+</td> <td>::-moz-placeholder</td> </tr> <tr> <td>Internet Explorer</td> <td>:-ms-input-placeholder</td> </tr> </table> Note that unlike other browsers, Firefox 19+ applies opacity:0.4 to the placeholder text. See <a href='https://bugzilla.mozilla.org/show_bug.cgi?id=556145' target='_blank'>Bug 556145 - Placeholder text default style should use opacity instead of GrayText</a> Because browsers are required to ignore the entire rule if a selector is invalid, separate rules are needed for each browser. For example: ::-webkit-input-placeholder { color: blue; opacity: 1;&#125;:-moz-placeholder { color: blue; opacity: 1;&#125;::-moz-placeholder { color: blue; opacity: 1;&#125;:-ms-input-placeholder { color: blue; opacity: 1;&#125; If using <a href='http://sass-lang.com' target='_blank'>Sass</a>, it may be useful to utilize Sass' <a href='http://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector' target='_blank'>parent selector feature</a>. For example: .myCustomItem,.myCustomItemRTL,.myCustomItemDisabled,.myCustomItemDisabledRTL,.myCustomItemError,.myCustomItemErrorRTL,.myCustomItemFocused,.myCustomItemFocusedRTL,.myCustomItemHint,.myCustomItemHintRTL,.myCustomItemDisabledHint,.myCustomItemDisabledHintRTL { // ... &amp;::-webkit-input-placeholder { color: blue; opacity: 1; } &amp;:-moz-placeholder { color: blue; opacity: 1; } &amp;::-moz-placeholder { color: blue; opacity: 1; } &amp;:-ms-input-placeholder { color: blue; opacity: 1; }&#125; If using <a href='http://compass-style.org' target='_blank'>Compass</a>, the <a href='http://compass-style.org/reference/compass/css3/user_interface/#mixin-input-placeholder' target='_blank'>input-placeholder mixin</a> that was added in version 1.0 can further simplify the code to style the placeholder text For example: .myCustomItem,.myCustomItemRTL,.myCustomItemDisabled,.myCustomItemDisabledRTL,.myCustomItemError,.myCustomItemErrorRTL,.myCustomItemFocused,.myCustomItemFocusedRTL,.myCustomItemHint,.myCustomItemHintRTL,.myCustomItemDisabledHint,.myCustomItemDisabledHintRTL { // ... &#64;include input-placeholder { color: blue; opacity: 1; }&#125; <h3>Accessibility concerns</h3> The HTML5 specification notes that a placeholder should not be used as a replacement for a title. The placeholder is intended to be a <em>short</em> hint that assists the user who is entering a value into the empty field. The placeholder can be mistaken by some users for a pre-filled value, particularly in Internet Explorer because the same color is used, and the placeholder text color may provide insufficient contrast, particularly in Firefox 19+ because of the default 0.4 opacity. Furthermore, not having a title reduces the hit area available for setting focus on the item.
		 * Flags: IRA, Group: appearance */
		usePlaceholderForHint?: boolean; // Flags=IRA
		/** Default width for fields.
		 * Flags: IRW, Group: appearance */
		width?: number; // Flags=IRW

		/* Method Overrides */

	} // TextItemProps


	/**
	 * FormItem for managing a text field. 
	 */
	export interface TextItem extends FormItem {
		browserAutoCapitalize: boolean /* Boolean */;

		/** In Mobile Safari, should automatic correction be offered for text in the item's text box? If null, then Mobile Safari determines automatically whether to enable autocorrect. When enabled, Mobile Safari displays "autocorrect bubbles" to suggest automatic corrections: <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAABaCAIAAACNE/xKAAANy0lEQVR4Ae2dB3hV5R3G7d6tdW9wgIoDtQ4cldZRq9Q9invSKlVkqgzZIIgICohKQUCUEBNIghjEhARCCJgACUrYZJA9ySAhi9Nf8vU5z9d7yXhI48017/t8T5573nPOHXB+9z++7yTHOD6VJEmCUJIEoSQJQkmSBKEkCUJJag8ShKGx6b2HBWtoaLTpWLZmR6MQrtxSLA41NNqawOXrdzcFIcORJKnNBIGCsAlJkiCUJEH43sr0xNTidjuSUosdSRKEvh2OJAlCQShJglCSBKEglCRBKEmCUBBKkiCUJEEoCCVJEEqSDyQIJanjQRjzTfrwKR/2fv7VB/sMHvbmB1+s32bvXRAazd41SamRm/aMnv7R/c8OHDTu3aCIeLM3JHrL4PEz7n6yX99hk7+K32XM0DWJnDLns1X288wNjsD8ZMU623x3YSgmb6DjQigJwilzAo/t3P2YYzsxfnjc2fz8+SnnA4Z7wOMvjcCcMGvRcedczgMzfnzCufNDot5ZEPKTE89zzV+fcRH4ccqyqM1sdr36VvuFLr6hF+ZN9z3tOpv3Ff6u06W8+qa9BYKwg0oQQsvPTu7605O6EAAJRxt2ZMPkb8+6BFqmz19mQwh1Pe9+YtHnMWB23zMDcIAHXAeOfYcISTzs8de/Y/Z6tK85q1P3G9lkl9lcuzXtB7/vjPObMy+GPWOCMQ5RVOlox5UgvPKW+8HgtUmzbXP24i8wT72wR8KefBfCzpf1BFFzQOy2DBMzH+k71D0rODIBp8tVt5jNJ/q9zub4mR+78ZZNQ+bi8PXGfGbgGEO7IOygEoQkgSSTvzztwvjdeR5wwhJ4wJUL4QPPDbIPINXEBFfXgUyc48+9wmzOWxppB0YqSbgdNW0e5oAx04153pU3E0thu4NCKAnCsLVJduyyx18e6sOuqXODXAj7j55mH9C9512GUhtpHOpGd5N8lc0tKUVsntbtWmpCslOOue6Oh3HC45LdErGDQigJQlOSXXHTvd4Q3vt0f3bRC3Uh5LE3hEtXb2oMQsadj7+IE7AyztD+7KCxJvr94tQLSHSHTn4fc9yMhR0XQkkQRiTsBgNilDeE197em100P1sDIYEU5+VRb9P14cGHgV9iPvbicB7D//W9HvnR8ecw89GhIZTUmPnV6d0o1VbEfmub65MzmTkAFSYMWwMhz0PNedWtD5Dc0oDduDMHc8bHYRz2VP9ROOzSZL3U0SHsM2S8KcxMI5ThBitDSGsgZNzwt0eZ2wDpa257yDhx27Nw6Mdw8CsTZ3V0CCVBSGfSTBt0u+52ZvyYqzCJ6AU9bmNmr/UQjnhrDiaj38iprnn5n+/BMZG2o0MoCUKTNDL9QHJowDixy5XMK0QnprCr9RCu+nonJoNZftd8Yegkw7nWjkqOILQRYtULq2G0gFuSdBeFJAlCQShJglCSBKEglCRBKEmCUBBKkiCUJD+Q/jSaJPkPhJ9KfqLFixcHBAQEBgYGBweHhISEh4dHRUVt3Lhx69atWVlZ1dXVjv9KEDp+Jelwg2praysrK0tKSnJychISEoKCglauXJmUlITp+ESSIJRqamrS0tKWLl0aFxcnFAWh5Ms4SXYKinv37nUkQSj5MCquXbuWihEmHZ9IEoRSbd3h6JjYoLDwqO350TsKfDU0uEG3KQjj95R8jyGUCIJx8ZuXha8WCT7nsFEI0fceQik2Nnbbtm2O7yV1YAjVqgkLCysqKnL8VIKQ/8J9+dXLE8tnrT4QvKksMf2QI/2ftD2r6tvMqvTCGqeNVVxcHBER4fidBCGV/bRVxZ1eST3h5RR7XDsxY0Fsqdpurdc5r6Xx7/nU3Fyn7RUTE5ORkeH4kQQh0e/2aVmGuuvfyHh+Yd4bK4pe+iT/0lHpxnxybm7ZoTqnLSUImXxn5p2FaU6T4gAO42CncbG2Zs2aNY6/SBBW1Ry+etx+ro+LXk9fkVTuWKqpPTwz8oDh8LE5OU5bShDGGRkOmyTQyGlSoaGhFRUVjl9IEL69qpiL4+xXU3NKjlyujAotNBwu+brMkY5W5zZA+PS83JYAxuOjOMBWcnLyvn37nPYvQZhVXHPm4Po68P3okia6NY98mMMxf5yU4ZofrSsxp2QW18xfV/qvRXmkr3PWlhSV1zrNiXM/aDiXLsXcmJJ/LMgbE1YYkXywru6wicyfJ5W/FlTw7Ee5U1YW84RuWH4v6gAdI96z4yUKV3bllh7h1RfF1e8i5bbNzWmHML2/Vnhj+JXVda6TkHJodtSBgUvyH/937vClhfNiSgqtzxi3t5LjQ7eUO17allnFLje5uGx0fW7Pv1Kzqea6BnlgxqbxW0IgokHKGhqn/UsQBmws48o4b2gal7jTuKDCBENafMY5f1jaKQNStqQd6josDd8d3UelJ+1vpqfKuacPSl2/p7Lz//aBJnxeVFFV99DsHNu8YHiaS92d72bhTP7Cs/++I7sKn6etPtKnoMRlL1WubUI45mkDU3hF1/wmowrzmvH7zWZZZd3AgHwcj8FbWrerwhwTs6sC56whqeVeNfMzvIT17XbTlEw2X19W6DQpA5vLYeNm82vZuAHKaf8ShFz3XBm3Ts10mlRaQbW5/hauL3VBYpNuKmAQxHbnVAfGl1FVYt49I7tZCE/sn3LG4FSOZDokPqWy36f55vlvnJRBNygooYwnXLa53BA+ICDfMe9/QymbV41rgMQSgRSfMOUcSSFbyj0+IyGX7x3zimt2Vrj+1C+LcUaHFprNVz8rYPO6iRnE0j151btyqqiQe0zIwPzTm5lumnDFmP04fHzH0oGDtRDO91R+Wa1x7puVzWG8hNlsOYdHQaB5Y9yI6LR/CUJKFK6M5+bntrCkeTO82IaQVqodQokPmIy80tqmITQXt91xNZfyyQNSCGuu+UkDdZBpNok2nYak4pAi2kRdPDIdkzjmeMkEtFMHpoC9m9kSwDneED5+eZF75G1vZ+F8va+Sx6WV/30tvg4cS+FbD2Iysg/UGGdyeDGbBHCP9BiTDNYj9pJ+m82Wc3gUBBotWbLEaf8ShCZHovXiNKeb36o/clhwgQ0S1Z1jidQOk5GcVdUshDMiDtgmVSUmcdU2N+6rxIR/16GmwiFGuU70jgqcnpMBtVE9ODubYwitdi9qWsNPwDMmIQtQu41IN5Oih2oOUzeu2nbQsWR8vinq4cytttOEk/qn2BXpHdOzMO1u86AlBTgEeQe1jMPWEOg3C6QEIQkhV0bfRXlOc7pweJq5cG2QVm/3bIJ3aUjzKAubhTAssdw2iUiYL9K3sEQUwqR0dB0qSVP+uRH4hY/zcOidOI2L+MMxL3+abzbvmpFtAiPBEKIIlZiLG8pjikDHS0Rsgudn8WW8yV4NdDF2WhH7npnZdvlHE8i7RjUfkNRdECJB6Bl/TDRoQlyF5sqjkWOD5A0bTYsWQkic8YZwSGCBbRJtPCBE1ISYX3570CSoNEXc0qsxZRTVcMolI9PNKWSnt7yV6fZOeCo3M/+K0GcFdtqbZhLVHXwZeUNIQYhDsmA2aR3ZWYMRT+WRSDtI6agg5NvdXOUmGjQmIp658vYX1dggbW0FhJx7dBCa9kmf+Xk8Zo6hhQsJTOJNwUmGyYOxYUVu5UbHkpDFq9BnYoLEnRHp/X6OyTNvnpLJlAntGT5XbR3pqCeEB6vqON0tIP8wdr/nBzT1rUli1ZgRhLYIC2aecGRIo2UhnQ+agW7B5nMICWskk3RNKM8enVPPCTMoTnOifWKyVpDjAZUkZkp+takn6ZHygN6JezxTf6b96xGxUwuq7dkaV7RwTfOTz243k+wZxXtnZhcfrNUUhSD01Dtf1adJZHRcJc6RRB1od/N9DiF64L1sfDjhG6SrKb2ak2GDHiYhkVlKpuPtruw/F+Z5dE2Y8MB5+APPGLt0Uzm+dzOWnqrJSA3trCtwWihN1gtC8iuaDSbvYgbCXixCu4+1juaaG2HPwvkaQm6zwr+8gZ+hlF4tEzOQ4EcUpY/iEcEYFIolFXUeSS8vXWol6tzbxfo+czzTmzi2rpmwH5+VMeSr3pM09GZZWrRhb+V3s2yNW3tTUlIcv5AgNCWNaUuYmTpSKSKAucQZXLV0GkhK2w+EfFOY9dD2azWrVxom3xlMUdhsGJPo6nFniZknpMAjKpIvUCLSBGKTYeLwEXMKBkmy4yUzy8970AJuQdhoHU9ldVfDujB3sOaDhZ3uV377gRANDiw4YunVkvbSptRDrllQVmvMeV7T6CxJM+QwzNsYt7x+Yd3EFUVs8i/jcTzT92QT7GIZUIsg1K1MgrCx9SXcAL52ZwWNPpOatk8xAeBOD7adiP/MxTM5yc9m72xmmoQ8gq8Y02JtXrqpVxD6r+iL0o+hirNvaPC5mAlsyRJtP/71FpIgpHZlmQs3T7HGwL0tyOfiPkwWM0QmV7C8jnSUaY/v7S96kgShuWXJDFqd5i5kn8ssu7FbPj5UZGRkG/7KQ0kQsrSApWdMM9w/K5vC1WkfoinKW2K+0dyy6EPxd5o2bNjgIEkQtnWzRG/JW4mJidHR0fq9eIJQ8s0fhKEdSgysq/vOu9mSIJR886fRJEEoVVdXf0d/JFQShBJJZm1tLWvQmADMzMz0+z+XLQglv1BAgwIDA4l1rALlpiSWocXHxzP9QP5JGHT8VIJQkiRBKEmCUJIkQShJglCSJEEoSYJQkiRBKEmCUJKkNtZ/AFmg+xQr+VKLAAAAAElFTkSuQmCC" width="150" height="45" alt="Screenshot of Mobile Safari suggesting &quot;On my way!&quot; to replace &quot;omw&quot;">
		 * Flags: IRA */
		browserAutoCorrect: boolean /* Boolean */;

		/** This property corresponds to the HTML5 "inputType" attribute applied to the &lt;input&gt; element for this TextItem. The only currently supported use of this attribute is hinting to touch-enabled mobile devices that a particular keyboard layout should be used. Even here, be careful; to take a random example, using type "number" on Android up to at least 3.2 leads to a keyboard with no "-" key, so negative numbers cannot be entered. Valid values: <table class="normal" cellpadding="2"> <tbody> <tr> <td valign="top"><em>"text"</em></td> <td>Normal text keyboard</td> </tr> <tr> <td valign="top"><em>"digits"</em></td> <td>Makes the text field more suitable for entering a string of digits 0 - 9. On iOS, this causes the virtual keyboard to show a numeric keypad with only "0", "1", "2", ..., "9", and delete keys.</td> </tr> <tr> <td valign="top"><em>"email"</em></td> <td>Makes the text field more suitable for entering an e-mail address. On iOS, this causes the virtual keyboard to show special "@" and "." keys on the alphabetic keys screen.</td> </tr> <tr> <td valign="top"><em>"tel"</em></td> <td>Makes the text field more suitable for entering a telephone number. On iOS, this causes the virtual keyboard to show a numeric keypad with a "+*#" key for displaying punctuation keys.</td> </tr> <tr> <td valign="top"><em>"number"</em></td> <td>Makes the text field more suitable for entering a floating-point value. On iOS, this causes the virtual keyboard to start on the number and punctuation keys screen. NOTE: This is not an appropriate text input type for credit card numbers, postal codes, ISBNs, and other formats that are not strictly parsable as floating-point numbers. This is because the browser is required to perform floating-point value sanitization to ensure that the value is a <a href="http://www.w3.org/TR/html5/infrastructure.html#valid-floating-point-number">valid floating-point number</a>.</td> </tr> <tr> <td valign="top"><em>"url"</em></td> <td>Makes the text field more suitable for entering a URL. On iOS, this causes the virtual keyboard to show a special ".com" key.</td> </tr> <tr> <td valign="top">Any&nbsp;vendor-specific value</td> <td>If a browser supports another input type.</td> </tr> </tbody> </table>
		 * Flags: IRA */
		browserInputType: string /* String */;

		/** Should this form item fire its FormItem.change','change handler (and store its value in the form) on every keypress? Set to false to suppress the 'change' handler firing (and the value stored) on every keypress. Note: If false, the value returned by FormItem.getValue','getValue will not reflect the value displayed in the form item element as long as focus is in the form item element.
		 * Flags: IRW, Group: eventHandling */
		changeOnKeypress: boolean /* Boolean */;

		/** Should entered characters be converted to upper or lowercase? Also applies to values applied with FormItem.setValue. Note: character casing cannot be used at the same time as a TextItem.mask.
		 * Flags: IRWA */
		characterCasing: CharacterCasing;

		/** Default class used to construct the EditProxy for this component when the component is Canvas.setEditMode','first placed into edit mode.
		 * Flags: IR */
		editProxyConstructor: string /* SCClassName */;

		/** How should an empty string entered by the user be stored? This value is typically set to null or "". Note that a call to FormItem.setValue','setValue(null) or FormItem.setValue','setValue("") automatically updates this property to ensure that "empty" values are stored in a consistent format.
		 * Flags: IRW, Group: formValues */
		emptyStringValue: any;

		/** If a TextItem.length is specified for this item, should user input be limited to the specified length? If set to true, user input and values passed to FormItem.setValue','setValue() will be trimmed to the specified length. Otherwise values exceeding the specified length will raise an error on validation. Note that having this value set to true limits user interactivity in some ways. For example users would be unable to paste a longer string into the field for editing without seeing it be truncated.
		 * Flags: IRW */
		enforceLength: boolean;

		/** If this form item has a specified FormItem.optionDataSource, should the item ever perform a fetch against this dataSource to retrieve the related record. Note that for editable textItems, behavior differs slightly than for other item types as we will not issue fetches unless FormItem.alwaysFetchMissingValues has been set to true. See TextItem.shouldFetchMissingValue for more details.
		 * Flags: IRWA, Group: display_values */
		fetchMissingValues: boolean /* Boolean */;

		/** With formatOnBlur enabled, this textItem will format its value according to the rules described in FormItem.mapValueToDisplay as long as the item does not have focus. Once the user puts focus into the item the formatter will be removed. This provides a simple way for developers to show a nicely formatted display value in a freeform text field, without the need for an explicit FormItem.formatEditorValue and FormItem.parseEditorValue pair.
		 * Flags: IRW */
		formatOnBlur: boolean /* Boolean */;

		/** Should FormItem.formatEditorValue re-run whenever this item recieves or loses focus? Setting this property allows developers to conditionally format the display value based on item.hasFocus, typically to display a longer, more informative string while the item does not have focus, and simplifying it down to an easier-to-edit string when the user puts focus into the item.
		 * Flags: IRW */
		formatOnFocusChange: boolean /* Boolean */;

		/** Default height for text items.
		 * Flags: IRW, Group: appearance */
		height: number;

		/** Sets a keypress filter regular expression to limit valid characters that can be entered by the user. If defined, keys that match the regular expression are allowed; all others are suppressed. The filter is applied after character casing, if defined. Note: keypress filtering cannot be used at the same time as a TextItem.mask.
		 * Flags: IRWA */
		keyPressFilter: string;

		/** If set, the maximum number of characters for this field. If TextItem.enforceLength','enforceLength is set to true, user input will be limited to this value, and values exceeding this length passed to FormItem.setValue','setValue() will be trimmed. Otherwise values exceeding the specified length will raise an error on validation. If the item has a numeric type, like IntegerItem','integer or FloatItem','float, length is applied to the raw number value, after any specified FormItem.decimalPrecision','decimalPrecision and FormItem.decimalPad','decimalPad but before any formatters - this means the string measured includes sign and decimal placeholder, and padded decimal places as required, but not thousands separators or any custom formatting. See also DataSourceField.length.
		 * Flags: IRW, Group: validation */
		length: number;

		/** Input mask used to filter text entry. Sample masks: Phone number: (###) ###-#### Social Security number: ###-##-#### First name: &gt;?&lt;?????????? Date: ##/##/#### State: &gt;LL Overview of available mask characters <table class="normal"> <tr><th>Character</th><th>Description</th></tr> <tr><td>0</td><td>Digit (0 through 9) or plus [+] or minus [-] signs</td></tr> <tr><td>9</td><td>Digit or space</td></tr> <tr><td>#</td><td>Digit</td></tr> <tr><td>L</td><td>Letter (A through Z)</td></tr> <tr><td>?</td><td>Letter (A through Z) or space</td></tr> <tr><td>A</td><td>Letter or digit</td></tr> <tr><td>a</td><td>Letter or digit</td></tr> <tr><td>C</td><td>Any character or space</td></tr> <tr><td>&nbsp;</td></tr> <tr><td>&lt;</td><td>Causes all characters that follow to be converted to lowercase</td></tr> <tr><td>&gt;</td><td>Causes all characters that follow to be converted to uppercase</td></tr> </table> Any character not matching one of the above mask characters or that is escaped with a backslash (\) is considered to be a literal. Custom mask characters can be defined by standard regular expression character set or range. For example, a hexadecimal color code mask could be: Color: \#>[0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F] Note: input mask cannot be used at the same time as a TextItem.keyPressFilter. Also note that this property is not supported for ComboBoxItem or SpinnerItem, or for items with TextItem.browserInputType set to "digits" or "number".
		 * Flags: IRWA */
		mask: string;

		/** During entry into masked field, should keystrokes overwrite current position value? By default new keystrokes are inserted into the field.
		 * Flags: IRWA */
		maskOverwriteMode: boolean;

		/** Character that is used to fill required empty mask positions to display text while control has no focus.
		 * Flags: IRWA */
		maskPadChar: string;

		/** Character that is used to fill required empty mask positions to display text while control has focus.
		 * Flags: IRWA */
		maskPromptChar: string;

		/** Should entered mask value be saved with embedded literals?
		 * Flags: IRWA */
		maskSaveLiterals: boolean;

		/** When generating a print-view of the component containing this TextItem, should the form item expand to accommodate its value? If set to false the text box will not expand to fit its content in the print view, instead showing exactly as it does in the live form.
		 * Flags: IRW, Group: printing */
		printFullText: boolean /* Boolean */;

		/** Text items will submit their containing form on enter keypress if DynamicForm.saveOnEnter','saveOnEnter is true. Setting this property to false will disable this behavior.
		 * Flags: IRW */
		saveOnEnter: boolean /* Boolean */;

		/** Allows the DynamicForm.selectOnClick','selectOnClick behavior to be configured on a per-FormItem basis. Normally all items in a form default to the value of DynamicForm.selectOnClick.
		 * Flags: IRW, Group: focus */
		selectOnClick: boolean;

		/** Allows the DynamicForm.selectOnFocus','selectOnFocus behavior to be configured on a per-FormItem basis. Normally all items in a form default to the value of DynamicForm.selectOnFocus.
		 * Flags: IRW, Group: focus */
		selectOnFocus: boolean;

		/** If FormItem.showHint','showing a hint for this form item, should the hint be shown within the field? Unless the HTML5 placeholder attribute is used to display the hint (see TextItem.usePlaceholderForHint), the value of the FormItem.getDataElement','data element will be set to the hint whenever this item is not focused. Also, when displaying the hint, the CSS style of the data element will be set to the TextItem.textBoxStyle','textBoxStyle with the suffix "Hint" appended to it; or, if the item is disabled, the suffix "DisabledHint" will be used. In Page.isRTL','RTL mode when FormItem.showRTL','showRTL is true, an additional "RTL" suffix will be appended; i.e. the CSS style of the data element when the hint is displayed will be the textBoxStyle plus "HintRTL" or "DisabledHintRTL". To change this attribute after being drawn, it is necessary to call FormItem.redraw or redraw the form. <h3>Styling the in-field hint</h3> The in-field hint can be styled with CSS for the textBoxStyle + "Hint" / "HintRTL" / "DisabledHint" / "DisabledHintRTL" styles. For example, if this item's textBoxStyle is set to "mySpecialItem", then changing the hint color to blue can be accomplished with the following CSS: .mySpecialItemHint,.mySpecialItemHintRTL,.mySpecialItemDisabledHint,.mySpecialItemDisabledHintRTL { color: blue;}
		 * Flags: IRWA, Group: appearance */
		showHintInField: boolean /* Boolean */;

		/** Does the current formItem support native cut and paste events? This attribute only applies to freeform text entry fields such as TextItem and TextAreaItem, and only if TextItem.changeOnKeypress is true. If true, developers can detect the user editing the value via cut or paste interactions (triggered from keyboard shortcuts or the native browser menu options) using the FormItem.isCutEvent and FormItem.isPasteEvent methods. This allows custom cut/paste handling to be added to the various change notification flow methods including FormItem.change, FormItem.handleChange and FormItem.transformInput.
		 * Flags: IRW */
		supportsCutPasteEvents: boolean;

		/** Base CSS class name for this item's input element. NOTE: See the CompoundFormItem_skinning discussion for special skinning considerations. For a rounded text item, you can set textBoxStyle to "roundedTextItem". This style exists only in Enterprise, EnterpriseBlue and Graphite skins. There is no corresponding rounded style for SelectItem or ComboBoxItem as this creates an awkward seam with the pop-up list (and a rounded pop-up list wouldn't help: data could not be flush to corners). For these reasons we recommend rounded inputs only in limited cases like single standalone fields.
		 * Flags: IRW, Group: appearance */
		textBoxStyle: string /* FormItemBaseStyle */;

		/** If TextItem.showHintInField','showing the hint in field and if supported by the browser, should the HTML5 <a href='http://www.whatwg.org/specs/web-apps/current-work/multipage/forms.html#attr-input-placeholder' target='_blank'>placeholder attribute</a> be used to display the hint within the field? If set to false, then use of the placeholder attribute is disabled and an alternative technique to display the hint in-field is used instead. The HTML5 placeholder attribute is supported in the following major browsers: Chrome 4+ Firefox 4+ Internet Explorer 10+ Safari 5+ Opera 11.50+ Android 2.1+ WebView (used by the stock Browser app and when phonegapIntegration','packaging with PhoneGap) Mobile Safari for iOS 3.2+ In browsers other than the above, in-field hints are implemented via a different technique. Note that placeholder behavior is known to differ in Internet Explorer and certain old versions of the above browsers due to a recent change in the HTML5 specification regarding the placeholder attribute. Under the old rules, the placeholder is cleared when the element is focused. In the latest HTML5 spec as published by WHATWG, the placeholder is still displayed when the element is focused as long as the value is an empty string. <h3>Styling the placeholder</h3> While there isn't a standard way to style the placeholder text, Chrome, Firefox, Internet Explorer, and Safari provide vendor-prefixed pseudo-classes and/or pseudo-elements that can be used in CSS selectors: <table border="1"> <tr> <th>Browser</th> <th>Pseudo-class or pseudo-element</th> </tr> <tr> <td>Chrome, Safari</td> <td>::-webkit-input-placeholder</td> </tr> <tr> <td>Firefox 4 - 18</td> <td>:-moz-placeholder</td> </tr> <tr> <td>Firefox 19+</td> <td>::-moz-placeholder</td> </tr> <tr> <td>Internet Explorer</td> <td>:-ms-input-placeholder</td> </tr> </table> Note that unlike other browsers, Firefox 19+ applies opacity:0.4 to the placeholder text. See <a href='https://bugzilla.mozilla.org/show_bug.cgi?id=556145' target='_blank'>Bug 556145 - Placeholder text default style should use opacity instead of GrayText</a> Because browsers are required to ignore the entire rule if a selector is invalid, separate rules are needed for each browser. For example: ::-webkit-input-placeholder { color: blue; opacity: 1;&#125;:-moz-placeholder { color: blue; opacity: 1;&#125;::-moz-placeholder { color: blue; opacity: 1;&#125;:-ms-input-placeholder { color: blue; opacity: 1;&#125; If using <a href='http://sass-lang.com' target='_blank'>Sass</a>, it may be useful to utilize Sass' <a href='http://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector' target='_blank'>parent selector feature</a>. For example: .myCustomItem,.myCustomItemRTL,.myCustomItemDisabled,.myCustomItemDisabledRTL,.myCustomItemError,.myCustomItemErrorRTL,.myCustomItemFocused,.myCustomItemFocusedRTL,.myCustomItemHint,.myCustomItemHintRTL,.myCustomItemDisabledHint,.myCustomItemDisabledHintRTL { // ... &amp;::-webkit-input-placeholder { color: blue; opacity: 1; } &amp;:-moz-placeholder { color: blue; opacity: 1; } &amp;::-moz-placeholder { color: blue; opacity: 1; } &amp;:-ms-input-placeholder { color: blue; opacity: 1; }&#125; If using <a href='http://compass-style.org' target='_blank'>Compass</a>, the <a href='http://compass-style.org/reference/compass/css3/user_interface/#mixin-input-placeholder' target='_blank'>input-placeholder mixin</a> that was added in version 1.0 can further simplify the code to style the placeholder text For example: .myCustomItem,.myCustomItemRTL,.myCustomItemDisabled,.myCustomItemDisabledRTL,.myCustomItemError,.myCustomItemErrorRTL,.myCustomItemFocused,.myCustomItemFocusedRTL,.myCustomItemHint,.myCustomItemHintRTL,.myCustomItemDisabledHint,.myCustomItemDisabledHintRTL { // ... &#64;include input-placeholder { color: blue; opacity: 1; }&#125; <h3>Accessibility concerns</h3> The HTML5 specification notes that a placeholder should not be used as a replacement for a title. The placeholder is intended to be a <em>short</em> hint that assists the user who is entering a value into the empty field. The placeholder can be mistaken by some users for a pre-filled value, particularly in Internet Explorer because the same color is used, and the placeholder text color may provide insufficient contrast, particularly in Firefox 19+ because of the default 0.4 opacity. Furthermore, not having a title reduces the hit area available for setting focus on the item.
		 * Flags: IRA, Group: appearance */
		usePlaceholderForHint: boolean;

		/** Default width for fields.
		 * Flags: IRW, Group: appearance */
		width: number;


		/* Instance Method Overrides */

	} // TextItem

	export interface TextItemStatic<T, P> extends FormItemStatic<T, P> {
	} // TextItemStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a TextSettings Props argument.
	 * This is derived from the methods in the TextSettings class and it's parents and their properties marked with the I flag.
	 */
	export interface TextSettingsProps  {
		/** EscapingMode expected for escaping special characters embedded in text values.
		 * Flags: IR */
		escapingMode?: EscapingMode; // Flags=IR
		/** For export, a set of fields to export. Default is to export all DataSource fields. Fields may be specified that are not in the DataSource but for which data values are present in the provided Records. In this case the field is assumed to be of type "text". For import, names of DataSource fields to use to parse values, in order. If fieldList is unset, DataSource fields are used, in order. If more values exist in a given Record than the listed fields or than all DataSource fields, remaining values are ignored.
		 * Flags: IR */
		fieldList?: Array<string> /* Array of String */; // Flags=IR
		/** Separator between field values. Default is a comma character, producing CSV (comma-separated values) format.
		 * Flags: IR */
		fieldSeparator?: string /* String */; // Flags=IR
		/** Separator between Records. For import, default of null means that either the Unix/Mac format of just a newline ("\n") or the typical DOS/Windows format of a carriage return and newline ("\r\n") will be accepted. For export, overridden in TextExportSettings.
		 * Flags: IR */
		lineSeparator?: string /* String */; // Flags=IR
	} // TextSettingsProps


	/**
	 * Common base class of TextImportSettings. 
	 */
	export interface TextSettings  {
		/** EscapingMode expected for escaping special characters embedded in text values.
		 * Flags: IR */
		escapingMode: EscapingMode;

		/** For export, a set of fields to export. Default is to export all DataSource fields. Fields may be specified that are not in the DataSource but for which data values are present in the provided Records. In this case the field is assumed to be of type "text". For import, names of DataSource fields to use to parse values, in order. If fieldList is unset, DataSource fields are used, in order. If more values exist in a given Record than the listed fields or than all DataSource fields, remaining values are ignored.
		 * Flags: IR */
		fieldList: Array<string> /* Array of String */;

		/** Separator between field values. Default is a comma character, producing CSV (comma-separated values) format.
		 * Flags: IR */
		fieldSeparator: string /* String */;

		/** Separator between Records. For import, default of null means that either the Unix/Mac format of just a newline ("\n") or the typical DOS/Windows format of a carriage return and newline ("\r\n") will be accepted. For export, overridden in TextExportSettings.
		 * Flags: IR */
		lineSeparator: string /* String */;

	} // TextSettings

	export interface TextSettingsStatic<T, P> extends ClassStatic<T, P> {
	} // TextSettingsStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a Time Props argument.
	 * This is derived from the methods in the Time class and it's parents and their properties marked with the I flag.
	 */
	export interface TimeProps  {
	} // TimeProps


	/**
	 * Helper methods and system-wide defaults for dealing with time values and time display formats. This class includes utility methods for the creation and display of logical time values, as well as modifying the default display timezone for datetime type values. See dateFormatAndStorage for more information on working with dates, times and datetimes in SmartClient. 
	 */
	export interface Time  {
	} // Time

	export interface TimeStatic<T, P> extends ClassStatic<T, P> {

	/* Methods */

		/** 
		 * Sets the offset from UTC to use when formatting values of type FieldType','datetime with standard display formatters. This property affects how dates are displayed and also the assumed timezone for user-input. For a concrete example - assume this method has been called and passed a value of "+01:00", and an application has a DateTimeItem visible in a DynamicForm. If the value of this field is set to the current date, with UTC time set to "10:00", the time portion of the value displayed in the form item will be "11:00". Similarly if a user modifies the time value in the text box to be "16:00", a call to FormItem.getValue for the item will return a date object with UTC time set to 15:00. Interaction with daylight savings time: The specified "defaultDisplayTimezone" should reflect the correct UTC offset for the current date, for which it will always be exactly respected; adjustment will only be made for dates that fall outside the current daylight savings time mode. In other words if DST is currently not in effect (IE: the current date is a Winter date), any other dates where DST is not in effect will be formatted to exactly respect the specified defaultDisplayTimezone (so for defaultDisplayTimezone of "+01:00", the display string will be 1 hour ahead of the UTC time on the date in question), and any dates where DST is in effect would be further adjusted to account for DST (so the display string would be 2 hours ahead for dates that fall in the Summer). Alternatively if DST currently is in effect (EG: Current date is a Summer date) the situation is reversed. Any date value for which DST should be applied will be be formatted for display with an offset of 1 hour from UTC - and any date value for which DST should not be applied would be formatted with an offset of 0 hours from UTC. Note that the Time.adjustForDST property may be set to false to disable this logic - in this case the time portion of dates will always be offset from UTC by exactly the specified defaultDisplayOffset, regardless of whether they fall in the range where Daylight Savings Time would usually be applied or not. Note that if a custom timezone is specified, it will not effect native javascript date formatting functions such as toLocaleString(). See dateFormatAndStorage for more on how SmartClient handles date and time formatting and storage. If this method is never called, the default display timezone for times and datetimes will be derived from the native browser local timezone. Note that the displayTimezone effects datetime fields only and has no effect on fields specified as logical date (field.type = "date";) or logical time (field.type = "time").
		 * @param {string} offset - offset from UTC. This should be a string in the format +/-HH:MM for example "-08:00"
		 */
		setDefaultDisplayTimezone(offset:string): void; 

	} // TimeStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a Toolbar Props argument.
	 * This is derived from the methods in the Toolbar class and it's parents and their properties marked with the I flag.
	 */
	export interface ToolbarProps extends LayoutProps {
		/** Default constructor for toolbar items.
		 * Flags: IRWA, Group: appearance */
		buttonConstructor?: Class; // Flags=IRWA
		/** Settings to apply to all buttons of a toolbar. Properties that can be applied to button objects can be applied to all buttons of a toolbar by specifying them in buttonDefaults using the following syntax: buttonDefaults:{property1:value1, property2:value2, ...} See the Button Widget Class for standard button properties.
		 * Flags: IRWA, Group: appearance */
		buttonDefaults?: any /* object */; // Flags=IRWA
		/** An array of button object initializers. See the Button Widget Class for standard button properties. The following additional properties can also be specified for button sizing and positioning on the toolbar itself: width--Specifies the width of this button as an absolute number of pixels, a named property of the toolbar that specifies an absolute number of pixels, a percentage of the remaining space (e.g. '60%'), or "*" (default) to allocate an equal portion of the remaining space. height--Specifies the height of this button. extraSpace--Specifies an optional amount of extra space, in pixels, to separate this button from the next button in the toolbar.
		 * Flags: IRW */
		buttons?: Array<any> /* array */; // Flags=IRW
		/** If true, items (buttons) can be dropped into this toolbar, and the toolbar will show a drop line at the drop location. Override drop() to decide what happens when the item is dropped.
		 * Flags: IRWA, Group: dragndrop */
		canAcceptDrop?: boolean /* Boolean */; // Flags=IRWA
		/** If true, items can be reordered by dragging on them.
		 * Flags: IRWA, Group: dragndrop */
		canReorderItems?: boolean /* Boolean */; // Flags=IRWA
		/** If true, items (buttons) can be resized by dragging on them.
		 * Flags: IRWA, Group: dragndrop */
		canResizeItems?: boolean /* Boolean */; // Flags=IRWA
		/** If set to true, causes child buttons to be created during initialization, instead of waiting until draw(). This property principally exists for backwards compatibility; the default behavior of waiting until draw makes certain pre-draw operations more efficient (such as adding, removing or reordering buttons). However, if you have code that assumes Buttons are created early and crashes if they are not, createButtonsOnInit will allow that code to continue working, with a minor performance penalty.
		 * Flags: IR */
		createButtonsOnInit?: boolean /* Boolean */; // Flags=IR
		/** Indicates whether the buttons are drawn horizontally from left to right (false), or vertically from top to bottom (true).
		 * Flags: IRW, Group: appearance */
		vertical?: boolean /* Boolean */; // Flags=IRW

		/* Method Overrides */

	} // ToolbarProps


	/**
	 * A Toolbar creates a vertical or horizontal strip of similar components (typically Buttons) and provides managed resizing and reordering behavior over those components. If you are creating a bar with a mixture of different elements (eg some MenuButtons, some Labels, some Buttons, some custom components), you want to use a ToolStrip. A Toolbar is better suited for managing a set of highly similar, interchangeable components, such as ListGrid headers. 
	 */
	export interface Toolbar extends Layout {
		/** Default constructor for toolbar items.
		 * Flags: IRWA, Group: appearance */
		buttonConstructor: Class;

		/** Settings to apply to all buttons of a toolbar. Properties that can be applied to button objects can be applied to all buttons of a toolbar by specifying them in buttonDefaults using the following syntax: buttonDefaults:{property1:value1, property2:value2, ...} See the Button Widget Class for standard button properties.
		 * Flags: IRWA, Group: appearance */
		buttonDefaults: any /* object */;

		/** An array of button object initializers. See the Button Widget Class for standard button properties. The following additional properties can also be specified for button sizing and positioning on the toolbar itself: width--Specifies the width of this button as an absolute number of pixels, a named property of the toolbar that specifies an absolute number of pixels, a percentage of the remaining space (e.g. '60%'), or "*" (default) to allocate an equal portion of the remaining space. height--Specifies the height of this button. extraSpace--Specifies an optional amount of extra space, in pixels, to separate this button from the next button in the toolbar.
		 * Flags: IRW */
		buttons: Array<any> /* array */;

		/** If true, items (buttons) can be dropped into this toolbar, and the toolbar will show a drop line at the drop location. Override drop() to decide what happens when the item is dropped.
		 * Flags: IRWA, Group: dragndrop */
		canAcceptDrop: boolean /* Boolean */;

		/** If true, items can be reordered by dragging on them.
		 * Flags: IRWA, Group: dragndrop */
		canReorderItems: boolean /* Boolean */;

		/** If true, items (buttons) can be resized by dragging on them.
		 * Flags: IRWA, Group: dragndrop */
		canResizeItems: boolean /* Boolean */;

		/** If set to true, causes child buttons to be created during initialization, instead of waiting until draw(). This property principally exists for backwards compatibility; the default behavior of waiting until draw makes certain pre-draw operations more efficient (such as adding, removing or reordering buttons). However, if you have code that assumes Buttons are created early and crashes if they are not, createButtonsOnInit will allow that code to continue working, with a minor performance penalty.
		 * Flags: IR */
		createButtonsOnInit: boolean /* Boolean */;

		/** Indicates whether the buttons are drawn horizontally from left to right (false), or vertically from top to bottom (true).
		 * Flags: IRW, Group: appearance */
		vertical: boolean /* Boolean */;


		/* Instance Method Overrides */

	} // Toolbar

	export interface ToolbarStatic<T, P> extends LayoutStatic<T, P> {
	} // ToolbarStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a ToolStrip Props argument.
	 * This is derived from the methods in the ToolStrip class and it's parents and their properties marked with the I flag.
	 */
	export interface ToolStripProps extends LayoutProps {
		/** DynamicForm instance created by ToolStrip.addFormItem to contain form items for display in this toolStrip. Each time addFormItem() is run, a new formWrapper autoChild will be created, picking up properties according to the standard AutoChild pattern.
		 * Flags: IR */
		formWrapper?:  DynamicForm /* MultiAutoChild DynamicForm */; // Flags=IR
		/** SmartClient class for generated ToolStrip.formWrapper components.
		 * Flags: IRA */
		formWrapperConstructor?: string /* String */; // Flags=IRA
		/** Default properties to apply to ToolStrip.formWrapper components. Default object is as follows: { showTitle:false, numCols:1, overflow:"visible", width:1, height:1 } 
		 * Flags: IR */
		formWrapperDefaults?: any /* Object */; // Flags=IR
		/** Properties to apply to ToolStrip.formWrapper components.
		 * Flags: IR */
		formWrapperProperties?: any /* Object */; // Flags=IR
		/** If set, this attribute affects the alignment of the titles in ToolStripGroup','ToolStripGroups. You can override this at the ToolStripGroup.titleAlign','individual ToolStripGroup level.
		 * Flags: IR */
		groupTitleAlign?: Alignment; // Flags=IR
		/** If set, this attribute affects the orientation of the titles in ToolStripGroup','ToolStripGroups. You can override this at the ToolStripGroup.titleAlign','individual ToolStripGroup level.
		 * Flags: IR */
		groupTitleOrientation?: VerticalAlignment; // Flags=IR
		/** ToolStrips set a default Canvas.height','height to avoid being stretched by containing layouts.
		 * Flags: IRW, Group: sizing */
		height?: number /* Number */; // Flags=IRW
		/** Array of components that will be contained within this Toolstrip, like Layout.members. Built-in special behaviors can be indicated as describe ToolStrip','here.
		 * Flags: IR */
		members?: Array<Canvas> /* Array of Canvas */; // Flags=IR
		/** Customized resizeBar with typical appearance for a ToolStrip.
		 * Flags: IR */
		resizeBarClass?: string /* String */; // Flags=IR
		/** Thickness of the resizeBars in pixels.
		 * Flags: IRA */
		resizeBarSize?: number /* int */; // Flags=IRA
		/** Class to create when the string "separator" appears in ToolStrip.members.
		 * Flags: IR */
		separatorClass?: string /* String */; // Flags=IR
		/** Separator thickness in pixels
		 * Flags: IR */
		separatorSize?: number /* int */; // Flags=IR
		/** If set, this attribute affects whether ToolStripGroup','ToolStripGroups in this ToolStrip show their header control. You can override this at the ToolStripGroup.setShowTitle','individual ToolStripGroup level.
		 * Flags: IR */
		showGroupTitle?: boolean /* Boolean */; // Flags=IR
		/** Indicates whether the components are drawn horizontally from left to right (false), or vertically from top to bottom (true).
		 * Flags: IR, Group: appearance */
		vertical?: boolean /* Boolean */; // Flags=IR
		/** Default stylename to use if ToolStrip.vertical','this.vertical is true. If unset, the standard ToolStrip.styleName will be used for both vertical and horizontal toolstrips. Note that this property only applies to the widget at init time. To modify the styleName after this widget has been initialized, you should simply call Canvas.setStyleName','setStyleName() rather than updating this property.
		 * Flags: IR, Group: appearance */
		verticalStyleName?: string /* CSSStyleName */; // Flags=IR

		/* Method Overrides */

	} // ToolStripProps


	/**
	 * Base class for creating toolstrips like those found in browsers and office applications: a mixed set of controls including ImgButton','icon buttons, Button.radioGroup','radio button groups, MenuButton','menus, ComboBoxItem','comboBoxes, LayoutSpacer','spacers, Label','status displays and SelectItem','drop-down selects. All of the above components are placed in the ToolStrip.members','members array to form a ToolStrip. Note that the FormItem','FormItems mentioned above (ComboBox and drop-down selects) need to be placed within a DynamicForm as usual. The following strings can be used to add special behaviors: the String "separator" will cause a separator to be created (instance of ToolStrip.separatorClass) the String "resizer" will cause a resizer to be created (instance of ToolStrip.resizeBarClass). This is equivalent to setting Canvas.showResizeBar','showResizeBar:true on the preceding member. the String "starSpacer" will cause a spacer to be created (instance of LayoutSpacer).  
	 */
	export interface ToolStrip extends Layout {
		/** DynamicForm instance created by ToolStrip.addFormItem to contain form items for display in this toolStrip. Each time addFormItem() is run, a new formWrapper autoChild will be created, picking up properties according to the standard AutoChild pattern.
		 * Flags: IR */
		formWrapper:  DynamicForm /* MultiAutoChild DynamicForm */;

		/** SmartClient class for generated ToolStrip.formWrapper components.
		 * Flags: IRA */
		formWrapperConstructor: string /* String */;

		/** Default properties to apply to ToolStrip.formWrapper components. Default object is as follows: { showTitle:false, numCols:1, overflow:"visible", width:1, height:1 } 
		 * Flags: IR */
		formWrapperDefaults: any /* Object */;

		/** Properties to apply to ToolStrip.formWrapper components.
		 * Flags: IR */
		formWrapperProperties: any /* Object */;

		/** If set, this attribute affects the alignment of the titles in ToolStripGroup','ToolStripGroups. You can override this at the ToolStripGroup.titleAlign','individual ToolStripGroup level.
		 * Flags: IR */
		groupTitleAlign: Alignment;

		/** If set, this attribute affects the orientation of the titles in ToolStripGroup','ToolStripGroups. You can override this at the ToolStripGroup.titleAlign','individual ToolStripGroup level.
		 * Flags: IR */
		groupTitleOrientation: VerticalAlignment;

		/** ToolStrips set a default Canvas.height','height to avoid being stretched by containing layouts.
		 * Flags: IRW, Group: sizing */
		height: number /* Number */;

		/** Array of components that will be contained within this Toolstrip, like Layout.members. Built-in special behaviors can be indicated as describe ToolStrip','here.
		 * Flags: IR */
		members: Array<Canvas> /* Array of Canvas */;

		/** Customized resizeBar with typical appearance for a ToolStrip.
		 * Flags: IR */
		resizeBarClass: string /* String */;

		/** Thickness of the resizeBars in pixels.
		 * Flags: IRA */
		resizeBarSize: number /* int */;

		/** Class to create when the string "separator" appears in ToolStrip.members.
		 * Flags: IR */
		separatorClass: string /* String */;

		/** Separator thickness in pixels
		 * Flags: IR */
		separatorSize: number /* int */;

		/** If set, this attribute affects whether ToolStripGroup','ToolStripGroups in this ToolStrip show their header control. You can override this at the ToolStripGroup.setShowTitle','individual ToolStripGroup level.
		 * Flags: IR */
		showGroupTitle: boolean /* Boolean */;

		/** Indicates whether the components are drawn horizontally from left to right (false), or vertically from top to bottom (true).
		 * Flags: IR, Group: appearance */
		vertical: boolean /* Boolean */;

		/** Default stylename to use if ToolStrip.vertical','this.vertical is true. If unset, the standard ToolStrip.styleName will be used for both vertical and horizontal toolstrips. Note that this property only applies to the widget at init time. To modify the styleName after this widget has been initialized, you should simply call Canvas.setStyleName','setStyleName() rather than updating this property.
		 * Flags: IR, Group: appearance */
		verticalStyleName: string /* CSSStyleName */;


		/* Instance Method Overrides */

	} // ToolStrip

	export interface ToolStripStatic<T, P> extends LayoutStatic<T, P> {
	} // ToolStripStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a ToolStripButton Props argument.
	 * This is derived from the methods in the ToolStripButton class and it's parents and their properties marked with the I flag.
	 */
	export interface ToolStripButtonProps extends ButtonProps {
	} // ToolStripButtonProps


	/**
	 * Simple subclass of StretchImgButton with appearance appropriate for a ToolStrip button. Can be used to create an icon-only button, and icon with text, or a text only button by setting the icon and title attributes as required. 
	 */
	export interface ToolStripButton extends Button {
	} // ToolStripButton

	export interface ToolStripButtonStatic<T, P> extends ButtonStatic<T, P> {
	} // ToolStripButtonStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a Tree Props argument.
	 * This is derived from the methods in the Tree class and it's parents and their properties marked with the I flag.
	 */
	export interface TreeProps  {
		/** If true, the root node is automatically opened when the tree is created or Tree.setRoot is called.
		 * Flags: IRW */
		autoOpenRoot?: boolean /* Boolean */; // Flags=IRW
		/** For trees with the modelType "children", this property specifies the name of the property that contains the list of children for a node.
		 * Flags: IRW */
		childrenProperty?: string; // Flags=IRW
		/** Optional initial data for the tree. How this data is interpreted depends on this tree's Tree.modelType. If modelType is "parent", the list that you provide will be passed to Tree.linkNodes, integrating the nodes into the tree. In this case the root node may be supplied explicitly via Tree.root, or auto generated, picking up its id via Tree.rootValue. Any nodes in the data with no explicitly specified TreeNode.parentId will be added as children to this root element. To create this tree: foo bar zoo with modelType:"parent", you can do this: Tree.create({ data: [ {name: "foo", id: "foo"}, {name: "bar", id: "bar", parentId: "foo"}, {name: "zoo", id: "zoo"} }); Or this (explicitly specified root): Tree.create({ root: {id: "root"}, data: [ {name: "foo", id: "foo", parentId: "root"}, {name: "bar", id: "bar", parentId: "foo"}, {name: "zoo", id: "zoo", parentId: "root"} }); Or this (explicitly specified rootValue): Tree.create({ rootValue: "root", data: [ {name: "foo", id: "foo", parentId: "root"}, {name: "bar", id: "bar", parentId: "foo"}, {name: "zoo", id: "zoo", parentId: "root"} }); Specifying the root node explicitly allows you to give it a name, changing the way path derivation works (see Tree.root for more on naming the root node). For modelType:"children" trees, the data passed in will be assumed to be an array of children of the tree's root node.
		 * Flags: IR */
		data?: any /* List of TreeNode */; // Flags=IR
		/** Controls whether nodes are assumed to be folders or leaves by default. Nodes that have children or have the Tree.isFolderProperty set to true will be considered folders by default. Other nodes will be considered folders or leaves by default according to this setting. See also ResultTree.defaultIsFolder for more details on how defaultIsFolder interacts with TreeGrid.loadDataOnDemand','loading data on demand.
		 * Flags: IR */
		defaultIsFolder?: boolean; // Flags=IR
		/** Title assigned to nodes without a Tree.titleProperty value or a Tree.nameProperty value.
		 * Flags: IRW */
		defaultNodeTitle?: string; // Flags=IRW
		/** If this tree has Tree.modelType','modelType:"parent", should nodes in the data array for the tree be dropped if they have an explicitly specified value for the Tree.parentIdField which doesn't match any other nodes in the tree. If set to false these nodes will be added as children of the root node.
		 * Flags: IRA */
		discardParentlessNodes?: boolean /* Boolean */; // Flags=IRA
		/** Name of the property on a TreeNode that holds an id for the node which is unique across the entire Tree. Required for all nodes for trees with modelType "parent". Default value is "id". See TreeNode.id for usage.
		 * Flags: IRA */
		idField?: string; // Flags=IRA
		/** Name of property that defines whether a node is a folder. By default this is set to TreeNode.isFolder.
		 * Flags: IRW */
		isFolderProperty?: string /* String */; // Flags=IRW
		/** Selects the model used to construct the tree representation. See TreeModelType for the available options and their implications. If the "parent" modelType is used, you can provide the initial parent-linked data set to the tree via the Tree.data attribute. If the "children" modelType is used, you can provide the initial tree structure to the Tree via the Tree.root attribute.
		 * Flags: IRWA */
		modelType?: TreeModelType; // Flags=IRWA
		/** Name of the property on a TreeNode that holds a name for the node that is unique among its immediate siblings, thus allowing a unique path to be used to identify the node, similar to a file system. Default value is "name". See TreeNode.name for usage.
		 * Flags: IRW */
		nameProperty?: string; // Flags=IRW
		/** The property consulted by the default implementation of Tree.isOpen to determine if the node is open or not. By default, this property is auto-generated for you, but you can set it to a custom value if you want to declaratively specify this state, but be careful - if you display this Tree in multiple TreeGrids at the same time, the open state will not be tracked independently - see sharingNodes for more info on this.
		 * Flags: IRWA, Group: openList */
		openProperty?: string; // Flags=IRWA
		/** For trees with modelType "parent", this property specifies the name of the property that contains the unique parent ID of a node. Default value is "parentId". See TreeNode.parentId for usage.
		 * Flags: IRA */
		parentIdField?: string; // Flags=IRA
		/** Specifies the delimiter between node names. The pathDelim is used to construct a unique path to each node. A path can be obtained for any node by calling Tree.getPath and can be used to find any node in the tree by calling Tree.find. Note that you can also hand-construct a path - in other words you are not required to call Tree.getPath in order to later use Tree.find to retrieve it. The pathDelim can be any character or sequence of characters, but must be a unique string with respect to the text that can appear in the Tree.nameProperty that's used for naming the nodes. So for example, if you have the following tree: one two three/four Then you will be unable to find the three/four node using Tree.find if your tree is using the default pathDelim of /. In such a case, you can use a different pathDelim for the tree. For example if you used | for the path delim, then you can find the three/four node in the tree above by calling tree.find("one|two|three/four"). The pathDelim is used only by Tree.getPath and Tree.find and does not affect any aspect of the tree structure or other forms of tree navigation (such as via Tree.getChildren).
		 * Flags: IRWA */
		pathDelim?: string /* String */; // Flags=IRWA
		/** If new nodes are added to a tree with modelType:"parent" which have the same Tree.idField','id field value as existing nodes, the existing nodes are removed when the new nodes are added. If reportCollisions is true, the Tree will log a warning in the developer console about this. Note that if an id collision occurs between a new node and its ancestor, the ancestor will be removed and the new node will not be added to the tree.
		 * Flags: IR */
		reportCollisions?: boolean /* Boolean */; // Flags=IR
		/** If you're using the "parent" modelType, you can provide the root node configuration via this property. If you don't provide it, one will be auto-created for you with an empty name. Read on for a description of what omitting the name property on the root node means for path derivation. If you're using the "children" modelType, you can provide the initial tree data via this property. So, for example, to construct the following tree: foo bar zoo You would initialize the tree as follows: Tree.create({ root: { name:"root", children: [ { name:"foo", children: [ { name: "bar" } ]}, { name: "zoo" } ]} }); Note that if you provide a name property for the root node, then the path to any node underneath it will start with that name. So in the example above, the path to the bar node would be root/foo/bar (assuming you're using the default Tree.pathDelim. If you omit the name attribute on the root node, then its name is automatically set to the Tree.pathDelim value. So in the example above, if you omitted name:"root", then the path to the bar node would be /foo/bar. Note: if you initialize a Tree with no root value, a root node will be auto-created for you. You can then call Tree.add to construct the tree.
		 * Flags: IRW */
		root?: TreeNode; // Flags=IRW
		/** If you are using the "parent" modelType and did not specify a root node via Tree.root with an id (Tree.idField), then you can provide the root node's id via this property. See the example in Tree.data for more info.
		 * Flags: IR */
		rootValue?: string|number; // Flags=IR
		/** Should folders be sorted separately from leaves or should nodes be ordered according to their sort field value regardless of whether the node is a leaf or folder?
		 * Flags: IRW */
		separateFolders?: boolean /* Boolean */; // Flags=IRW
		/** Controls whether the implicit root node is returned as part of the visible tree, specifically, whether it is returned in Tree.getOpenList, which is the API view components typically use to get the list of visible nodes. Default is to have the root node be implicit and not included in the open list, which means that the visible tree begins with the children of root. This allows multiple nodes to appear at the top level of the tree. You can set showRoot:true to show the single, logical root node as the only top-level node. This property is only meaningful for Trees where you supplied a value for Tree.root, otherwise, you will see an automatically generated root node that is meaningless to the user.
		 * Flags: IRW */
		showRoot?: boolean /* Boolean */; // Flags=IRW
		/** If Tree.separateFolders is true, should folders be displayed above or below leaves? When set to true folders will appear above leaves when the sortDirection applied to the tree is SortDirection','"ascending"
		 * Flags: IRW */
		sortFoldersBeforeLeaves?: boolean /* Boolean */; // Flags=IRW
		/** Name of the property on a TreeNode that holds the title of the node as it should be shown to the user. Default value is "title". See TreeNode.title for usage.
		 * Flags: IRW */
		titleProperty?: string; // Flags=IRW

		/* Method Overrides */

	} // TreeProps


	/**
	 * A Tree is a data model representing a set of objects linked into a hierarchy. A Tree has no visual presentation, it is displayed by a TreeGrid or ColumnTree when supplied as TreeGrid.data or ColumnTree.data. A Tree can be constructed out of a List of objects interlinked by IDs or via explicitly specified Arrays of child objects. See Tree.modelType for an explanation of how to pass data to a Tree. Typical usage is to call TreeGrid.fetchData to cause automatic creation of a ResultTree, which is a type of Tree that automatically handles loading data on demand. For information on DataBinding Trees, see treeDataBinding. 
	 */
	export interface Tree  {
		/** If true, the root node is automatically opened when the tree is created or Tree.setRoot is called.
		 * Flags: IRW */
		autoOpenRoot: boolean /* Boolean */;

		/** For trees with the modelType "children", this property specifies the name of the property that contains the list of children for a node.
		 * Flags: IRW */
		childrenProperty: string;

		/** Optional initial data for the tree. How this data is interpreted depends on this tree's Tree.modelType. If modelType is "parent", the list that you provide will be passed to Tree.linkNodes, integrating the nodes into the tree. In this case the root node may be supplied explicitly via Tree.root, or auto generated, picking up its id via Tree.rootValue. Any nodes in the data with no explicitly specified TreeNode.parentId will be added as children to this root element. To create this tree: foo bar zoo with modelType:"parent", you can do this: Tree.create({ data: [ {name: "foo", id: "foo"}, {name: "bar", id: "bar", parentId: "foo"}, {name: "zoo", id: "zoo"} }); Or this (explicitly specified root): Tree.create({ root: {id: "root"}, data: [ {name: "foo", id: "foo", parentId: "root"}, {name: "bar", id: "bar", parentId: "foo"}, {name: "zoo", id: "zoo", parentId: "root"} }); Or this (explicitly specified rootValue): Tree.create({ rootValue: "root", data: [ {name: "foo", id: "foo", parentId: "root"}, {name: "bar", id: "bar", parentId: "foo"}, {name: "zoo", id: "zoo", parentId: "root"} }); Specifying the root node explicitly allows you to give it a name, changing the way path derivation works (see Tree.root for more on naming the root node). For modelType:"children" trees, the data passed in will be assumed to be an array of children of the tree's root node.
		 * Flags: IR */
		data: any /* List of TreeNode */;

		/** Controls whether nodes are assumed to be folders or leaves by default. Nodes that have children or have the Tree.isFolderProperty set to true will be considered folders by default. Other nodes will be considered folders or leaves by default according to this setting. See also ResultTree.defaultIsFolder for more details on how defaultIsFolder interacts with TreeGrid.loadDataOnDemand','loading data on demand.
		 * Flags: IR */
		defaultIsFolder: boolean;

		/** Title assigned to nodes without a Tree.titleProperty value or a Tree.nameProperty value.
		 * Flags: IRW */
		defaultNodeTitle: string;

		/** If this tree has Tree.modelType','modelType:"parent", should nodes in the data array for the tree be dropped if they have an explicitly specified value for the Tree.parentIdField which doesn't match any other nodes in the tree. If set to false these nodes will be added as children of the root node.
		 * Flags: IRA */
		discardParentlessNodes: boolean /* Boolean */;

		/** Name of the property on a TreeNode that holds an id for the node which is unique across the entire Tree. Required for all nodes for trees with modelType "parent". Default value is "id". See TreeNode.id for usage.
		 * Flags: IRA */
		idField: string;

		/** Name of property that defines whether a node is a folder. By default this is set to TreeNode.isFolder.
		 * Flags: IRW */
		isFolderProperty: string /* String */;

		/** Selects the model used to construct the tree representation. See TreeModelType for the available options and their implications. If the "parent" modelType is used, you can provide the initial parent-linked data set to the tree via the Tree.data attribute. If the "children" modelType is used, you can provide the initial tree structure to the Tree via the Tree.root attribute.
		 * Flags: IRWA */
		modelType: TreeModelType;

		/** Name of the property on a TreeNode that holds a name for the node that is unique among its immediate siblings, thus allowing a unique path to be used to identify the node, similar to a file system. Default value is "name". See TreeNode.name for usage.
		 * Flags: IRW */
		nameProperty: string;

		/** The property consulted by the default implementation of Tree.isOpen to determine if the node is open or not. By default, this property is auto-generated for you, but you can set it to a custom value if you want to declaratively specify this state, but be careful - if you display this Tree in multiple TreeGrids at the same time, the open state will not be tracked independently - see sharingNodes for more info on this.
		 * Flags: IRWA, Group: openList */
		openProperty: string;

		/** For trees with modelType "parent", this property specifies the name of the property that contains the unique parent ID of a node. Default value is "parentId". See TreeNode.parentId for usage.
		 * Flags: IRA */
		parentIdField: string;

		/** Specifies the delimiter between node names. The pathDelim is used to construct a unique path to each node. A path can be obtained for any node by calling Tree.getPath and can be used to find any node in the tree by calling Tree.find. Note that you can also hand-construct a path - in other words you are not required to call Tree.getPath in order to later use Tree.find to retrieve it. The pathDelim can be any character or sequence of characters, but must be a unique string with respect to the text that can appear in the Tree.nameProperty that's used for naming the nodes. So for example, if you have the following tree: one two three/four Then you will be unable to find the three/four node using Tree.find if your tree is using the default pathDelim of /. In such a case, you can use a different pathDelim for the tree. For example if you used | for the path delim, then you can find the three/four node in the tree above by calling tree.find("one|two|three/four"). The pathDelim is used only by Tree.getPath and Tree.find and does not affect any aspect of the tree structure or other forms of tree navigation (such as via Tree.getChildren).
		 * Flags: IRWA */
		pathDelim: string /* String */;

		/** If new nodes are added to a tree with modelType:"parent" which have the same Tree.idField','id field value as existing nodes, the existing nodes are removed when the new nodes are added. If reportCollisions is true, the Tree will log a warning in the developer console about this. Note that if an id collision occurs between a new node and its ancestor, the ancestor will be removed and the new node will not be added to the tree.
		 * Flags: IR */
		reportCollisions: boolean /* Boolean */;

		/** If you're using the "parent" modelType, you can provide the root node configuration via this property. If you don't provide it, one will be auto-created for you with an empty name. Read on for a description of what omitting the name property on the root node means for path derivation. If you're using the "children" modelType, you can provide the initial tree data via this property. So, for example, to construct the following tree: foo bar zoo You would initialize the tree as follows: Tree.create({ root: { name:"root", children: [ { name:"foo", children: [ { name: "bar" } ]}, { name: "zoo" } ]} }); Note that if you provide a name property for the root node, then the path to any node underneath it will start with that name. So in the example above, the path to the bar node would be root/foo/bar (assuming you're using the default Tree.pathDelim. If you omit the name attribute on the root node, then its name is automatically set to the Tree.pathDelim value. So in the example above, if you omitted name:"root", then the path to the bar node would be /foo/bar. Note: if you initialize a Tree with no root value, a root node will be auto-created for you. You can then call Tree.add to construct the tree.
		 * Flags: IRW */
		root: TreeNode;

		/** If you are using the "parent" modelType and did not specify a root node via Tree.root with an id (Tree.idField), then you can provide the root node's id via this property. See the example in Tree.data for more info.
		 * Flags: IR */
		rootValue: string|number;

		/** Should folders be sorted separately from leaves or should nodes be ordered according to their sort field value regardless of whether the node is a leaf or folder?
		 * Flags: IRW */
		separateFolders: boolean /* Boolean */;

		/** Controls whether the implicit root node is returned as part of the visible tree, specifically, whether it is returned in Tree.getOpenList, which is the API view components typically use to get the list of visible nodes. Default is to have the root node be implicit and not included in the open list, which means that the visible tree begins with the children of root. This allows multiple nodes to appear at the top level of the tree. You can set showRoot:true to show the single, logical root node as the only top-level node. This property is only meaningful for Trees where you supplied a value for Tree.root, otherwise, you will see an automatically generated root node that is meaningless to the user.
		 * Flags: IRW */
		showRoot: boolean /* Boolean */;

		/** If Tree.separateFolders is true, should folders be displayed above or below leaves? When set to true folders will appear above leaves when the sortDirection applied to the tree is SortDirection','"ascending"
		 * Flags: IRW */
		sortFoldersBeforeLeaves: boolean /* Boolean */;

		/** Name of the property on a TreeNode that holds the title of the node as it should be shown to the user. Default value is "title". See TreeNode.title for usage.
		 * Flags: IRW */
		titleProperty: string;


		/* Instance Method Overrides */

	} // Tree

	export interface TreeStatic<T, P> extends ClassStatic<T, P> {

	/* Methods */

	} // TreeStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a UserTask Props argument.
	 * This is derived from the methods in the UserTask class and it's parents and their properties marked with the I flag.
	 */
	export interface UserTaskProps  {
		/** Next element to proceed to if the task is cancelled because the UserTask.targetForm or UserTask.targetVM had cancelEditing() called on it.
		 * Flags: IR */
		cancelElement?: string /* String */; // Flags=IR
		/** An inline definition of the form. Could be used to encode form directly in process xml.
		 * Flags: IRW */
		inlineView?: Canvas; // Flags=IRW
		/** Previous workflow Process.sequences','sequence or Process.elements','element that is helpful for wizards. This element will be executed if UserTask.goToPrevious method of userTask will be invoked. You can get userTask for attached form by using DynamicForm.userTask','userTask property.
		 * Flags: IR */
		previousElement?: string /* String */; // Flags=IR
		/** If saveToServer is set then associated form will perform the normal DynamicForm.submit actions when called (typically from a SubmitItem). By default the form submit action is bypassed.
		 * Flags: IR */
		saveToServer?: boolean /* Boolean */; // Flags=IR
		/** DynamicForm that should be populated with data and that should provide the data for the task outputs. Use UserTask.targetVM to use a ValuesManager instead.
		 * Flags: IR */
		targetForm?: DynamicForm; // Flags=IR
		/** Optional widget that should be shown to allow user input. If this widget is a DynamicForm, it will also be automatically used as the UserTask.targetForm unless either targetForm or UserTask.targetVM is set. UserTask will automatically handle various scenarios of the targetView being not currently visible or draw()n, according to the following rules: if the view itself is marked hidden, it will be show()n if the view is inside a hidden parent, the parent will be show()n if the view is the Tab.pane of a tab in a TabSet, the tab will be selected if the view is listed in SectionStackSection.items for a which is either collapsed or hidden section, the section will be shown and expanded if the view is listed in Window.items for a Window, the Window will be shown if any of these conditions apply to any parent of the targetView, the rules will be applied to that parent as well. For example, the targetView is in a collapsed section inside a tab which is not selected, the section will be expanded and the tab selected 
		 * Flags: IR */
		targetView?: Canvas | string /* Canvas or String */; // Flags=IR
		/** Optional ValuesManager which will receive task inputs and provide task outputs. Use UserTask.targetForm instead of you want to use a DynamicForm.
		 * Flags: IR */
		targetVM?: ValuesManager | string /* ValuesManager or String */; // Flags=IR
		/** If wizard is set then associated form will be hidden after user goes to next or prev step of current workflow.
		 * Flags: IR */
		wizard?: boolean /* Boolean */; // Flags=IR

		/* Method Overrides */

	} // UserTaskProps


	/**
	 * A task that involves showing a user interface to the end user allowing the user to view and input data and press a button (or do some other UI gesture) to complete the task. A UserTask takes the following steps: Optionally show() or otherwise make visible the UserTask.targetView','targetView Provide values to either a DynamicForm designated as the UserTask.targetForm','targetForm or to a ValuesManager designated as the UserTask.targetVM','targetVM, via ValuesManager.setValues','setValues() Waits for notification of completion or cancellation. The UserTask is notified of completion if a SubmitItem is pressed in either the targetForm or any form that is a member of the targetVM. Likewise a CancelItem triggers cancellation. Direct calls to DynamicForm.cancelEditing or DynamicForm.completeEditing achieve the same result. if cancellation occurs, the process continues to the UserTask.cancelElement','cancelElement if completion occurs, values are retrieved from the form or valuesManager and applied to the process state  
	 */
	export interface UserTask  {
		/** Next element to proceed to if the task is cancelled because the UserTask.targetForm or UserTask.targetVM had cancelEditing() called on it.
		 * Flags: IR */
		cancelElement: string /* String */;

		/** An inline definition of the form. Could be used to encode form directly in process xml.
		 * Flags: IRW */
		inlineView: Canvas;

		/** Previous workflow Process.sequences','sequence or Process.elements','element that is helpful for wizards. This element will be executed if UserTask.goToPrevious method of userTask will be invoked. You can get userTask for attached form by using DynamicForm.userTask','userTask property.
		 * Flags: IR */
		previousElement: string /* String */;

		/** If saveToServer is set then associated form will perform the normal DynamicForm.submit actions when called (typically from a SubmitItem). By default the form submit action is bypassed.
		 * Flags: IR */
		saveToServer: boolean /* Boolean */;

		/** DynamicForm that should be populated with data and that should provide the data for the task outputs. Use UserTask.targetVM to use a ValuesManager instead.
		 * Flags: IR */
		targetForm: DynamicForm;

		/** Optional widget that should be shown to allow user input. If this widget is a DynamicForm, it will also be automatically used as the UserTask.targetForm unless either targetForm or UserTask.targetVM is set. UserTask will automatically handle various scenarios of the targetView being not currently visible or draw()n, according to the following rules: if the view itself is marked hidden, it will be show()n if the view is inside a hidden parent, the parent will be show()n if the view is the Tab.pane of a tab in a TabSet, the tab will be selected if the view is listed in SectionStackSection.items for a which is either collapsed or hidden section, the section will be shown and expanded if the view is listed in Window.items for a Window, the Window will be shown if any of these conditions apply to any parent of the targetView, the rules will be applied to that parent as well. For example, the targetView is in a collapsed section inside a tab which is not selected, the section will be expanded and the tab selected 
		 * Flags: IR */
		targetView: Canvas | string /* Canvas or String */;

		/** Optional ValuesManager which will receive task inputs and provide task outputs. Use UserTask.targetForm instead of you want to use a DynamicForm.
		 * Flags: IR */
		targetVM: ValuesManager | string /* ValuesManager or String */;

		/** If wizard is set then associated form will be hidden after user goes to next or prev step of current workflow.
		 * Flags: IR */
		wizard: boolean /* Boolean */;


		/* Instance Method Overrides */

	} // UserTask

	export interface UserTaskStatic<T, P> extends ClassStatic<T, P> {
	} // UserTaskStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a Validator Props argument.
	 * This is derived from the methods in the Validator class and it's parents and their properties marked with the I flag.
	 */
	export interface ValidatorProps  {
		/** Used to create a conditional validator based on AdvancedCriteria','criteria. The criteria defines when the validator applies. The form current values or ListGrid record is used as reference for the criteria. If the criteria match, then the validator will be processed. Otherwise the validator is skipped and assumed valid. To use an applyWhen criteria the form or grid must use a DataSource. <strong>NOTE:</strong> applyWhen is not supported for "binary" fields. <h3>Server and client use</h3> Conditional validators are enforced both on the server and on the client-side when defined on a DataSource field as shown in the examples below. Note the applyWhen element is treated as a Criterion. &lt;!-- Normal format --&gt; &lt;field name="age" type="integer"&gt; &lt;validators&gt; &lt;validator type="integerRange" min="0" max="100"&gt; &lt;applyWhen operator="or"&gt; &lt;criteria&gt; &lt;criterion fieldName="restrictAge" operator="equals" value="true"/&gt; &lt;criterion fieldName="gender" operator="equals" value="female"/&gt; &lt;/criteria&gt; &lt;/applyWhen&gt; &lt;/validator&gt; &lt;/validators&gt; &lt;/field&gt; &lt;!-- Conditional requirement --&gt; &lt;field name="reason" type="text"&gt; &lt;validators&gt; &lt;validator type="required"&gt; &lt;applyWhen fieldName="willAttend" operator="equals" value="false"/&gt; &lt;/validator&gt; &lt;/validators&gt; &lt;/field&gt; The last example above shows an alternate to the requiredIf validator using a xmlCriteriaShorthand','shorthand format which is only available for client-side use. On the client the reason field will change appearance to match other required or non-required fields when willAttend changes. Please see the discussion of conditionally required fields in the DataSourceField.required documentation for important information about additional complexities that can be introduced. <h3>Component XML and client-only use</h3> Conditional validators can also be applied to componentXML','Component XML similarly to provide client-only validations or read-only state management. A common use case is conditionally displaying or enabling fields. Use the readOnly validator with an applyWhen value to control the read-only appearance of a field. The example below shows a field which is hidden when willAttend=true. &lt;!-- field definition within a Component XML DynamicForm --&gt; &lt;field name="reason" type="text"&gt; &lt;validators&gt; &lt;validator type="readOnly" fieldAppearance="hidden"&gt; &lt;applyWhen fieldName="willAttend" operator="equals" value="true"/&gt; &lt;/validator&gt; &lt;/validators&gt; &lt;/field&gt; Conditional validators can be applied to DynamicForm or ListGrid fields in JavaScript code as well.
		 * Flags: IRA */
		applyWhen?: AdvancedCriteria; // Flags=IRA
		/** Applies only to the "isUnique" validator and controls whether the search for existing records is case sensitive or not.
		 * Flags: IR */
		caseSensitive?: boolean; // Flags=IR
		/** Indicates this validator runs on the client only. Normally, if the server is trying to run validators and finds a validator that it can't execute, for safety reasons validation is considered to have failed. Use this flag to explicitly mark a validator that only needs to run on the client.
		 * Flags: IR */
		clientOnly?: boolean /* Boolean */; // Flags=IR
		/** User-defined list of fields on which this validator depends. Primarily used for validators of type "custom" but can also be used to supplement Validator.applyWhen criteria.
		 * Flags: IRA */
		dependentFields?: Array<string> /* Array[] of String */; // Flags=IRA
		/** Text to display if the value does not pass this validation check. If unspecified, default error messages exist for all built-in validators, and a generic message will be used for a custom validator that is not passed.
		 * Flags: IR */
		errorMessage?: string /* String */; // Flags=IR
		/** Applies only to the "isUnique" validator; allows you to name a specific DataSource.operationBindings','operation for the uniqueness check.
		 * Flags: IR */
		operationId?: string /* String */; // Flags=IR
		/** To transform the incoming value that is validated into a different value or format set this property from Validator.condition to the desired value.
		 * Flags: IR */
		resultingValue?: any /* Object */; // Flags=IR
		/** For validators of type "serverCustom" only: a scriptlet in any supported JSR223 scripting language which is run in order to see if validation passes. For example: &lt;validator type="serverCustom"&gt; &lt;serverCondition language="groovy"&gt;&lt;![CDATA[ value &lt; dataSources.StockItem.fetchById(record.itemId).quantity ]]&gt;&lt;/serverCondition&gt; &lt;/validator&gt; The scriptlet should return a boolean true or false value - failing to return a value will be considered a false result (validator failed). If your expression is syntactically invalid, an exception is thrown and the error message is displayed in the client. See serverScript for general information on Server Scripting and JSR223, and velocitySupport for general information on Velocity support, and also see below for special rules for Velocity. Available variables The following variables are available in a serverCondition: dataSource - The current DataSource record - Other submitted values part of the same update value - The value of the field validator - The config of this validator, including all attributes declared on the &lt;validator&gt; tag, presented as a Map field - The field (as a DSField object) Note that "record" will contain only other values submitted at the same time, not the complete DataSource record. For most types of cross-field validation, you should fetch the current saved record using the server-side API DataSource.fetchById(). For example, in Velocity: $dataSource.fetchById($record.primaryKeyField).otherFieldName Note that, while a DSRequest provides dsRequest.oldValues, these values cannot be relied upon for a security check since they could be faked. Server-side custom validators also have access to the standard set of context variables that come from the Servlet API. However, be aware that if you write conditions that depend upon these variables, you preclude your Validator from being used in the widest possible variety of circumstances; for example, in a command-line process. Rather, it will be tied to operating in the context of, say, an HttpSession. Given the above caveat, the following context variables are also available: servletRequest - The associated HttpServletRequest session - The associated HttpSession httpParameters - This variable gives you access to the parameters Map of the associated HttpServletRequest; it is an alternate form of $servletRequest.getParameter requestAttributes - This variable gives you access to the attributes Map of the associated HttpServletRequest; it is an alternate form of $servletRequest.getAttribute sessionAttributes - This variable gives you access to the attributes Map of the associated HttpSession; it is an alternate form of $session.getAttribute Special considerations for Velocity To return a true or false value in Velocity, you script can either be just an expression that returns a boolean value, or the result of evaluating the Velocity template can result in output of "true" or "false". All of the following are valid forms: &nbsp;&nbsp;$value &lt; 100 &nbsp;&nbsp;$util.contains($value, "some string") &nbsp;&nbsp;$record.someField(assuming that "someField" contains a boolean value) &nbsp;&nbsp;$value &gt; $record.otherField For additional troubleshooting information when Velocity expressions aren't working as expected, set the log category org.apache.Velocity to DEBUG in log4j.isc.config.xml. Because it's tricky to call arbitrary Java methods in Velocity, the following special objects are passed to Velocity for convenience: dataSources - The list of all DataSources, accessible by name (so, for example, $dataSources.supplyItem refers to the supplyItem DataSource object). util - A com.isomorphic.util.DataTools object, giving you access to all of that class's useful helper functions 
		 * Flags: IR */
		serverCondition?: string /* String */; // Flags=IR
		/** For validators of type "serverCustom" only, a ServerObject declaration that allows the SmartClient Server to find a Java class via a variety of possible approaches, and call a method on it to perform validation. The target object must implement a method whose first 4 arguments are: Object value, Validator validator, String fieldName, Map record (com.isomorphic.datasource.Validator is a subclass of Map that represents a validator's configuration, and also provides APIs for implementing templated error messages). You provide the name of the method to call by specifying ServerObject.methodName','methodName as part of the serverObject declaration. If you do not specify a methodName, SmartClient expects to find a compliant method called "condition". Additional arguments may be declared and are automatically supplied based on the declared argument type, via dmiOverview','DMI. Available objects include: DataSource - the DataSource where this validator is declared, an instance of com.isomorphic.datasource.DataSource or a subclass HttpServletRequest - from standard Java servlets API HttpServletResponse - from standard Java servlets API ServletContext - from standard Java servlets API HttpSession - from standard Java servlets API RequestContext - an instance of com.isomorphic.servlet.RequestContext RPCManager - the RPCManager associated with the transaction this validation is part of; an instance of com.isomorphic.rpc.RPCManager DSRequest - the DSRequest this validation is part of; an instance of com.isomorphic.datasource.DSRequest DSField - the datasource field which value is validated; an instance of com.isomorphic.datasource.DSField ValidationContext - the context where value is validated; an instance of com.isomorphic.datasource.ValidationContext Note that any servlet-related objects will not be available if your validator is run outside of the scope of an HTTP servlet request, such as a command-line process. Note that "record" will contain only other values submitted at the same time, not the complete DataSource record. For most types of cross-field validation, you should fetch the current saved record. For example: final Map<String, Object> existingRecord = dataSource.fetchById(record); 
		 * Flags: IR */
		serverObject?: ServerObject; // Flags=IR
		/** Indicates this validator runs on the server only.
		 * Flags: IR */
		serverOnly?: boolean; // Flags=IR
		/** Normally, all validators defined for a field will be run even if one of the validators has already failed. However, if stopIfFalse is set, validation will not proceed beyond this validator if the check fails. This is useful to prevent expensive validators from being run unnecessarily, or to allow custom validators that don't need to be robust about handling every conceivable type of value.
		 * Flags: IR */
		stopIfFalse?: boolean /* Boolean */; // Flags=IR
		/** Indicates that if this validator is not passed, the user should not be allowed to exit the field - focus will be forced back into the field until the error is corrected. This property defaults to FormItem.stopOnError if unset. Enabling this property also implies FormItem.validateOnExit is automatically enabled. If this is a server-based validator, setting this property also implies that FormItem.synchronousValidation is forced on.
		 * Flags: IR */
		stopOnError?: boolean; // Flags=IR
		/** Type of the validator. This can be one of the built-in ValidatorType, the string "custom" to define a custom validator, or the string "serverCustom" to define a server-only custom validator.
		 * Flags: IR */
		type?: ValidatorType | string /* ValidatorType | String */; // Flags=IR
		/** If true, validator will be validated when each item's "change" handler is fired as well as when the entire form is submitted or validated. If false, this validator will not fire on the item's "change" handler. Note that this property can also be set at the form/grid or field level; If true at any level and not explicitly false on the validator, the validator will be fired on change - displaying errors and rejecting the change on validation failure.
		 * Flags: IRW */
		validateOnChange?: boolean; // Flags=IRW

		/* Method Overrides */

	} // ValidatorProps


	/**
	 * A validator describes a check that should be performed on a value the user is trying to save. Validators are specified for DataSource fields via the DataSourceField.validators property. Validators that need not be run on the server can also be specified for a specific FormItem or ListGridField. SmartClient supports a powerful library of ValidatorType','ValidatorTypes which have identical behavior on both the client and the server. Beyond this, custom validators can be defined on the client and custom validation logic added on the server. Note that the regexp and mask validator types are very flexible and can be used to perform virtually any kind of formatting check that doesn't involve some large external dataset. Custom validators can be reused on the client by adding them to the global validator list, via the Validator.addValidator method. 
	 */
	export interface Validator  {
		/** Used to create a conditional validator based on AdvancedCriteria','criteria. The criteria defines when the validator applies. The form current values or ListGrid record is used as reference for the criteria. If the criteria match, then the validator will be processed. Otherwise the validator is skipped and assumed valid. To use an applyWhen criteria the form or grid must use a DataSource. <strong>NOTE:</strong> applyWhen is not supported for "binary" fields. <h3>Server and client use</h3> Conditional validators are enforced both on the server and on the client-side when defined on a DataSource field as shown in the examples below. Note the applyWhen element is treated as a Criterion. &lt;!-- Normal format --&gt; &lt;field name="age" type="integer"&gt; &lt;validators&gt; &lt;validator type="integerRange" min="0" max="100"&gt; &lt;applyWhen operator="or"&gt; &lt;criteria&gt; &lt;criterion fieldName="restrictAge" operator="equals" value="true"/&gt; &lt;criterion fieldName="gender" operator="equals" value="female"/&gt; &lt;/criteria&gt; &lt;/applyWhen&gt; &lt;/validator&gt; &lt;/validators&gt; &lt;/field&gt; &lt;!-- Conditional requirement --&gt; &lt;field name="reason" type="text"&gt; &lt;validators&gt; &lt;validator type="required"&gt; &lt;applyWhen fieldName="willAttend" operator="equals" value="false"/&gt; &lt;/validator&gt; &lt;/validators&gt; &lt;/field&gt; The last example above shows an alternate to the requiredIf validator using a xmlCriteriaShorthand','shorthand format which is only available for client-side use. On the client the reason field will change appearance to match other required or non-required fields when willAttend changes. Please see the discussion of conditionally required fields in the DataSourceField.required documentation for important information about additional complexities that can be introduced. <h3>Component XML and client-only use</h3> Conditional validators can also be applied to componentXML','Component XML similarly to provide client-only validations or read-only state management. A common use case is conditionally displaying or enabling fields. Use the readOnly validator with an applyWhen value to control the read-only appearance of a field. The example below shows a field which is hidden when willAttend=true. &lt;!-- field definition within a Component XML DynamicForm --&gt; &lt;field name="reason" type="text"&gt; &lt;validators&gt; &lt;validator type="readOnly" fieldAppearance="hidden"&gt; &lt;applyWhen fieldName="willAttend" operator="equals" value="true"/&gt; &lt;/validator&gt; &lt;/validators&gt; &lt;/field&gt; Conditional validators can be applied to DynamicForm or ListGrid fields in JavaScript code as well.
		 * Flags: IRA */
		applyWhen: AdvancedCriteria;

		/** Applies only to the "isUnique" validator and controls whether the search for existing records is case sensitive or not.
		 * Flags: IR */
		caseSensitive: boolean;

		/** Indicates this validator runs on the client only. Normally, if the server is trying to run validators and finds a validator that it can't execute, for safety reasons validation is considered to have failed. Use this flag to explicitly mark a validator that only needs to run on the client.
		 * Flags: IR */
		clientOnly: boolean /* Boolean */;

		/** User-defined list of fields on which this validator depends. Primarily used for validators of type "custom" but can also be used to supplement Validator.applyWhen criteria.
		 * Flags: IRA */
		dependentFields: Array<string> /* Array[] of String */;

		/** Text to display if the value does not pass this validation check. If unspecified, default error messages exist for all built-in validators, and a generic message will be used for a custom validator that is not passed.
		 * Flags: IR */
		errorMessage: string /* String */;

		/** Applies only to the "isUnique" validator; allows you to name a specific DataSource.operationBindings','operation for the uniqueness check.
		 * Flags: IR */
		operationId: string /* String */;

		/** To transform the incoming value that is validated into a different value or format set this property from Validator.condition to the desired value.
		 * Flags: IR */
		resultingValue: any /* Object */;

		/** For validators of type "serverCustom" only: a scriptlet in any supported JSR223 scripting language which is run in order to see if validation passes. For example: &lt;validator type="serverCustom"&gt; &lt;serverCondition language="groovy"&gt;&lt;![CDATA[ value &lt; dataSources.StockItem.fetchById(record.itemId).quantity ]]&gt;&lt;/serverCondition&gt; &lt;/validator&gt; The scriptlet should return a boolean true or false value - failing to return a value will be considered a false result (validator failed). If your expression is syntactically invalid, an exception is thrown and the error message is displayed in the client. See serverScript for general information on Server Scripting and JSR223, and velocitySupport for general information on Velocity support, and also see below for special rules for Velocity. Available variables The following variables are available in a serverCondition: dataSource - The current DataSource record - Other submitted values part of the same update value - The value of the field validator - The config of this validator, including all attributes declared on the &lt;validator&gt; tag, presented as a Map field - The field (as a DSField object) Note that "record" will contain only other values submitted at the same time, not the complete DataSource record. For most types of cross-field validation, you should fetch the current saved record using the server-side API DataSource.fetchById(). For example, in Velocity: $dataSource.fetchById($record.primaryKeyField).otherFieldName Note that, while a DSRequest provides dsRequest.oldValues, these values cannot be relied upon for a security check since they could be faked. Server-side custom validators also have access to the standard set of context variables that come from the Servlet API. However, be aware that if you write conditions that depend upon these variables, you preclude your Validator from being used in the widest possible variety of circumstances; for example, in a command-line process. Rather, it will be tied to operating in the context of, say, an HttpSession. Given the above caveat, the following context variables are also available: servletRequest - The associated HttpServletRequest session - The associated HttpSession httpParameters - This variable gives you access to the parameters Map of the associated HttpServletRequest; it is an alternate form of $servletRequest.getParameter requestAttributes - This variable gives you access to the attributes Map of the associated HttpServletRequest; it is an alternate form of $servletRequest.getAttribute sessionAttributes - This variable gives you access to the attributes Map of the associated HttpSession; it is an alternate form of $session.getAttribute Special considerations for Velocity To return a true or false value in Velocity, you script can either be just an expression that returns a boolean value, or the result of evaluating the Velocity template can result in output of "true" or "false". All of the following are valid forms: &nbsp;&nbsp;$value &lt; 100 &nbsp;&nbsp;$util.contains($value, "some string") &nbsp;&nbsp;$record.someField(assuming that "someField" contains a boolean value) &nbsp;&nbsp;$value &gt; $record.otherField For additional troubleshooting information when Velocity expressions aren't working as expected, set the log category org.apache.Velocity to DEBUG in log4j.isc.config.xml. Because it's tricky to call arbitrary Java methods in Velocity, the following special objects are passed to Velocity for convenience: dataSources - The list of all DataSources, accessible by name (so, for example, $dataSources.supplyItem refers to the supplyItem DataSource object). util - A com.isomorphic.util.DataTools object, giving you access to all of that class's useful helper functions 
		 * Flags: IR */
		serverCondition: string /* String */;

		/** For validators of type "serverCustom" only, a ServerObject declaration that allows the SmartClient Server to find a Java class via a variety of possible approaches, and call a method on it to perform validation. The target object must implement a method whose first 4 arguments are: Object value, Validator validator, String fieldName, Map record (com.isomorphic.datasource.Validator is a subclass of Map that represents a validator's configuration, and also provides APIs for implementing templated error messages). You provide the name of the method to call by specifying ServerObject.methodName','methodName as part of the serverObject declaration. If you do not specify a methodName, SmartClient expects to find a compliant method called "condition". Additional arguments may be declared and are automatically supplied based on the declared argument type, via dmiOverview','DMI. Available objects include: DataSource - the DataSource where this validator is declared, an instance of com.isomorphic.datasource.DataSource or a subclass HttpServletRequest - from standard Java servlets API HttpServletResponse - from standard Java servlets API ServletContext - from standard Java servlets API HttpSession - from standard Java servlets API RequestContext - an instance of com.isomorphic.servlet.RequestContext RPCManager - the RPCManager associated with the transaction this validation is part of; an instance of com.isomorphic.rpc.RPCManager DSRequest - the DSRequest this validation is part of; an instance of com.isomorphic.datasource.DSRequest DSField - the datasource field which value is validated; an instance of com.isomorphic.datasource.DSField ValidationContext - the context where value is validated; an instance of com.isomorphic.datasource.ValidationContext Note that any servlet-related objects will not be available if your validator is run outside of the scope of an HTTP servlet request, such as a command-line process. Note that "record" will contain only other values submitted at the same time, not the complete DataSource record. For most types of cross-field validation, you should fetch the current saved record. For example: final Map<String, Object> existingRecord = dataSource.fetchById(record); 
		 * Flags: IR */
		serverObject: ServerObject;

		/** Indicates this validator runs on the server only.
		 * Flags: IR */
		serverOnly: boolean;

		/** Normally, all validators defined for a field will be run even if one of the validators has already failed. However, if stopIfFalse is set, validation will not proceed beyond this validator if the check fails. This is useful to prevent expensive validators from being run unnecessarily, or to allow custom validators that don't need to be robust about handling every conceivable type of value.
		 * Flags: IR */
		stopIfFalse: boolean /* Boolean */;

		/** Indicates that if this validator is not passed, the user should not be allowed to exit the field - focus will be forced back into the field until the error is corrected. This property defaults to FormItem.stopOnError if unset. Enabling this property also implies FormItem.validateOnExit is automatically enabled. If this is a server-based validator, setting this property also implies that FormItem.synchronousValidation is forced on.
		 * Flags: IR */
		stopOnError: boolean;

		/** Type of the validator. This can be one of the built-in ValidatorType, the string "custom" to define a custom validator, or the string "serverCustom" to define a server-only custom validator.
		 * Flags: IR */
		type: ValidatorType | string /* ValidatorType | String */;

		/** If true, validator will be validated when each item's "change" handler is fired as well as when the entire form is submitted or validated. If false, this validator will not fire on the item's "change" handler. Note that this property can also be set at the form/grid or field level; If true at any level and not explicitly false on the validator, the validator will be fired on change - displaying errors and rejecting the change on validation failure.
		 * Flags: IRW */
		validateOnChange: boolean;


		/* Instance Method Overrides */

	} // Validator

	export interface ValidatorStatic<T, P> extends ClassStatic<T, P> {
		/** Default error message to display when the standard maxFileSize type validator returns false.
		 * Flags: IR, Group: i18nMessages */
		maxFileSizeExceeded: string /* HTMLString */;

		/** Default error message to display when standard dateRange type validator returns false because the value passed in is less than the specified maximum date. This is a dynamic string - text within &#36;{...} will be evaluated as JS code when the message is displayed, with max and min available as variables mapped to validator.max and validator.min.
		 * Flags: IRA, Group: i18nMessages */
		mustBeEarlierThan: string;

		/** Default error message to display when standard timeRange type validator returns false because the time-portion of the date-value passed in is greater than the specified minimum time. This is a dynamic string - text within &#36;{...} will be evaluated as JS code when the message is displayed, with max and min available as variables mapped to validator.max and validator.min.
		 * Flags: IRA, Group: i18nMessages */
		mustBeEarlierThanTime: string;

		/** Default error message to display when standard lengthRange type validator has validator.max and validator.min set to the same value, and returns false because the value passed is not the same length as these limits. This is a dynamic string - text within &#36;{...} will be evaluated as JS code when the message is displayed, with max and min available as variables mapped to validator.max and validator.min.
		 * Flags: IRA, Group: i18nMessages */
		mustBeExactLength: string;

		/** Default error message to display when standard integerRange type validator returns false because the value passed in is less than the specified minimum. This is a dynamic string - text within &#36;{...} will be evaluated as JS code when the message is displayed, with max and min available as variables mapped to validator.max and validator.min.
		 * Flags: IRA, Group: i18nMessages */
		mustBeGreaterThan: string;

		/** Default error message to display when standard dateRange type validator returns false because the value passed in is greater than the specified maximum date. This is a dynamic string - text within &#36;{...} will be evaluated as JS code when the message is displayed, with max and min available as variables mapped to validator.max and validator.min.
		 * Flags: IRA, Group: i18nMessages */
		mustBeLaterThan: string;

		/** Default error message to display when standard timeRange type validator returns false because the time-portion of the date-value passed in is less than the specified minimum time. This is a dynamic string - text within &#36;{...} will be evaluated as JS code when the message is displayed, with max and min available as variables mapped to validator.max and validator.min.
		 * Flags: IRA, Group: i18nMessages */
		mustBeLaterThanTime: string;

		/** Default error message to display when standard integerRange type validator returns false because the value passed in is greater than the specified maximum. This is a dynamic string - text within &#36;{...} will be evaluated as JS code when the message is displayed, with max and min available as variables mapped to validator.max and validator.min.
		 * Flags: IRA, Group: i18nMessages */
		mustBeLessThan: string;

		/** Default error message to display when standard lengthRange type validator returns false because the value passed in has fewer than validator.min characters. This is a dynamic string - text within &#36;{...} will be evaluated as JS code when the message is displayed, with max and min available as variables mapped to validator.max and validator.min.
		 * Flags: IRA, Group: i18nMessages */
		mustBeLongerThan: string;

		/** Default error message to display when standard lengthRange type validator returns false because the value passed in has more than validator.max characters. This is a dynamic string - text within &#36;{...} will be evaluated as JS code when the message is displayed, with max and min available as variables mapped to validator.max and validator.min.
		 * Flags: IRA, Group: i18nMessages */
		mustBeShorterThan: string;

		/** Default error message to display when standard isBoolean type validator returns false.
		 * Flags: IRA, Group: i18nMessages */
		notABoolean: string;

		/** Default error message to display when standard isDate type validator returns false.
		 * Flags: IRA, Group: i18nMessages */
		notADate: string;

		/** Default error message to display when standard isFloat type validator returns false.
		 * Flags: IRA, Group: i18nMessages */
		notADecimal: string;

		/** Default error message to display when standard isInteger type validator returns false.
		 * Flags: IRA, Group: i18nMessages */
		notAnInteger: string;

		/** Default error message to display when standard isString type validator returns false.
		 * Flags: IRA, Group: i18nMessages */
		notAString: string;

		/** Default error message to display when standard isOneOf type validator is not passed.
		 * Flags: IRA, Group: i18nMessages */
		notOneOf: string;

		/** Default error message to display when validation fails for a field marked as required or with a standard required type validator. The message is also displayed for a field with a standard requiredIf type validator whose condition evaluates to true, because the field has no value.
		 * Flags: IRA, Group: i18nMessages */
		requiredField: string;


	/* Methods */

/* Not - because it conflicts with Class.create()
		/** 
		 * A Validator shouldn't be created directly. Instead pass Properties as each Validator in FormItem.validators or wherever a Validator is needed. 
		 * /
		create(): void; 

 */ 

	} // ValidatorStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a ValuesManager Props argument.
	 * This is derived from the methods in the ValuesManager class and it's parents and their properties marked with the I flag.
	 */
	export interface ValuesManagerProps  {
		/** DSRequest.operationId','operationId to use when performing add operations.
		 * Flags: IRW, Group: operations */
		addOperation?: string /* String */; // Flags=IRW
		/** If explicitly set to false, prevents the ValuesManager from automatically propagating data value changes to its members. You can manually synchronize member data values at any time with a call to ValuesManager.synchronizeMembers.
		 * Flags: IRWA */
		autoSynchronize?: boolean; // Flags=IRWA
		/** Specifies a dataSource for this valuesManager. This dataSource will then be used for validation and client-server flow methods. Can be specified as a dataSource object or an identifier for the dataSource. Note that member forms should have the same dataSource applied to them to allow their items to inherit properties from the DataSource fields.
		 * Flags: IRWA */
		dataSource?: DataSource | string /* DataSource | String */; // Flags=IRWA
		/** Before we start editing the values of this ValuesManager in one or more DataBoundComponents, should we perform a deep clone of the underlying values. See DataSource.deepCloneOnEdit for details of what this means. If this value is not explicitly set, it defaults to the value of DataSource.deepCloneOnEdit. This value can be overridden per-field with DataSourceField.deepCloneOnEdit. Like the other deepCloneOnEdit settings, this flag only has an effect if you are editing a values object that contains nested objects or arrays, using Canvas.dataPath','dataPaths.
		 * Flags: IRWA */
		deepCloneOnEdit?: boolean /* Boolean */; // Flags=IRWA
		/** If set to true, client-side validators will not run on the form when validate() is called. Server-side validators (if any) will still run on attempted save.
		 * Flags: IRWA, Group: validation */
		disableValidation?: boolean; // Flags=IRWA
		/** DSRequest.operationId','operationId to use when performing fetch operations.
		 * Flags: IRW, Group: operations */
		fetchOperation?: string /* String */; // Flags=IRW
		/** The set of member components for this valuesManager. These can be specified at init time via the members property, or updated at runtime via addMember() and removeMember(). Note: Alternatively a DataBoundComponent can be initialized as a member of a valuesManager by setting the valuesManager property of the component to a pre-defined valuesManager instance, or by calling setValuesManager on the component.
		 * Flags: IRW */
		members?: Array<DynamicForm> /* Array of DynamicForm */; // Flags=IRW
		/** What operator should be used to combine sub-criteria from member forms when ValuesManager.getValuesAsCriteria is called?
		 * Flags: IR */
		operator?: OperatorId; // Flags=IR
		/** DSRequest.operationId','operationId to use when performing remove operations.
		 * Flags: IRW, Group: operations */
		removeOperation?: string /* String */; // Flags=IRW
		/** Default DSOperationType to be performed when DynamicForm.saveData is called. This property is automatically set on a call to DynamicForm.editRecord or DynamicForm.editNewRecord, or may be set directly via DynamicForm.setSaveOperationType. If saveOperationType is unset, the form will heuristically determine whether an "add" or "update" operation is intended based on whether the primaryKey field is present and editable.
		 * Flags: IRW */
		saveOperationType?: DSOperationType; // Flags=IRW
		/** When calling ValuesManager.saveData on a form or valuesManager, by default if the server returns an error code, any callback passed into saveData() will not be fired. If the error code returned by the server indicates a validation error, it will be displayed to the user by updating the form items to show the error messages, and firing any specified hiddenValidationErrors handler, otherwise the standard RPCManager error handling logic would be invoked. Developers who want to handle errors themselves can override this default by specifying RPCRequest.willHandleError','dsRequest.willHandleError on the DSRequest. In this case the callback passed in will be fired even if the server returns an error status code. If suppressValidationErrorCallback is set to true, if a save attempt returns a validation error code, the user-specified callback will not be fired even if willHandleError:true was specified on the dsRequest - though for other error codes, the callback would be fired if willHandleError is specified on the request. Note that this is the historical behavior for SmartClient builds 8.0 and earlier 
		 * Flags: IRWA */
		suppressValidationErrorCallback?: boolean /* Boolean */; // Flags=IRWA
		/** DSRequest.operationId','operationId to use when performing update operations.
		 * Flags: IRW, Group: operations */
		updateOperation?: string /* String */; // Flags=IRW

		/* Method Overrides */

		/** 
		 * Add a new member to this valuesManager. Any Canvas can be a member of a valuesManager, even components like Layout or TabSet that do not actually have any values to manage. When "valueless" components like these bind to a ValuesManager, it is in order to provide their own child components with a shared valuesManager so that complex data can be displayed and edited - see DataPath for more details. For components like DynamicForm and ListGrid, which do have a set of values to manage, the component's values will subsequently be available through this valuesManager. Note on pre-existent values when the member component is a DynamicForm: If the valuesManager has a value specified for some field, for which the member form has an item, this value will be applied to the member form. This is true whether the item has a value or not. However if the member form has a value for some field, and the ValuesManager does not have a specified value for the same field, we allow the valuesManager to pick up the value from the member form. Caution: If a DynamicForm without a DataSource is passed to this method, DataBoundComponent.setDataSource will be called on that form, recreating the items from copies of the item configuration stored at the time the form was created. This means that any properties or handlers added to the items after form creation will be lost. When in doubt, set the DataSource in the form as soon as possible.
		 * @param {DynamicForm} member - component (or ID of component) to add to this valuesManager as a member.
		 */
		addMember?(member:DynamicForm | string /* DynamicForm | String */): void; 

		/** 
		 * Retrieve data that matches the provided criteria, and edit the first record returned 
		 * @param {Criteria} criteria - search criteria
		 * @param {DSCallback} callback - callback to invoke on completion
		 * @param {DSRequest} requestProperties - additional properties to set on the DSRequest that will be issued
		 */
		fetchData?(criteria?:Criteria, callback?:DSCallback, requestProperties?:DSRequest): void; 

		/** 
		 * Returns the dataSource for this valuesManager. Will return null if this is not a data-bound valuesManager instance.
		 */
		getDataSource?(): DataSource; 

		/** 
		 * Retrieve a FormItem from this ValuesManager. Takes a field FormItem.name','name or DataPath, and searches through the members of this valuesManager for an editor for that field. If found the appropriate formItem will be returned. If the "retrieveAll" parameter is true, this method will return all FormItems that are bound to the supplied name or dataPath (a dataPath can be bound to more than one FormItem, as long as those FormItems are on different forms); if "retrieveAll" is false or unset, and there is more than one binding for the dataPath, this method just returns the first one it finds. Note that if a dataPath is passed in, it should be the full data path for the item, including any canvas level Canvas.dataPath','dataPath specified on the member form containing this form item. Note: Unlike the DynamicForm class, this method will not return an item by index
		 * @param {string} itemID - item fieldName or dataPath identifier
		 * @param {boolean} retrieveAll - If true, return the list of all FormItems that are bound to this name or dataPath on a member form of this ValuesManager
		 */
		getItem?(itemID:string | string /* fieldName | dataPath */, retrieveAll?:boolean): FormItem /* formItem */; 

		/** 
		 * Returns the value for some field.
		 * @param {string} fieldName - Which value to be returned
		 * @param {Canvas} component - Optional, the component for which we are trying to retrieve a value. This is used to identify which of the potential records to use when the ValuesManager is managing a complex structure involving nested Lists
		 */
		getValue?(fieldName:string, component?:Canvas): any; 

	} // ValuesManagerProps


	/**
	 * The ValuesManager manages data from multiple member forms. If a single logical form needs to be separated into multiple DynamicForm instances for Layout purposes (for example, spanning one logical form across multiple Tabs), a ValuesManager can be used to make the forms act as one logical form, supporting all value-related APIs otherwise called on DynamicForm directly. A ValuesManager has no visual representation - it is strictly a logical entity, and the member forms provide the user interface. You can initialize a ValuesManager with a set of member forms (by setting ValuesManager.members at init) or add and remove member forms dynamically. Calling ValuesManager.setValues on a ValuesManager will automatically route new field values to whichever member form is showing an editor for that field. Likewise, calling ValuesManager.validate will validate all member forms, and ValuesManager.saveData will initiate a save operation which aggregates values from all member forms. Like a DynamicForm, a ValuesManager can be databound by setting ValuesManager.dataSource. In this case all member forms must also be bound to the same DataSource. In general, when working with a ValuesManager and its member forms, call APIs on the ValuesManager whenever you are dealing with values that span multiple forms, and only call APIs on member forms that are specific to that form or its fields. Note that, just as a DynamicForm can track values that are not shown in any FormItem, a ValuesManager may track values for which there is no FormItem in any member form. However, when using a ValuesManager these extra values are only allowed on the ValuesManager itself. Member forms will not track values for which they do not have FormItems. 
	 */
	export interface ValuesManager  {
		/** DSRequest.operationId','operationId to use when performing add operations.
		 * Flags: IRW, Group: operations */
		addOperation: string /* String */;

		/** If explicitly set to false, prevents the ValuesManager from automatically propagating data value changes to its members. You can manually synchronize member data values at any time with a call to ValuesManager.synchronizeMembers.
		 * Flags: IRWA */
		autoSynchronize: boolean;

		/** Specifies a dataSource for this valuesManager. This dataSource will then be used for validation and client-server flow methods. Can be specified as a dataSource object or an identifier for the dataSource. Note that member forms should have the same dataSource applied to them to allow their items to inherit properties from the DataSource fields.
		 * Flags: IRWA */
		dataSource: DataSource | string /* DataSource | String */;

		/** Before we start editing the values of this ValuesManager in one or more DataBoundComponents, should we perform a deep clone of the underlying values. See DataSource.deepCloneOnEdit for details of what this means. If this value is not explicitly set, it defaults to the value of DataSource.deepCloneOnEdit. This value can be overridden per-field with DataSourceField.deepCloneOnEdit. Like the other deepCloneOnEdit settings, this flag only has an effect if you are editing a values object that contains nested objects or arrays, using Canvas.dataPath','dataPaths.
		 * Flags: IRWA */
		deepCloneOnEdit: boolean /* Boolean */;

		/** If set to true, client-side validators will not run on the form when validate() is called. Server-side validators (if any) will still run on attempted save.
		 * Flags: IRWA, Group: validation */
		disableValidation: boolean;

		/** DSRequest.operationId','operationId to use when performing fetch operations.
		 * Flags: IRW, Group: operations */
		fetchOperation: string /* String */;

		/** The set of member components for this valuesManager. These can be specified at init time via the members property, or updated at runtime via addMember() and removeMember(). Note: Alternatively a DataBoundComponent can be initialized as a member of a valuesManager by setting the valuesManager property of the component to a pre-defined valuesManager instance, or by calling setValuesManager on the component.
		 * Flags: IRW */
		members: Array<DynamicForm> /* Array of DynamicForm */;

		/** What operator should be used to combine sub-criteria from member forms when ValuesManager.getValuesAsCriteria is called?
		 * Flags: IR */
		operator: OperatorId;

		/** DSRequest.operationId','operationId to use when performing remove operations.
		 * Flags: IRW, Group: operations */
		removeOperation: string /* String */;

		/** Default DSOperationType to be performed when DynamicForm.saveData is called. This property is automatically set on a call to DynamicForm.editRecord or DynamicForm.editNewRecord, or may be set directly via DynamicForm.setSaveOperationType. If saveOperationType is unset, the form will heuristically determine whether an "add" or "update" operation is intended based on whether the primaryKey field is present and editable.
		 * Flags: IRW */
		saveOperationType: DSOperationType;

		/** When calling ValuesManager.saveData on a form or valuesManager, by default if the server returns an error code, any callback passed into saveData() will not be fired. If the error code returned by the server indicates a validation error, it will be displayed to the user by updating the form items to show the error messages, and firing any specified hiddenValidationErrors handler, otherwise the standard RPCManager error handling logic would be invoked. Developers who want to handle errors themselves can override this default by specifying RPCRequest.willHandleError','dsRequest.willHandleError on the DSRequest. In this case the callback passed in will be fired even if the server returns an error status code. If suppressValidationErrorCallback is set to true, if a save attempt returns a validation error code, the user-specified callback will not be fired even if willHandleError:true was specified on the dsRequest - though for other error codes, the callback would be fired if willHandleError is specified on the request. Note that this is the historical behavior for SmartClient builds 8.0 and earlier 
		 * Flags: IRWA */
		suppressValidationErrorCallback: boolean /* Boolean */;

		/** DSRequest.operationId','operationId to use when performing update operations.
		 * Flags: IRW, Group: operations */
		updateOperation: string /* String */;


		/* Instance Method Overrides */

		/** 
		 * Add a new member to this valuesManager. Any Canvas can be a member of a valuesManager, even components like Layout or TabSet that do not actually have any values to manage. When "valueless" components like these bind to a ValuesManager, it is in order to provide their own child components with a shared valuesManager so that complex data can be displayed and edited - see DataPath for more details. For components like DynamicForm and ListGrid, which do have a set of values to manage, the component's values will subsequently be available through this valuesManager. Note on pre-existent values when the member component is a DynamicForm: If the valuesManager has a value specified for some field, for which the member form has an item, this value will be applied to the member form. This is true whether the item has a value or not. However if the member form has a value for some field, and the ValuesManager does not have a specified value for the same field, we allow the valuesManager to pick up the value from the member form. Caution: If a DynamicForm without a DataSource is passed to this method, DataBoundComponent.setDataSource will be called on that form, recreating the items from copies of the item configuration stored at the time the form was created. This means that any properties or handlers added to the items after form creation will be lost. When in doubt, set the DataSource in the form as soon as possible.
		 * @param {DynamicForm} member - component (or ID of component) to add to this valuesManager as a member.
		 */
		addMember?(member:DynamicForm | string /* DynamicForm | String */): void; 

		/** 
		 * Retrieve data that matches the provided criteria, and edit the first record returned 
		 * @param {Criteria} criteria - search criteria
		 * @param {DSCallback} callback - callback to invoke on completion
		 * @param {DSRequest} requestProperties - additional properties to set on the DSRequest that will be issued
		 */
		fetchData?(criteria?:Criteria, callback?:DSCallback, requestProperties?:DSRequest): void; 

		/** 
		 * Returns the dataSource for this valuesManager. Will return null if this is not a data-bound valuesManager instance.
		 */
		getDataSource?(): DataSource; 

		/** 
		 * Retrieve a FormItem from this ValuesManager. Takes a field FormItem.name','name or DataPath, and searches through the members of this valuesManager for an editor for that field. If found the appropriate formItem will be returned. If the "retrieveAll" parameter is true, this method will return all FormItems that are bound to the supplied name or dataPath (a dataPath can be bound to more than one FormItem, as long as those FormItems are on different forms); if "retrieveAll" is false or unset, and there is more than one binding for the dataPath, this method just returns the first one it finds. Note that if a dataPath is passed in, it should be the full data path for the item, including any canvas level Canvas.dataPath','dataPath specified on the member form containing this form item. Note: Unlike the DynamicForm class, this method will not return an item by index
		 * @param {string} itemID - item fieldName or dataPath identifier
		 * @param {boolean} retrieveAll - If true, return the list of all FormItems that are bound to this name or dataPath on a member form of this ValuesManager
		 */
		getItem?(itemID:string | string /* fieldName | dataPath */, retrieveAll?:boolean): FormItem /* formItem */; 

		/** 
		 * Returns the value for some field.
		 * @param {string} fieldName - Which value to be returned
		 * @param {Canvas} component - Optional, the component for which we are trying to retrieve a value. This is used to identify which of the potential records to use when the ValuesManager is managing a complex structure involving nested Lists
		 */
		getValue?(fieldName:string, component?:Canvas): any; 

	} // ValuesManager

	export interface ValuesManagerStatic<T, P> extends ClassStatic<T, P> {

	/* Methods */

		/** 
		 * Retrieve a ValuesManager by it's global Canvas.ID','ID.
		 * @param {string} ID - global ID of the ValuesManager
		 */
		getById(ID:string /* String */): ValuesManager; 

	} // ValuesManagerStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a VLayout Props argument.
	 * This is derived from the methods in the VLayout class and it's parents and their properties marked with the I flag.
	 */
	export interface VLayoutProps extends LayoutProps {
	} // VLayoutProps


	/**
	 * A subclass of Layout that applies a sizing policy along the vertical axis, interpreting percent and "*" sizes as proportions of the height of the layout. VLayouts will set any members that do not have explicit widths to match the layout. 
	 */
	export interface VLayout extends Layout {
	} // VLayout

	export interface VLayoutStatic<T, P> extends LayoutStatic<T, P> {
	} // VLayoutStatic


	/**
	 * Properties used for passing into .create() or anything else that takes a Window Props argument.
	 * This is derived from the methods in the Window class and it's parents and their properties marked with the I flag.
	 */
	export interface WindowProps extends LayoutProps {
		/** Should this window minimize, maximize, and restore as an animation, or as a simple 1-step transition?
		 * Flags: IRWA, Group: appearance */
		animateMinimize?: boolean; // Flags=IRWA
		/** If true, this Window widget will automatically be centered on the page when shown. If false, it will show up in the last position it was placed (either programmatically, or by user interaction). Note: If an auto-centering Window is either programmatically moved or dragged by an end user, auto-centering behavior is automatically turned off. To manually center a Window, you can use Window.centerInPage.
		 * Flags: IRW, Group: appearance */
		autoCenter?: boolean /* Boolean */; // Flags=IRW
		/** If true, the window is resized automatically to accommodate the contents of the body, if they would otherwise require scrolling.
		 * Flags: IRW, Group: appearance */
		autoSize?: boolean /* Boolean */; // Flags=IRW
		/** Color of the Window body. Overrides the background color specified in the style.
		 * Flags: IRW, Group: appearance */
		bodyColor?: string /* CSSColor */; // Flags=IRW
		/** The name of the widget class (as a string) to use for the body. If unset the appropriate constructor type will be determined as follows: - if Window.items is defined as an array of widgets, and Window.contentLayout is not set to "none", bodyConstructor defaults to a VLayout - if Window.src is set, bodyConstructor defaults to an HTMLFlow - otherwise bodyConstructor will default to a simple Canvas Note that if this property is overridden for some window, the specified constructor should be a subclass of one of these defaults to ensure the window renders out as expected.
		 * Flags: IRWA, Group: appearance */
		bodyConstructor?: string; // Flags=IRWA
		/** Default properties for the body of the Window You can change the class-level bodyDefaults for all Windows by changing this item or set instance.body to be another object of properties to override for your instance only
		 * Flags: IRWA, Group: appearance */
		bodyDefaults?: any /* object */; // Flags=IRWA
		/** Style of the Window body.
		 * Flags: IRW, Group: appearance */
		bodyStyle?: string /* CSSStyleName */; // Flags=IRW
		/** Should this window automatically be shown at the top of the page's z-order and be brought to front via Canvas.bringToFront whenever the user clicks it? If Window.isModal is true for this window, this setting will have no effect - we always bring the window to the front on initial display and on mouseDown. By default we also do this for non-modal windows (which matches user expectation for most standard interfaces - think of switching between OS-level application windows), but this may be disabled for cases where it is not appropriate by setting this attribute to false
		 * Flags: IRW */
		bringToFrontOnMouseUp?: boolean; // Flags=IRW
		/** If true, this Window may be moved around by the user by dragging on the Window header. Note that if the header is not showing, the Window can't be drag-repositioned regardless of this setting.
		 * Flags: IRW, Group: dragging */
		canDragReposition?: boolean /* Boolean */; // Flags=IRW
		/** Can the window be drag-resized? If true the window may be drag resized from its edges, and if showing, via the resizer icon in the footer.
		 * Flags: IRW, Group: dragging */
		canDragResize?: boolean /* Boolean */; // Flags=IRW
		/** If true, the user can give the header buttons focus (see Window.minimizeButton, Window.maximizeButton, Window.restoreButton and Window.closeButton).
		 * Flags: IRWA, Group: focus */
		canFocusInHeaderButtons?: boolean /* Boolean */; // Flags=IRWA
		/** The layout policy that should be used for widgets within the Window body. See ContentLayoutPolicy and Window.bodyConstructor for details.
		 * Flags: IRWA, Group: appearance */
		contentLayout?: ContentLayoutPolicy; // Flags=IRWA
		/** If this window has Window.src specified, this property can be used to indicate whether the source is a standalone HTML page or an HTML fragment. This is similar to the HTMLFlow.contentsType property - be sure to read the HTMLFlow documentation to understand circumstances where contentsType:"page" is unsafe and not recommended.
		 * Flags: IR, Group: appearance */
		contentsType?: string; // Flags=IR
		/** If Window.minimizeHeight is unset, by the window will shrink to the height of the header when minimized. If there is no header, the defaultMinimizeHeight will be used instead.
		 * Flags: IRWA, Group: appearance */
		defaultMinimizeHeight?: number; // Flags=IRWA
		/** Should this window be dismissed (same effect as pressing the "Cancel" button) when the user presses the "Escape" key? Behavior will only occur while the window or one of its descendants has focus, and does not cancel the Escape keypress. If unset default behavior depends on whether a close / cancel button is visible for this item.
		 * Flags: IRW */
		dismissOnEscape?: boolean /* Boolean */; // Flags=IRW
		/** If true, a click outside the bounds of the Window will have the same effect as pressing its cancel button. Note: Applies only to modal windows.
		 * Flags: IRW, Group: modal */
		dismissOnOutsideClick?: boolean /* Boolean */; // Flags=IRW
		/** Default class used to construct the EditProxy for this component when the component is Canvas.setEditMode','first placed into edit mode.
		 * Flags: IR */
		editProxyConstructor?: string /* SCClassName */; // Flags=IR
		/** Alternative style for the window used whenever Window.placement settings indicate the menu will be filling a portion of the screen or a panel. Generally this alternative style should not have rounded or excessively large edges.
		 * Flags: IR */
		fillSpaceStyleName?: string /* CSSStyleName */; // Flags=IR
		/** Array of members to show in the Window footer. The default value of footerControls is an Array of Strings listing the standard footer controls in their default order: footerControls : ["spacer", "resizer"] As with Window.headerControls, you can override footerControls to change the order of standard controls in the footer. "spacer" is a special value which will create a LayoutSpacer in the footer bar. "resizer" will show the Window.resizer in the footer. By embedding a Canvas directly in this list you can add arbitrary additional controls to the footer. Note that the Window.statusBar is not part of the set of footer controls - it is a separate canvas rendered behind all footer controls. If you include some custom status bar directly in the footerControls you may want to set Window.showFooter to false. Tip: custom controls need to set layoutAlign:"center" to appear vertically centered. Component XML: To define footerControls in Component XML a special set of components are used as markers. The standard footer controls can be explicitly specified as: &lt;footerControls&gt; &lt;WindowFooterSpacer/&gt; &lt;WindowResizer/&gt; &lt;/footerControls&gt; 
		 * Flags: IR */
		footerControls?: Array<string> /* Array of String */; // Flags=IR
		/** The height of the footer, in pixels.
		 * Flags: IR, Group: appearance */
		footerHeight?: number; // Flags=IR
		/** Array of members to show in the Window header. The default value of headerControls is an Array of Strings listing the standard header controls in their default order: headerControls : ["headerIcon", "headerLabel", "minimizeButton", "maximizeButton", "closeButton"] You can override headerControls to change the order of standard controls in the header. You can also omit standard controls this way, although it more efficient to use the related "show" property if available (eg Window.showMinimizeButton). By embedding a Canvas directly in this list you can add arbitrary additional controls to the header, for example, an additional button (eg return to dock) or a DynamicForm with various kinds of input controls. Note that having added controls to headerControls, you can still call APIs directly on those controls to change their appearance, and you can also show() and hide() them if they should not be shown in some circumstances. Tip: custom controls need to set layoutAlign:"center" to appear vertically centered. Component XML: To define headerControls in Component XML a special set of components are used as markers. The standard header controls can be explicitly specified as: &lt;headerControls&gt; &lt;WindowHeaderIcon/&gt; &lt;WindowHeaderLabel/&gt; &lt;WindowMinimizeButton/&gt; &lt;WindowMaximizeButton/&gt; &lt;WindowCloseButton/&gt; &lt;/headerControls&gt; 
		 * Flags: IR */
		headerControls?: Array<string> /* Array of String */; // Flags=IR
		/** This is an object literal property block specifying the various properties of the headerIcon - the icon that appears at the top left of the window and is by default the Isomorphic logo. Overrideable defaults are as follows: width - default to 16 and specifies the width of the headerIcon. height - default to 14 and specifies the height of the headerIcon. src - defaults to "[SKIN]/Window/minimize.gif" and specifies the image for the headerIcon. You can override the the above properties by calling Class.changeDefaults.
		 * Flags: IRWA, Group: appearance */
		headerIconDefaults?: any /* object */; // Flags=IRWA
		/** This is an object literal property block specifying various properties of the header label that displays the Window.title. Overrideable defaults are as follows: styleName- defaults to "windowHeaderText" and specifies the css style that is used to render the Window.title text. You can override the the above properties by calling Class.changeDefaults.
		 * Flags: IRWA, Group: appearance */
		headerLabelDefaults?: any /* Object */; // Flags=IRWA
		/** If Window.showHeaderBackground is true, this property provides the URL of the background image for the header.
		 * Flags: IRWA, Group: appearance */
		headerSrc?: string /* SCImgURL */; // Flags=IRWA
		/** Style for the Window header.
		 * Flags: IRWA, Group: appearance */
		headerStyle?: string /* CSSStyleName */; // Flags=IRWA
		/** Highlight color for the Window body (shown when the body is flashed).
		 * Flags: IRW, Group: appearance */
		hiliteBodyColor?: string /* CSSColor */; // Flags=IRW
		/** If Window.showHeaderBackground is true, this governs the URL of the image to use in the header's highlighted state when the window is Window.flash','flashed
		 * Flags: IRWA, Group: appearance */
		hiliteHeaderSrc?: string /* SCImgURL */; // Flags=IRWA
		/** Highlight style for the Window header. Displayed when a window is Window.flash','flashed
		 * Flags: IRWA, Group: appearance */
		hiliteHeaderStyle?: string /* CSSStyleName */; // Flags=IRWA
		/** If true, when shown this Window will intercept and block events to all other existing components on the page. Use Window.showModalMask to darken all other elements on the screen when a modal dialog is showing. Chained modal windows - that is, modal windows that launch other modal windows - are allowed. You can accomplish this by simply creating a second modal Window while a modal Window is showing. Note only top-level Windows (Windows without parents) can be modal.
		 * Flags: IRW, Group: modal */
		isModal?: boolean /* Boolean */; // Flags=IRW
		/** The contents of the Window body. Can be specified three different ways: an Array of Canvases that will become the children of the Window's body when it is initialized; the canvases in this array should be created, but not drawn (autodraw: false). a single canvas that will become a child of the Window body. a string that will be set as the body's contents.
		 * Flags: IR, Group: appearance */
		items?: Array<Canvas> /* Array of Canvas | Canvas | String */; // Flags=IR
		/** If Window.canDragReposition or Window.canDragResize is true, should the windows size and position be constrained such that it remains within the viewport of its parent element (or for top level windows, within the viewport of the browser window)? Can also be set to an array denoting an arbitrary rect [Left,Top,Width,Height] beyond which the window cannot be moved. Note: keepInParentRect affects only user drag interactions, not programmatic moves.
		 * Flags: IRWA, Group: dragdrop */
		keepInParentRect?: boolean | any /* boolean or rect */; // Flags=IRWA
		/** Is this window maximized. If true at init time, the window will be drawn maximized. To set this property at runtime use Window.maximize or Window.restore.
		 * Flags: IRW, Group: appearance */
		maximized?: boolean /* Boolean */; // Flags=IRW
		/** Default acceleration function for performing an animated minimize / maximize. If unset, this.animateAcceleration will be used by default instead
		 * Flags: IRWA, Group: appearance */
		minimizeAcceleration?: AnimationAcceleration; // Flags=IRWA
		/** Is this window minimized. If true at init time, the window will be drawn minimized. To set this property at runtime use Window.minimize or Window.restore.
		 * Flags: IRW, Group: appearance */
		minimized?: boolean /* Boolean */; // Flags=IRW
		/** Height for the window when minimized. If unset the window will shrink to the height of the header, if present, otherwise Window.defaultMinimizeHeight','this.defaultMinimizeHeight
		 * Flags: IRWA, Group: appearance */
		minimizeHeight?: number; // Flags=IRWA
		/** If this window is minimizeable, and animateMinimize is true, what should the duration of the minimize / maximize be (in ms)? If unset defaults to canvas.animationTime.
		 * Flags: IRWA, Group: appearance */
		minimizeTime?: number; // Flags=IRWA
		/** Controls the opacity of the modal mask displayed behind modal windows.
		 * Flags: IR, Group: modal */
		modalMaskOpacity?: number; // Flags=IR
		/** Specifies the CSS style for the modal mask.
		 * Flags: IR, Group: modal */
		modalMaskStyle?: string; // Flags=IR
		/** Renders the widget to be partly transparent. A widget's opacity property may be set to any number between 0 (transparent) to 100 (opaque). Null means don't specify opacity directly, 100 is fully opaque. Note that heavy use of opacity may have a performance impact on some older browsers. In older versions of Internet Explorer (Pre IE9 / HTML5), opacity is achieved through proprietary filters. If Canvas.neverUseFilters','filters have been disabled within this application developers must set Canvas.useOpacityFilter to true for specific components on which opacity support is required. Also note that opacity is incompatible with Canvas.useBackMask','backMasks, and that this property is enabled by default for Window instances.
		 * Flags: IRWA */
		opacity?: number /* integer */; // Flags=IRWA
		/** Where should the window be placed on the screen? Valid settings include "fillScreen", "fillPanel", "halfScreen" and "none" If not explicitly specified, default is to use PanelPlacement "fillScreen" if Browser.isHandset, and "none" for non-handset devices. If window.placement is something other than "none", sizing and positioning settings (either explicit left, top, width, height settings or the Window.autoCenter and Window.autoSize features) will have no effect.
		 * Flags: IR */
		placement?: PanelPlacement; // Flags=IR
		/** Style for the Window body in printed output.
		 * Flags: IR */
		printBodyStyle?: string /* CSSStyleName */; // Flags=IR
		/** CSS Style for header in printed output
		 * Flags: IR */
		printHeaderStyle?: string /* CSSStyleName */; // Flags=IR
		/** If true, draw the body contents when this Window is drawn.
		 * Flags: IRWA, Group: appearance */
		showBody?: boolean /* Boolean */; // Flags=IRWA
		/** If true, show a close button in the header, which will dismiss this window by calling Window.closeClick.
		 * Flags: IRW, Group: appearance */
		showCloseButton?: boolean /* Boolean */; // Flags=IRW
		/** showEdges dynamically defaults to false when the Window.placement setting indicates the Window will be filling a portion of the screen or a panel.
		 * Flags: IR */
		showEdges?: boolean /* Boolean */; // Flags=IR
		/** If true, show a footer for this Window, including resizer, statusBar, etc. This setting is commonly overridden for skinning purposes.
		 * Flags: IRW, Group: appearance */
		showFooter?: boolean /* Boolean */; // Flags=IRW
		/** If true, show a Window.header for this Window. Note that in certain Smartclient skins Window.showHeaderBackground may be set to false and the header's appearance implemented as part of the window's Canvas.showEdges','edge media. In this case suppressing the header can be achieved by overriding the edge media as well as setting this property to false. For example, to create a headerless window with a similar appearance to a Menu in the TreeFrog skin, the following attributes could be used: showHeader:false, edgeImage:"[SKIN]/Menu/m.png", edgeSize:10, edgeTop:17, edgeBottom:17, edgeCenterBackgroundColor:"#F7F7F7" 
		 * Flags: IR, Group: appearance */
		showHeader?: boolean /* Boolean */; // Flags=IR
		/** Should the window header show a background image? Default value is true for all browsers except for Internet Explorer. If set to true the image source is derived from Window.headerSrc and Window.hiliteHeaderSrc, otherwise the background will be styled according to Window.headerStyle / Window.hiliteHeaderStyle.
		 * Flags: IRA, Group: appearance */
		showHeaderBackground?: boolean /* Boolean */; // Flags=IRA
		/** If true, we show an icon on the left in the header.
		 * Flags: IRW, Group: appearance */
		showHeaderIcon?: boolean /* Boolean */; // Flags=IRW
		/** If true, show a maximize button in the header - clicking it maximizes the Window
		 * Flags: IRW, Group: appearance */
		showMaximizeButton?: boolean /* Boolean */; // Flags=IRW
		/** If true, show a minimize button in the header--clicking it minimizes the Window.
		 * Flags: IRW, Group: appearance */
		showMinimizeButton?: boolean /* Boolean */; // Flags=IRW
		/** If true, displays a translucent mask over the rest of the page when a modal window is displayed.
		 * Flags: IR, Group: modal */
		showModalMask?: boolean; // Flags=IR
		/** If true, show a button in the lower right corner that allows users to resize the Window. Note that the resizer will only be displayed if the footer is showing for the window (Window.showFooter) and Window.canDragResize is true.
		 * Flags: IRW, Group: appearance */
		showResizer?: boolean /* Boolean */; // Flags=IRW
		/** Whether to show a drop shadow for this Canvas. Developers should be aware that the drop shadow is drawn outside the specified width and height of the widget meaning a widget with shadows takes up a little more space than it otherwise would. A full screen canvas with showShadow set to true as this would be likely to cause browser scrollbars to appear - developers can handle this by either setting this property to false on full-screen widgets, or by setting overflow to "hidden" on the &lt;body&gt; element browser-level scrolling is never intended to occur. showShadow dynamically defaults to false when the Window.placement setting indicates the Window will be filling a portion of the screen or a panel.
		 * Flags: IR */
		showShadow?: boolean /* Boolean */; // Flags=IR
		/** If true, show a statusBar for this Window, including resizer.
		 * Flags: IRW, Group: appearance */
		showStatusBar?: boolean /* Boolean */; // Flags=IRW
		/** Show a title (typically just text) on the header for this window.
		 * Flags: IRW, Group: appearance */
		showTitle?: boolean /* Boolean */; // Flags=IRW
		/** A URL to load as content for the Window's body. If specified, this attribute will take precedence over the items attribute. Note that setting window.src is essentially a shortcut for setting Window.items to a single HTMLflow with a specified HTMLFlow.contentsURL','contentsURL.
		 * Flags: IRW, Group: appearance */
		src?: string; // Flags=IRW
		/** Text to show in the status bar of the window (if one is visible)
		 * Flags: IRW, Group: appearance */
		status?: string; // Flags=IRW
		/** title for this Window, shown in the header (if drawn)
		 * Flags: IRW, Group: appearance */
		title?: string /* HTMLString */; // Flags=IRW
		/** By default Windows show a Canvas.useBackMask','backMask in Internet Explorer versions predating Internet Explorer 9. This is a workaround for a native browser issue whereby certain DOM elements such as IFRAMEs (whether rendered within SmartClient components via features such as HTMLFlow.contentsURL','contentsURL or explicitly written into the HTML of the page) will not be properly occluded by DOM elements which overlap them but have a higher z-index. A side-effect of this is that the Canvas.opacity','opacity can not be modified for the entire window. Developers may disable the backmask in order to support opacity in IE versions less than 9 by setting this property to false, however you should be aware that in doing this there is a potential for the "burn through" problem described above.
		 * Flags: IRA */
		useBackMask?: boolean /* Boolean */; // Flags=IRA

		/* Method Overrides */

		/** 
		 * Adds a widget to the body area of the window.
		 * @param {Canvas} item - the widget to be added
		 */
		addItem?(item:Canvas): Array<any> /* array */; 

		/** 
		 * Same as Layout.addMember. Note that in order to add items to Window.body, you use Window.addItem rather than addMember. Adding a member to a Window adds the member as a sibling to the header, body and other built-in Window subcomponents.
		 * @param {Canvas} newMember - the canvas object to be added to the layout
		 * @param {number} position - the position in the layout to place newMember (starts with 0); if omitted, it will be added at the last position
		 */
		addMember?(newMember:Canvas, position?:number /* Integer */): void; 

		/** 
		 * Close this window. This method is fired by the default Window.closeClick implementation. Default implementation will hide the window.
		 */
		close?(): void; 

		/** 
		 * Handles a click on the close button of this window. The default implementation calls Window.close','close() and returns false to prevent bubbling of the click event. Override this method if you want other actions to be taken. Custom implementations may call close() to trigger the default behavior.
		 */
		closeClick?(): boolean /* Boolean */; 

	} // WindowProps


	/**
	 * A general purpose Window class for implementing dialogs, portlets, alerts, prompts, wizards and desktop-like windowing interfaces. Windows can contain arbitrary SmartClient components, configured via the Window.items property. Windows may be Window.isModal','modal or non-modal. Windows provide a series of highly configurable and skinnable AutoChild','autoChildren including a header, various header controls, footer, and corner resizer. The more specialized Dialog subclass of Window has additional functionality targetted at simple prompts and confirmations, such as buttons with default actions, and single-method isc.warn','shortcuts for common application dialogs. 
	 */
	export interface Window extends Layout {
		/** Should this window minimize, maximize, and restore as an animation, or as a simple 1-step transition?
		 * Flags: IRWA, Group: appearance */
		animateMinimize: boolean;

		/** If true, this Window widget will automatically be centered on the page when shown. If false, it will show up in the last position it was placed (either programmatically, or by user interaction). Note: If an auto-centering Window is either programmatically moved or dragged by an end user, auto-centering behavior is automatically turned off. To manually center a Window, you can use Window.centerInPage.
		 * Flags: IRW, Group: appearance */
		autoCenter: boolean /* Boolean */;

		/** If true, the window is resized automatically to accommodate the contents of the body, if they would otherwise require scrolling.
		 * Flags: IRW, Group: appearance */
		autoSize: boolean /* Boolean */;

		/** Body of the Window, where Items','contained components or Window.src','loaded content is shown. The following autoChildUsage','passthroughs apply: Window.bodyStyle','bodyStyle for the Canvas.styleName Window.printBodyStyle','printBodyStyle for the styleName to use when printing Window.bodyColor','bodyColor / Window.hiliteBodyColor','hiliteBodyColor for the Canvas.backgroundColor 
		 * Flags: R */
		body:  Canvas /* AutoChild Canvas */;

		/** Color of the Window body. Overrides the background color specified in the style.
		 * Flags: IRW, Group: appearance */
		bodyColor: string /* CSSColor */;

		/** The name of the widget class (as a string) to use for the body. If unset the appropriate constructor type will be determined as follows: - if Window.items is defined as an array of widgets, and Window.contentLayout is not set to "none", bodyConstructor defaults to a VLayout - if Window.src is set, bodyConstructor defaults to an HTMLFlow - otherwise bodyConstructor will default to a simple Canvas Note that if this property is overridden for some window, the specified constructor should be a subclass of one of these defaults to ensure the window renders out as expected.
		 * Flags: IRWA, Group: appearance */
		bodyConstructor: string;

		/** Default properties for the body of the Window You can change the class-level bodyDefaults for all Windows by changing this item or set instance.body to be another object of properties to override for your instance only
		 * Flags: IRWA, Group: appearance */
		bodyDefaults: any /* object */;

		/** Style of the Window body.
		 * Flags: IRW, Group: appearance */
		bodyStyle: string /* CSSStyleName */;

		/** Should this window automatically be shown at the top of the page's z-order and be brought to front via Canvas.bringToFront whenever the user clicks it? If Window.isModal is true for this window, this setting will have no effect - we always bring the window to the front on initial display and on mouseDown. By default we also do this for non-modal windows (which matches user expectation for most standard interfaces - think of switching between OS-level application windows), but this may be disabled for cases where it is not appropriate by setting this attribute to false
		 * Flags: IRW */
		bringToFrontOnMouseUp: boolean;

		/** If true, this Window may be moved around by the user by dragging on the Window header. Note that if the header is not showing, the Window can't be drag-repositioned regardless of this setting.
		 * Flags: IRW, Group: dragging */
		canDragReposition: boolean /* Boolean */;

		/** Can the window be drag-resized? If true the window may be drag resized from its edges, and if showing, via the resizer icon in the footer.
		 * Flags: IRW, Group: dragging */
		canDragResize: boolean /* Boolean */;

		/** If true, the user can give the header buttons focus (see Window.minimizeButton, Window.maximizeButton, Window.restoreButton and Window.closeButton).
		 * Flags: IRWA, Group: focus */
		canFocusInHeaderButtons: boolean /* Boolean */;

		/** Button show in the header that will close this Window by calling Window.closeClick.
		 * Flags: R */
		closeButton:  ImgButton /* AutoChild ImgButton */;

		/** The layout policy that should be used for widgets within the Window body. See ContentLayoutPolicy and Window.bodyConstructor for details.
		 * Flags: IRWA, Group: appearance */
		contentLayout: ContentLayoutPolicy;

		/** If this window has Window.src specified, this property can be used to indicate whether the source is a standalone HTML page or an HTML fragment. This is similar to the HTMLFlow.contentsType property - be sure to read the HTMLFlow documentation to understand circumstances where contentsType:"page" is unsafe and not recommended.
		 * Flags: IR, Group: appearance */
		contentsType: string;

		/** If Window.minimizeHeight is unset, by the window will shrink to the height of the header when minimized. If there is no header, the defaultMinimizeHeight will be used instead.
		 * Flags: IRWA, Group: appearance */
		defaultMinimizeHeight: number;

		/** Should this window be dismissed (same effect as pressing the "Cancel" button) when the user presses the "Escape" key? Behavior will only occur while the window or one of its descendants has focus, and does not cancel the Escape keypress. If unset default behavior depends on whether a close / cancel button is visible for this item.
		 * Flags: IRW */
		dismissOnEscape: boolean /* Boolean */;

		/** If true, a click outside the bounds of the Window will have the same effect as pressing its cancel button. Note: Applies only to modal windows.
		 * Flags: IRW, Group: modal */
		dismissOnOutsideClick: boolean /* Boolean */;

		/** Default class used to construct the EditProxy for this component when the component is Canvas.setEditMode','first placed into edit mode.
		 * Flags: IR */
		editProxyConstructor: string /* SCClassName */;

		/** Alternative style for the window used whenever Window.placement settings indicate the menu will be filling a portion of the screen or a panel. Generally this alternative style should not have rounded or excessively large edges.
		 * Flags: IR */
		fillSpaceStyleName: string /* CSSStyleName */;

		/** Optional footer for the window, providing space for controls such as the resizer and status bar.
		 * Flags: R */
		footer:  HLayout /* AutoChild HLayout */;

		/** Array of members to show in the Window footer. The default value of footerControls is an Array of Strings listing the standard footer controls in their default order: footerControls : ["spacer", "resizer"] As with Window.headerControls, you can override footerControls to change the order of standard controls in the footer. "spacer" is a special value which will create a LayoutSpacer in the footer bar. "resizer" will show the Window.resizer in the footer. By embedding a Canvas directly in this list you can add arbitrary additional controls to the footer. Note that the Window.statusBar is not part of the set of footer controls - it is a separate canvas rendered behind all footer controls. If you include some custom status bar directly in the footerControls you may want to set Window.showFooter to false. Tip: custom controls need to set layoutAlign:"center" to appear vertically centered. Component XML: To define footerControls in Component XML a special set of components are used as markers. The standard footer controls can be explicitly specified as: &lt;footerControls&gt; &lt;WindowFooterSpacer/&gt; &lt;WindowResizer/&gt; &lt;/footerControls&gt; 
		 * Flags: IR */
		footerControls: Array<string> /* Array of String */;

		/** The height of the footer, in pixels.
		 * Flags: IR, Group: appearance */
		footerHeight: number;

		/** Header for the Window, based on an HLayout. The header contains the title and some standard controls for the window, which may be configured via Window.headerControls. The following autoChildUsage','passthroughs apply: Window.headerStyle','headerStyle for Canvas.styleName Window.printHeaderStyle','printHeaderStyle for the styleName to use when printing. 
		 * Flags: R */
		header:  HLayout /* AutoChild HLayout */;

		/** Img background component for the header, for gradient or image-based display
		 * Flags: R */
		headerBackground:  Img /* AutoChild Img */;

		/** Array of members to show in the Window header. The default value of headerControls is an Array of Strings listing the standard header controls in their default order: headerControls : ["headerIcon", "headerLabel", "minimizeButton", "maximizeButton", "closeButton"] You can override headerControls to change the order of standard controls in the header. You can also omit standard controls this way, although it more efficient to use the related "show" property if available (eg Window.showMinimizeButton). By embedding a Canvas directly in this list you can add arbitrary additional controls to the header, for example, an additional button (eg return to dock) or a DynamicForm with various kinds of input controls. Note that having added controls to headerControls, you can still call APIs directly on those controls to change their appearance, and you can also show() and hide() them if they should not be shown in some circumstances. Tip: custom controls need to set layoutAlign:"center" to appear vertically centered. Component XML: To define headerControls in Component XML a special set of components are used as markers. The standard header controls can be explicitly specified as: &lt;headerControls&gt; &lt;WindowHeaderIcon/&gt; &lt;WindowHeaderLabel/&gt; &lt;WindowMinimizeButton/&gt; &lt;WindowMaximizeButton/&gt; &lt;WindowCloseButton/&gt; &lt;/headerControls&gt; 
		 * Flags: IR */
		headerControls: Array<string> /* Array of String */;

		/** Header icon shown at left end of header by default.
		 * Flags: R */
		headerIcon:  Img /* AutoChild Img */;

		/** This is an object literal property block specifying the various properties of the headerIcon - the icon that appears at the top left of the window and is by default the Isomorphic logo. Overrideable defaults are as follows: width - default to 16 and specifies the width of the headerIcon. height - default to 14 and specifies the height of the headerIcon. src - defaults to "[SKIN]/Window/minimize.gif" and specifies the image for the headerIcon. You can override the the above properties by calling Class.changeDefaults.
		 * Flags: IRWA, Group: appearance */
		headerIconDefaults: any /* object */;

		/** Label that shows Window title in header. The following autoChildUsage','passthrough applies: Window.title','title for Label.contents.
		 * Flags: R */
		headerLabel:  Label /* AutoChild Label */;

		/** This is an object literal property block specifying various properties of the header label that displays the Window.title. Overrideable defaults are as follows: styleName- defaults to "windowHeaderText" and specifies the css style that is used to render the Window.title text. You can override the the above properties by calling Class.changeDefaults.
		 * Flags: IRWA, Group: appearance */
		headerLabelDefaults: any /* Object */;

		/** If Window.showHeaderBackground is true, this property provides the URL of the background image for the header.
		 * Flags: IRWA, Group: appearance */
		headerSrc: string /* SCImgURL */;

		/** Style for the Window header.
		 * Flags: IRWA, Group: appearance */
		headerStyle: string /* CSSStyleName */;

		/** Highlight color for the Window body (shown when the body is flashed).
		 * Flags: IRW, Group: appearance */
		hiliteBodyColor: string /* CSSColor */;

		/** If Window.showHeaderBackground is true, this governs the URL of the image to use in the header's highlighted state when the window is Window.flash','flashed
		 * Flags: IRWA, Group: appearance */
		hiliteHeaderSrc: string /* SCImgURL */;

		/** Highlight style for the Window header. Displayed when a window is Window.flash','flashed
		 * Flags: IRWA, Group: appearance */
		hiliteHeaderStyle: string /* CSSStyleName */;

		/** If true, when shown this Window will intercept and block events to all other existing components on the page. Use Window.showModalMask to darken all other elements on the screen when a modal dialog is showing. Chained modal windows - that is, modal windows that launch other modal windows - are allowed. You can accomplish this by simply creating a second modal Window while a modal Window is showing. Note only top-level Windows (Windows without parents) can be modal.
		 * Flags: IRW, Group: modal */
		isModal: boolean /* Boolean */;

		/** The contents of the Window body. Can be specified three different ways: an Array of Canvases that will become the children of the Window's body when it is initialized; the canvases in this array should be created, but not drawn (autodraw: false). a single canvas that will become a child of the Window body. a string that will be set as the body's contents.
		 * Flags: IR, Group: appearance */
		items: Array<Canvas> /* Array of Canvas | Canvas | String */;

		/** If Window.canDragReposition or Window.canDragResize is true, should the windows size and position be constrained such that it remains within the viewport of its parent element (or for top level windows, within the viewport of the browser window)? Can also be set to an array denoting an arbitrary rect [Left,Top,Width,Height] beyond which the window cannot be moved. Note: keepInParentRect affects only user drag interactions, not programmatic moves.
		 * Flags: IRWA, Group: dragdrop */
		keepInParentRect: boolean | any /* boolean or rect */;

		/** Button that will make this Window fill the browser via Window.maximize.
		 * Flags: R */
		maximizeButton:  ImgButton /* AutoChild ImgButton */;

		/** Is this window maximized. If true at init time, the window will be drawn maximized. To set this property at runtime use Window.maximize or Window.restore.
		 * Flags: IRW, Group: appearance */
		maximized: boolean /* Boolean */;

		/** Default acceleration function for performing an animated minimize / maximize. If unset, this.animateAcceleration will be used by default instead
		 * Flags: IRWA, Group: appearance */
		minimizeAcceleration: AnimationAcceleration;

		/** ImgButton shown in the header that will minimize this Window by calling Window.minimize.
		 * Flags: R */
		minimizeButton:  ImgButton /* AutoChild ImgButton */;

		/** Is this window minimized. If true at init time, the window will be drawn minimized. To set this property at runtime use Window.minimize or Window.restore.
		 * Flags: IRW, Group: appearance */
		minimized: boolean /* Boolean */;

		/** Height for the window when minimized. If unset the window will shrink to the height of the header, if present, otherwise Window.defaultMinimizeHeight','this.defaultMinimizeHeight
		 * Flags: IRWA, Group: appearance */
		minimizeHeight: number;

		/** If this window is minimizeable, and animateMinimize is true, what should the duration of the minimize / maximize be (in ms)? If unset defaults to canvas.animationTime.
		 * Flags: IRWA, Group: appearance */
		minimizeTime: number;

		/** A ScreenSpan instance used to darken the rest of a page when a modal window is active. To use, set Window.showModalMask to true, add a CSS style "modalMask" to the active skin (generally with background-color set), and adjust Window.modalMaskOpacity.
		 * Flags: R, Group: modal */
		modalMask:  Canvas /* AutoChild Canvas */;

		/** Controls the opacity of the modal mask displayed behind modal windows.
		 * Flags: IR, Group: modal */
		modalMaskOpacity: number;

		/** Specifies the CSS style for the modal mask.
		 * Flags: IR, Group: modal */
		modalMaskStyle: string;

		/** Renders the widget to be partly transparent. A widget's opacity property may be set to any number between 0 (transparent) to 100 (opaque). Null means don't specify opacity directly, 100 is fully opaque. Note that heavy use of opacity may have a performance impact on some older browsers. In older versions of Internet Explorer (Pre IE9 / HTML5), opacity is achieved through proprietary filters. If Canvas.neverUseFilters','filters have been disabled within this application developers must set Canvas.useOpacityFilter to true for specific components on which opacity support is required. Also note that opacity is incompatible with Canvas.useBackMask','backMasks, and that this property is enabled by default for Window instances.
		 * Flags: IRWA */
		opacity: number /* integer */;

		/** Where should the window be placed on the screen? Valid settings include "fillScreen", "fillPanel", "halfScreen" and "none" If not explicitly specified, default is to use PanelPlacement "fillScreen" if Browser.isHandset, and "none" for non-handset devices. If window.placement is something other than "none", sizing and positioning settings (either explicit left, top, width, height settings or the Window.autoCenter and Window.autoSize features) will have no effect.
		 * Flags: IR */
		placement: PanelPlacement;

		/** Style for the Window body in printed output.
		 * Flags: IR */
		printBodyStyle: string /* CSSStyleName */;

		/** CSS Style for header in printed output
		 * Flags: IR */
		printHeaderStyle: string /* CSSStyleName */;

		/** ImgButton-based resizer, shown in the footer.
		 * Flags: R */
		resizer:  ImgButton /* AutoChild ImgButton */;

		/** ImgButton that restores the Window via Window.restore.
		 * Flags: R */
		restoreButton:  ImgButton /* AutoChild ImgButton */;

		/** If true, draw the body contents when this Window is drawn.
		 * Flags: IRWA, Group: appearance */
		showBody: boolean /* Boolean */;

		/** If true, show a close button in the header, which will dismiss this window by calling Window.closeClick.
		 * Flags: IRW, Group: appearance */
		showCloseButton: boolean /* Boolean */;

		/** showEdges dynamically defaults to false when the Window.placement setting indicates the Window will be filling a portion of the screen or a panel.
		 * Flags: IR */
		showEdges: boolean /* Boolean */;

		/** If true, show a footer for this Window, including resizer, statusBar, etc. This setting is commonly overridden for skinning purposes.
		 * Flags: IRW, Group: appearance */
		showFooter: boolean /* Boolean */;

		/** If true, show a Window.header for this Window. Note that in certain Smartclient skins Window.showHeaderBackground may be set to false and the header's appearance implemented as part of the window's Canvas.showEdges','edge media. In this case suppressing the header can be achieved by overriding the edge media as well as setting this property to false. For example, to create a headerless window with a similar appearance to a Menu in the TreeFrog skin, the following attributes could be used: showHeader:false, edgeImage:"[SKIN]/Menu/m.png", edgeSize:10, edgeTop:17, edgeBottom:17, edgeCenterBackgroundColor:"#F7F7F7" 
		 * Flags: IR, Group: appearance */
		showHeader: boolean /* Boolean */;

		/** Should the window header show a background image? Default value is true for all browsers except for Internet Explorer. If set to true the image source is derived from Window.headerSrc and Window.hiliteHeaderSrc, otherwise the background will be styled according to Window.headerStyle / Window.hiliteHeaderStyle.
		 * Flags: IRA, Group: appearance */
		showHeaderBackground: boolean /* Boolean */;

		/** If true, we show an icon on the left in the header.
		 * Flags: IRW, Group: appearance */
		showHeaderIcon: boolean /* Boolean */;

		/** If true, show a maximize button in the header - clicking it maximizes the Window
		 * Flags: IRW, Group: appearance */
		showMaximizeButton: boolean /* Boolean */;

		/** If true, show a minimize button in the header--clicking it minimizes the Window.
		 * Flags: IRW, Group: appearance */
		showMinimizeButton: boolean /* Boolean */;

		/** If true, displays a translucent mask over the rest of the page when a modal window is displayed.
		 * Flags: IR, Group: modal */
		showModalMask: boolean;

		/** If true, show a button in the lower right corner that allows users to resize the Window. Note that the resizer will only be displayed if the footer is showing for the window (Window.showFooter) and Window.canDragResize is true.
		 * Flags: IRW, Group: appearance */
		showResizer: boolean /* Boolean */;

		/** Whether to show a drop shadow for this Canvas. Developers should be aware that the drop shadow is drawn outside the specified width and height of the widget meaning a widget with shadows takes up a little more space than it otherwise would. A full screen canvas with showShadow set to true as this would be likely to cause browser scrollbars to appear - developers can handle this by either setting this property to false on full-screen widgets, or by setting overflow to "hidden" on the &lt;body&gt; element browser-level scrolling is never intended to occur. showShadow dynamically defaults to false when the Window.placement setting indicates the Window will be filling a portion of the screen or a panel.
		 * Flags: IR */
		showShadow: boolean /* Boolean */;

		/** If true, show a statusBar for this Window, including resizer.
		 * Flags: IRW, Group: appearance */
		showStatusBar: boolean /* Boolean */;

		/** Show a title (typically just text) on the header for this window.
		 * Flags: IRW, Group: appearance */
		showTitle: boolean /* Boolean */;

		/** A URL to load as content for the Window's body. If specified, this attribute will take precedence over the items attribute. Note that setting window.src is essentially a shortcut for setting Window.items to a single HTMLflow with a specified HTMLFlow.contentsURL','contentsURL.
		 * Flags: IRW, Group: appearance */
		src: string;

		/** Text to show in the status bar of the window (if one is visible)
		 * Flags: IRW, Group: appearance */
		status: string;

		/** Simple Canvas-based status bar, shown in the footer. Window.setStatus can be used to show text here.
		 * Flags: R */
		statusBar:  Canvas /* AutoChild Canvas */;

		/** title for this Window, shown in the header (if drawn)
		 * Flags: IRW, Group: appearance */
		title: string /* HTMLString */;

		/** By default Windows show a Canvas.useBackMask','backMask in Internet Explorer versions predating Internet Explorer 9. This is a workaround for a native browser issue whereby certain DOM elements such as IFRAMEs (whether rendered within SmartClient components via features such as HTMLFlow.contentsURL','contentsURL or explicitly written into the HTML of the page) will not be properly occluded by DOM elements which overlap them but have a higher z-index. A side-effect of this is that the Canvas.opacity','opacity can not be modified for the entire window. Developers may disable the backmask in order to support opacity in IE versions less than 9 by setting this property to false, however you should be aware that in doing this there is a potential for the "burn through" problem described above.
		 * Flags: IRA */
		useBackMask: boolean /* Boolean */;


		/* Instance Method Overrides */

		/** 
		 * Adds a widget to the body area of the window.
		 * @param {Canvas} item - the widget to be added
		 */
		addItem?(item:Canvas): Array<any> /* array */; 

		/** 
		 * Same as Layout.addMember. Note that in order to add items to Window.body, you use Window.addItem rather than addMember. Adding a member to a Window adds the member as a sibling to the header, body and other built-in Window subcomponents.
		 * @param {Canvas} newMember - the canvas object to be added to the layout
		 * @param {number} position - the position in the layout to place newMember (starts with 0); if omitted, it will be added at the last position
		 */
		addMember?(newMember:Canvas, position?:number /* Integer */): void; 

		/** 
		 * Close this window. This method is fired by the default Window.closeClick implementation. Default implementation will hide the window.
		 */
		close?(): void; 

		/** 
		 * Handles a click on the close button of this window. The default implementation calls Window.close','close() and returns false to prevent bubbling of the click event. Override this method if you want other actions to be taken. Custom implementations may call close() to trigger the default behavior.
		 */
		closeClick?(): boolean /* Boolean */; 

	} // Window

	export interface WindowStatic<T, P> extends LayoutStatic<T, P> {
	} // WindowStatic



}